{
  "parsed": {
    "kind": "KASAN: out-of-bounds in ext4_ext_rm_leaf <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730'>fs/ext4/extents.c:2730</a> [inline]",
    "access": {
      "op": "read",
      "size": 18446744073709551544,
      "addr": "ffff88811baa3054"
    },
    "object_info": null,
    "allocated_by": [],
    "freed_by": [],
    "link_frames": [
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730",
        "file": "fs/ext4/extents.c",
        "line": 2730
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952",
        "file": "fs/ext4/extents.c",
        "line": 2952
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#77",
        "file": "lib/dump_stack.c",
        "line": 77
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#118",
        "file": "lib/dump_stack.c",
        "line": 118
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#248",
        "file": "mm/kasan/report.c",
        "line": 248
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#435",
        "file": "mm/kasan/report.c",
        "line": 435
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#452",
        "file": "mm/kasan/report.c",
        "line": 452
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/generic.c#189",
        "file": "mm/kasan/generic.c",
        "line": 189
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/shadow.c#54",
        "file": "mm/kasan/shadow.c",
        "line": 54
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730",
        "file": "fs/ext4/extents.c",
        "line": 2730
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952",
        "file": "fs/ext4/extents.c",
        "line": 2952
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#4205",
        "file": "fs/ext4/inode.c",
        "line": 4205
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4704",
        "file": "fs/ext4/extents.c",
        "line": 4704
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/open.c#310",
        "file": "fs/open.c",
        "line": 310
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#732",
        "file": "fs/ioctl.c",
        "line": 732
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#751",
        "file": "fs/ioctl.c",
        "line": 751
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#35",
        "file": "include/linux/page_owner.h",
        "line": 35
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2456",
        "file": "mm/page_alloc.c",
        "line": 2456
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2462",
        "file": "mm/page_alloc.c",
        "line": 2462
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#4254",
        "file": "mm/page_alloc.c",
        "line": 4254
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#5346",
        "file": "mm/page_alloc.c",
        "line": 5346
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#544",
        "file": "include/linux/gfp.h",
        "line": 544
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#557",
        "file": "include/linux/gfp.h",
        "line": 557
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#571",
        "file": "include/linux/gfp.h",
        "line": 571
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#590",
        "file": "include/linux/gfp.h",
        "line": 590
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#290",
        "file": "include/linux/pagemap.h",
        "line": 290
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#1848",
        "file": "mm/filemap.c",
        "line": 1848
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#402",
        "file": "include/linux/pagemap.h",
        "line": 402
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#976",
        "file": "fs/buffer.c",
        "line": 976
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1045",
        "file": "fs/buffer.c",
        "line": 1045
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1072",
        "file": "fs/buffer.c",
        "line": 1072
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1370",
        "file": "fs/buffer.c",
        "line": 1370
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/buffer_head.h#368",
        "file": "include/linux/buffer_head.h",
        "line": 368
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1325",
        "file": "fs/ext4/extents.c",
        "line": 1325
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1424",
        "file": "fs/ext4/extents.c",
        "line": 1424
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2094",
        "file": "fs/ext4/extents.c",
        "line": 2094
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4302",
        "file": "fs/ext4/extents.c",
        "line": 4302
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#646",
        "file": "fs/ext4/inode.c",
        "line": 646
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#793",
        "file": "fs/ext4/inode.c",
        "line": 793
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#810",
        "file": "fs/ext4/inode.c",
        "line": 810
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#1077",
        "file": "fs/ext4/inode.c",
        "line": 1077
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#3021",
        "file": "fs/ext4/inode.c",
        "line": 3021
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#3506",
        "file": "mm/filemap.c",
        "line": 3506
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#271",
        "file": "fs/ext4/file.c",
        "line": 271
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#685",
        "file": "fs/ext4/file.c",
        "line": 685
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#28",
        "file": "include/linux/page_owner.h",
        "line": 28
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1349",
        "file": "mm/page_alloc.c",
        "line": 1349
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1421",
        "file": "mm/page_alloc.c",
        "line": 1421
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3336",
        "file": "mm/page_alloc.c",
        "line": 3336
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3443",
        "file": "mm/page_alloc.c",
        "line": 3443
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap.c#1103",
        "file": "mm/swap.c",
        "line": 1103
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap_state.c#356",
        "file": "mm/swap_state.c",
        "line": 356
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#49",
        "file": "mm/mmu_gather.c",
        "line": 49
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#240",
        "file": "mm/mmu_gather.c",
        "line": 240
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#247",
        "file": "mm/mmu_gather.c",
        "line": 247
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#326",
        "file": "mm/mmu_gather.c",
        "line": 326
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#2807",
        "file": "mm/mmap.c",
        "line": 2807
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3036",
        "file": "mm/mmap.c",
        "line": 3036
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3059",
        "file": "mm/mmap.c",
        "line": 3059
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3085",
        "file": "mm/mmap.c",
        "line": 3085
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081",
        "file": "mm/mmap.c",
        "line": 3081
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081",
        "file": "mm/mmap.c",
        "line": 3081
      }
    ],
    "frames": [
      {
        "func": "EXT4-fs",
        "file": "error (device loop0) in ext4_mb_clear_bb",
        "line": 5614,
        "raw": "EXT4-fs error (device loop0) in ext4_mb_clear_bb:5614: Corrupt filesystem"
      },
      {
        "func": "EXT4-fs",
        "file": "error (device loop0) in ext4_reserve_inode_write",
        "line": 5886,
        "raw": "EXT4-fs error (device loop0) in ext4_reserve_inode_write:5886: Corrupt filesystem"
      }
    ],
    "raw": "EXT4-fs (loop0): Remounting filesystem read-only\nEXT4-fs error (device loop0) in ext4_mb_clear_bb:5614: Corrupt filesystem\n==================================================================\nBUG: KASAN: out-of-bounds in ext4_ext_rm_leaf <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730'>fs/ext4/extents.c:2730</a> [inline]\nBUG: KASAN: out-of-bounds in ext4_ext_remove_space+0x1fbc/0x4e10 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952'>fs/ext4/extents.c:2952</a>\nRead of size 18446744073709551544 at addr ffff88811baa3054 by task syz-executor226/292\n\nCPU: 1 PID: 292 Comm: syz-executor226 Not tainted 5.10.192-syzkaller-00409-gc8ca447a86a2 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/26/2023\nCall Trace:\n __dump_stack <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#77'>lib/dump_stack.c:77</a> [inline]\n dump_stack_lvl+0x1e2/0x24b <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#118'>lib/dump_stack.c:118</a>\n print_address_description+0x81/0x3b0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#248'>mm/kasan/report.c:248</a>\n __kasan_report <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#435'>mm/kasan/report.c:435</a> [inline]\n kasan_report+0x179/0x1c0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#452'>mm/kasan/report.c:452</a>\n kasan_check_range+0x293/0x2a0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/generic.c#189'>mm/kasan/generic.c:189</a>\n memmove+0x2d/0x70 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/shadow.c#54'>mm/kasan/shadow.c:54</a>\n ext4_ext_rm_leaf <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730'>fs/ext4/extents.c:2730</a> [inline]\n ext4_ext_remove_space+0x1fbc/0x4e10 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952'>fs/ext4/extents.c:2952</a>\n ext4_punch_hole+0x720/0xb10 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#4205'>fs/ext4/inode.c:4205</a>\n ext4_fallocate+0x2e8/0x1ca0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4704'>fs/ext4/extents.c:4704</a>\n vfs_fallocate+0x492/0x570 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/open.c#310'>fs/open.c:310</a>\n do_vfs_ioctl+0x1686/0x1a30 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x99/0x190 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x34/0x70\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\nRIP: 0033:0x7fbe6877e729\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 b1 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fbe6035a218 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007fbe688066d8 RCX: 00007fbe6877e729\nRDX: 0000000020000080 RSI: 000000004030582b RDI: 0000000000000004\nRBP: 00007fbe688066d0 R08: 00007fffa8dac757 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fbe687d3678\nR13: 0000000000000002 R14: 00007fffa8dac670 R15: 6f6f6c2f7665642f\n\nThe buggy address belongs to the page:\npage:ffffea00046ea8c0 refcount:2 mapcount:0 mapping:ffff888109191c10 index:0x3a pfn:0x11baa3\naops:def_blk_aops ino:0\nflags: 0x4000000000002036(referenced|uptodate|lru|active|private)\nraw: 4000000000002036 ffffea0004440248 ffffea0004707c88 ffff888109191c10\nraw: 000000000000003a ffff88811c496930 00000002ffffffff ffff888100142000\npage dumped because: kasan: bad access detected\npage->mem_cgroup:ffff888100142000\npage_owner tracks the page as allocated\npage last allocated via order 0, migratetype Movable, gfp_mask 0x108c48(GFP_NOFS|__GFP_NOFAIL|__GFP_HARDWALL|__GFP_MOVABLE), pid 287, ts 19953384406, free_ts 19753654753\n set_page_owner <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#35'>include/linux/page_owner.h:35</a> [inline]\n post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2456'>mm/page_alloc.c:2456</a> [inline]\n prep_new_page+0x166/0x180 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2462'>mm/page_alloc.c:2462</a>\n get_page_from_freelist+0x2d8c/0x2f30 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#4254'>mm/page_alloc.c:4254</a>\n __alloc_pages_nodemask+0x435/0xaf0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#5346'>mm/page_alloc.c:5346</a>\n __alloc_pages <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#544'>include/linux/gfp.h:544</a> [inline]\n __alloc_pages_node <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#557'>include/linux/gfp.h:557</a> [inline]\n alloc_pages_node <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#571'>include/linux/gfp.h:571</a> [inline]\n alloc_pages <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#590'>include/linux/gfp.h:590</a> [inline]\n __page_cache_alloc <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#290'>include/linux/pagemap.h:290</a> [inline]\n pagecache_get_page+0x669/0x950 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#1848'>mm/filemap.c:1848</a>\n find_or_create_page <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#402'>include/linux/pagemap.h:402</a> [inline]\n grow_dev_page <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#976'>fs/buffer.c:976</a> [inline]\n grow_buffers <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1045'>fs/buffer.c:1045</a> [inline]\n __getblk_slow <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1072'>fs/buffer.c:1072</a> [inline]\n __getblk_gfp+0x221/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1370'>fs/buffer.c:1370</a>\n sb_getblk_gfp <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/buffer_head.h#368'>include/linux/buffer_head.h:368</a> [inline]\n ext4_ext_grow_indepth <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1325'>fs/ext4/extents.c:1325</a> [inline]\n ext4_ext_create_new_leaf <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1424'>fs/ext4/extents.c:1424</a> [inline]\n ext4_ext_insert_extent+0xf88/0x4d20 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2094'>fs/ext4/extents.c:2094</a>\n ext4_ext_map_blocks+0x1b4c/0x6be0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4302'>fs/ext4/extents.c:4302</a>\n ext4_map_blocks+0xaa7/0x1ec0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#646'>fs/ext4/inode.c:646</a>\n _ext4_get_block+0x21b/0x610 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#793'>fs/ext4/inode.c:793</a>\n ext4_get_block+0x39/0x50 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#810'>fs/ext4/inode.c:810</a>\n ext4_block_write_begin+0x61e/0x13b0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#1077'>fs/ext4/inode.c:1077</a>\n ext4_write_begin+0x6fa/0x1730\n ext4_da_write_begin+0x49d/0xf60 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#3021'>fs/ext4/inode.c:3021</a>\n generic_perform_write+0x2cd/0x570 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#3506'>mm/filemap.c:3506</a>\n ext4_buffered_write_iter+0x482/0x610 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#271'>fs/ext4/file.c:271</a>\n ext4_file_write_iter+0x193/0x1c80 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#685'>fs/ext4/file.c:685</a>\npage last free stack trace:\n reset_page_owner <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#28'>include/linux/page_owner.h:28</a> [inline]\n free_pages_prepare <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1349'>mm/page_alloc.c:1349</a> [inline]\n free_pcp_prepare <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1421'>mm/page_alloc.c:1421</a> [inline]\n free_unref_page_prepare+0x2ae/0x2d0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3336'>mm/page_alloc.c:3336</a>\n free_unref_page_list+0x122/0xb20 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3443'>mm/page_alloc.c:3443</a>\n release_pages+0xea0/0xef0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap.c#1103'>mm/swap.c:1103</a>\n free_pages_and_swap_cache+0x8a/0xa0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap_state.c#356'>mm/swap_state.c:356</a>\n tlb_batch_pages_flush <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#49'>mm/mmu_gather.c:49</a> [inline]\n tlb_flush_mmu_free <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#240'>mm/mmu_gather.c:240</a> [inline]\n tlb_flush_mmu <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#247'>mm/mmu_gather.c:247</a> [inline]\n tlb_finish_mmu+0x177/0x320 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#326'>mm/mmu_gather.c:326</a>\n unmap_region+0x31c/0x370 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#2807'>mm/mmap.c:2807</a>\n __do_munmap+0x699/0x8c0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3036'>mm/mmap.c:3036</a>\n __vm_munmap <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3059'>mm/mmap.c:3059</a> [inline]\n __do_sys_munmap <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3085'>mm/mmap.c:3085</a> [inline]\n __se_sys_munmap+0x120/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081'>mm/mmap.c:3081</a>\n __x64_sys_munmap+0x5b/0x70 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081'>mm/mmap.c:3081</a>\n do_syscall_64+0x34/0x70\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nMemory state around the buggy address:\n ffff88811baa2f00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n ffff88811baa2f80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n>ffff88811baa3000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n                                                 ^\n ffff88811baa3080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88811baa3100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n==================================================================\nEXT4-fs error (device loop0): __ext4_get_inode_loc:4426: comm syz-executor226: Invalid inode table block 0 in block_group 0\nEXT4-fs error (device loop0) in ext4_reserve_inode_write:5886: Corrupt filesystem\nEXT4-fs error (device loop0): ext4_punch_hole:4218: inode #16: comm syz-executor226: mark_inode_dirty error\n"
  },
  "snippets": {
    "urls": {
      "https://android.googlesource.com/kernel/common/": {
        "error": "URL not in expected +/commit/path format"
      }
    },
    "links": {
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730#2730": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730",
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "function_snippet": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n\t\t struct ext4_ext_path *path,\n\t\t struct partial_cluster *partial,\n\t\t ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint err = 0, correct_index = 0;\n\tint depth = ext_depth(inode), credits, revoke_credits;\n\tstruct ext4_extent_header *eh;\n\text4_lblk_t a, b;\n\tunsigned num;\n\text4_lblk_t ex_ee_block;\n\tunsigned short ex_ee_len;\n\tunsigned unwritten = 0;\n\tstruct ext4_extent *ex;\n\text4_fsblk_t pblk;\n\n\t/* the header must be checked already in ext4_ext_remove_space() */\n\text_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);\n\tif (!path[depth].p_hdr)\n\t\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t/* find where to start removing */\n\tex = path[depth].p_ext;\n\tif (!ex)\n\t\tex = EXT_LAST_EXTENT(eh);\n\n\tex_ee_block = le32_to_cpu(ex->ee_block);\n\tex_ee_len = ext4_ext_get_actual_len(ex);\n\n\ttrace_ext4_ext_rm_leaf(inode, start, ex, partial);\n\n\twhile (ex >= EXT_FIRST_EXTENT(eh) &&\n\t\t\tex_ee_block + ex_ee_len > start) {\n\n\t\tif (ext4_ext_is_unwritten(ex))\n\t\t\tunwritten = 1;\n\t\telse\n\t\t\tunwritten = 0;\n\n\t\text_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,\n\t\t\t  unwritten, ex_ee_len);\n\t\tpath[depth].p_ext = ex;\n\n\t\ta = ex_ee_block > start ? ex_ee_block : start;\n\t\tb = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\tex_ee_block+ex_ee_len - 1 : end;\n\n\t\text_debug(inode, \"  border %u:%u\\n\", a, b);\n\n\t\t/* If this extent is beyond the end of the hole, skip it */\n\t\tif (end < ex_ee_block) {\n\t\t\t/*\n\t\t\t * We're going to skip this extent and move to another,\n\t\t\t * so note that its first cluster is in use to avoid\n\t\t\t * freeing it when removing blocks.  Eventually, the\n\t\t\t * right edge of the truncated/punched region will\n\t\t\t * be just to the left.\n\t\t\t */\n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex);\n\t\t\t\tpartial->pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial->state = nofree;\n\t\t\t}\n\t\t\tex--;\n\t\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t\t\tcontinue;\n\t\t} else if (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"can not handle truncate %u:%u \"\n\t\t\t\t\t \"on extent %u:%u\",\n\t\t\t\t\t start, end, ex_ee_block,\n\t\t\t\t\t ex_ee_block + ex_ee_len - 1);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t} else if (a != ex_ee_block) {\n\t\t\t/* remove tail of the extent */\n\t\t\tnum = a - ex_ee_block;\n\t\t} else {\n\t\t\t/* remove whole extent: excellent! */\n\t\t\tnum = 0;\n\t\t}\n\t\t/*\n\t\t * 3 for leaf, sb, and inode plus 2 (bmap and group\n\t\t * descriptor) for each block group; assume two block\n\t\t * groups plus ex_ee_len/blocks_per_block_group for\n\t\t * the worst case\n\t\t */\n\t\tcredits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));\n\t\tif (ex == EXT_FIRST_EXTENT(eh)) {\n\t\t\tcorrect_index = 1;\n\t\t\tcredits += (ext_depth(inode)) + 1;\n\t\t}\n\t\tcredits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\t\t/*\n\t\t * We may end up freeing some index blocks and data from the\n\t\t * punched range. Note that partial clusters are accounted for\n\t\t * by ext4_free_data_revoke_credits().\n\t\t */\n\t\trevoke_credits =\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb,\n\t\t\t\t\t\t\t  ext_depth(inode)) +\n\t\t\text4_free_data_revoke_credits(inode, b - a + 1);\n\n\t\terr = ext4_datasem_ensure_credits(handle, inode, credits,\n\t\t\t\t\t\t  credits, revoke_credits);\n\t\tif (err) {\n\t\t\tif (err > 0)\n\t\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_remove_blocks(handle, inode, ex, partial, a, b);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (num == 0)\n\t\t\t/* this extent is removed; mark slot entirely unused */\n\t\t\text4_ext_store_pblock(ex, 0);\n\n\t\tex->ee_len = cpu_to_le16(num);\n\t\t/*\n\t\t * Do not mark unwritten if all the blocks in the\n\t\t * extent have been removed.\n\t\t */\n\t\tif (unwritten && num)\n\t\t\text4_ext_mark_unwritten(ex);\n\t\t/*\n\t\t * If the extent was completely released,\n\t\t * we need to remove it from the leaf\n\t\t */\n\t\tif (num == 0) {\n\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n\t\t\t\t/*\n\t\t\t\t * For hole punching, we need to scoot all the\n\t\t\t\t * extents up when an extent is removed so that\n\t\t\t\t * we dont have blank extents in the middle\n\t\t\t\t */\n\t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952#2952": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952",
        "file": "fs/ext4/extents.c",
        "line": 2952,
        "function_snippet": "int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t  ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint depth = ext_depth(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tstruct partial_cluster partial;\n\thandle_t *handle;\n\tint i = 0, err = 0;\n\n\tpartial.pclu = 0;\n\tpartial.lblk = 0;\n\tpartial.state = initial;\n\n\text_debug(inode, \"truncate since %u to %u\\n\", start, end);\n\n\t/* probably first extent we're gonna free will be last in block */\n\thandle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\n\t\t\tdepth + 1,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, depth));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\nagain:\n\ttrace_ext4_ext_remove_space(inode, start, end, depth);\n\n\t/*\n\t * Check if we are removing extents inside the extent tree. If that\n\t * is the case, we are going to punch a hole inside the extent tree\n\t * so we have to check whether we need to split the extent covering\n\t * the last block to remove so we can easily remove the part of it\n\t * in ext4_ext_rm_leaf().\n\t */\n\tif (end < EXT_MAX_BLOCKS - 1) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t ee_block, ex_end, lblk;\n\t\text4_fsblk_t pblk;\n\n\t\t/* find extent for or closest extent to this block */\n\t\tpath = ext4_find_extent(inode, end, NULL,\n\t\t\t\t\tEXT4_EX_NOCACHE | EXT4_EX_NOFAIL);\n\t\tif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\t/* Leaf not may not exist only if inode has no blocks at all */\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tif (depth) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t\t\t depth);\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tex_end = ee_block + ext4_ext_get_actual_len(ex) - 1;\n\n\t\t/*\n\t\t * See if the last block is inside the extent, if so split\n\t\t * the extent at 'end' block so we can easily remove the\n\t\t * tail of the first part of the split extent in\n\t\t * ext4_ext_rm_leaf().\n\t\t */\n\t\tif (end >= ee_block && end < ex_end) {\n\n\t\t\t/*\n\t\t\t * If we're going to split the extent, note that\n\t\t\t * the cluster containing the block after 'end' is\n\t\t\t * in use to avoid freeing it when removing blocks.\n\t\t\t */\n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex) + end - ee_block + 1;\n\t\t\t\tpartial.pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial.state = nofree;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Split the extent in two so that 'end' is the last\n\t\t\t * block in the first new extent. Also we should not\n\t\t\t * fail removing space due to ENOSPC so try to use\n\t\t\t * reserved block if that happens.\n\t\t\t */\n\t\t\terr = ext4_force_split_extent_at(handle, inode, &path,\n\t\t\t\t\t\t\t end + 1, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&\n\t\t\t   partial.state == initial) {\n\t\t\t/*\n\t\t\t * If we're punching, there's an extent to the right.\n\t\t\t * If the partial cluster hasn't been set, set it to\n\t\t\t * that extent's first cluster and its state to nofree\n\t\t\t * so it won't be freed should it contain blocks to be\n\t\t\t * removed. If it's already set (tofree/nofree), we're\n\t\t\t * retrying and keep the original partial cluster info\n\t\t\t * so a cluster marked tofree as a result of earlier\n\t\t\t * extent removal is not lost.\n\t\t\t */\n\t\t\tlblk = ex_end + 1;\n\t\t\terr = ext4_ext_search_right(inode, path, &lblk, &pblk,\n\t\t\t\t\t\t    NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tif (pblk) {\n\t\t\t\tpartial.pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial.state = nofree;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * We start scanning from right side, freeing all the blocks\n\t * after i_size and walking into the tree depth-wise.\n\t */\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\tint k = i = depth;\n\t\twhile (--k > 0)\n\t\t\tpath[k].p_block =\n\t\t\t\tle16_to_cpu(path[k].p_hdr->eh_entries)+1;\n\t} else {\n\t\tpath = kcalloc(depth + 1, sizeof(struct ext4_ext_path),\n\t\t\t       GFP_NOFS | __GFP_NOFAIL);\n\t\tif (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpath[0].p_maxdepth = path[0].p_depth = depth;\n\t\tpath[0].p_hdr = ext_inode_hdr(inode);\n\t\ti = 0;\n\n\t\tif (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = 0;\n\n\twhile (i >= 0 && err == 0) {\n\t\tif (i == depth) {\n\t\t\t/* this is leaf block */\n\t\t\terr = ext4_ext_rm_leaf(handle, inode, path,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#77#77": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#77",
        "file": "lib/dump_stack.c",
        "line": 77,
        "function_snippet": "static void __dump_stack(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\tshow_stack(NULL, NULL, log_lvl);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#118#118": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#118",
        "file": "lib/dump_stack.c",
        "line": 118,
        "function_snippet": "asmlinkage __visible void dump_stack_lvl(const char *log_lvl)\n{\n\tunsigned long flags;\n\tint was_locked;\n\tint old;\n\tint cpu;\n\n\t/*\n\t * Permit this cpu to perform nested stack dumps while serialising\n\t * against other CPUs\n\t */\nretry:\n\tlocal_irq_save(flags);\n\tcpu = smp_processor_id();\n\told = atomic_cmpxchg(&dump_lock, -1, cpu);\n\tif (old == -1) {\n\t\twas_locked = 0;\n\t} else if (old == cpu) {\n\t\twas_locked = 1;\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t\t/*\n\t\t * Wait for the lock to release before jumping to\n\t\t * atomic_cmpxchg() in order to mitigate the thundering herd\n\t\t * problem.\n\t\t */\n\t\tdo { cpu_relax(); } while (atomic_read(&dump_lock) != -1);\n\t\tgoto retry;\n\t}\n\n\t__dump_stack(log_lvl);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#248#248": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#248",
        "file": "mm/kasan/report.c",
        "line": 248,
        "function_snippet": "static void print_address_description(void *addr, u8 tag)\n{\n\tstruct page *page = kasan_addr_to_page(addr);\n\n\tdump_stack_lvl(KERN_ERR);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#435#435": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#435",
        "file": "mm/kasan/report.c",
        "line": 435,
        "function_snippet": "static void __kasan_report(unsigned long addr, size_t size, bool is_write,\n\t\t\t\tunsigned long ip)\n{\n\tstruct kasan_access_info info;\n\tvoid *tagged_addr;\n\tvoid *untagged_addr;\n\tunsigned long flags;\n\n#if IS_ENABLED(CONFIG_KUNIT)\n\tif (current->kunit_test)\n\t\tkasan_update_kunit_status(current->kunit_test, true);\n#endif /* IS_ENABLED(CONFIG_KUNIT) */\n\n\tdisable_trace_on_warning();\n\n\ttagged_addr = (void *)addr;\n\tuntagged_addr = kasan_reset_tag(tagged_addr);\n\n\tinfo.access_addr = tagged_addr;\n\tif (addr_has_metadata(untagged_addr))\n\t\tinfo.first_bad_addr =\n\t\t\tkasan_find_first_bad_addr(tagged_addr, size);\n\telse\n\t\tinfo.first_bad_addr = untagged_addr;\n\tinfo.access_size = size;\n\tinfo.is_write = is_write;\n\tinfo.ip = ip;\n\n\tstart_report(&flags);\n\n\tprint_error_description(&info);\n\tif (addr_has_metadata(untagged_addr))\n\t\tkasan_print_tags(get_tag(tagged_addr), info.first_bad_addr);\n\tpr_err(\"\\n\");\n\n\tif (addr_has_metadata(untagged_addr)) {\n\t\tprint_address_description(untagged_addr, get_tag(tagged_addr));"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#452#452": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#452",
        "file": "mm/kasan/report.c",
        "line": 452,
        "function_snippet": "bool kasan_report(unsigned long addr, size_t size, bool is_write,\n\t\t\tunsigned long ip)\n{\n\tunsigned long flags = user_access_save();\n\tbool ret = false;\n\n\tif (likely(report_enabled())) {\n\t\t__kasan_report(addr, size, is_write, ip);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/generic.c#189#189": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/generic.c#189",
        "file": "mm/kasan/generic.c",
        "line": 189,
        "function_snippet": "\treturn check_region_inline(addr, size, write, ret_ip);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/shadow.c#54#54": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/shadow.c#54",
        "file": "mm/kasan/shadow.c",
        "line": 54,
        "function_snippet": "void *memmove(void *dest, const void *src, size_t len)\n{\n\tif (!kasan_check_range((unsigned long)src, len, false, _RET_IP_) ||"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#4205#4205": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#4205",
        "file": "fs/ext4/inode.c",
        "line": 4205,
        "function_snippet": "int ext4_punch_hole(struct file *file, loff_t offset, loff_t length)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset, max_length;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0, ret2 = 0;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinode_lock(inode);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_SIZE - (inode->i_size & (PAGE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\t/*\n\t * For punch hole the length + offset needs to be within one block\n\t * before last range. Adjust the length if it goes beyond that limit.\n\t */\n\tmax_length = sbi->s_bitmap_maxbytes - inode->i_sb->s_blocksize;\n\tif (offset + length > max_length)\n\t\tlength = max_length - offset;\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\tinode_dio_wait(inode);\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out_mutex;\n\n\t/*\n\t * Prevent page faults from reinstantiating pages we have released from\n\t * page cache.\n\t */\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\n\tret = ext4_break_layouts(inode);\n\tif (ret)\n\t\tgoto out_dio;\n\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset) {\n\t\tret = ext4_update_disksize_before_punch(inode, offset, length);\n\t\tif (ret)\n\t\t\tgoto out_dio;\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are blocks to remove, do it */\n\tif (stop_block > first_block) {\n\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\text4_discard_preallocations(inode, 0);\n\n\t\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t\t    stop_block - first_block);\n\t\tif (ret) {\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto out_stop;\n\t\t}\n\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\t\tret = ext4_ext_remove_space(inode, first_block,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4704#4704": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4704",
        "file": "fs/ext4/extents.c",
        "line": 4704,
        "function_snippet": "long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t new_size = 0;\n\tunsigned int max_blocks;\n\tint ret = 0;\n\tint flags;\n\text4_lblk_t lblk;\n\tunsigned int blkbits = inode->i_blkbits;\n\n\t/*\n\t * Encrypted inodes can't handle collapse range or insert\n\t * range since we would need to re-encrypt blocks with a\n\t * different IV or XTS tweak (which are based on the logical\n\t * block number).\n\t */\n\tif (IS_ENCRYPTED(inode) &&\n\t    (mode & (FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_INSERT_RANGE)))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t     FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE |\n\t\t     FALLOC_FL_INSERT_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\tret = ext4_convert_inline_data(inode);\n\tinode_unlock(inode);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tret = ext4_punch_hole(file, offset, len);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/open.c#310#310": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/open.c#310",
        "file": "fs/open.c",
        "line": 310,
        "function_snippet": "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#732#732": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#732",
        "file": "fs/ioctl.c",
        "line": 732,
        "function_snippet": "\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t    -EFAULT : 0;\n\t\t}\n\n\t\treturn -ENOTTY;\n\n\tcase FIFREEZE:\n\t\treturn ioctl_fsfreeze(filp);\n\n\tcase FITHAW:\n\t\treturn ioctl_fsthaw(filp);\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, argp);\n\n\tcase FIGETBSZ:\n\t\t/* anon_bdev filesystems may not have a block size */\n\t\tif (!inode->i_sb->s_blocksize)\n\t\t\treturn -EINVAL;\n\n\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tcase FIONREAD:\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\treturn vfs_ioctl(filp, cmd, arg);\n\n\t\treturn put_user(i_size_read(inode) - filp->f_pos,\n\t\t\t\t(int __user *)argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\treturn file_ioctl(filp, cmd, argp);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#751#751": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#751",
        "file": "fs/ioctl.c",
        "line": 751,
        "function_snippet": "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\n\tstruct fd f = fdget(fd);\n\tint error;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_vfs_ioctl(f.file, fd, cmd, arg);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739#739": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739,
        "function_snippet": "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#35#35": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#35",
        "file": "include/linux/page_owner.h",
        "line": 35,
        "function_snippet": "\t\t__set_page_owner(page, order, gfp_mask);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2456#2456": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2456",
        "file": "mm/page_alloc.c",
        "line": 2456,
        "function_snippet": "\tset_page_owner(page, order, gfp_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2462#2462": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2462",
        "file": "mm/page_alloc.c",
        "line": 2462,
        "function_snippet": "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,\n\t\t\t\t\t\t\tunsigned int alloc_flags)\n{\n\tpost_alloc_hook(page, order, gfp_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#4254#4254": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#4254",
        "file": "mm/page_alloc.c",
        "line": 4254,
        "function_snippet": "get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\tbool no_fallback;\n\nretry:\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tno_fallback = alloc_flags & ALLOC_NOFRAGMENT;\n\tz = ac->preferred_zoneref;\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->highest_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (no_fallback && nr_online_nodes > 1 &&\n\t\t    zone != ac->preferred_zoneref->zone) {\n\t\t\tint local_nid;\n\n\t\t\t/*\n\t\t\t * If moving to a remote node, retry but allow\n\t\t\t * fragmenting fallbacks. Locality is more important\n\t\t\t * than fragmentation avoidance.\n\t\t\t */\n\t\t\tlocal_nid = zone_to_nid(ac->preferred_zoneref->zone);\n\t\t\tif (zone_to_nid(zone) != local_nid) {\n\t\t\t\talloc_flags &= ~ALLOC_NOFRAGMENT;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\tmark = wmark_pages(zone, alloc_flags & ALLOC_WMARK_MASK);\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac->highest_zoneidx, alloc_flags,\n\t\t\t\t       gfp_mask)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\tac->highest_zoneidx, alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#5346#5346": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#5346",
        "file": "mm/page_alloc.c",
        "line": 5346,
        "function_snippet": "__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\t/*\n\t * Forbid the first pass from falling back to types that fragment\n\t * memory until all local zones are considered.\n\t */\n\talloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref->zone, gfp_mask);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#544#544": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#544",
        "file": "include/linux/gfp.h",
        "line": 544,
        "function_snippet": "__alloc_pages(gfp_t gfp_mask, unsigned int order, int preferred_nid)\n{\n\treturn __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#557#557": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#557",
        "file": "include/linux/gfp.h",
        "line": 557,
        "function_snippet": "__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)\n{\n\tVM_BUG_ON(nid < 0 || nid >= MAX_NUMNODES);\n\tVM_WARN_ON((gfp_mask & __GFP_THISNODE) && !node_online(nid));\n\n\treturn __alloc_pages(gfp_mask, order, nid);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#571#571": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#571",
        "file": "include/linux/gfp.h",
        "line": 571,
        "function_snippet": "static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,\n\t\t\t\t\t\tunsigned int order)\n{\n\tif (nid == NUMA_NO_NODE)\n\t\tnid = numa_mem_id();\n\n\treturn __alloc_pages_node(nid, gfp_mask, order);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#590#590": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#590",
        "file": "include/linux/gfp.h",
        "line": 590,
        "function_snippet": "static inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\treturn alloc_pages_node(numa_node_id(), gfp_mask, order);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#290#290": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#290",
        "file": "include/linux/pagemap.h",
        "line": 290,
        "function_snippet": "\treturn alloc_pages(gfp, 0);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#1848#1848": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#1848",
        "file": "mm/filemap.c",
        "line": 1848,
        "function_snippet": "struct page *pagecache_get_page(struct address_space *mapping, pgoff_t index,\n\t\tint fgp_flags, gfp_t gfp_mask)\n{\n\tstruct page *page;\n\nrepeat:\n\tpage = find_get_entry(mapping, index);\n\tif (xa_is_value(page))\n\t\tpage = NULL;\n\n\ttrace_android_vh_pagecache_get_page(mapping, index, fgp_flags,\n\t\t\t\t\tgfp_mask, page);\n\tif (!page)\n\t\tgoto no_page;\n\n\tif (fgp_flags & FGP_LOCK) {\n\t\tif (fgp_flags & FGP_NOWAIT) {\n\t\t\tif (!trylock_page(page)) {\n\t\t\t\tput_page(page);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tlock_page(page);\n\t\t}\n\n\t\t/* Has the page been truncated? */\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tVM_BUG_ON_PAGE(!thp_contains(page, index), page);\n\t}\n\n\tif (fgp_flags & FGP_ACCESSED)\n\t\tmark_page_accessed(page);\n\telse if (fgp_flags & FGP_WRITE) {\n\t\t/* Clear idle flag for buffer write */\n\t\tif (page_is_idle(page))\n\t\t\tclear_page_idle(page);\n\t}\n\tif (!(fgp_flags & FGP_HEAD))\n\t\tpage = find_subpage(page, index);\n\nno_page:\n\tif (!page && (fgp_flags & FGP_CREAT)) {\n\t\tint err;\n\t\tif ((fgp_flags & FGP_WRITE) && mapping_can_writeback(mapping))\n\t\t\tgfp_mask |= __GFP_WRITE;\n\t\tif (fgp_flags & FGP_NOFS)\n\t\t\tgfp_mask &= ~__GFP_FS;\n\n\t\tpage = __page_cache_alloc(gfp_mask);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#402#402": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#402",
        "file": "include/linux/pagemap.h",
        "line": 402,
        "function_snippet": "static inline struct page *find_or_create_page(struct address_space *mapping,\n\t\t\t\t\tpgoff_t index, gfp_t gfp_mask)\n{\n\treturn pagecache_get_page(mapping, index,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#976#976": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#976",
        "file": "fs/buffer.c",
        "line": 976,
        "function_snippet": "grow_dev_page(struct block_device *bdev, sector_t block,\n\t      pgoff_t index, int size, int sizebits, gfp_t gfp)\n{\n\tstruct inode *inode = bdev->bd_inode;\n\tstruct page *page;\n\tstruct buffer_head *bh;\n\tsector_t end_block;\n\tint ret = 0;\n\tgfp_t gfp_mask;\n\n\tgfp_mask = mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS) | gfp;\n\n\t/*\n\t * XXX: __getblk_slow() can not really deal with failure and\n\t * will endlessly loop on improvised global reclaim.  Prefer\n\t * looping in the allocator rather than here, at least that\n\t * code knows what it's doing.\n\t */\n\tgfp_mask |= __GFP_NOFAIL;\n\n\tpage = find_or_create_page(inode->i_mapping, index, gfp_mask);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1045#1045": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1045",
        "file": "fs/buffer.c",
        "line": 1045,
        "function_snippet": "\treturn grow_dev_page(bdev, block, index, size, sizebits, gfp);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1072#1072": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1072",
        "file": "fs/buffer.c",
        "line": 1072,
        "function_snippet": "__getblk_slow(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\t/* Size must be multiple of hard sectorsize */\n\tif (unlikely(size & (bdev_logical_block_size(bdev)-1) ||\n\t\t\t(size < 512 || size > PAGE_SIZE))) {\n\t\tprintk(KERN_ERR \"getblk(): invalid block size %d requested\\n\",\n\t\t\t\t\tsize);\n\t\tprintk(KERN_ERR \"logical block size: %d\\n\",\n\t\t\t\t\tbdev_logical_block_size(bdev));\n\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\tfor (;;) {\n\t\tstruct buffer_head *bh;\n\t\tint ret;\n\n\t\tbh = __find_get_block(bdev, block, size);\n\t\tif (bh)\n\t\t\treturn bh;\n\n\t\tret = grow_buffers(bdev, block, size, gfp);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1370#1370": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1370",
        "file": "fs/buffer.c",
        "line": 1370,
        "function_snippet": "__getblk_gfp(struct block_device *bdev, sector_t block,\n\t     unsigned size, gfp_t gfp)\n{\n\tstruct buffer_head *bh = __find_get_block(bdev, block, size);\n\n\tmight_sleep();\n\tif (bh == NULL)\n\t\tbh = __getblk_slow(bdev, block, size, gfp);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/buffer_head.h#368#368": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/buffer_head.h#368",
        "file": "include/linux/buffer_head.h",
        "line": 368,
        "function_snippet": "\treturn __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1325#1325": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1325",
        "file": "fs/ext4/extents.c",
        "line": 1325,
        "function_snippet": "static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,\n\t\t\t\t unsigned int flags)\n{\n\tstruct ext4_extent_header *neh;\n\tstruct buffer_head *bh;\n\text4_fsblk_t newblock, goal = 0;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\tint err = 0;\n\tsize_t ext_size = 0;\n\n\t/* Try to prepend new index to old one */\n\tif (ext_depth(inode))\n\t\tgoal = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));\n\tif (goal > le32_to_cpu(es->s_first_data_block)) {\n\t\tflags |= EXT4_MB_HINT_TRY_GOAL;\n\t\tgoal--;\n\t} else\n\t\tgoal = ext4_inode_to_goal_block(inode);\n\tnewblock = ext4_new_meta_blocks(handle, inode, goal, flags,\n\t\t\t\t\tNULL, &err);\n\tif (newblock == 0)\n\t\treturn err;\n\n\tbh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1424#1424": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1424",
        "file": "fs/ext4/extents.c",
        "line": 1424,
        "function_snippet": "static int ext4_ext_create_new_leaf(handle_t *handle, struct inode *inode,\n\t\t\t\t    unsigned int mb_flags,\n\t\t\t\t    unsigned int gb_flags,\n\t\t\t\t    struct ext4_ext_path **ppath,\n\t\t\t\t    struct ext4_extent *newext)\n{\n\tstruct ext4_ext_path *path = *ppath;\n\tstruct ext4_ext_path *curp;\n\tint depth, i, err = 0;\n\nrepeat:\n\ti = depth = ext_depth(inode);\n\n\t/* walk up to the tree and look for free index entry */\n\tcurp = path + depth;\n\twhile (i > 0 && !EXT_HAS_FREE_INDEX(curp)) {\n\t\ti--;\n\t\tcurp--;\n\t}\n\n\t/* we use already allocated block for index block,\n\t * so subsequent data blocks should be contiguous */\n\tif (EXT_HAS_FREE_INDEX(curp)) {\n\t\t/* if we found index with free entry, then use that\n\t\t * entry: create all needed subtree and add new leaf */\n\t\terr = ext4_ext_split(handle, inode, mb_flags, path, newext, i);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* refill path */\n\t\tpath = ext4_find_extent(inode,\n\t\t\t\t    (ext4_lblk_t)le32_to_cpu(newext->ee_block),\n\t\t\t\t    ppath, gb_flags);\n\t\tif (IS_ERR(path))\n\t\t\terr = PTR_ERR(path);\n\t} else {\n\t\t/* tree is full, time to grow in depth */\n\t\terr = ext4_ext_grow_indepth(handle, inode, mb_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2094#2094": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2094",
        "file": "fs/ext4/extents.c",
        "line": 2094,
        "function_snippet": "\t\t    le32_to_cpu(newext->ee_block))) {\n\t\t\tex += 1;\n\t\t\tgoto prepend;\n\t\t} else if ((ex > EXT_FIRST_EXTENT(eh)) &&\n\t\t\t   (le32_to_cpu(newext->ee_block) +\n\t\t\t   ext4_ext_get_actual_len(newext) <\n\t\t\t   le32_to_cpu(ex->ee_block)))\n\t\t\tex -= 1;\n\n\t\t/* Try to append newex to the ex */\n\t\tif (ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\t\text_debug(inode, \"append [%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\teh = path[depth].p_hdr;\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\nprepend:\n\t\t/* Try to prepend newex to the ex */\n\t\tif (ext4_can_extents_be_merged(inode, newext, ex)) {\n\t\t\text_debug(inode, \"prepend %u[%d]%d block to %u:[%d]%d\"\n\t\t\t\t  \"(from %llu)\\n\",\n\t\t\t\t  le32_to_cpu(newext->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(newext),\n\t\t\t\t  ext4_ext_get_actual_len(newext),\n\t\t\t\t  le32_to_cpu(ex->ee_block),\n\t\t\t\t  ext4_ext_is_unwritten(ex),\n\t\t\t\t  ext4_ext_get_actual_len(ex),\n\t\t\t\t  ext4_ext_pblock(ex));\n\t\t\terr = ext4_ext_get_access(handle, inode,\n\t\t\t\t\t\t  path + depth);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tunwritten = ext4_ext_is_unwritten(ex);\n\t\t\tex->ee_block = newext->ee_block;\n\t\t\text4_ext_store_pblock(ex, ext4_ext_pblock(newext));\n\t\t\tex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)\n\t\t\t\t\t+ ext4_ext_get_actual_len(newext));\n\t\t\tif (unwritten)\n\t\t\t\text4_ext_mark_unwritten(ex);\n\t\t\teh = path[depth].p_hdr;\n\t\t\tnearex = ex;\n\t\t\tgoto merge;\n\t\t}\n\t}\n\n\tdepth = ext_depth(inode);\n\teh = path[depth].p_hdr;\n\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))\n\t\tgoto has_space;\n\n\t/* probably next leaf has space for us? */\n\tfex = EXT_LAST_EXTENT(eh);\n\tnext = EXT_MAX_BLOCKS;\n\tif (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))\n\t\tnext = ext4_ext_next_leaf_block(path);\n\tif (next != EXT_MAX_BLOCKS) {\n\t\text_debug(inode, \"next leaf block - %u\\n\", next);\n\t\tBUG_ON(npath != NULL);\n\t\tnpath = ext4_find_extent(inode, next, NULL, gb_flags);\n\t\tif (IS_ERR(npath))\n\t\t\treturn PTR_ERR(npath);\n\t\tBUG_ON(npath->p_depth != path->p_depth);\n\t\teh = npath[depth].p_hdr;\n\t\tif (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {\n\t\t\text_debug(inode, \"next leaf isn't full(%d)\\n\",\n\t\t\t\t  le16_to_cpu(eh->eh_entries));\n\t\t\tpath = npath;\n\t\t\tgoto has_space;\n\t\t}\n\t\text_debug(inode, \"next leaf has no free space(%d,%d)\\n\",\n\t\t\t  le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));\n\t}\n\n\t/*\n\t * There is no free space in the found leaf.\n\t * We're gonna add a new leaf in the tree.\n\t */\n\tif (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)\n\t\tmb_flags |= EXT4_MB_USE_RESERVED;\n\terr = ext4_ext_create_new_leaf(handle, inode, mb_flags, gb_flags,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4302#4302": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4302",
        "file": "fs/ext4/extents.c",
        "line": 4302,
        "function_snippet": "\t    get_implied_cluster_alloc(inode->i_sb, map, &ex2, path)) {\n\t\tar.len = allocated = map->m_len;\n\t\tnewblock = map->m_pblk;\n\t\tgoto got_allocated_blocks;\n\t}\n\n\t/*\n\t * See if request is beyond maximum number of blocks we can have in\n\t * a single extent. For an initialized extent this limit is\n\t * EXT_INIT_MAX_LEN and for an unwritten extent this limit is\n\t * EXT_UNWRITTEN_MAX_LEN.\n\t */\n\tif (map->m_len > EXT_INIT_MAX_LEN &&\n\t    !(flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_INIT_MAX_LEN;\n\telse if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&\n\t\t (flags & EXT4_GET_BLOCKS_UNWRIT_EXT))\n\t\tmap->m_len = EXT_UNWRITTEN_MAX_LEN;\n\n\t/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */\n\tnewex.ee_len = cpu_to_le16(map->m_len);\n\terr = ext4_ext_check_overlap(sbi, inode, &newex, path);\n\tif (err)\n\t\tallocated = ext4_ext_get_actual_len(&newex);\n\telse\n\t\tallocated = map->m_len;\n\n\t/* allocate new block */\n\tar.inode = inode;\n\tar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);\n\tar.logical = map->m_lblk;\n\t/*\n\t * We calculate the offset from the beginning of the cluster\n\t * for the logical block number, since when we allocate a\n\t * physical cluster, the physical block should start at the\n\t * same offset from the beginning of the cluster.  This is\n\t * needed so that future calls to get_implied_cluster_alloc()\n\t * work correctly.\n\t */\n\toffset = EXT4_LBLK_COFF(sbi, map->m_lblk);\n\tar.len = EXT4_NUM_B2C(sbi, offset+allocated);\n\tar.goal -= offset;\n\tar.logical -= offset;\n\tif (S_ISREG(inode->i_mode))\n\t\tar.flags = EXT4_MB_HINT_DATA;\n\telse\n\t\t/* disable in-core preallocation for non-regular files */\n\t\tar.flags = 0;\n\tif (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)\n\t\tar.flags |= EXT4_MB_HINT_NOPREALLOC;\n\tif (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)\n\t\tar.flags |= EXT4_MB_DELALLOC_RESERVED;\n\tif (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)\n\t\tar.flags |= EXT4_MB_USE_RESERVED;\n\tnewblock = ext4_mb_new_blocks(handle, &ar, &err);\n\tif (!newblock)\n\t\tgoto out;\n\tallocated_clusters = ar.len;\n\tar.len = EXT4_C2B(sbi, ar.len) - offset;\n\text_debug(inode, \"allocate new block: goal %llu, found %llu/%u, requested %u\\n\",\n\t\t  ar.goal, newblock, ar.len, allocated);\n\tif (ar.len > allocated)\n\t\tar.len = allocated;\n\ngot_allocated_blocks:\n\t/* try to insert new extent into found leaf and return */\n\tpblk = newblock + offset;\n\text4_ext_store_pblock(&newex, pblk);\n\tnewex.ee_len = cpu_to_le16(ar.len);\n\t/* Mark unwritten */\n\tif (flags & EXT4_GET_BLOCKS_UNWRIT_EXT) {\n\t\text4_ext_mark_unwritten(&newex);\n\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t}\n\n\terr = ext4_ext_insert_extent(handle, inode, &path, &newex, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#646#646": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#646",
        "file": "fs/ext4/inode.c",
        "line": 646,
        "function_snippet": "\t    ext4_es_lookup_extent(inode, map->m_lblk, NULL, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tmap->m_pblk = 0;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, 0);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, 0);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    !(status & EXTENT_STATUS_WRITTEN) &&\n\t\t    ext4_es_scan_range(inode, &ext4_es_is_delayed, map->m_lblk,\n\t\t\t\t       map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#793#793": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#793",
        "file": "fs/ext4/inode.c",
        "line": 793,
        "function_snippet": "static int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\tstruct ext4_map_blocks map;\n\tint ret = 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tret = ext4_map_blocks(ext4_journal_current_handle(), inode, &map,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#810#810": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#810",
        "file": "fs/ext4/inode.c",
        "line": 810,
        "function_snippet": "int ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh, int create)\n{\n\treturn _ext4_get_block(inode, iblock, bh,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#1077#1077": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#1077",
        "file": "fs/ext4/inode.c",
        "line": 1077,
        "function_snippet": "static int ext4_block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\t\t\t  get_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned bbits;\n\tstruct buffer_head *bh, *head, *wait[2];\n\tint nr_wait = 0;\n\tint i;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\thead = page_buffers(page);\n\tbbits = ilog2(blocksize);\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#3021#3021": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#3021",
        "file": "fs/ext4/inode.c",
        "line": 3021,
        "function_snippet": "\t    ext4_verity_in_progress(inode)) {\n\t\t*fsdata = (void *)FALL_BACK_TO_NONDELALLOC;\n\t\treturn ext4_write_begin(file, mapping, pos,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#3506#3506": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#3506",
        "file": "mm/filemap.c",
        "line": 3506,
        "function_snippet": "ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\t/* Offset into pagecache page */\n\t\tunsigned long bytes;\t/* Bytes to write to page */\n\t\tsize_t copied;\t\t/* Bytes copied from user */\n\t\tvoid *fsdata = NULL;\n\n\t\toffset = (pos & (PAGE_SIZE - 1));\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\n\nagain:\n\t\t/*\n\t\t * Bring in the user page that we will copy from _first_.\n\t\t * Otherwise there's a nasty deadlock on copying from the\n\t\t * same page as we're writing to, without it being marked\n\t\t * up-to-date.\n\t\t *\n\t\t * Not only is this an optimisation, but it is also required\n\t\t * to check that the address is actually valid, when atomic\n\t\t * usercopies are used, below.\n\t\t */\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\tstatus = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#271#271": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#271",
        "file": "fs/ext4/file.c",
        "line": 271,
        "function_snippet": "static ssize_t ext4_buffered_write_iter(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *from)\n{\n\tssize_t ret;\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\n\tif (iocb->ki_flags & IOCB_NOWAIT)\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\tret = ext4_write_checks(iocb, from);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\tret = generic_perform_write(iocb->ki_filp, from, iocb->ki_pos);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#685#685": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#685",
        "file": "fs/ext4/file.c",
        "line": 685,
        "function_snippet": "\t\treturn ext4_buffered_write_iter(iocb, from);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#28#28": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#28",
        "file": "include/linux/page_owner.h",
        "line": 28,
        "function_snippet": "\t\t__reset_page_owner(page, order);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1349#1349": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1349",
        "file": "mm/page_alloc.c",
        "line": 1349,
        "function_snippet": "static __always_inline bool free_pages_prepare(struct page *page,\n\t\t\tunsigned int order, bool check_free, fpi_t fpi_flags)\n{\n\tint bad = 0;\n\tbool skip_kasan_poison = should_skip_kasan_poison(page, fpi_flags);\n\tbool init = want_init_on_free();\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\tif (unlikely(PageHWPoison(page)) && !order) {\n\t\t/*\n\t\t * Do not let hwpoison pages hit pcplists/buddy\n\t\t * Untie memcg state and reset page's owner\n\t\t */\n\t\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\t\t__memcg_kmem_uncharge_page(page, order);\n\t\treset_page_owner(page, order);\n\t\tfree_page_pinner(page, order);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(check_free_page(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\t__memcg_kmem_uncharge_page(page, order);\n\tif (check_free)\n\t\tbad += check_free_page(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1421#1421": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1421",
        "file": "mm/page_alloc.c",
        "line": 1421,
        "function_snippet": "\t\treturn free_pages_prepare(page, 0, false, FPI_NONE);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3336#3336": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3336",
        "file": "mm/page_alloc.c",
        "line": 3336,
        "function_snippet": "static bool free_unref_page_prepare(struct page *page, unsigned long pfn)\n{\n\tint migratetype;\n\n\tif (!free_pcp_prepare(page))"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3443#3443": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3443",
        "file": "mm/page_alloc.c",
        "line": 3443,
        "function_snippet": "\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tunsigned long pfn = page_to_pfn(page);\n\t\tif (!free_unref_page_prepare(page, pfn)) {"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap.c#1103#1103": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap.c#1103",
        "file": "mm/swap.c",
        "line": 1103,
        "function_snippet": "void release_pages(struct page **pages, int nr)\n{\n\tint i;\n\tLIST_HEAD(pages_to_free);\n\tstruct pglist_data *locked_pgdat = NULL;\n\tstruct lruvec *lruvec;\n\tunsigned long flags;\n\tunsigned int lock_batch;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pages[i];\n\n\t\t/*\n\t\t * Make sure the IRQ-safe lock-holding time does not get\n\t\t * excessive with a continuous string of pages from the\n\t\t * same pgdat. The lock is held only if pgdat != NULL.\n\t\t */\n\t\tif (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {\n\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\tlocked_pgdat = NULL;\n\t\t}\n\n\t\tpage = compound_head(page);\n\t\tif (is_huge_zero_page(page))\n\t\t\tcontinue;\n\n\t\tif (is_zone_device_page(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t/*\n\t\t\t * ZONE_DEVICE pages that return 'false' from\n\t\t\t * page_is_devmap_managed() do not require special\n\t\t\t * processing, and instead, expect a call to\n\t\t\t * put_page_testzero().\n\t\t\t */\n\t\t\tif (page_is_devmap_managed(page)) {\n\t\t\t\tput_devmap_managed_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (!put_page_testzero(page))\n\t\t\tcontinue;\n\n\t\tif (PageCompound(page)) {\n\t\t\tif (locked_pgdat) {\n\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\t\t\t\tlocked_pgdat = NULL;\n\t\t\t}\n\t\t\t__put_compound_page(page);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (PageLRU(page)) {\n\t\t\tstruct pglist_data *pgdat = page_pgdat(page);\n\n\t\t\tif (pgdat != locked_pgdat) {\n\t\t\t\tif (locked_pgdat)\n\t\t\t\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock,\n\t\t\t\t\t\t\t\t\tflags);\n\t\t\t\tlock_batch = 0;\n\t\t\t\tlocked_pgdat = pgdat;\n\t\t\t\tspin_lock_irqsave(&locked_pgdat->lru_lock, flags);\n\t\t\t}\n\n\t\t\tlruvec = mem_cgroup_page_lruvec(page, locked_pgdat);\n\t\t\tdel_page_from_lru_list(page, lruvec);\n\t\t\t__clear_page_lru_flags(page);\n\t\t}\n\n\t\t__ClearPageWaiters(page);\n\n\t\tlist_add(&page->lru, &pages_to_free);\n\t}\n\tif (locked_pgdat)\n\t\tspin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);\n\n\tmem_cgroup_uncharge_list(&pages_to_free);\n\tfree_unref_page_list(&pages_to_free);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap_state.c#356#356": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap_state.c#356",
        "file": "mm/swap_state.c",
        "line": 356,
        "function_snippet": "\trelease_pages(pagep, nr);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#49#49": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#49",
        "file": "mm/mmu_gather.c",
        "line": 49,
        "function_snippet": "static void tlb_batch_pages_flush(struct mmu_gather *tlb)\n{\n\tstruct mmu_gather_batch *batch;\n\n\tfor (batch = &tlb->local; batch && batch->nr; batch = batch->next) {\n\t\tfree_pages_and_swap_cache(batch->pages, batch->nr);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#240#240": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#240",
        "file": "mm/mmu_gather.c",
        "line": 240,
        "function_snippet": "\ttlb_batch_pages_flush(tlb);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#247#247": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#247",
        "file": "mm/mmu_gather.c",
        "line": 247,
        "function_snippet": "void tlb_flush_mmu(struct mmu_gather *tlb)\n{\n\ttlb_flush_mmu_tlbonly(tlb);\n\ttlb_flush_mmu_free(tlb);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#326#326": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#326",
        "file": "mm/mmu_gather.c",
        "line": 326,
        "function_snippet": "void tlb_finish_mmu(struct mmu_gather *tlb,\n\t\tunsigned long start, unsigned long end)\n{\n\t/*\n\t * If there are parallel threads are doing PTE changes on same range\n\t * under non-exclusive lock (e.g., mmap_lock read-side) but defer TLB\n\t * flush by batching, one thread may end up seeing inconsistent PTEs\n\t * and result in having stale TLB entries.  So flush TLB forcefully\n\t * if we detect parallel PTE batching threads.\n\t *\n\t * However, some syscalls, e.g. munmap(), may free page tables, this\n\t * needs force flush everything in the given range. Otherwise this\n\t * may result in having stale TLB entries for some architectures,\n\t * e.g. aarch64, that could specify flush what level TLB.\n\t */\n\tif (mm_tlb_flush_nested(tlb->mm)) {\n\t\t/*\n\t\t * The aarch64 yields better performance with fullmm by\n\t\t * avoiding multiple CPUs spamming TLBI messages at the\n\t\t * same time.\n\t\t *\n\t\t * On x86 non-fullmm doesn't yield significant difference\n\t\t * against fullmm.\n\t\t */\n\t\ttlb->fullmm = 1;\n\t\t__tlb_reset_range(tlb);\n\t\ttlb->freed_tables = 1;\n\t}\n\n\ttlb_flush_mmu(tlb);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#2807#2807": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#2807",
        "file": "mm/mmap.c",
        "line": 2807,
        "function_snippet": "static void unmap_region(struct mm_struct *mm,\n\t\tstruct vm_area_struct *vma, struct vm_area_struct *prev,\n\t\tunsigned long start, unsigned long end)\n{\n\tstruct vm_area_struct *next = vma_next(mm, prev);\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *cur_vma;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, start, end);\n\tupdate_hiwater_rss(mm);\n\tunmap_vmas(&tlb, vma, start, end);\n\n\t/*\n\t * Ensure we have no stale TLB entries by the time this mapping is\n\t * removed from the rmap.\n\t * Note that we don't have to worry about nested flushes here because\n\t * we're holding the mm semaphore for removing the mapping - so any\n\t * concurrent flush in this region has to be coming through the rmap,\n\t * and we synchronize against that using the rmap lock.\n\t */\n\tfor (cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next) {\n\t\tif ((cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0) {\n\t\t\ttlb_flush_mmu(&tlb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,\n\t\t\t\t next ? next->vm_start : USER_PGTABLES_CEILING);\n\ttlb_finish_mmu(&tlb, start, end);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3036#3036": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3036",
        "file": "mm/mmap.c",
        "line": 3036,
        "function_snippet": "int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,\n\t\tstruct list_head *uf, bool downgrade)\n{\n\tunsigned long end;\n\tstruct vm_area_struct *vma, *prev, *last;\n\n\tif ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)\n\t\treturn -EINVAL;\n\n\tlen = PAGE_ALIGN(len);\n\tend = start + len;\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * arch_unmap() might do unmaps itself.  It must be called\n\t * and finish any rbtree manipulation before this code\n\t * runs and also starts to manipulate the rbtree.\n\t */\n\tarch_unmap(mm, start, end);\n\n\t/* Find the first overlapping VMA */\n\tvma = find_vma(mm, start);\n\tif (!vma)\n\t\treturn 0;\n\tprev = vma->vm_prev;\n\t/* we have  start < vma->vm_end  */\n\n\t/* if it doesn't overlap, we have nothing.. */\n\tif (vma->vm_start >= end)\n\t\treturn 0;\n\n\t/*\n\t * If we need to split any vma, do it now to save pain later.\n\t *\n\t * Note: mremap's move_vma VM_ACCOUNT handling assumes a partially\n\t * unmapped vm_area_struct will remain in use: so lower split_vma\n\t * places tmp vma above, and higher split_vma places tmp vma below.\n\t */\n\tif (start > vma->vm_start) {\n\t\tint error;\n\n\t\t/*\n\t\t * Make sure that map_count on return from munmap() will\n\t\t * not exceed its limit; but let map_count go just above\n\t\t * its limit temporarily, to help free resources as expected.\n\t\t */\n\t\tif (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)\n\t\t\treturn -ENOMEM;\n\n\t\terror = __split_vma(mm, vma, start, 0);\n\t\tif (error)\n\t\t\treturn error;\n\t\tprev = vma;\n\t}\n\n\t/* Does it split the last one? */\n\tlast = find_vma(mm, end);\n\tif (last && end > last->vm_start) {\n\t\tint error = __split_vma(mm, last, end, 1);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tvma = vma_next(mm, prev);\n\n\tif (unlikely(uf)) {\n\t\t/*\n\t\t * If userfaultfd_unmap_prep returns an error the vmas\n\t\t * will remain splitted, but userland will get a\n\t\t * highly unexpected error anyway. This is no\n\t\t * different than the case where the first of the two\n\t\t * __split_vma fails, but we don't undo the first\n\t\t * split, despite we could. This is unlikely enough\n\t\t * failure that it's not worth optimizing it for.\n\t\t */\n\t\tint error = userfaultfd_unmap_prep(vma, start, end, uf);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * unlock any mlock()ed ranges before detaching vmas\n\t */\n\tif (mm->locked_vm) {\n\t\tstruct vm_area_struct *tmp = vma;\n\t\twhile (tmp && tmp->vm_start < end) {\n\t\t\tif (tmp->vm_flags & VM_LOCKED) {\n\t\t\t\tmm->locked_vm -= vma_pages(tmp);\n\t\t\t\tmunlock_vma_pages_all(tmp);\n\t\t\t}\n\n\t\t\ttmp = tmp->vm_next;\n\t\t}\n\t}\n\n\t/* Detach vmas from rbtree */\n\tif (!detach_vmas_to_be_unmapped(mm, vma, prev, end))\n\t\tdowngrade = false;\n\n\tif (downgrade)\n\t\tmmap_write_downgrade(mm);\n\n\tunmap_region(mm, vma, prev, start, end);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3059#3059": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3059",
        "file": "mm/mmap.c",
        "line": 3059,
        "function_snippet": "static int __vm_munmap(unsigned long start, size_t len, bool downgrade)\n{\n\tint ret;\n\tstruct mm_struct *mm = current->mm;\n\tLIST_HEAD(uf);\n\n\tif (mmap_write_lock_killable(mm))\n\t\treturn -EINTR;\n\n\tret = __do_munmap(mm, start, len, &uf, downgrade);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3085#3085": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3085",
        "file": "mm/mmap.c",
        "line": 3085,
        "function_snippet": "SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)\n{\n\taddr = untagged_addr(addr);\n\tprofile_munmap(addr);\n\treturn __vm_munmap(addr, len, true);"
      },
      "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081#3081": {
        "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081",
        "file": "mm/mmap.c",
        "line": 3081,
        "function_snippet": "SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)"
      }
    }
  },
  "evidence": {
    "https://android.googlesource.com/kernel/common/": {
      "error": "URL not in expected +/commit/path format"
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730#2730": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
        ],
        [
          2,
          "struct ext4_ext_path *path,"
        ],
        [
          3,
          "struct partial_cluster *partial,"
        ],
        [
          6,
          "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
        ],
        [
          9,
          "struct ext4_extent_header *eh;"
        ],
        [
          15,
          "struct ext4_extent *ex;"
        ],
        [
          18,
          "/* the header must be checked already in ext4_ext_remove_space() */"
        ],
        [
          21,
          "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
        ],
        [
          22,
          "eh = path[depth].p_hdr;"
        ],
        [
          24,
          "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
        ],
        [
          27,
          "/* find where to start removing */"
        ],
        [
          28,
          "ex = path[depth].p_ext;"
        ],
        [
          32,
          "ex_ee_block = le32_to_cpu(ex->ee_block);"
        ],
        [
          45,
          "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
        ],
        [
          47,
          "path[depth].p_ext = ex;"
        ],
        [
          55,
          "/* If this extent is beyond the end of the hole, skip it */"
        ],
        [
          57,
          "/*"
        ],
        [
          58,
          "* We're going to skip this extent and move to another,"
        ],
        [
          59,
          "* so note that its first cluster is in use to avoid"
        ],
        [
          61,
          "* right edge of the truncated/punched region will"
        ],
        [
          63,
          "*/"
        ],
        [
          64,
          "if (sbi->s_cluster_ratio > 1) {"
        ],
        [
          66,
          "partial->pclu = EXT4_B2C(sbi, pblk);"
        ],
        [
          67,
          "partial->state = nofree;"
        ],
        [
          70,
          "ex_ee_block = le32_to_cpu(ex->ee_block);"
        ],
        [
          82,
          "/* remove tail of the extent */"
        ],
        [
          85,
          "/* remove whole extent: excellent! */"
        ],
        [
          88,
          "/*"
        ],
        [
          89,
          "* 3 for leaf, sb, and inode plus 2 (bmap and group"
        ],
        [
          90,
          "* descriptor) for each block group; assume two block"
        ],
        [
          91,
          "* groups plus ex_ee_len/blocks_per_block_group for"
        ],
        [
          92,
          "* the worst case"
        ],
        [
          93,
          "*/"
        ],
        [
          94,
          "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
        ],
        [
          99,
          "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
        ],
        [
          100,
          "/*"
        ],
        [
          101,
          "* We may end up freeing some index blocks and data from the"
        ],
        [
          104,
          "*/"
        ],
        [
          106,
          "ext4_free_metadata_revoke_credits(inode->i_sb,"
        ],
        [
          127,
          "/* this extent is removed; mark slot entirely unused */"
        ],
        [
          130,
          "ex->ee_len = cpu_to_le16(num);"
        ],
        [
          131,
          "/*"
        ],
        [
          132,
          "* Do not mark unwritten if all the blocks in the"
        ],
        [
          134,
          "*/"
        ],
        [
          137,
          "/*"
        ],
        [
          138,
          "* If the extent was completely released,"
        ],
        [
          139,
          "* we need to remove it from the leaf"
        ],
        [
          140,
          "*/"
        ],
        [
          143,
          "/*"
        ],
        [
          144,
          "* For hole punching, we need to scoot all the"
        ],
        [
          145,
          "* extents up when an extent is removed so that"
        ],
        [
          146,
          "* we dont have blank extents in the middle"
        ],
        [
          147,
          "*/"
        ],
        [
          148,
          "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
        ],
        [
          148,
          "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
        ]
      ],
      "deref_writes": 4,
      "deref_reads": 8,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730",
      "source_file": "fs/ext4/extents.c",
      "source_line": 2730
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952#2952": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,"
        ],
        [
          4,
          "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
        ],
        [
          6,
          "struct ext4_ext_path *path = NULL;"
        ],
        [
          8,
          "handle_t *handle;"
        ],
        [
          17,
          "/* probably first extent we're gonna free will be last in block */"
        ],
        [
          20,
          "ext4_free_metadata_revoke_credits(inode->i_sb, depth));"
        ],
        [
          27,
          "/*"
        ],
        [
          29,
          "* is the case, we are going to punch a hole inside the extent tree"
        ],
        [
          30,
          "* so we have to check whether we need to split the extent covering"
        ],
        [
          31,
          "* the last block to remove so we can easily remove the part of it"
        ],
        [
          33,
          "*/"
        ],
        [
          35,
          "struct ext4_extent *ex;"
        ],
        [
          39,
          "/* find extent for or closest extent to this block */"
        ],
        [
          47,
          "/* Leaf not may not exist only if inode has no blocks at all */"
        ],
        [
          48,
          "ex = path[depth].p_ext;"
        ],
        [
          52,
          "\"path[%d].p_hdr == NULL\","
        ],
        [
          59,
          "ee_block = le32_to_cpu(ex->ee_block);"
        ],
        [
          62,
          "/*"
        ],
        [
          63,
          "* See if the last block is inside the extent, if so split"
        ],
        [
          64,
          "* the extent at 'end' block so we can easily remove the"
        ],
        [
          65,
          "* tail of the first part of the split extent in"
        ],
        [
          67,
          "*/"
        ],
        [
          70,
          "/*"
        ],
        [
          71,
          "* If we're going to split the extent, note that"
        ],
        [
          72,
          "* the cluster containing the block after 'end' is"
        ],
        [
          74,
          "*/"
        ],
        [
          75,
          "if (sbi->s_cluster_ratio > 1) {"
        ],
        [
          81,
          "/*"
        ],
        [
          82,
          "* Split the extent in two so that 'end' is the last"
        ],
        [
          84,
          "* fail removing space due to ENOSPC so try to use"
        ],
        [
          86,
          "*/"
        ],
        [
          92,
          "} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&"
        ],
        [
          94,
          "/*"
        ],
        [
          96,
          "* If the partial cluster hasn't been set, set it to"
        ],
        [
          97,
          "* that extent's first cluster and its state to nofree"
        ],
        [
          98,
          "* so it won't be freed should it contain blocks to be"
        ],
        [
          100,
          "* retrying and keep the original partial cluster info"
        ],
        [
          101,
          "* so a cluster marked tofree as a result of earlier"
        ],
        [
          103,
          "*/"
        ],
        [
          115,
          "/*"
        ],
        [
          116,
          "* We start scanning from right side, freeing all the blocks"
        ],
        [
          118,
          "*/"
        ],
        [
          123,
          "path[k].p_block ="
        ],
        [
          124,
          "le16_to_cpu(path[k].p_hdr->eh_entries)+1;"
        ],
        [
          124,
          "le16_to_cpu(path[k].p_hdr->eh_entries)+1;"
        ],
        [
          132,
          "path[0].p_maxdepth = path[0].p_depth = depth;"
        ],
        [
          133,
          "path[0].p_hdr = ext_inode_hdr(inode);"
        ],
        [
          145,
          "/* this is leaf block */"
        ]
      ],
      "deref_writes": 3,
      "deref_reads": 7,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952",
      "source_file": "fs/ext4/extents.c",
      "source_line": 2952
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#77#77": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void __dump_stack(const char *log_lvl)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#77",
      "source_file": "lib/dump_stack.c",
      "source_line": 77
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#118#118": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "asmlinkage __visible void dump_stack_lvl(const char *log_lvl)"
        ],
        [
          8,
          "/*"
        ],
        [
          9,
          "* Permit this cpu to perform nested stack dumps while serialising"
        ],
        [
          10,
          "* against other CPUs"
        ],
        [
          11,
          "*/"
        ],
        [
          22,
          "/*"
        ],
        [
          23,
          "* Wait for the lock to release before jumping to"
        ],
        [
          24,
          "* atomic_cmpxchg() in order to mitigate the thundering herd"
        ],
        [
          26,
          "*/"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#118",
      "source_file": "lib/dump_stack.c",
      "source_line": 118
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#248#248": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void print_address_description(void *addr, u8 tag)"
        ],
        [
          3,
          "struct page *page = kasan_addr_to_page(addr);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#248",
      "source_file": "mm/kasan/report.c",
      "source_line": 248
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#435#435": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          5,
          "void *tagged_addr;"
        ],
        [
          6,
          "void *untagged_addr;"
        ],
        [
          10,
          "if (current->kunit_test)"
        ],
        [
          11,
          "kasan_update_kunit_status(current->kunit_test, true);"
        ],
        [
          12,
          "#endif /* IS_ENABLED(CONFIG_KUNIT) */"
        ],
        [
          16,
          "tagged_addr = (void *)addr;"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 3,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#435",
      "source_file": "mm/kasan/report.c",
      "source_line": 435
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#452#452": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#452",
      "source_file": "mm/kasan/report.c",
      "source_line": 452
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/generic.c#189#189": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/generic.c#189",
      "source_file": "mm/kasan/generic.c",
      "source_line": 189
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/shadow.c#54#54": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void *memmove(void *dest, const void *src, size_t len)"
        ],
        [
          1,
          "void *memmove(void *dest, const void *src, size_t len)"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 1,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/shadow.c#54",
      "source_file": "mm/kasan/shadow.c",
      "source_line": 54
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#4205#4205": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int ext4_punch_hole(struct file *file, loff_t offset, loff_t length)"
        ],
        [
          3,
          "struct inode *inode = file_inode(file);"
        ],
        [
          4,
          "struct super_block *sb = inode->i_sb;"
        ],
        [
          6,
          "struct address_space *mapping = inode->i_mapping;"
        ],
        [
          8,
          "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
        ],
        [
          9,
          "handle_t *handle;"
        ],
        [
          15,
          "/*"
        ],
        [
          16,
          "* Write out all dirty pages to avoid race conditions"
        ],
        [
          18,
          "*/"
        ],
        [
          28,
          "/* No need to punch hole beyond i_size */"
        ],
        [
          29,
          "if (offset >= inode->i_size)"
        ],
        [
          32,
          "/*"
        ],
        [
          33,
          "* If the hole extends beyond i_size, set the hole"
        ],
        [
          34,
          "* to end after the page that contains i_size"
        ],
        [
          35,
          "*/"
        ],
        [
          36,
          "if (offset + length > inode->i_size) {"
        ],
        [
          37,
          "length = inode->i_size +"
        ],
        [
          38,
          "PAGE_SIZE - (inode->i_size & (PAGE_SIZE - 1)) -"
        ],
        [
          42,
          "/*"
        ],
        [
          43,
          "* For punch hole the length + offset needs to be within one block"
        ],
        [
          45,
          "*/"
        ],
        [
          46,
          "max_length = sbi->s_bitmap_maxbytes - inode->i_sb->s_blocksize;"
        ],
        [
          50,
          "if (offset & (sb->s_blocksize - 1) ||"
        ],
        [
          51,
          "(offset + length) & (sb->s_blocksize - 1)) {"
        ],
        [
          52,
          "/*"
        ],
        [
          53,
          "* Attach jinode to inode for jbd2 if we do any zeroing of"
        ],
        [
          54,
          "* partial block"
        ],
        [
          55,
          "*/"
        ],
        [
          62,
          "/* Wait all existing dio workers, newcomers will block on i_mutex */"
        ],
        [
          69,
          "/*"
        ],
        [
          70,
          "* Prevent page faults from reinstantiating pages we have released from"
        ],
        [
          72,
          "*/"
        ],
        [
          73,
          "down_write(&EXT4_I(inode)->i_mmap_sem);"
        ],
        [
          79,
          "first_block_offset = round_up(offset, sb->s_blocksize);"
        ],
        [
          80,
          "last_block_offset = round_down((offset + length), sb->s_blocksize) - 1;"
        ],
        [
          82,
          "/* Now release the pages and zero block aligned part of pages*/"
        ],
        [
          107,
          "first_block = (offset + sb->s_blocksize - 1) >>"
        ],
        [
          111,
          "/* If there are blocks to remove, do it */"
        ],
        [
          114,
          "down_write(&EXT4_I(inode)->i_data_sem);"
        ],
        [
          120,
          "up_write(&EXT4_I(inode)->i_data_sem);"
        ]
      ],
      "deref_writes": 4,
      "deref_reads": 17,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#4205",
      "source_file": "fs/ext4/inode.c",
      "source_line": 4205
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4704#4704": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)"
        ],
        [
          3,
          "struct inode *inode = file_inode(file);"
        ],
        [
          9,
          "unsigned int blkbits = inode->i_blkbits;"
        ],
        [
          11,
          "/*"
        ],
        [
          12,
          "* Encrypted inodes can't handle collapse range or insert"
        ],
        [
          13,
          "* range since we would need to re-encrypt blocks with a"
        ],
        [
          14,
          "* different IV or XTS tweak (which are based on the logical"
        ],
        [
          16,
          "*/"
        ],
        [
          21,
          "/* Return error if mode is not supported */"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 2,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4704",
      "source_file": "fs/ext4/extents.c",
      "source_line": 4704
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/open.c#310#310": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)"
        ],
        [
          3,
          "struct inode *inode = file_inode(file);"
        ],
        [
          9,
          "/* Return error if mode is not supported */"
        ],
        [
          13,
          "/* Punch hole and zero range are mutually exclusive */"
        ],
        [
          18,
          "/* Punch hole must have keep size set */"
        ],
        [
          38,
          "if (!(file->f_mode & FMODE_WRITE))"
        ],
        [
          41,
          "/*"
        ],
        [
          42,
          "* We can only allow pure fallocate on append only files"
        ],
        [
          43,
          "*/"
        ],
        [
          50,
          "/*"
        ],
        [
          51,
          "* We cannot allow any fallocate operation on an active swapfile"
        ],
        [
          52,
          "*/"
        ],
        [
          56,
          "/*"
        ],
        [
          57,
          "* Revalidate the write permissions, in case security policy has"
        ],
        [
          59,
          "*/"
        ],
        [
          64,
          "if (S_ISFIFO(inode->i_mode))"
        ],
        [
          67,
          "if (S_ISDIR(inode->i_mode))"
        ],
        [
          70,
          "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))"
        ],
        [
          73,
          "/* Check for wrap through zero too */"
        ],
        [
          74,
          "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))"
        ],
        [
          77,
          "if (!file->f_op->fallocate)"
        ],
        [
          81,
          "ret = file->f_op->fallocate(file, mode, offset, len);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 8,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/open.c#310",
      "source_file": "fs/open.c",
      "source_line": 310
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#732#732": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "S_ISLNK(inode->i_mode)) {"
        ],
        [
          3,
          "return copy_to_user(argp, &res, sizeof(res)) ?"
        ],
        [
          19,
          "/* anon_bdev filesystems may not have a block size */"
        ],
        [
          20,
          "if (!inode->i_sb->s_blocksize)"
        ],
        [
          23,
          "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);"
        ],
        [
          35,
          "if (!S_ISREG(inode->i_mode))"
        ],
        [
          38,
          "return put_user(i_size_read(inode) - filp->f_pos,"
        ],
        [
          39,
          "(int __user *)argp);"
        ],
        [
          42,
          "if (S_ISREG(inode->i_mode))"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 7,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#732",
      "source_file": "fs/ioctl.c",
      "source_line": 732
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#751#751": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#751",
      "source_file": "fs/ioctl.c",
      "source_line": 751
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739#739": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739",
      "source_file": "fs/ioctl.c",
      "source_line": 739
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#35#35": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#35",
      "source_file": "include/linux/page_owner.h",
      "source_line": 35
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2456#2456": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2456",
      "source_file": "mm/page_alloc.c",
      "source_line": 2456
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2462#2462": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2462",
      "source_file": "mm/page_alloc.c",
      "source_line": 2462
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#4254#4254": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "const struct alloc_context *ac)"
        ],
        [
          4,
          "struct zoneref *z;"
        ],
        [
          5,
          "struct zone *zone;"
        ],
        [
          6,
          "struct pglist_data *last_pgdat_dirty_limit = NULL;"
        ],
        [
          10,
          "/*"
        ],
        [
          13,
          "*/"
        ],
        [
          15,
          "z = ac->preferred_zoneref;"
        ],
        [
          16,
          "for_next_zone_zonelist_nodemask(zone, z, ac->highest_zoneidx,"
        ],
        [
          17,
          "ac->nodemask) {"
        ],
        [
          18,
          "struct page *page;"
        ],
        [
          25,
          "/*"
        ],
        [
          26,
          "* When allocating a page cache page for writing, we"
        ],
        [
          27,
          "* want to get it from a node that is within its dirty"
        ],
        [
          28,
          "* limit, such that no single node holds more than its"
        ],
        [
          30,
          "* The dirty limits take into account the node's"
        ],
        [
          31,
          "* lowmem reserves and high watermark so that kswapd"
        ],
        [
          32,
          "* should be able to balance it without having to"
        ],
        [
          34,
          "*"
        ],
        [
          35,
          "* XXX: For now, allow allocations to potentially"
        ],
        [
          36,
          "* exceed the per-node dirty limit in the slowpath"
        ],
        [
          37,
          "* (spread_dirty_pages unset) before going into reclaim,"
        ],
        [
          38,
          "* which is important when on a NUMA setup the allowed"
        ],
        [
          39,
          "* nodes are together not big enough to reach the"
        ],
        [
          41,
          "* will require awareness of nodes in the"
        ],
        [
          43,
          "*/"
        ],
        [
          44,
          "if (ac->spread_dirty_pages) {"
        ],
        [
          45,
          "if (last_pgdat_dirty_limit == zone->zone_pgdat)"
        ],
        [
          48,
          "if (!node_dirty_ok(zone->zone_pgdat)) {"
        ],
        [
          49,
          "last_pgdat_dirty_limit = zone->zone_pgdat;"
        ],
        [
          55,
          "zone != ac->preferred_zoneref->zone) {"
        ],
        [
          58,
          "/*"
        ],
        [
          59,
          "* If moving to a remote node, retry but allow"
        ],
        [
          62,
          "*/"
        ],
        [
          63,
          "local_nid = zone_to_nid(ac->preferred_zoneref->zone);"
        ],
        [
          72,
          "ac->highest_zoneidx, alloc_flags,"
        ],
        [
          77,
          "/*"
        ],
        [
          78,
          "* Watermark failed for this zone, but see if we can"
        ],
        [
          80,
          "*/"
        ],
        [
          86,
          "/* Checked here to keep the fast path fast */"
        ],
        [
          92,
          "!zone_allows_reclaim(ac->preferred_zoneref->zone, zone))"
        ],
        [
          95,
          "ret = node_reclaim(zone->zone_pgdat, gfp_mask, order);"
        ],
        [
          98,
          "/* did not scan */"
        ],
        [
          101,
          "/* scanned but unreclaimable */"
        ],
        [
          104,
          "/* did we reclaim enough */"
        ],
        [
          106,
          "ac->highest_zoneidx, alloc_flags))"
        ],
        [
          114,
          "page = rmqueue(ac->preferred_zoneref->zone, zone, order,"
        ],
        [
          115,
          "gfp_mask, alloc_flags, ac->migratetype);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 16,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#4254",
      "source_file": "mm/page_alloc.c",
      "source_line": 4254
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#5346#5346": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "nodemask_t *nodemask)"
        ],
        [
          4,
          "struct page *page;"
        ],
        [
          6,
          "gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */"
        ],
        [
          9,
          "/*"
        ],
        [
          10,
          "* There are several places where we assume that the order value is sane"
        ],
        [
          12,
          "*/"
        ],
        [
          23,
          "/*"
        ],
        [
          24,
          "* Forbid the first pass from falling back to types that fragment"
        ],
        [
          26,
          "*/"
        ],
        [
          27,
          "alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref->zone, gfp_mask);"
        ],
        [
          29,
          "/* First allocation attempt */"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#5346",
      "source_file": "mm/page_alloc.c",
      "source_line": 5346
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#544#544": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#544",
      "source_file": "include/linux/gfp.h",
      "source_line": 544
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#557#557": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#557",
      "source_file": "include/linux/gfp.h",
      "source_line": 557
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#571#571": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#571",
      "source_file": "include/linux/gfp.h",
      "source_line": 571
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#590#590": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [
        [
          1,
          "static inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)"
        ]
      ],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#590",
      "source_file": "include/linux/gfp.h",
      "source_line": 590
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#290#290": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [
        [
          1,
          "return alloc_pages(gfp, 0);"
        ]
      ],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#290",
      "source_file": "include/linux/pagemap.h",
      "source_line": 290
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#1848#1848": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "struct page *pagecache_get_page(struct address_space *mapping, pgoff_t index,"
        ],
        [
          4,
          "struct page *page;"
        ],
        [
          26,
          "/* Has the page been truncated? */"
        ],
        [
          27,
          "if (unlikely(page->mapping != mapping)) {"
        ],
        [
          38,
          "/* Clear idle flag for buffer write */"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#1848",
      "source_file": "mm/filemap.c",
      "source_line": 1848
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#402#402": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline struct page *find_or_create_page(struct address_space *mapping,"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#402",
      "source_file": "include/linux/pagemap.h",
      "source_line": 402
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#976#976": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "grow_dev_page(struct block_device *bdev, sector_t block,"
        ],
        [
          4,
          "struct inode *inode = bdev->bd_inode;"
        ],
        [
          5,
          "struct page *page;"
        ],
        [
          6,
          "struct buffer_head *bh;"
        ],
        [
          11,
          "gfp_mask = mapping_gfp_constraint(inode->i_mapping, ~__GFP_FS) | gfp;"
        ],
        [
          13,
          "/*"
        ],
        [
          14,
          "* XXX: __getblk_slow() can not really deal with failure and"
        ],
        [
          16,
          "* looping in the allocator rather than here, at least that"
        ],
        [
          18,
          "*/"
        ],
        [
          21,
          "page = find_or_create_page(inode->i_mapping, index, gfp_mask);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 3,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#976",
      "source_file": "fs/buffer.c",
      "source_line": 976
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1045#1045": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1045",
      "source_file": "fs/buffer.c",
      "source_line": 1045
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1072#1072": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "__getblk_slow(struct block_device *bdev, sector_t block,"
        ],
        [
          4,
          "/* Size must be multiple of hard sectorsize */"
        ],
        [
          17,
          "struct buffer_head *bh;"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1072",
      "source_file": "fs/buffer.c",
      "source_line": 1072
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1370#1370": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "__getblk_gfp(struct block_device *bdev, sector_t block,"
        ],
        [
          4,
          "struct buffer_head *bh = __find_get_block(bdev, block, size);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1370",
      "source_file": "fs/buffer.c",
      "source_line": 1370
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/buffer_head.h#368#368": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/buffer_head.h#368",
      "source_file": "include/linux/buffer_head.h",
      "source_line": 368
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1325#1325": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,"
        ],
        [
          4,
          "struct ext4_extent_header *neh;"
        ],
        [
          5,
          "struct buffer_head *bh;"
        ],
        [
          7,
          "struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;"
        ],
        [
          11,
          "/* Try to prepend new index to old one */"
        ],
        [
          14,
          "if (goal > le32_to_cpu(es->s_first_data_block)) {"
        ],
        [
          24,
          "bh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 3,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1325",
      "source_file": "fs/ext4/extents.c",
      "source_line": 1325
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1424#1424": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ext4_ext_create_new_leaf(handle_t *handle, struct inode *inode,"
        ],
        [
          4,
          "struct ext4_ext_path **ppath,"
        ],
        [
          5,
          "struct ext4_extent *newext)"
        ],
        [
          7,
          "struct ext4_ext_path *path = *ppath;"
        ],
        [
          8,
          "struct ext4_ext_path *curp;"
        ],
        [
          14,
          "/* walk up to the tree and look for free index entry */"
        ],
        [
          21,
          "/* we use already allocated block for index block,"
        ],
        [
          22,
          "* so subsequent data blocks should be contiguous */"
        ],
        [
          24,
          "/* if we found index with free entry, then use that"
        ],
        [
          25,
          "* entry: create all needed subtree and add new leaf */"
        ],
        [
          30,
          "/* refill path */"
        ],
        [
          32,
          "(ext4_lblk_t)le32_to_cpu(newext->ee_block),"
        ],
        [
          37,
          "/* tree is full, time to grow in depth */"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 3,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1424",
      "source_file": "fs/ext4/extents.c",
      "source_line": 1424
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2094#2094": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "le32_to_cpu(newext->ee_block))) {"
        ],
        [
          5,
          "(le32_to_cpu(newext->ee_block) +"
        ],
        [
          7,
          "le32_to_cpu(ex->ee_block)))"
        ],
        [
          10,
          "/* Try to append newex to the ex */"
        ],
        [
          12,
          "ext_debug(inode, \"append [%d]%d block to %u:[%d]%d\""
        ],
        [
          16,
          "le32_to_cpu(ex->ee_block),"
        ],
        [
          25,
          "ex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)"
        ],
        [
          29,
          "eh = path[depth].p_hdr;"
        ],
        [
          35,
          "/* Try to prepend newex to the ex */"
        ],
        [
          37,
          "ext_debug(inode, \"prepend %u[%d]%d block to %u:[%d]%d\""
        ],
        [
          39,
          "le32_to_cpu(newext->ee_block),"
        ],
        [
          42,
          "le32_to_cpu(ex->ee_block),"
        ],
        [
          52,
          "ex->ee_block = newext->ee_block;"
        ],
        [
          54,
          "ex->ee_len = cpu_to_le16(ext4_ext_get_actual_len(ex)"
        ],
        [
          58,
          "eh = path[depth].p_hdr;"
        ],
        [
          65,
          "eh = path[depth].p_hdr;"
        ],
        [
          66,
          "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))"
        ],
        [
          69,
          "/* probably next leaf has space for us? */"
        ],
        [
          72,
          "if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))"
        ],
        [
          80,
          "BUG_ON(npath->p_depth != path->p_depth);"
        ],
        [
          81,
          "eh = npath[depth].p_hdr;"
        ],
        [
          82,
          "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {"
        ],
        [
          84,
          "le16_to_cpu(eh->eh_entries));"
        ],
        [
          89,
          "le16_to_cpu(eh->eh_entries), le16_to_cpu(eh->eh_max));"
        ],
        [
          92,
          "/*"
        ],
        [
          95,
          "*/"
        ]
      ],
      "deref_writes": 4,
      "deref_reads": 13,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2094",
      "source_file": "fs/ext4/extents.c",
      "source_line": 2094
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4302#4302": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "get_implied_cluster_alloc(inode->i_sb, map, &ex2, path)) {"
        ],
        [
          2,
          "ar.len = allocated = map->m_len;"
        ],
        [
          3,
          "newblock = map->m_pblk;"
        ],
        [
          7,
          "/*"
        ],
        [
          8,
          "* See if request is beyond maximum number of blocks we can have in"
        ],
        [
          10,
          "* EXT_INIT_MAX_LEN and for an unwritten extent this limit is"
        ],
        [
          12,
          "*/"
        ],
        [
          13,
          "if (map->m_len > EXT_INIT_MAX_LEN &&"
        ],
        [
          15,
          "map->m_len = EXT_INIT_MAX_LEN;"
        ],
        [
          16,
          "else if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&"
        ],
        [
          18,
          "map->m_len = EXT_UNWRITTEN_MAX_LEN;"
        ],
        [
          20,
          "/* Check if we can really insert (m_lblk)::(m_lblk + m_len) extent */"
        ],
        [
          21,
          "newex.ee_len = cpu_to_le16(map->m_len);"
        ],
        [
          26,
          "allocated = map->m_len;"
        ],
        [
          28,
          "/* allocate new block */"
        ],
        [
          30,
          "ar.goal = ext4_ext_find_goal(inode, path, map->m_lblk);"
        ],
        [
          31,
          "ar.logical = map->m_lblk;"
        ],
        [
          32,
          "/*"
        ],
        [
          33,
          "* We calculate the offset from the beginning of the cluster"
        ],
        [
          34,
          "* for the logical block number, since when we allocate a"
        ],
        [
          35,
          "* physical cluster, the physical block should start at the"
        ],
        [
          37,
          "* needed so that future calls to get_implied_cluster_alloc()"
        ],
        [
          39,
          "*/"
        ],
        [
          40,
          "offset = EXT4_LBLK_COFF(sbi, map->m_lblk);"
        ],
        [
          44,
          "if (S_ISREG(inode->i_mode))"
        ],
        [
          47,
          "/* disable in-core preallocation for non-regular files */"
        ],
        [
          66,
          "/* try to insert new extent into found leaf and return */"
        ],
        [
          70,
          "/* Mark unwritten */"
        ],
        [
          73,
          "map->m_flags |= EXT4_MAP_UNWRITTEN;"
        ]
      ],
      "deref_writes": 3,
      "deref_reads": 13,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4302",
      "source_file": "fs/ext4/extents.c",
      "source_line": 4302
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#646#646": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "ext4_es_lookup_extent(inode, map->m_lblk, NULL, &es)) {"
        ],
        [
          3,
          "map->m_pblk = ext4_es_pblock(&es) +"
        ],
        [
          4,
          "map->m_lblk - es.es_lblk;"
        ],
        [
          5,
          "map->m_flags |= ext4_es_is_written(&es) ?"
        ],
        [
          7,
          "retval = es.es_len - (map->m_lblk - es.es_lblk);"
        ],
        [
          8,
          "if (retval > map->m_len)"
        ],
        [
          9,
          "retval = map->m_len;"
        ],
        [
          10,
          "map->m_len = retval;"
        ],
        [
          12,
          "map->m_pblk = 0;"
        ],
        [
          13,
          "retval = es.es_len - (map->m_lblk - es.es_lblk);"
        ],
        [
          14,
          "if (retval > map->m_len)"
        ],
        [
          15,
          "retval = map->m_len;"
        ],
        [
          16,
          "map->m_len = retval;"
        ],
        [
          28,
          "/*"
        ],
        [
          29,
          "* Try to see if we can get the block without requesting a new"
        ],
        [
          31,
          "*/"
        ],
        [
          32,
          "down_read(&EXT4_I(inode)->i_data_sem);"
        ],
        [
          41,
          "if (unlikely(retval != map->m_len)) {"
        ],
        [
          42,
          "ext4_warning(inode->i_sb,"
        ],
        [
          44,
          "\"%lu: retval %d != map->m_len %d\","
        ],
        [
          45,
          "inode->i_ino, retval, map->m_len);"
        ],
        [
          49,
          "status = map->m_flags & EXT4_MAP_UNWRITTEN ?"
        ],
        [
          53,
          "ext4_es_scan_range(inode, &ext4_es_is_delayed, map->m_lblk,"
        ],
        [
          54,
          "map->m_lblk + map->m_len - 1))"
        ],
        [
          56,
          "ret = ext4_es_insert_extent(inode, map->m_lblk,"
        ],
        [
          57,
          "map->m_len, map->m_pblk, status);"
        ],
        [
          61,
          "up_read((&EXT4_I(inode)->i_data_sem));"
        ],
        [
          64,
          "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {"
        ],
        [
          70,
          "/* If it is only a block(s) look up */"
        ],
        [
          74,
          "/*"
        ],
        [
          75,
          "* Returns if the blocks have already allocated"
        ],
        [
          76,
          "*"
        ],
        [
          77,
          "* Note that if blocks have been preallocated"
        ],
        [
          78,
          "* ext4_ext_get_block() returns the create = 0"
        ],
        [
          80,
          "*/"
        ],
        [
          81,
          "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)"
        ],
        [
          82,
          "/*"
        ],
        [
          83,
          "* If we need to convert extent to unwritten"
        ],
        [
          84,
          "* we continue and do the actual work in"
        ],
        [
          85,
          "* ext4_ext_map_blocks()"
        ],
        [
          86,
          "*/"
        ],
        [
          90,
          "/*"
        ],
        [
          91,
          "* Here we clear m_flags because after allocating an new extent,"
        ],
        [
          93,
          "*/"
        ],
        [
          94,
          "map->m_flags &= ~EXT4_MAP_FLAGS;"
        ],
        [
          96,
          "/*"
        ],
        [
          97,
          "* New blocks allocate and/or writing to unwritten extent"
        ],
        [
          98,
          "* will possibly result in updating i_data, so we take"
        ],
        [
          99,
          "* the write lock of i_data_sem, and call get_block()"
        ],
        [
          101,
          "*/"
        ],
        [
          102,
          "down_write(&EXT4_I(inode)->i_data_sem);"
        ],
        [
          104,
          "/*"
        ],
        [
          105,
          "* We need to check for EXT4 here because migrate"
        ],
        [
          106,
          "* could have changed the inode type in between"
        ],
        [
          107,
          "*/"
        ]
      ],
      "deref_writes": 7,
      "deref_reads": 25,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#646",
      "source_file": "fs/ext4/inode.c",
      "source_line": 646
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#793#793": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int _ext4_get_block(struct inode *inode, sector_t iblock,"
        ],
        [
          2,
          "struct buffer_head *bh, int flags)"
        ],
        [
          11,
          "map.m_len = bh->b_size >> inode->i_blkbits;"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#793",
      "source_file": "fs/ext4/inode.c",
      "source_line": 793
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#810#810": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int ext4_get_block(struct inode *inode, sector_t iblock,"
        ],
        [
          2,
          "struct buffer_head *bh, int create)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#810",
      "source_file": "fs/ext4/inode.c",
      "source_line": 810
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#1077#1077": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ext4_block_write_begin(struct page *page, loff_t pos, unsigned len,"
        ],
        [
          2,
          "get_block_t *get_block)"
        ],
        [
          6,
          "struct inode *inode = page->mapping->host;"
        ],
        [
          10,
          "unsigned blocksize = inode->i_sb->s_blocksize;"
        ],
        [
          12,
          "struct buffer_head *bh, *head, *wait[2];"
        ],
        [
          12,
          "struct buffer_head *bh, *head, *wait[2];"
        ],
        [
          25,
          "block = (sector_t)page->index << (PAGE_SHIFT - bbits);"
        ],
        [
          28,
          "block++, block_start = block_end, bh = bh->b_this_page) {"
        ],
        [
          40,
          "WARN_ON(bh->b_size != blocksize);"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 4,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#1077",
      "source_file": "fs/ext4/inode.c",
      "source_line": 1077
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#3021#3021": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "*fsdata = (void *)FALL_BACK_TO_NONDELALLOC;"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 1,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#3021",
      "source_file": "fs/ext4/inode.c",
      "source_line": 3021
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#3506#3506": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "ssize_t generic_perform_write(struct file *file,"
        ],
        [
          2,
          "struct iov_iter *i, loff_t pos)"
        ],
        [
          4,
          "struct address_space *mapping = file->f_mapping;"
        ],
        [
          5,
          "const struct address_space_operations *a_ops = mapping->a_ops;"
        ],
        [
          11,
          "struct page *page;"
        ],
        [
          12,
          "unsigned long offset;\t/* Offset into pagecache page */"
        ],
        [
          13,
          "unsigned long bytes;\t/* Bytes to write to page */"
        ],
        [
          14,
          "size_t copied;\t\t/* Bytes copied from user */"
        ],
        [
          15,
          "void *fsdata = NULL;"
        ],
        [
          22,
          "/*"
        ],
        [
          24,
          "* Otherwise there's a nasty deadlock on copying from the"
        ],
        [
          25,
          "* same page as we're writing to, without it being marked"
        ],
        [
          27,
          "*"
        ],
        [
          28,
          "* Not only is this an optimisation, but it is also required"
        ],
        [
          29,
          "* to check that the address is actually valid, when atomic"
        ],
        [
          31,
          "*/"
        ],
        [
          42,
          "status = a_ops->write_begin(file, mapping, pos, bytes, flags,"
        ]
      ],
      "deref_writes": 3,
      "deref_reads": 3,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#3506",
      "source_file": "mm/filemap.c",
      "source_line": 3506
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#271#271": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static ssize_t ext4_buffered_write_iter(struct kiocb *iocb,"
        ],
        [
          2,
          "struct iov_iter *from)"
        ],
        [
          5,
          "struct inode *inode = file_inode(iocb->ki_filp);"
        ],
        [
          7,
          "if (iocb->ki_flags & IOCB_NOWAIT)"
        ],
        [
          15,
          "current->backing_dev_info = inode_to_bdi(inode);"
        ],
        [
          16,
          "ret = generic_perform_write(iocb->ki_filp, from, iocb->ki_pos);"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 3,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#271",
      "source_file": "fs/ext4/file.c",
      "source_line": 271
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#685#685": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#685",
      "source_file": "fs/ext4/file.c",
      "source_line": 685
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#28#28": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#28",
      "source_file": "include/linux/page_owner.h",
      "source_line": 28
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1349#1349": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline bool free_pages_prepare(struct page *page,"
        ],
        [
          13,
          "/*"
        ],
        [
          14,
          "* Do not let hwpoison pages hit pcplists/buddy"
        ],
        [
          15,
          "* Untie memcg state and reset page's owner"
        ],
        [
          16,
          "*/"
        ],
        [
          24,
          "/*"
        ],
        [
          25,
          "* Check tail pages before head page information is cleared to"
        ],
        [
          27,
          "*/"
        ],
        [
          43,
          "(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;"
        ],
        [
          47,
          "page->mapping = NULL;"
        ],
        [
          56,
          "page->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;"
        ]
      ],
      "deref_writes": 3,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1349",
      "source_file": "mm/page_alloc.c",
      "source_line": 1349
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1421#1421": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1421",
      "source_file": "mm/page_alloc.c",
      "source_line": 1421
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3336#3336": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static bool free_unref_page_prepare(struct page *page, unsigned long pfn)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3336",
      "source_file": "mm/page_alloc.c",
      "source_line": 3336
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3443#3443": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3443",
      "source_file": "mm/page_alloc.c",
      "source_line": 3443
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap.c#1103#1103": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void release_pages(struct page **pages, int nr)"
        ],
        [
          5,
          "struct pglist_data *locked_pgdat = NULL;"
        ],
        [
          6,
          "struct lruvec *lruvec;"
        ],
        [
          11,
          "struct page *page = pages[i];"
        ],
        [
          11,
          "struct page *page = pages[i];"
        ],
        [
          13,
          "/*"
        ],
        [
          14,
          "* Make sure the IRQ-safe lock-holding time does not get"
        ],
        [
          15,
          "* excessive with a continuous string of pages from the"
        ],
        [
          17,
          "*/"
        ],
        [
          19,
          "spin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);"
        ],
        [
          29,
          "spin_unlock_irqrestore(&locked_pgdat->lru_lock,"
        ],
        [
          33,
          "/*"
        ],
        [
          34,
          "* ZONE_DEVICE pages that return 'false' from"
        ],
        [
          35,
          "* page_is_devmap_managed() do not require special"
        ],
        [
          36,
          "* processing, and instead, expect a call to"
        ],
        [
          38,
          "*/"
        ],
        [
          50,
          "spin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);"
        ],
        [
          58,
          "struct pglist_data *pgdat = page_pgdat(page);"
        ],
        [
          62,
          "spin_unlock_irqrestore(&locked_pgdat->lru_lock,"
        ],
        [
          66,
          "spin_lock_irqsave(&locked_pgdat->lru_lock, flags);"
        ],
        [
          76,
          "list_add(&page->lru, &pages_to_free);"
        ],
        [
          79,
          "spin_unlock_irqrestore(&locked_pgdat->lru_lock, flags);"
        ]
      ],
      "deref_writes": 3,
      "deref_reads": 8,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap.c#1103",
      "source_file": "mm/swap.c",
      "source_line": 1103
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap_state.c#356#356": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap_state.c#356",
      "source_file": "mm/swap_state.c",
      "source_line": 356
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#49#49": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void tlb_batch_pages_flush(struct mmu_gather *tlb)"
        ],
        [
          3,
          "struct mmu_gather_batch *batch;"
        ],
        [
          5,
          "for (batch = &tlb->local; batch && batch->nr; batch = batch->next) {"
        ],
        [
          6,
          "free_pages_and_swap_cache(batch->pages, batch->nr);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 2,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#49",
      "source_file": "mm/mmu_gather.c",
      "source_line": 49
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#240#240": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#240",
      "source_file": "mm/mmu_gather.c",
      "source_line": 240
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#247#247": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void tlb_flush_mmu(struct mmu_gather *tlb)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#247",
      "source_file": "mm/mmu_gather.c",
      "source_line": 247
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#326#326": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void tlb_finish_mmu(struct mmu_gather *tlb,"
        ],
        [
          4,
          "/*"
        ],
        [
          5,
          "* If there are parallel threads are doing PTE changes on same range"
        ],
        [
          7,
          "* flush by batching, one thread may end up seeing inconsistent PTEs"
        ],
        [
          10,
          "*"
        ],
        [
          13,
          "* may result in having stale TLB entries for some architectures,"
        ],
        [
          15,
          "*/"
        ],
        [
          16,
          "if (mm_tlb_flush_nested(tlb->mm)) {"
        ],
        [
          17,
          "/*"
        ],
        [
          18,
          "* The aarch64 yields better performance with fullmm by"
        ],
        [
          19,
          "* avoiding multiple CPUs spamming TLBI messages at the"
        ],
        [
          21,
          "*"
        ],
        [
          22,
          "* On x86 non-fullmm doesn't yield significant difference"
        ],
        [
          24,
          "*/"
        ],
        [
          25,
          "tlb->fullmm = 1;"
        ],
        [
          27,
          "tlb->freed_tables = 1;"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 1,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#326",
      "source_file": "mm/mmu_gather.c",
      "source_line": 326
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#2807#2807": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void unmap_region(struct mm_struct *mm,"
        ],
        [
          2,
          "struct vm_area_struct *vma, struct vm_area_struct *prev,"
        ],
        [
          5,
          "struct vm_area_struct *next = vma_next(mm, prev);"
        ],
        [
          7,
          "struct vm_area_struct *cur_vma;"
        ],
        [
          14,
          "/*"
        ],
        [
          15,
          "* Ensure we have no stale TLB entries by the time this mapping is"
        ],
        [
          17,
          "* Note that we don't have to worry about nested flushes here because"
        ],
        [
          18,
          "* we're holding the mm semaphore for removing the mapping - so any"
        ],
        [
          19,
          "* concurrent flush in this region has to be coming through the rmap,"
        ],
        [
          21,
          "*/"
        ],
        [
          22,
          "for (cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next) {"
        ],
        [
          23,
          "if ((cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0) {"
        ],
        [
          29,
          "free_pgtables(&tlb, vma, prev ? prev->vm_end : FIRST_USER_ADDRESS,"
        ],
        [
          30,
          "next ? next->vm_start : USER_PGTABLES_CEILING);"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 3,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#2807",
      "source_file": "mm/mmap.c",
      "source_line": 2807
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3036#3036": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int __do_munmap(struct mm_struct *mm, unsigned long start, size_t len,"
        ],
        [
          2,
          "struct list_head *uf, bool downgrade)"
        ],
        [
          5,
          "struct vm_area_struct *vma, *prev, *last;"
        ],
        [
          15,
          "/*"
        ],
        [
          17,
          "* and finish any rbtree manipulation before this code"
        ],
        [
          19,
          "*/"
        ],
        [
          22,
          "/* Find the first overlapping VMA */"
        ],
        [
          26,
          "prev = vma->vm_prev;"
        ],
        [
          27,
          "/* we have  start < vma->vm_end  */"
        ],
        [
          30,
          "if (vma->vm_start >= end)"
        ],
        [
          33,
          "/*"
        ],
        [
          35,
          "*"
        ],
        [
          36,
          "* Note: mremap's move_vma VM_ACCOUNT handling assumes a partially"
        ],
        [
          37,
          "* unmapped vm_area_struct will remain in use: so lower split_vma"
        ],
        [
          39,
          "*/"
        ],
        [
          40,
          "if (start > vma->vm_start) {"
        ],
        [
          43,
          "/*"
        ],
        [
          44,
          "* Make sure that map_count on return from munmap() will"
        ],
        [
          45,
          "* not exceed its limit; but let map_count go just above"
        ],
        [
          47,
          "*/"
        ],
        [
          48,
          "if (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)"
        ],
        [
          57,
          "/* Does it split the last one? */"
        ],
        [
          59,
          "if (last && end > last->vm_start) {"
        ],
        [
          67,
          "/*"
        ],
        [
          68,
          "* If userfaultfd_unmap_prep returns an error the vmas"
        ],
        [
          69,
          "* will remain splitted, but userland will get a"
        ],
        [
          71,
          "* different than the case where the first of the two"
        ],
        [
          72,
          "* __split_vma fails, but we don't undo the first"
        ],
        [
          75,
          "*/"
        ],
        [
          81,
          "/*"
        ],
        [
          82,
          "* unlock any mlock()ed ranges before detaching vmas"
        ],
        [
          83,
          "*/"
        ],
        [
          84,
          "if (mm->locked_vm) {"
        ],
        [
          85,
          "struct vm_area_struct *tmp = vma;"
        ],
        [
          86,
          "while (tmp && tmp->vm_start < end) {"
        ],
        [
          87,
          "if (tmp->vm_flags & VM_LOCKED) {"
        ],
        [
          88,
          "mm->locked_vm -= vma_pages(tmp);"
        ],
        [
          92,
          "tmp = tmp->vm_next;"
        ],
        [
          96,
          "/* Detach vmas from rbtree */"
        ]
      ],
      "deref_writes": 4,
      "deref_reads": 8,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3036",
      "source_file": "mm/mmap.c",
      "source_line": 3036
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3059#3059": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          4,
          "struct mm_struct *mm = current->mm;"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 1,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3059",
      "source_file": "mm/mmap.c",
      "source_line": 3059
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3085#3085": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3085",
      "source_file": "mm/mmap.c",
      "source_line": 3085
    },
    "link:https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081#3081": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "access_op": "read",
      "access_size": 18446744073709551544,
      "source_url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081",
      "source_file": "mm/mmap.c",
      "source_line": 3081
    }
  },
  "classification": {
    "primitive": "out-of-bounds read",
    "vulnerability": "info-leak (bounded or unbounded read)",
    "confidence": 1.0,
    "preconditions": [
      "Triggering syzkaller syscall(s): error",
      "Triggering syscall(s) from crash text: ioctl, munmap",
      "An externally-controlled syscall input (fuzzer/syzkaller) reached the vulnerable syscall path",
      "Input state: attacker-controlled syscall parameters or user-supplied data must reach the vulnerable code path",
      "Code path: execution reaches function 'ext4_mb_clear_bb' (from crash context)",
      "State: variable(s) like handle, inode, path may point into freed/reclaimed memory (observed in nearby source lines)",
      "path constraint (input): !path[depth].p_hdr -- at fs/ext4/extents.c:2750",
      "path constraint (input): unlikely(path[depth].p_hdr == NULL) -- at fs/ext4/extents.c:2753",
      "path constraint (input): ex >= EXT_FIRST_EXTENT(eh -- at fs/ext4/extents.c:2767",
      "path constraint (input): end < ex_ee_block -- at fs/ext4/extents.c:2786",
      "path constraint (input): sbi->s_cluster_ratio > 1 -- at fs/ext4/extents.c:2794",
      "path constraint (kernel state): return -EFSCORRUPTED; -- at fs/ext4/extents.c:2755",
      "path constraint (kernel state): !ex -- at fs/ext4/extents.c:2759",
      "path constraint (kernel state): ext4_ext_is_unwritten(ex) -- at fs/ext4/extents.c:2770",
      "path constraint (kernel state): goto out; -- at fs/ext4/extents.c:2810",
      "path constraint (kernel state): a != ex_ee_block -- at fs/ext4/extents.c:2811",
      "path constraint (kernel state): ex == EXT_FIRST_EXTENT(eh) -- at fs/ext4/extents.c:2825",
      "path constraint (kernel state): err -- at fs/ext4/extents.c:2842",
      "path constraint (kernel state): goto out; -- at fs/ext4/extents.c:2845",
      "Precondition: attacker must trigger the vulnerable path that allows reading reclaimed or out-of-bounds memory"
    ],
    "postconditions": [
      "KASAN or BUG report emitted indicating invalid memory access",
      "Postcondition: attacker may read sensitive kernel memory (info-leak)"
    ],
    "support": [
      "KASAN reported slab-out-of-bounds (log contains 'slab-out-of-bounds')",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains alloc-like calls near crash site",
      "Source contains alloc-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Control-flow path constraints extracted from stack snippets (if/for/while/switch, returns)",
      "Syscall(s) detected in crash text: ioctl, munmap",
      "Syzkaller repro indicates syscalls: error"
    ],
    "path_constraints": {
      "input_constraints": [
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2750,
          "code": "if (!path[depth].p_hdr)",
          "condition": "!path[depth].p_hdr",
          "variables": [
            "path",
            "depth",
            "p_hdr"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (!path[depth].p_hdr)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2753,
          "code": "if (unlikely(path[depth].p_hdr == NULL)) {",
          "condition": "unlikely(path[depth].p_hdr == NULL)",
          "variables": [
            "unlikely",
            "path",
            "depth",
            "p_hdr",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2767,
          "code": "while (ex >= EXT_FIRST_EXTENT(eh) &&",
          "condition": "ex >= EXT_FIRST_EXTENT(eh",
          "variables": [
            "ex",
            "EXT_FIRST_EXTENT",
            "eh"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "while (ex >= EXT_FIRST_EXTENT(eh) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2786,
          "code": "if (end < ex_ee_block) {",
          "condition": "end < ex_ee_block",
          "variables": [
            "end",
            "ex_ee_block"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "if (end < ex_ee_block) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2794,
          "code": "if (sbi->s_cluster_ratio > 1) {",
          "condition": "sbi->s_cluster_ratio > 1",
          "variables": [
            "sbi",
            "s_cluster_ratio"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (sbi->s_cluster_ratio > 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2803,
          "code": "} else if (b != ex_ee_block + ex_ee_len - 1) {",
          "condition": "b != ex_ee_block + ex_ee_len - 1",
          "variables": [
            "b",
            "ex_ee_block",
            "ex_ee_len"
          ],
          "evidence": [
            {
              "line_no": 73,
              "text": "} else if (b != ex_ee_block + ex_ee_len - 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2843,
          "code": "if (err > 0)",
          "condition": "err > 0",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 113,
              "text": "if (err > 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2986,
          "code": "if (end < EXT_MAX_BLOCKS - 1) {",
          "condition": "end < EXT_MAX_BLOCKS - 1",
          "variables": [
            "end",
            "EXT_MAX_BLOCKS"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if (end < EXT_MAX_BLOCKS - 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2994,
          "code": "if (IS_ERR(path)) {",
          "condition": "IS_ERR(path)",
          "variables": [
            "IS_ERR",
            "path"
          ],
          "evidence": [
            {
              "line_no": 42,
              "text": "if (IS_ERR(path)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2996,
          "code": "return PTR_ERR(path);",
          "condition": "return PTR_ERR(path);",
          "variables": [
            "return",
            "PTR_ERR",
            "path"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "return PTR_ERR(path);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3020,
          "code": "if (end >= ee_block && end < ex_end) {",
          "condition": "end >= ee_block && end < ex_end",
          "variables": [
            "end",
            "ee_block",
            "end",
            "ex_end"
          ],
          "evidence": [
            {
              "line_no": 68,
              "text": "if (end >= ee_block && end < ex_end) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3027,
          "code": "if (sbi->s_cluster_ratio > 1) {",
          "condition": "sbi->s_cluster_ratio > 1",
          "variables": [
            "sbi",
            "s_cluster_ratio"
          ],
          "evidence": [
            {
              "line_no": 75,
              "text": "if (sbi->s_cluster_ratio > 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3041,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 89,
              "text": "if (err < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3044,
          "code": "} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&",
          "condition": "} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&",
          "variables": [
            "else",
            "if",
            "sbi",
            "s_cluster_ratio",
            "end",
            "ex_end"
          ],
          "evidence": [
            {
              "line_no": 92,
              "text": "} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3059,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 107,
              "text": "if (err < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3072,
          "code": "if (path) {",
          "condition": "path",
          "variables": [
            "path"
          ],
          "evidence": [
            {
              "line_no": 120,
              "text": "if (path) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3074,
          "code": "while (--k > 0)",
          "condition": "--k > 0",
          "variables": [
            "k"
          ],
          "evidence": [
            {
              "line_no": 122,
              "text": "while (--k > 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3080,
          "code": "if (path == NULL) {",
          "condition": "path == NULL",
          "variables": [
            "path",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 128,
              "text": "if (path == NULL) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3088,
          "code": "if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {",
          "condition": "ext4_ext_check(inode, path[0].p_hdr, depth, 0)",
          "variables": [
            "ext4_ext_check",
            "inode",
            "path",
            "p_hdr",
            "depth"
          ],
          "evidence": [
            {
              "line_no": 136,
              "text": "if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3095,
          "code": "while (i >= 0 && err == 0) {",
          "condition": "i >= 0 && err == 0",
          "variables": [
            "i",
            "err"
          ],
          "evidence": [
            {
              "line_no": 143,
              "text": "while (i >= 0 && err == 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 445,
          "code": "if (current->kunit_test)",
          "condition": "current->kunit_test",
          "variables": [
            "current",
            "kunit_test"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "if (current->kunit_test)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/generic.c",
          "line": 190,
          "code": "return check_region_inline(addr, size, write, ret_ip);",
          "condition": "return check_region_inline(addr, size, write, ret_ip);",
          "variables": [
            "return",
            "check_region_inline",
            "addr",
            "size",
            "write",
            "ret_ip"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return check_region_inline(addr, size, write, ret_ip);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/shadow.c",
          "line": 57,
          "code": "if (!kasan_check_range((unsigned long)src, len, false, _RET_IP_) ||",
          "condition": "!kasan_check_range((unsigned long)src, len, false, _RET_IP_",
          "variables": [
            "kasan_check_range",
            "unsigned",
            "long",
            "src",
            "len",
            "false",
            "_RET_IP_"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "if (!kasan_check_range((unsigned long)src, len, false, _RET_IP_) ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4234,
          "code": "if (offset >= inode->i_size)",
          "condition": "offset >= inode->i_size",
          "variables": [
            "offset",
            "inode",
            "i_size"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "if (offset >= inode->i_size)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4241,
          "code": "if (offset + length > inode->i_size) {",
          "condition": "offset + length > inode->i_size",
          "variables": [
            "offset",
            "length",
            "inode",
            "i_size"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "if (offset + length > inode->i_size) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4252,
          "code": "if (offset + length > max_length)",
          "condition": "offset + length > max_length",
          "variables": [
            "offset",
            "length",
            "max_length"
          ],
          "evidence": [
            {
              "line_no": 47,
              "text": "if (offset + length > max_length)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4255,
          "code": "if (offset & (sb->s_blocksize - 1) ||",
          "condition": "offset & (sb->s_blocksize - 1",
          "variables": [
            "offset",
            "sb",
            "s_blocksize"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (offset & (sb->s_blocksize - 1) ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4262,
          "code": "if (ret < 0)",
          "condition": "ret < 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 57,
              "text": "if (ret < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4288,
          "code": "if (last_block_offset > first_block_offset) {",
          "condition": "last_block_offset > first_block_offset",
          "variables": [
            "last_block_offset",
            "first_block_offset"
          ],
          "evidence": [
            {
              "line_no": 83,
              "text": "if (last_block_offset > first_block_offset) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4317,
          "code": "if (stop_block > first_block) {",
          "condition": "stop_block > first_block",
          "variables": [
            "stop_block",
            "first_block"
          ],
          "evidence": [
            {
              "line_no": 112,
              "text": "if (stop_block > first_block) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4726,
          "code": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "condition": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "variables": [
            "if",
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 316,
          "code": "if (offset < 0 || len <= 0)",
          "condition": "offset < 0 || len <= 0",
          "variables": [
            "offset",
            "len"
          ],
          "evidence": [
            {
              "line_no": 6,
              "text": "if (offset < 0 || len <= 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 348,
          "code": "if (!(file->f_mode & FMODE_WRITE))",
          "condition": "!(file->f_mode & FMODE_WRITE)",
          "variables": [
            "file",
            "f_mode",
            "FMODE_WRITE"
          ],
          "evidence": [
            {
              "line_no": 38,
              "text": "if (!(file->f_mode & FMODE_WRITE))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 354,
          "code": "if ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))",
          "condition": "(mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode)",
          "variables": [
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "IS_APPEND",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "if ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 374,
          "code": "if (S_ISFIFO(inode->i_mode))",
          "condition": "S_ISFIFO(inode->i_mode)",
          "variables": [
            "S_ISFIFO",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (S_ISFIFO(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 377,
          "code": "if (S_ISDIR(inode->i_mode))",
          "condition": "S_ISDIR(inode->i_mode)",
          "variables": [
            "S_ISDIR",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "if (S_ISDIR(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 380,
          "code": "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode",
            "S_ISBLK",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 70,
              "text": "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 384,
          "code": "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))",
          "condition": "((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0)",
          "variables": [
            "offset",
            "len",
            "inode",
            "i_sb",
            "s_maxbytes",
            "offset",
            "len"
          ],
          "evidence": [
            {
              "line_no": 74,
              "text": "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 387,
          "code": "if (!file->f_op->fallocate)",
          "condition": "!file->f_op->fallocate",
          "variables": [
            "file",
            "f_op",
            "fallocate"
          ],
          "evidence": [
            {
              "line_no": 77,
              "text": "if (!file->f_op->fallocate)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 735,
          "code": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "condition": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "variables": [
            "return",
            "copy_to_user",
            "argp",
            "res",
            "sizeof",
            "res"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return copy_to_user(argp, &res, sizeof(res)) ?"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 742,
          "code": "return ioctl_fsfreeze(filp);",
          "condition": "return ioctl_fsfreeze(filp);",
          "variables": [
            "return",
            "ioctl_fsfreeze",
            "filp"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "return ioctl_fsfreeze(filp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 745,
          "code": "return ioctl_fsthaw(filp);",
          "condition": "return ioctl_fsthaw(filp);",
          "variables": [
            "return",
            "ioctl_fsthaw",
            "filp"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "return ioctl_fsthaw(filp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 748,
          "code": "return ioctl_fiemap(filp, argp);",
          "condition": "return ioctl_fiemap(filp, argp);",
          "variables": [
            "return",
            "ioctl_fiemap",
            "filp",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "return ioctl_fiemap(filp, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 752,
          "code": "if (!inode->i_sb->s_blocksize)",
          "condition": "!inode->i_sb->s_blocksize",
          "variables": [
            "inode",
            "i_sb",
            "s_blocksize"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (!inode->i_sb->s_blocksize)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 755,
          "code": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "condition": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "variables": [
            "return",
            "put_user",
            "inode",
            "i_sb",
            "s_blocksize",
            "int",
            "__user",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "condition": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "variables": [
            "return",
            "ioctl_file_clone",
            "filp",
            "arg"
          ],
          "evidence": [
            {
              "line_no": 26,
              "text": "return ioctl_file_clone(filp, arg, 0, 0, 0);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "return ioctl_file_clone_range(filp, argp);",
          "condition": "return ioctl_file_clone_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_clone_range",
            "filp",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "return ioctl_file_clone_range(filp, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 764,
          "code": "return ioctl_file_dedupe_range(filp, argp);",
          "condition": "return ioctl_file_dedupe_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_dedupe_range",
            "filp",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "return ioctl_file_dedupe_range(filp, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 767,
          "code": "if (!S_ISREG(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 35,
              "text": "if (!S_ISREG(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 768,
          "code": "return vfs_ioctl(filp, cmd, arg);",
          "condition": "return vfs_ioctl(filp, cmd, arg);",
          "variables": [
            "return",
            "vfs_ioctl",
            "filp",
            "cmd",
            "arg"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "return vfs_ioctl(filp, cmd, arg);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 770,
          "code": "return put_user(i_size_read(inode) - filp->f_pos,",
          "condition": "return put_user(i_size_read(inode) - filp->f_pos,",
          "variables": [
            "return",
            "put_user",
            "i_size_read",
            "inode",
            "filp",
            "f_pos"
          ],
          "evidence": [
            {
              "line_no": 38,
              "text": "return put_user(i_size_read(inode) - filp->f_pos,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 774,
          "code": "if (S_ISREG(inode->i_mode))",
          "condition": "S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 42,
              "text": "if (S_ISREG(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 775,
          "code": "return file_ioctl(filp, cmd, argp);",
          "condition": "return file_ioctl(filp, cmd, argp);",
          "variables": [
            "return",
            "file_ioctl",
            "filp",
            "cmd",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 43,
              "text": "return file_ioctl(filp, cmd, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4298,
          "code": "if (ac->spread_dirty_pages) {",
          "condition": "ac->spread_dirty_pages",
          "variables": [
            "ac",
            "spread_dirty_pages"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "if (ac->spread_dirty_pages) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4299,
          "code": "if (last_pgdat_dirty_limit == zone->zone_pgdat)",
          "condition": "last_pgdat_dirty_limit == zone->zone_pgdat",
          "variables": [
            "last_pgdat_dirty_limit",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [
            {
              "line_no": 45,
              "text": "if (last_pgdat_dirty_limit == zone->zone_pgdat)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4302,
          "code": "if (!node_dirty_ok(zone->zone_pgdat)) {",
          "condition": "!node_dirty_ok(zone->zone_pgdat)",
          "variables": [
            "node_dirty_ok",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (!node_dirty_ok(zone->zone_pgdat)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4308,
          "code": "if (no_fallback && nr_online_nodes > 1 &&",
          "condition": "if (no_fallback && nr_online_nodes > 1 &&",
          "variables": [
            "if",
            "no_fallback",
            "nr_online_nodes"
          ],
          "evidence": [
            {
              "line_no": 54,
              "text": "if (no_fallback && nr_online_nodes > 1 &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1046,
          "code": "return grow_dev_page(bdev, block, index, size, sizebits, gfp);",
          "condition": "return grow_dev_page(bdev, block, index, size, sizebits, gfp);",
          "variables": [
            "return",
            "grow_dev_page",
            "bdev",
            "block",
            "index",
            "size",
            "sizebits",
            "gfp"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return grow_dev_page(bdev, block, index, size, sizebits, gfp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1077,
          "code": "if (unlikely(size & (bdev_logical_block_size(bdev)-1) ||",
          "condition": "unlikely(size & (bdev_logical_block_size(bdev)-1",
          "variables": [
            "unlikely",
            "size",
            "bdev_logical_block_size",
            "bdev"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "if (unlikely(size & (bdev_logical_block_size(bdev)-1) ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/buffer_head.h",
          "line": 369,
          "code": "return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);",
          "condition": "return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);",
          "variables": [
            "return",
            "__getblk_gfp",
            "sb",
            "s_bdev",
            "block",
            "sb",
            "s_blocksize",
            "gfp"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1339,
          "code": "if (goal > le32_to_cpu(es->s_first_data_block)) {",
          "condition": "goal > le32_to_cpu(es->s_first_data_block)",
          "variables": [
            "goal",
            "le32_to_cpu",
            "es",
            "s_first_data_block"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "if (goal > le32_to_cpu(es->s_first_data_block)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1440,
          "code": "while (i > 0 && !EXT_HAS_FREE_INDEX(curp)) {",
          "condition": "i > 0 && !EXT_HAS_FREE_INDEX(curp)",
          "variables": [
            "i",
            "EXT_HAS_FREE_INDEX",
            "curp"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "while (i > 0 && !EXT_HAS_FREE_INDEX(curp)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1458,
          "code": "if (IS_ERR(path))",
          "condition": "IS_ERR(path)",
          "variables": [
            "IS_ERR",
            "path"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if (IS_ERR(path))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2098,
          "code": "} else if ((ex > EXT_FIRST_EXTENT(eh)) &&",
          "condition": "(ex > EXT_FIRST_EXTENT(eh)",
          "variables": [
            "ex",
            "EXT_FIRST_EXTENT",
            "eh"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "} else if ((ex > EXT_FIRST_EXTENT(eh)) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2160,
          "code": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))",
          "condition": "le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)",
          "variables": [
            "le16_to_cpu",
            "eh",
            "eh_entries",
            "le16_to_cpu",
            "eh",
            "eh_max"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2166,
          "code": "if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))",
          "condition": "le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)",
          "variables": [
            "le32_to_cpu",
            "newext",
            "ee_block",
            "le32_to_cpu",
            "fex",
            "ee_block"
          ],
          "evidence": [
            {
              "line_no": 72,
              "text": "if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2172,
          "code": "if (IS_ERR(npath))",
          "condition": "IS_ERR(npath)",
          "variables": [
            "IS_ERR",
            "npath"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "if (IS_ERR(npath))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2173,
          "code": "return PTR_ERR(npath);",
          "condition": "return PTR_ERR(npath);",
          "variables": [
            "return",
            "PTR_ERR",
            "npath"
          ],
          "evidence": [
            {
              "line_no": 79,
              "text": "return PTR_ERR(npath);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2176,
          "code": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {",
          "condition": "le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)",
          "variables": [
            "le16_to_cpu",
            "eh",
            "eh_entries",
            "le16_to_cpu",
            "eh",
            "eh_max"
          ],
          "evidence": [
            {
              "line_no": 82,
              "text": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4315,
          "code": "if (map->m_len > EXT_INIT_MAX_LEN &&",
          "condition": "if (map->m_len > EXT_INIT_MAX_LEN &&",
          "variables": [
            "if",
            "map",
            "m_len",
            "EXT_INIT_MAX_LEN"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "if (map->m_len > EXT_INIT_MAX_LEN &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4318,
          "code": "else if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&",
          "condition": "else if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&",
          "variables": [
            "else",
            "if",
            "map",
            "m_len",
            "EXT_UNWRITTEN_MAX_LEN"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "else if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4346,
          "code": "if (S_ISREG(inode->i_mode))",
          "condition": "S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "if (S_ISREG(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4364,
          "code": "if (ar.len > allocated)",
          "condition": "ar.len > allocated",
          "variables": [
            "ar",
            "len",
            "allocated"
          ],
          "evidence": [
            {
              "line_no": 62,
              "text": "if (ar.len > allocated)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 654,
          "code": "if (retval > map->m_len)",
          "condition": "retval > map->m_len",
          "variables": [
            "retval",
            "map",
            "m_len"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "if (retval > map->m_len)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 660,
          "code": "if (retval > map->m_len)",
          "condition": "retval > map->m_len",
          "variables": [
            "retval",
            "map",
            "m_len"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "if (retval > map->m_len)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 684,
          "code": "if (retval > 0) {",
          "condition": "retval > 0",
          "variables": [
            "retval"
          ],
          "evidence": [
            {
              "line_no": 38,
              "text": "if (retval > 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 687,
          "code": "if (unlikely(retval != map->m_len)) {",
          "condition": "unlikely(retval != map->m_len)",
          "variables": [
            "unlikely",
            "retval",
            "map",
            "m_len"
          ],
          "evidence": [
            {
              "line_no": 41,
              "text": "if (unlikely(retval != map->m_len)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 704,
          "code": "if (ret < 0)",
          "condition": "ret < 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 58,
              "text": "if (ret < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 710,
          "code": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {",
          "condition": "retval > 0 && map->m_flags & EXT4_MAP_MAPPED",
          "variables": [
            "retval",
            "map",
            "m_flags",
            "EXT4_MAP_MAPPED"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 727,
          "code": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)",
          "condition": "retval > 0 && map->m_flags & EXT4_MAP_MAPPED",
          "variables": [
            "retval",
            "map",
            "m_flags",
            "EXT4_MAP_MAPPED"
          ],
          "evidence": [
            {
              "line_no": 81,
              "text": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1098,
          "code": "if (!page_has_buffers(page))",
          "condition": "!page_has_buffers(page)",
          "variables": [
            "page_has_buffers",
            "page"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (!page_has_buffers(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1107,
          "code": "if (block_end <= from || block_start >= to) {",
          "condition": "block_end <= from || block_start >= to",
          "variables": [
            "block_end",
            "from",
            "block_start",
            "to"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "if (block_end <= from || block_start >= to) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1109,
          "code": "if (!buffer_uptodate(bh))",
          "condition": "!buffer_uptodate(bh)",
          "variables": [
            "buffer_uptodate",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "if (!buffer_uptodate(bh))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1114,
          "code": "if (buffer_new(bh))",
          "condition": "buffer_new(bh)",
          "variables": [
            "buffer_new",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "if (buffer_new(bh))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1116,
          "code": "if (!buffer_mapped(bh)) {",
          "condition": "!buffer_mapped(bh)",
          "variables": [
            "buffer_mapped",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (!buffer_mapped(bh)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 278,
          "code": "if (iocb->ki_flags & IOCB_NOWAIT)",
          "condition": "iocb->ki_flags & IOCB_NOWAIT",
          "variables": [
            "iocb",
            "ki_flags",
            "IOCB_NOWAIT"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (iocb->ki_flags & IOCB_NOWAIT)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 283,
          "code": "if (ret <= 0)",
          "condition": "ret <= 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (ret <= 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 686,
          "code": "return ext4_buffered_write_iter(iocb, from);",
          "condition": "return ext4_buffered_write_iter(iocb, from);",
          "variables": [
            "return",
            "ext4_buffered_write_iter",
            "iocb",
            "from"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return ext4_buffered_write_iter(iocb, from);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1385,
          "code": "for (i = 1; i < (1 << order); i++) {",
          "condition": "i = 1; i < (1 << order); i++",
          "variables": [
            "i",
            "i",
            "order",
            "i"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "for (i = 1; i < (1 << order); i++) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1113,
          "code": "for (i = 0; i < nr; i++) {",
          "condition": "i = 0; i < nr; i++",
          "variables": [
            "i",
            "i",
            "nr",
            "i"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "for (i = 0; i < nr; i++) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmu_gather.c",
          "line": 54,
          "code": "for (batch = &tlb->local; batch && batch->nr; batch = batch->next) {",
          "condition": "batch = &tlb->local; batch && batch->nr; batch = batch->next",
          "variables": [
            "batch",
            "tlb",
            "local",
            "batch",
            "batch",
            "nr",
            "batch",
            "batch",
            "next"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "for (batch = &tlb->local; batch && batch->nr; batch = batch->next) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmu_gather.c",
          "line": 342,
          "code": "if (mm_tlb_flush_nested(tlb->mm)) {",
          "condition": "mm_tlb_flush_nested(tlb->mm)",
          "variables": [
            "mm_tlb_flush_nested",
            "tlb",
            "mm"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "if (mm_tlb_flush_nested(tlb->mm)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 2829,
          "code": "for (cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next) {",
          "condition": "cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next",
          "variables": [
            "cur_vma",
            "vma",
            "cur_vma",
            "cur_vma",
            "cur_vma",
            "vm_next"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "for (cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 2830,
          "code": "if ((cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0) {",
          "condition": "(cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0",
          "variables": [
            "cur_vma",
            "vm_flags",
            "VM_PFNMAP",
            "VM_MIXEDMAP"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if ((cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3043,
          "code": "if ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)",
          "condition": "(offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start",
          "variables": [
            "offset_in_page",
            "start",
            "start",
            "TASK_SIZE",
            "len",
            "TASK_SIZE",
            "start"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3048,
          "code": "if (len == 0)",
          "condition": "len == 0",
          "variables": [
            "len"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (len == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3066,
          "code": "if (vma->vm_start >= end)",
          "condition": "vma->vm_start >= end",
          "variables": [
            "vma",
            "vm_start",
            "end"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "if (vma->vm_start >= end)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3076,
          "code": "if (start > vma->vm_start) {",
          "condition": "start > vma->vm_start",
          "variables": [
            "start",
            "vma",
            "vm_start"
          ],
          "evidence": [
            {
              "line_no": 40,
              "text": "if (start > vma->vm_start) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3080,
          "code": "* Make sure that map_count on return from munmap() will",
          "condition": "* Make sure that map_count on return from munmap() will",
          "variables": [
            "Make",
            "sure",
            "that",
            "map_count",
            "on",
            "return",
            "from",
            "munmap",
            "will"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "* Make sure that map_count on return from munmap() will"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3084,
          "code": "if (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)",
          "condition": "end < vma->vm_end && mm->map_count >= sysctl_max_map_count",
          "variables": [
            "end",
            "vma",
            "vm_end",
            "mm",
            "map_count",
            "sysctl_max_map_count"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3095,
          "code": "if (last && end > last->vm_start) {",
          "condition": "last && end > last->vm_start",
          "variables": [
            "last",
            "end",
            "last",
            "vm_start"
          ],
          "evidence": [
            {
              "line_no": 59,
              "text": "if (last && end > last->vm_start) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3120,
          "code": "if (mm->locked_vm) {",
          "condition": "mm->locked_vm",
          "variables": [
            "mm",
            "locked_vm"
          ],
          "evidence": [
            {
              "line_no": 84,
              "text": "if (mm->locked_vm) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3122,
          "code": "while (tmp && tmp->vm_start < end) {",
          "condition": "tmp && tmp->vm_start < end",
          "variables": [
            "tmp",
            "tmp",
            "vm_start",
            "end"
          ],
          "evidence": [
            {
              "line_no": 86,
              "text": "while (tmp && tmp->vm_start < end) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3123,
          "code": "if (tmp->vm_flags & VM_LOCKED) {",
          "condition": "tmp->vm_flags & VM_LOCKED",
          "variables": [
            "tmp",
            "vm_flags",
            "VM_LOCKED"
          ],
          "evidence": [
            {
              "line_no": 87,
              "text": "if (tmp->vm_flags & VM_LOCKED) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3090,
          "code": "return __vm_munmap(addr, len, true);",
          "condition": "return __vm_munmap(addr, len, true);",
          "variables": [
            "return",
            "__vm_munmap",
            "addr",
            "len",
            "true"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "return __vm_munmap(addr, len, true);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        }
      ],
      "kernel_state_constraints": [
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2755,
          "code": "return -EFSCORRUPTED;",
          "condition": "return -EFSCORRUPTED;",
          "variables": [
            "return",
            "EFSCORRUPTED"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "return -EFSCORRUPTED;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2759,
          "code": "if (!ex)",
          "condition": "!ex",
          "variables": [
            "ex"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "if (!ex)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2770,
          "code": "if (ext4_ext_is_unwritten(ex))",
          "condition": "ext4_ext_is_unwritten(ex)",
          "variables": [
            "ext4_ext_is_unwritten",
            "ex"
          ],
          "evidence": [
            {
              "line_no": 40,
              "text": "if (ext4_ext_is_unwritten(ex))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2810,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 80,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2811,
          "code": "} else if (a != ex_ee_block) {",
          "condition": "a != ex_ee_block",
          "variables": [
            "a",
            "ex_ee_block"
          ],
          "evidence": [
            {
              "line_no": 81,
              "text": "} else if (a != ex_ee_block) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2825,
          "code": "if (ex == EXT_FIRST_EXTENT(eh)) {",
          "condition": "ex == EXT_FIRST_EXTENT(eh)",
          "variables": [
            "ex",
            "EXT_FIRST_EXTENT",
            "eh"
          ],
          "evidence": [
            {
              "line_no": 95,
              "text": "if (ex == EXT_FIRST_EXTENT(eh)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2842,
          "code": "if (err) {",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 112,
              "text": "if (err) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2845,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 115,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2849,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 119,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2850,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 120,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2853,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 123,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2854,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 124,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2856,
          "code": "if (num == 0)",
          "condition": "num == 0",
          "variables": [
            "num"
          ],
          "evidence": [
            {
              "line_no": 126,
              "text": "if (num == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2865,
          "code": "if (unwritten && num)",
          "condition": "unwritten && num",
          "variables": [
            "unwritten",
            "num"
          ],
          "evidence": [
            {
              "line_no": 135,
              "text": "if (unwritten && num)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2871,
          "code": "if (num == 0) {",
          "condition": "num == 0",
          "variables": [
            "num"
          ],
          "evidence": [
            {
              "line_no": 141,
              "text": "if (num == 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2872,
          "code": "if (end != EXT_MAX_BLOCKS - 1) {",
          "condition": "end != EXT_MAX_BLOCKS - 1",
          "variables": [
            "end",
            "EXT_MAX_BLOCKS"
          ],
          "evidence": [
            {
              "line_no": 142,
              "text": "if (end != EXT_MAX_BLOCKS - 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2973,
          "code": "if (IS_ERR(handle))",
          "condition": "IS_ERR(handle)",
          "variables": [
            "IS_ERR",
            "handle"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (IS_ERR(handle))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2974,
          "code": "return PTR_ERR(handle);",
          "condition": "return PTR_ERR(handle);",
          "variables": [
            "return",
            "PTR_ERR",
            "handle"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "return PTR_ERR(handle);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3001,
          "code": "if (!ex) {",
          "condition": "!ex",
          "variables": [
            "ex"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "if (!ex) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3002,
          "code": "if (depth) {",
          "condition": "depth",
          "variables": [
            "depth"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (depth) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3008,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3042,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 90,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3060,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 108,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3061,
          "code": "if (pblk) {",
          "condition": "pblk",
          "variables": [
            "pblk"
          ],
          "evidence": [
            {
              "line_no": 109,
              "text": "if (pblk) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3082,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [
            {
              "line_no": 130,
              "text": "return -ENOMEM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3090,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 138,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3096,
          "code": "if (i == depth) {",
          "condition": "i == depth",
          "variables": [
            "i",
            "depth"
          ],
          "evidence": [
            {
              "line_no": 144,
              "text": "if (i == depth) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 134,
          "code": "if (old == -1) {",
          "condition": "old == -1",
          "variables": [
            "old"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "if (old == -1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 136,
          "code": "} else if (old == cpu) {",
          "condition": "old == cpu",
          "variables": [
            "old",
            "cpu"
          ],
          "evidence": [
            {
              "line_no": 18,
              "text": "} else if (old == cpu) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 145,
          "code": "do { cpu_relax(); } while (atomic_read(&dump_lock) != -1);",
          "condition": "atomic_read(&dump_lock) != -1",
          "variables": [
            "atomic_read",
            "dump_lock"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "do { cpu_relax(); } while (atomic_read(&dump_lock) != -1);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 146,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "goto retry;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 455,
          "code": "if (addr_has_metadata(untagged_addr))",
          "condition": "addr_has_metadata(untagged_addr)",
          "variables": [
            "addr_has_metadata",
            "untagged_addr"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (addr_has_metadata(untagged_addr))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 467,
          "code": "if (addr_has_metadata(untagged_addr))",
          "condition": "addr_has_metadata(untagged_addr)",
          "variables": [
            "addr_has_metadata",
            "untagged_addr"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "if (addr_has_metadata(untagged_addr))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 471,
          "code": "if (addr_has_metadata(untagged_addr)) {",
          "condition": "addr_has_metadata(untagged_addr)",
          "variables": [
            "addr_has_metadata",
            "untagged_addr"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "if (addr_has_metadata(untagged_addr)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 459,
          "code": "if (likely(report_enabled())) {",
          "condition": "likely(report_enabled())",
          "variables": [
            "likely",
            "report_enabled"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (likely(report_enabled())) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4224,
          "code": "if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {",
          "condition": "mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)",
          "variables": [
            "mapping_tagged",
            "mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "evidence": [
            {
              "line_no": 19,
              "text": "if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4227,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4228,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "return ret;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4235,
          "code": "goto out_mutex;",
          "condition": "goto out_mutex;",
          "variables": [
            "goto",
            "out_mutex"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "goto out_mutex;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4263,
          "code": "goto out_mutex;",
          "condition": "goto out_mutex;",
          "variables": [
            "goto",
            "out_mutex"
          ],
          "evidence": [
            {
              "line_no": 58,
              "text": "goto out_mutex;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4271,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4272,
          "code": "goto out_mutex;",
          "condition": "goto out_mutex;",
          "variables": [
            "goto",
            "out_mutex"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "goto out_mutex;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4281,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 76,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4282,
          "code": "goto out_dio;",
          "condition": "goto out_dio;",
          "variables": [
            "goto",
            "out_dio"
          ],
          "evidence": [
            {
              "line_no": 77,
              "text": "goto out_dio;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4290,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 85,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4291,
          "code": "goto out_dio;",
          "condition": "goto out_dio;",
          "variables": [
            "goto",
            "out_dio"
          ],
          "evidence": [
            {
              "line_no": 86,
              "text": "goto out_dio;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4296,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 91,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4301,
          "code": "if (IS_ERR(handle)) {",
          "condition": "IS_ERR(handle)",
          "variables": [
            "IS_ERR",
            "handle"
          ],
          "evidence": [
            {
              "line_no": 96,
              "text": "if (IS_ERR(handle)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4304,
          "code": "goto out_dio;",
          "condition": "goto out_dio;",
          "variables": [
            "goto",
            "out_dio"
          ],
          "evidence": [
            {
              "line_no": 99,
              "text": "goto out_dio;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4309,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 104,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4310,
          "code": "goto out_stop;",
          "condition": "goto out_stop;",
          "variables": [
            "goto",
            "out_stop"
          ],
          "evidence": [
            {
              "line_no": 105,
              "text": "goto out_stop;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4324,
          "code": "if (ret) {",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 119,
              "text": "if (ret) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4326,
          "code": "goto out_stop;",
          "condition": "goto out_stop;",
          "variables": [
            "goto",
            "out_stop"
          ],
          "evidence": [
            {
              "line_no": 121,
              "text": "goto out_stop;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4329,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 124,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4721,
          "code": "if (IS_ENCRYPTED(inode) &&",
          "condition": "IS_ENCRYPTED(inode",
          "variables": [
            "IS_ENCRYPTED",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 17,
              "text": "if (IS_ENCRYPTED(inode) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4723,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 19,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4729,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4734,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4735,
          "code": "goto exit;",
          "condition": "goto exit;",
          "variables": [
            "goto",
            "exit"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "goto exit;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4737,
          "code": "if (mode & FALLOC_FL_PUNCH_HOLE) {",
          "condition": "mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [
            {
              "line_no": 33,
              "text": "if (mode & FALLOC_FL_PUNCH_HOLE) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 317,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 320,
          "code": "if (mode & ~FALLOC_FL_SUPPORTED_MASK)",
          "condition": "mode & ~FALLOC_FL_SUPPORTED_MASK",
          "variables": [
            "mode",
            "FALLOC_FL_SUPPORTED_MASK"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "if (mode & ~FALLOC_FL_SUPPORTED_MASK)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 321,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 324,
          "code": "if ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==",
          "condition": "(mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE",
            "FALLOC_FL_ZERO_RANGE"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "if ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) =="
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 326,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 329,
          "code": "if ((mode & FALLOC_FL_PUNCH_HOLE) &&",
          "condition": "(mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [
            {
              "line_no": 19,
              "text": "if ((mode & FALLOC_FL_PUNCH_HOLE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 331,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 334,
          "code": "if ((mode & FALLOC_FL_COLLAPSE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_COLLAPSE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_COLLAPSE_RANGE"
          ],
          "evidence": [
            {
              "line_no": 24,
              "text": "if ((mode & FALLOC_FL_COLLAPSE_RANGE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 336,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 26,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 339,
          "code": "if ((mode & FALLOC_FL_INSERT_RANGE) &&",
          "condition": "(mode & FALLOC_FL_INSERT_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_INSERT_RANGE"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "if ((mode & FALLOC_FL_INSERT_RANGE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 341,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 344,
          "code": "if ((mode & FALLOC_FL_UNSHARE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_UNSHARE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_UNSHARE_RANGE"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if ((mode & FALLOC_FL_UNSHARE_RANGE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 346,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 349,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "return -EBADF;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 355,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [
            {
              "line_no": 45,
              "text": "return -EPERM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 357,
          "code": "if (IS_IMMUTABLE(inode))",
          "condition": "IS_IMMUTABLE(inode)",
          "variables": [
            "IS_IMMUTABLE",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 47,
              "text": "if (IS_IMMUTABLE(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 358,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "return -EPERM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 363,
          "code": "if (IS_SWAPFILE(inode))",
          "condition": "IS_SWAPFILE(inode)",
          "variables": [
            "IS_SWAPFILE",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "if (IS_SWAPFILE(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 364,
          "code": "return -ETXTBSY;",
          "condition": "return -ETXTBSY;",
          "variables": [
            "return",
            "ETXTBSY"
          ],
          "evidence": [
            {
              "line_no": 54,
              "text": "return -ETXTBSY;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 371,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 61,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 372,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [
            {
              "line_no": 62,
              "text": "return ret;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 375,
          "code": "return -ESPIPE;",
          "condition": "return -ESPIPE;",
          "variables": [
            "return",
            "ESPIPE"
          ],
          "evidence": [
            {
              "line_no": 65,
              "text": "return -ESPIPE;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 378,
          "code": "return -EISDIR;",
          "condition": "return -EISDIR;",
          "variables": [
            "return",
            "EISDIR"
          ],
          "evidence": [
            {
              "line_no": 68,
              "text": "return -EISDIR;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 381,
          "code": "return -ENODEV;",
          "condition": "return -ENODEV;",
          "variables": [
            "return",
            "ENODEV"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "return -ENODEV;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 385,
          "code": "return -EFBIG;",
          "condition": "return -EFBIG;",
          "variables": [
            "return",
            "EFBIG"
          ],
          "evidence": [
            {
              "line_no": 75,
              "text": "return -EFBIG;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 388,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 739,
          "code": "return -ENOTTY;",
          "condition": "return -ENOTTY;",
          "variables": [
            "return",
            "ENOTTY"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return -ENOTTY;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 753,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 757,
          "code": "if (!f.file)",
          "condition": "!f.file",
          "variables": [
            "f",
            "file"
          ],
          "evidence": [
            {
              "line_no": 6,
              "text": "if (!f.file)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return -EBADF;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 762,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4275,
          "code": "if (cpusets_enabled() &&",
          "condition": "cpusets_enabled(",
          "variables": [
            "cpusets_enabled"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (cpusets_enabled() &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4318,
          "code": "if (zone_to_nid(zone) != local_nid) {",
          "condition": "zone_to_nid(zone) != local_nid",
          "variables": [
            "zone_to_nid",
            "zone",
            "local_nid"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (zone_to_nid(zone) != local_nid) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4320,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "goto retry;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4325,
          "code": "if (!zone_watermark_fast(zone, order, mark,",
          "condition": "if (!zone_watermark_fast(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_fast",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "if (!zone_watermark_fast(zone, order, mark,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4335,
          "code": "if (static_branch_unlikely(&deferred_pages)) {",
          "condition": "static_branch_unlikely(&deferred_pages)",
          "variables": [
            "static_branch_unlikely",
            "deferred_pages"
          ],
          "evidence": [
            {
              "line_no": 81,
              "text": "if (static_branch_unlikely(&deferred_pages)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4336,
          "code": "if (_deferred_grow_zone(zone, order))",
          "condition": "_deferred_grow_zone(zone, order)",
          "variables": [
            "_deferred_grow_zone",
            "zone",
            "order"
          ],
          "evidence": [
            {
              "line_no": 82,
              "text": "if (_deferred_grow_zone(zone, order))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4337,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [
            {
              "line_no": 83,
              "text": "goto try_this_zone;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4342,
          "code": "if (alloc_flags & ALLOC_NO_WATERMARKS)",
          "condition": "alloc_flags & ALLOC_NO_WATERMARKS",
          "variables": [
            "alloc_flags",
            "ALLOC_NO_WATERMARKS"
          ],
          "evidence": [
            {
              "line_no": 88,
              "text": "if (alloc_flags & ALLOC_NO_WATERMARKS)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4343,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [
            {
              "line_no": 89,
              "text": "goto try_this_zone;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4345,
          "code": "if (node_reclaim_mode == 0 ||",
          "condition": "if (node_reclaim_mode == 0 ||",
          "variables": [
            "if",
            "node_reclaim_mode"
          ],
          "evidence": [
            {
              "line_no": 91,
              "text": "if (node_reclaim_mode == 0 ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4350,
          "code": "switch (ret) {",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 96,
              "text": "switch (ret) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4359,
          "code": "if (zone_watermark_ok(zone, order, mark,",
          "condition": "if (zone_watermark_ok(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_ok",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [
            {
              "line_no": 105,
              "text": "if (zone_watermark_ok(zone, order, mark,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4361,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [
            {
              "line_no": 107,
              "text": "goto try_this_zone;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4370,
          "code": "if (page) {",
          "condition": "page",
          "variables": [
            "page"
          ],
          "evidence": [
            {
              "line_no": 116,
              "text": "if (page) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5359,
          "code": "if (unlikely(order >= MAX_ORDER)) {",
          "condition": "unlikely(order >= MAX_ORDER)",
          "variables": [
            "unlikely",
            "order",
            "MAX_ORDER"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "if (unlikely(order >= MAX_ORDER)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5361,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 15,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5366,
          "code": "if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))",
          "condition": "!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags)",
          "variables": [
            "prepare_alloc_pages",
            "gfp_mask",
            "order",
            "preferred_nid",
            "nodemask",
            "ac",
            "alloc_mask",
            "alloc_flags"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5367,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 547,
          "code": "return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);",
          "condition": "return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);",
          "variables": [
            "return",
            "__alloc_pages_nodemask",
            "gfp_mask",
            "order",
            "preferred_nid",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 563,
          "code": "return __alloc_pages(gfp_mask, order, nid);",
          "condition": "return __alloc_pages(gfp_mask, order, nid);",
          "variables": [
            "return",
            "__alloc_pages",
            "gfp_mask",
            "order",
            "nid"
          ],
          "evidence": [
            {
              "line_no": 6,
              "text": "return __alloc_pages(gfp_mask, order, nid);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 575,
          "code": "if (nid == NUMA_NO_NODE)",
          "condition": "nid == NUMA_NO_NODE",
          "variables": [
            "nid",
            "NUMA_NO_NODE"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "if (nid == NUMA_NO_NODE)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 578,
          "code": "return __alloc_pages_node(nid, gfp_mask, order);",
          "condition": "return __alloc_pages_node(nid, gfp_mask, order);",
          "variables": [
            "return",
            "__alloc_pages_node",
            "nid",
            "gfp_mask",
            "order"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return __alloc_pages_node(nid, gfp_mask, order);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 593,
          "code": "return alloc_pages_node(numa_node_id(), gfp_mask, order);",
          "condition": "return alloc_pages_node(numa_node_id(), gfp_mask, order);",
          "variables": [
            "return",
            "alloc_pages_node",
            "numa_node_id",
            "gfp_mask",
            "order"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return alloc_pages_node(numa_node_id(), gfp_mask, order);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/pagemap.h",
          "line": 291,
          "code": "return alloc_pages(gfp, 0);",
          "condition": "return alloc_pages(gfp, 0);",
          "variables": [
            "return",
            "alloc_pages",
            "gfp"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return alloc_pages(gfp, 0);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1856,
          "code": "if (xa_is_value(page))",
          "condition": "xa_is_value(page)",
          "variables": [
            "xa_is_value",
            "page"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "if (xa_is_value(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1861,
          "code": "if (!page)",
          "condition": "!page",
          "variables": [
            "page"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "if (!page)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1862,
          "code": "goto no_page;",
          "condition": "goto no_page;",
          "variables": [
            "goto",
            "no_page"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "goto no_page;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1864,
          "code": "if (fgp_flags & FGP_LOCK) {",
          "condition": "fgp_flags & FGP_LOCK",
          "variables": [
            "fgp_flags",
            "FGP_LOCK"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "if (fgp_flags & FGP_LOCK) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1865,
          "code": "if (fgp_flags & FGP_NOWAIT) {",
          "condition": "fgp_flags & FGP_NOWAIT",
          "variables": [
            "fgp_flags",
            "FGP_NOWAIT"
          ],
          "evidence": [
            {
              "line_no": 17,
              "text": "if (fgp_flags & FGP_NOWAIT) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1866,
          "code": "if (!trylock_page(page)) {",
          "condition": "!trylock_page(page)",
          "variables": [
            "trylock_page",
            "page"
          ],
          "evidence": [
            {
              "line_no": 18,
              "text": "if (!trylock_page(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1868,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1875,
          "code": "if (unlikely(page->mapping != mapping)) {",
          "condition": "unlikely(page->mapping != mapping)",
          "variables": [
            "unlikely",
            "page",
            "mapping",
            "mapping"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (unlikely(page->mapping != mapping)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1878,
          "code": "goto repeat;",
          "condition": "goto repeat;",
          "variables": [
            "goto",
            "repeat"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "goto repeat;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1883,
          "code": "if (fgp_flags & FGP_ACCESSED)",
          "condition": "fgp_flags & FGP_ACCESSED",
          "variables": [
            "fgp_flags",
            "FGP_ACCESSED"
          ],
          "evidence": [
            {
              "line_no": 35,
              "text": "if (fgp_flags & FGP_ACCESSED)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1885,
          "code": "else if (fgp_flags & FGP_WRITE) {",
          "condition": "fgp_flags & FGP_WRITE",
          "variables": [
            "fgp_flags",
            "FGP_WRITE"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "else if (fgp_flags & FGP_WRITE) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1887,
          "code": "if (page_is_idle(page))",
          "condition": "page_is_idle(page)",
          "variables": [
            "page_is_idle",
            "page"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (page_is_idle(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1890,
          "code": "if (!(fgp_flags & FGP_HEAD))",
          "condition": "!(fgp_flags & FGP_HEAD)",
          "variables": [
            "fgp_flags",
            "FGP_HEAD"
          ],
          "evidence": [
            {
              "line_no": 42,
              "text": "if (!(fgp_flags & FGP_HEAD))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1894,
          "code": "if (!page && (fgp_flags & FGP_CREAT)) {",
          "condition": "!page && (fgp_flags & FGP_CREAT)",
          "variables": [
            "page",
            "fgp_flags",
            "FGP_CREAT"
          ],
          "evidence": [
            {
              "line_no": 46,
              "text": "if (!page && (fgp_flags & FGP_CREAT)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1896,
          "code": "if ((fgp_flags & FGP_WRITE) && mapping_can_writeback(mapping))",
          "condition": "(fgp_flags & FGP_WRITE) && mapping_can_writeback(mapping)",
          "variables": [
            "fgp_flags",
            "FGP_WRITE",
            "mapping_can_writeback",
            "mapping"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if ((fgp_flags & FGP_WRITE) && mapping_can_writeback(mapping))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1898,
          "code": "if (fgp_flags & FGP_NOFS)",
          "condition": "fgp_flags & FGP_NOFS",
          "variables": [
            "fgp_flags",
            "FGP_NOFS"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (fgp_flags & FGP_NOFS)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/pagemap.h",
          "line": 406,
          "code": "return pagecache_get_page(mapping, index,",
          "condition": "return pagecache_get_page(mapping, index,",
          "variables": [
            "return",
            "pagecache_get_page",
            "mapping",
            "index"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "return pagecache_get_page(mapping, index,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1085,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1088,
          "code": "for (;;) {",
          "condition": ";;",
          "variables": [],
          "evidence": [
            {
              "line_no": 16,
              "text": "for (;;) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1093,
          "code": "if (bh)",
          "condition": "bh",
          "variables": [
            "bh"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (bh)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1094,
          "code": "return bh;",
          "condition": "return bh;",
          "variables": [
            "return",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "return bh;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1377,
          "code": "if (bh == NULL)",
          "condition": "bh == NULL",
          "variables": [
            "bh",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (bh == NULL)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1337,
          "code": "if (ext_depth(inode))",
          "condition": "ext_depth(inode)",
          "variables": [
            "ext_depth",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (ext_depth(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1346,
          "code": "if (newblock == 0)",
          "condition": "newblock == 0",
          "variables": [
            "newblock"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (newblock == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1347,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "return err;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1447,
          "code": "if (EXT_HAS_FREE_INDEX(curp)) {",
          "condition": "EXT_HAS_FREE_INDEX(curp)",
          "variables": [
            "EXT_HAS_FREE_INDEX",
            "curp"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if (EXT_HAS_FREE_INDEX(curp)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1451,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1452,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2097,
          "code": "goto prepend;",
          "condition": "goto prepend;",
          "variables": [
            "goto",
            "prepend"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "goto prepend;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2105,
          "code": "if (ext4_can_extents_be_merged(inode, ex, newext)) {",
          "condition": "ext4_can_extents_be_merged(inode, ex, newext)",
          "variables": [
            "ext4_can_extents_be_merged",
            "inode",
            "ex",
            "newext"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "if (ext4_can_extents_be_merged(inode, ex, newext)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2116,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2117,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "return err;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2121,
          "code": "if (unwritten)",
          "condition": "unwritten",
          "variables": [
            "unwritten"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (unwritten)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2125,
          "code": "goto merge;",
          "condition": "goto merge;",
          "variables": [
            "goto",
            "merge"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "goto merge;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2130,
          "code": "if (ext4_can_extents_be_merged(inode, newext, ex)) {",
          "condition": "ext4_can_extents_be_merged(inode, newext, ex)",
          "variables": [
            "ext4_can_extents_be_merged",
            "inode",
            "newext",
            "ex"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "if (ext4_can_extents_be_merged(inode, newext, ex)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2142,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2143,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "return err;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2150,
          "code": "if (unwritten)",
          "condition": "unwritten",
          "variables": [
            "unwritten"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "if (unwritten)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2154,
          "code": "goto merge;",
          "condition": "goto merge;",
          "variables": [
            "goto",
            "merge"
          ],
          "evidence": [
            {
              "line_no": 60,
              "text": "goto merge;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2161,
          "code": "goto has_space;",
          "condition": "goto has_space;",
          "variables": [
            "goto",
            "has_space"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "goto has_space;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2168,
          "code": "if (next != EXT_MAX_BLOCKS) {",
          "condition": "next != EXT_MAX_BLOCKS",
          "variables": [
            "next",
            "EXT_MAX_BLOCKS"
          ],
          "evidence": [
            {
              "line_no": 74,
              "text": "if (next != EXT_MAX_BLOCKS) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2180,
          "code": "goto has_space;",
          "condition": "goto has_space;",
          "variables": [
            "goto",
            "has_space"
          ],
          "evidence": [
            {
              "line_no": 86,
              "text": "goto has_space;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2190,
          "code": "if (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)",
          "condition": "gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL",
          "variables": [
            "gb_flags",
            "EXT4_GET_BLOCKS_METADATA_NOFAIL"
          ],
          "evidence": [
            {
              "line_no": 96,
              "text": "if (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4306,
          "code": "goto got_allocated_blocks;",
          "condition": "goto got_allocated_blocks;",
          "variables": [
            "goto",
            "got_allocated_blocks"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "goto got_allocated_blocks;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4325,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4351,
          "code": "if (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)",
          "condition": "flags & EXT4_GET_BLOCKS_NO_NORMALIZE",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_NO_NORMALIZE"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "if (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4353,
          "code": "if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)",
          "condition": "flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_DELALLOC_RESERVE"
          ],
          "evidence": [
            {
              "line_no": 51,
              "text": "if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4355,
          "code": "if (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)",
          "condition": "flags & EXT4_GET_BLOCKS_METADATA_NOFAIL",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_METADATA_NOFAIL"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "if (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4358,
          "code": "if (!newblock)",
          "condition": "!newblock",
          "variables": [
            "newblock"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "if (!newblock)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4359,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 57,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4368,
          "code": "/* try to insert new extent into found leaf and return */",
          "condition": "/* try to insert new extent into found leaf and return */",
          "variables": [
            "try",
            "to",
            "insert",
            "new",
            "extent",
            "into",
            "found",
            "leaf",
            "and",
            "return"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "/* try to insert new extent into found leaf and return */"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4373,
          "code": "if (flags & EXT4_GET_BLOCKS_UNWRIT_EXT) {",
          "condition": "flags & EXT4_GET_BLOCKS_UNWRIT_EXT",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_UNWRIT_EXT"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "if (flags & EXT4_GET_BLOCKS_UNWRIT_EXT) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 648,
          "code": "if (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {",
          "condition": "ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)",
          "variables": [
            "ext4_es_is_written",
            "es",
            "ext4_es_is_unwritten",
            "es"
          ],
          "evidence": [
            {
              "line_no": 2,
              "text": "if (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 657,
          "code": "} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {",
          "condition": "ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)",
          "variables": [
            "ext4_es_is_delayed",
            "es",
            "ext4_es_is_hole",
            "es"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 671,
          "code": "goto found;",
          "condition": "goto found;",
          "variables": [
            "goto",
            "found"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "goto found;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 679,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 33,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 697,
          "code": "if (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&",
          "condition": "!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_DELALLOC_RESERVE"
          ],
          "evidence": [
            {
              "line_no": 51,
              "text": "if (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 712,
          "code": "if (ret != 0)",
          "condition": "ret != 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (ret != 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 713,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "return ret;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 717,
          "code": "if ((flags & EXT4_GET_BLOCKS_CREATE) == 0)",
          "condition": "(flags & EXT4_GET_BLOCKS_CREATE) == 0",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_CREATE"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "if ((flags & EXT4_GET_BLOCKS_CREATE) == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 718,
          "code": "return retval;",
          "condition": "return retval;",
          "variables": [
            "return",
            "retval"
          ],
          "evidence": [
            {
              "line_no": 72,
              "text": "return retval;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 733,
          "code": "if (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))",
          "condition": "!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_CONVERT_UNWRITTEN"
          ],
          "evidence": [
            {
              "line_no": 87,
              "text": "if (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 734,
          "code": "return retval;",
          "condition": "return retval;",
          "variables": [
            "return",
            "retval"
          ],
          "evidence": [
            {
              "line_no": 88,
              "text": "return retval;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 754,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 108,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 800,
          "code": "if (ext4_has_inline_data(inode))",
          "condition": "ext4_has_inline_data(inode)",
          "variables": [
            "ext4_has_inline_data",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (ext4_has_inline_data(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 801,
          "code": "return -ERANGE;",
          "condition": "return -ERANGE;",
          "variables": [
            "return",
            "ERANGE"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -ERANGE;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 814,
          "code": "return _ext4_get_block(inode, iblock, bh,",
          "condition": "return _ext4_get_block(inode, iblock, bh,",
          "variables": [
            "return",
            "_ext4_get_block",
            "inode",
            "iblock",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "return _ext4_get_block(inode, iblock, bh,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1104,
          "code": "for (bh = head, block_start = 0; bh != head || !block_start;",
          "condition": "for (bh = head, block_start = 0; bh != head || !block_start;",
          "variables": [
            "for",
            "bh",
            "head",
            "block_start",
            "bh",
            "head",
            "block_start"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "for (bh = head, block_start = 0; bh != head || !block_start;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1108,
          "code": "if (PageUptodate(page)) {",
          "condition": "PageUptodate(page)",
          "variables": [
            "PageUptodate",
            "page"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "if (PageUptodate(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 3024,
          "code": "return ext4_write_begin(file, mapping, pos,",
          "condition": "return ext4_write_begin(file, mapping, pos,",
          "variables": [
            "return",
            "ext4_write_begin",
            "file",
            "mapping",
            "pos"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return ext4_write_begin(file, mapping, pos,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 3538,
          "code": "if (unlikely(iov_iter_fault_in_readable(i, bytes))) {",
          "condition": "unlikely(iov_iter_fault_in_readable(i, bytes))",
          "variables": [
            "unlikely",
            "iov_iter_fault_in_readable",
            "i",
            "bytes"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "if (unlikely(iov_iter_fault_in_readable(i, bytes))) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 3543,
          "code": "if (fatal_signal_pending(current)) {",
          "condition": "fatal_signal_pending(current)",
          "variables": [
            "fatal_signal_pending",
            "current"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "if (fatal_signal_pending(current)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 279,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 284,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1361,
          "code": "if (unlikely(PageHWPoison(page)) && !order) {",
          "condition": "unlikely(PageHWPoison(page)) && !order",
          "variables": [
            "unlikely",
            "PageHWPoison",
            "page",
            "order"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (unlikely(PageHWPoison(page)) && !order) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1366,
          "code": "if (memcg_kmem_enabled() && PageKmemcg(page))",
          "condition": "memcg_kmem_enabled() && PageKmemcg(page)",
          "variables": [
            "memcg_kmem_enabled",
            "PageKmemcg",
            "page"
          ],
          "evidence": [
            {
              "line_no": 17,
              "text": "if (memcg_kmem_enabled() && PageKmemcg(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1370,
          "code": "return false;",
          "condition": "return false;",
          "variables": [
            "return",
            "false"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return false;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1377,
          "code": "if (unlikely(order)) {",
          "condition": "unlikely(order)",
          "variables": [
            "unlikely",
            "order"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "if (unlikely(order)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1383,
          "code": "if (compound)",
          "condition": "compound",
          "variables": [
            "compound"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if (compound)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1386,
          "code": "if (compound)",
          "condition": "compound",
          "variables": [
            "compound"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "if (compound)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1388,
          "code": "if (unlikely(check_free_page(page + i))) {",
          "condition": "unlikely(check_free_page(page + i))",
          "variables": [
            "unlikely",
            "check_free_page",
            "page",
            "i"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (unlikely(check_free_page(page + i))) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1395,
          "code": "if (PageMappingFlags(page))",
          "condition": "PageMappingFlags(page)",
          "variables": [
            "PageMappingFlags",
            "page"
          ],
          "evidence": [
            {
              "line_no": 46,
              "text": "if (PageMappingFlags(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1397,
          "code": "if (memcg_kmem_enabled() && PageKmemcg(page))",
          "condition": "memcg_kmem_enabled() && PageKmemcg(page)",
          "variables": [
            "memcg_kmem_enabled",
            "PageKmemcg",
            "page"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (memcg_kmem_enabled() && PageKmemcg(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1399,
          "code": "if (check_free)",
          "condition": "check_free",
          "variables": [
            "check_free"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (check_free)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1401,
          "code": "if (bad)",
          "condition": "bad",
          "variables": [
            "bad"
          ],
          "evidence": [
            {
              "line_no": 52,
              "text": "if (bad)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1402,
          "code": "return false;",
          "condition": "return false;",
          "variables": [
            "return",
            "false"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "return false;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1422,
          "code": "return free_pages_prepare(page, 0, false, FPI_NONE);",
          "condition": "return free_pages_prepare(page, 0, false, FPI_NONE);",
          "variables": [
            "return",
            "free_pages_prepare",
            "page",
            "false",
            "FPI_NONE"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return free_pages_prepare(page, 0, false, FPI_NONE);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 3341,
          "code": "if (!free_pcp_prepare(page))",
          "condition": "!free_pcp_prepare(page)",
          "variables": [
            "free_pcp_prepare",
            "page"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "if (!free_pcp_prepare(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 3446,
          "code": "if (!free_unref_page_prepare(page, pfn)) {",
          "condition": "!free_unref_page_prepare(page, pfn)",
          "variables": [
            "free_unref_page_prepare",
            "page",
            "pfn"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "if (!free_unref_page_prepare(page, pfn)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1121,
          "code": "if (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {",
          "condition": "locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX",
          "variables": [
            "locked_pgdat",
            "lock_batch",
            "SWAP_CLUSTER_MAX"
          ],
          "evidence": [
            {
              "line_no": 18,
              "text": "if (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1127,
          "code": "if (is_huge_zero_page(page))",
          "condition": "is_huge_zero_page(page)",
          "variables": [
            "is_huge_zero_page",
            "page"
          ],
          "evidence": [
            {
              "line_no": 24,
              "text": "if (is_huge_zero_page(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1130,
          "code": "if (is_zone_device_page(page)) {",
          "condition": "is_zone_device_page(page)",
          "variables": [
            "is_zone_device_page",
            "page"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (is_zone_device_page(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1131,
          "code": "if (locked_pgdat) {",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "if (locked_pgdat) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1137,
          "code": "* ZONE_DEVICE pages that return 'false' from",
          "condition": "* ZONE_DEVICE pages that return 'false' from",
          "variables": [
            "ZONE_DEVICE",
            "pages",
            "that",
            "return",
            "false",
            "from"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "* ZONE_DEVICE pages that return 'false' from"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1142,
          "code": "if (page_is_devmap_managed(page)) {",
          "condition": "page_is_devmap_managed(page)",
          "variables": [
            "page_is_devmap_managed",
            "page"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (page_is_devmap_managed(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1148,
          "code": "if (!put_page_testzero(page))",
          "condition": "!put_page_testzero(page)",
          "variables": [
            "put_page_testzero",
            "page"
          ],
          "evidence": [
            {
              "line_no": 45,
              "text": "if (!put_page_testzero(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1151,
          "code": "if (PageCompound(page)) {",
          "condition": "PageCompound(page)",
          "variables": [
            "PageCompound",
            "page"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (PageCompound(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1152,
          "code": "if (locked_pgdat) {",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "if (locked_pgdat) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1160,
          "code": "if (PageLRU(page)) {",
          "condition": "PageLRU(page)",
          "variables": [
            "PageLRU",
            "page"
          ],
          "evidence": [
            {
              "line_no": 57,
              "text": "if (PageLRU(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1163,
          "code": "if (pgdat != locked_pgdat) {",
          "condition": "pgdat != locked_pgdat",
          "variables": [
            "pgdat",
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 60,
              "text": "if (pgdat != locked_pgdat) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1164,
          "code": "if (locked_pgdat)",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 61,
              "text": "if (locked_pgdat)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1181,
          "code": "if (locked_pgdat)",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "if (locked_pgdat)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3044,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3049,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3060,
          "code": "if (!vma)",
          "condition": "!vma",
          "variables": [
            "vma"
          ],
          "evidence": [
            {
              "line_no": 24,
              "text": "if (!vma)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3061,
          "code": "return 0;",
          "condition": "return 0;",
          "variables": [
            "return"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "return 0;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3067,
          "code": "return 0;",
          "condition": "return 0;",
          "variables": [
            "return"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "return 0;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3085,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "return -ENOMEM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3088,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 52,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3089,
          "code": "return error;",
          "condition": "return error;",
          "variables": [
            "return",
            "error"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "return error;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3097,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 61,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3098,
          "code": "return error;",
          "condition": "return error;",
          "variables": [
            "return",
            "error"
          ],
          "evidence": [
            {
              "line_no": 62,
              "text": "return error;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3102,
          "code": "if (unlikely(uf)) {",
          "condition": "unlikely(uf)",
          "variables": [
            "unlikely",
            "uf"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (unlikely(uf)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3113,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 77,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3114,
          "code": "return error;",
          "condition": "return error;",
          "variables": [
            "return",
            "error"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "return error;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3133,
          "code": "if (!detach_vmas_to_be_unmapped(mm, vma, prev, end))",
          "condition": "!detach_vmas_to_be_unmapped(mm, vma, prev, end)",
          "variables": [
            "detach_vmas_to_be_unmapped",
            "mm",
            "vma",
            "prev",
            "end"
          ],
          "evidence": [
            {
              "line_no": 97,
              "text": "if (!detach_vmas_to_be_unmapped(mm, vma, prev, end))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3136,
          "code": "if (downgrade)",
          "condition": "downgrade",
          "variables": [
            "downgrade"
          ],
          "evidence": [
            {
              "line_no": 100,
              "text": "if (downgrade)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3066,
          "code": "if (mmap_write_lock_killable(mm))",
          "condition": "mmap_write_lock_killable(mm)",
          "variables": [
            "mmap_write_lock_killable",
            "mm"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (mmap_write_lock_killable(mm))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3067,
          "code": "return -EINTR;",
          "condition": "return -EINTR;",
          "variables": [
            "return",
            "EINTR"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -EINTR;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        }
      ]
    },
    "exploitability": "high"
  },
  "exploitability": {
    "free_site": null,
    "trigger_site": {
      "file": "fs/ext4/extents.c",
      "line": 2730,
      "url": "https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730",
      "func": "ext4_ext_rm_leaf"
    },
    "allocation_site": null,
    "object": null,
    "struct_info": {
      "struct_name": null,
      "fields_used": [
        "Adjust",
        "Also",
        "Eventually",
        "For",
        "If",
        "It",
        "Locality",
        "Note",
        "Otherwise",
        "Prefer",
        "So",
        "The",
        "This",
        "a_ops",
        "aarch64",
        "access_addr",
        "access_size",
        "b_size",
        "b_this_page",
        "backing_dev_info",
        "bd_inode",
        "c",
        "ee_block",
        "ee_len",
        "eh_entries",
        "eh_max",
        "es_lblk",
        "es_len",
        "f_mapping",
        "f_mode",
        "f_op",
        "f_pos",
        "fallocate",
        "file",
        "first_bad_addr",
        "flags",
        "freed_tables",
        "fullmm",
        "g",
        "goal",
        "highest_zoneidx",
        "host",
        "i_blkbits",
        "i_data_sem",
        "i_ino",
        "i_mapping",
        "i_mmap_sem",
        "i_mode",
        "i_sb",
        "i_size",
        "index",
        "inode",
        "ip",
        "is_write",
        "ki_filp",
        "ki_flags",
        "ki_pos",
        "kunit_test",
        "lblk",
        "len",
        "local",
        "locked_vm",
        "logical",
        "lru",
        "lru_lock",
        "m_flags",
        "m_lblk",
        "m_len",
        "m_pblk",
        "map_count",
        "mapping",
        "migratetype",
        "mm",
        "munmap",
        "next",
        "nodemask",
        "nr",
        "p_bh",
        "p_block",
        "p_depth",
        "p_ext",
        "p_hdr",
        "p_maxdepth",
        "pages",
        "pclu",
        "preferred_zoneref",
        "s_bdev",
        "s_bitmap_maxbytes",
        "s_blocksize",
        "s_cluster_ratio",
        "s_es",
        "s_first_data_block",
        "s_maxbytes",
        "spread_dirty_pages",
        "state",
        "vm_end",
        "vm_flags",
        "vm_next",
        "vm_prev",
        "vm_start",
        "write_begin",
        "zone",
        "zone_pgdat"
      ],
      "struct_def_snippet": null
    },
    "usage_examples": [
      {
        "line_no": 1,
        "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
      },
      {
        "line_no": 2,
        "text": "struct ext4_ext_path *path,"
      },
      {
        "line_no": 3,
        "text": "struct partial_cluster *partial,"
      },
      {
        "line_no": 6,
        "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
      },
      {
        "line_no": 9,
        "text": "struct ext4_extent_header *eh;"
      },
      {
        "line_no": 15,
        "text": "struct ext4_extent *ex;"
      },
      {
        "line_no": 18,
        "text": "/* the header must be checked already in ext4_ext_remove_space() */"
      },
      {
        "line_no": 20,
        "text": "if (!path[depth].p_hdr)"
      },
      {
        "line_no": 21,
        "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
      },
      {
        "line_no": 22,
        "text": "eh = path[depth].p_hdr;"
      },
      {
        "line_no": 23,
        "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
      },
      {
        "line_no": 24,
        "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
      },
      {
        "line_no": 27,
        "text": "/* find where to start removing */"
      },
      {
        "line_no": 28,
        "text": "ex = path[depth].p_ext;"
      },
      {
        "line_no": 32,
        "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
      },
      {
        "line_no": 45,
        "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
      },
      {
        "line_no": 47,
        "text": "path[depth].p_ext = ex;"
      },
      {
        "line_no": 55,
        "text": "/* If this extent is beyond the end of the hole, skip it */"
      },
      {
        "line_no": 57,
        "text": "/*"
      },
      {
        "line_no": 58,
        "text": "* We're going to skip this extent and move to another,"
      },
      {
        "line_no": 59,
        "text": "* so note that its first cluster is in use to avoid"
      },
      {
        "line_no": 60,
        "text": "* freeing it when removing blocks.  Eventually, the"
      },
      {
        "line_no": 61,
        "text": "* right edge of the truncated/punched region will"
      },
      {
        "line_no": 62,
        "text": "* be just to the left."
      },
      {
        "line_no": 63,
        "text": "*/"
      },
      {
        "line_no": 64,
        "text": "if (sbi->s_cluster_ratio > 1) {"
      },
      {
        "line_no": 66,
        "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
      },
      {
        "line_no": 67,
        "text": "partial->state = nofree;"
      },
      {
        "line_no": 70,
        "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
      },
      {
        "line_no": 82,
        "text": "/* remove tail of the extent */"
      },
      {
        "line_no": 85,
        "text": "/* remove whole extent: excellent! */"
      },
      {
        "line_no": 88,
        "text": "/*"
      },
      {
        "line_no": 89,
        "text": "* 3 for leaf, sb, and inode plus 2 (bmap and group"
      },
      {
        "line_no": 90,
        "text": "* descriptor) for each block group; assume two block"
      },
      {
        "line_no": 91,
        "text": "* groups plus ex_ee_len/blocks_per_block_group for"
      },
      {
        "line_no": 92,
        "text": "* the worst case"
      },
      {
        "line_no": 93,
        "text": "*/"
      },
      {
        "line_no": 94,
        "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
      },
      {
        "line_no": 99,
        "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
      },
      {
        "line_no": 100,
        "text": "/*"
      },
      {
        "line_no": 101,
        "text": "* We may end up freeing some index blocks and data from the"
      },
      {
        "line_no": 102,
        "text": "* punched range. Note that partial clusters are accounted for"
      },
      {
        "line_no": 103,
        "text": "* by ext4_free_data_revoke_credits()."
      },
      {
        "line_no": 104,
        "text": "*/"
      },
      {
        "line_no": 106,
        "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
      },
      {
        "line_no": 127,
        "text": "/* this extent is removed; mark slot entirely unused */"
      },
      {
        "line_no": 130,
        "text": "ex->ee_len = cpu_to_le16(num);"
      },
      {
        "line_no": 131,
        "text": "/*"
      },
      {
        "line_no": 132,
        "text": "* Do not mark unwritten if all the blocks in the"
      },
      {
        "line_no": 133,
        "text": "* extent have been removed."
      },
      {
        "line_no": 134,
        "text": "*/"
      },
      {
        "line_no": 137,
        "text": "/*"
      },
      {
        "line_no": 138,
        "text": "* If the extent was completely released,"
      },
      {
        "line_no": 139,
        "text": "* we need to remove it from the leaf"
      },
      {
        "line_no": 140,
        "text": "*/"
      },
      {
        "line_no": 143,
        "text": "/*"
      },
      {
        "line_no": 144,
        "text": "* For hole punching, we need to scoot all the"
      },
      {
        "line_no": 145,
        "text": "* extents up when an extent is removed so that"
      },
      {
        "line_no": 146,
        "text": "* we dont have blank extents in the middle"
      },
      {
        "line_no": 147,
        "text": "*/"
      },
      {
        "line_no": 148,
        "text": "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
      }
    ],
    "notes": [],
    "concrete_preconditions": [
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,",
        "variables": [
          "handle",
          "inode"
        ],
        "indices": [],
        "constraint": "variable(s) handle, inode may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 74,
            "text": "EXT4_ERROR_INODE(inode,"
          },
          {
            "line_no": 75,
            "text": "\"can not handle truncate %u:%u \""
          },
          {
            "line_no": 89,
            "text": "* 3 for leaf, sb, and inode plus 2 (bmap and group"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "struct ext4_ext_path *path,",
        "variables": [
          "path"
        ],
        "indices": [],
        "constraint": "variable(s) path may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "struct partial_cluster *partial,",
        "variables": [
          "partial"
        ],
        "indices": [],
        "constraint": "variable(s) partial may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 3,
            "text": "struct partial_cluster *partial,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 102,
            "text": "* punched range. Note that partial clusters are accounted for"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);",
        "variables": [
          "inode"
        ],
        "indices": [],
        "constraint": "field(s) i_sb may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 74,
            "text": "EXT4_ERROR_INODE(inode,"
          },
          {
            "line_no": 89,
            "text": "* 3 for leaf, sb, and inode plus 2 (bmap and group"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "struct ext4_extent_header *eh;",
        "variables": [
          "eh"
        ],
        "indices": [],
        "constraint": "variable(s) eh may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 9,
            "text": "struct ext4_extent_header *eh;"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 30,
            "text": "ex = EXT_LAST_EXTENT(eh);"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 37,
            "text": "while (ex >= EXT_FIRST_EXTENT(eh) &&"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 95,
            "text": "if (ex == EXT_FIRST_EXTENT(eh)) {"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 148,
            "text": "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "struct ext4_extent *ex;",
        "variables": [
          "ex"
        ],
        "indices": [],
        "constraint": "variable(s) ex may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 4,
            "text": "ext4_lblk_t start, ext4_lblk_t end)"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 7,
            "text": "int err = 0, correct_index = 0;"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 9,
            "text": "struct ext4_extent_header *eh;"
          },
          {
            "line_no": 10,
            "text": "ext4_lblk_t a, b;"
          },
          {
            "line_no": 12,
            "text": "ext4_lblk_t ex_ee_block;"
          },
          {
            "line_no": 13,
            "text": "unsigned short ex_ee_len;"
          },
          {
            "line_no": 15,
            "text": "struct ext4_extent *ex;"
          },
          {
            "line_no": 16,
            "text": "ext4_fsblk_t pblk;"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 29,
            "text": "if (!ex)"
          },
          {
            "line_no": 30,
            "text": "ex = EXT_LAST_EXTENT(eh);"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 33,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 37,
            "text": "while (ex >= EXT_FIRST_EXTENT(eh) &&"
          },
          {
            "line_no": 38,
            "text": "ex_ee_block + ex_ee_len > start) {"
          },
          {
            "line_no": 40,
            "text": "if (ext4_ext_is_unwritten(ex))"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 46,
            "text": "unwritten, ex_ee_len);"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 49,
            "text": "a = ex_ee_block > start ? ex_ee_block : start;"
          },
          {
            "line_no": 50,
            "text": "b = ex_ee_block+ex_ee_len - 1 < end ?"
          },
          {
            "line_no": 51,
            "text": "ex_ee_block+ex_ee_len - 1 : end;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 56,
            "text": "if (end < ex_ee_block) {"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 65,
            "text": "pblk = ext4_ext_pblock(ex);"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 69,
            "text": "ex--;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 71,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 73,
            "text": "} else if (b != ex_ee_block + ex_ee_len - 1) {"
          },
          {
            "line_no": 76,
            "text": "\"on extent %u:%u\","
          },
          {
            "line_no": 77,
            "text": "start, end, ex_ee_block,"
          },
          {
            "line_no": 78,
            "text": "ex_ee_block + ex_ee_len - 1);"
          },
          {
            "line_no": 81,
            "text": "} else if (a != ex_ee_block) {"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 83,
            "text": "num = a - ex_ee_block;"
          },
          {
            "line_no": 85,
            "text": "/* remove whole extent: excellent! */"
          },
          {
            "line_no": 91,
            "text": "* groups plus ex_ee_len/blocks_per_block_group for"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 95,
            "text": "if (ex == EXT_FIRST_EXTENT(eh)) {"
          },
          {
            "line_no": 96,
            "text": "correct_index = 1;"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 103,
            "text": "* by ext4_free_data_revoke_credits()."
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 128,
            "text": "ext4_ext_store_pblock(ex, 0);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          },
          {
            "line_no": 136,
            "text": "ext4_ext_mark_unwritten(ex);"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          },
          {
            "line_no": 148,
            "text": "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/* the header must be checked already in ext4_ext_remove_space() */",
        "variables": [
          "the"
        ],
        "indices": [],
        "constraint": "variable(s) the may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 60,
            "text": "* freeing it when removing blocks.  Eventually, the"
          },
          {
            "line_no": 61,
            "text": "* right edge of the truncated/punched region will"
          },
          {
            "line_no": 62,
            "text": "* be just to the left."
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 92,
            "text": "* the worst case"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 132,
            "text": "* Do not mark unwritten if all the blocks in the"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          },
          {
            "line_no": 139,
            "text": "* we need to remove it from the leaf"
          },
          {
            "line_no": 144,
            "text": "* For hole punching, we need to scoot all the"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "if (!path[depth].p_hdr)",
        "variables": [
          "path"
        ],
        "indices": [
          {
            "base": "path",
            "index_expr": "depth"
          }
        ],
        "constraint": "index expression 'depth' on path may be attacker-controlled and cause OOB access",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);",
        "variables": [
          "path"
        ],
        "indices": [
          {
            "base": "path",
            "index_expr": "depth"
          },
          {
            "base": "path",
            "index_expr": "depth"
          }
        ],
        "constraint": "index expression 'depth' on path may be attacker-controlled and cause OOB access",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "eh = path[depth].p_hdr;",
        "variables": [
          "path"
        ],
        "indices": [
          {
            "base": "path",
            "index_expr": "depth"
          }
        ],
        "constraint": "index expression 'depth' on path may be attacker-controlled and cause OOB access",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "if (unlikely(path[depth].p_hdr == NULL)) {",
        "variables": [
          "path"
        ],
        "indices": [
          {
            "base": "path",
            "index_expr": "depth"
          }
        ],
        "constraint": "index expression 'depth' on path may be attacker-controlled and cause OOB access",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);",
        "variables": [
          "path"
        ],
        "indices": [
          {
            "base": "path",
            "index_expr": "%d"
          }
        ],
        "constraint": "index expression '%d' on path may be attacker-controlled and cause OOB access",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/* find where to start removing */",
        "variables": [
          "find"
        ],
        "indices": [],
        "constraint": "variable(s) find may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 27,
            "text": "/* find where to start removing */"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "ex = path[depth].p_ext;",
        "variables": [
          "path"
        ],
        "indices": [
          {
            "base": "path",
            "index_expr": "depth"
          }
        ],
        "constraint": "index expression 'depth' on path may be attacker-controlled and cause OOB access",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "ex_ee_block = le32_to_cpu(ex->ee_block);",
        "variables": [
          "ex"
        ],
        "indices": [],
        "constraint": "field(s) ee_block may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 4,
            "text": "ext4_lblk_t start, ext4_lblk_t end)"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 7,
            "text": "int err = 0, correct_index = 0;"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 9,
            "text": "struct ext4_extent_header *eh;"
          },
          {
            "line_no": 10,
            "text": "ext4_lblk_t a, b;"
          },
          {
            "line_no": 12,
            "text": "ext4_lblk_t ex_ee_block;"
          },
          {
            "line_no": 13,
            "text": "unsigned short ex_ee_len;"
          },
          {
            "line_no": 15,
            "text": "struct ext4_extent *ex;"
          },
          {
            "line_no": 16,
            "text": "ext4_fsblk_t pblk;"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 29,
            "text": "if (!ex)"
          },
          {
            "line_no": 30,
            "text": "ex = EXT_LAST_EXTENT(eh);"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 33,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 37,
            "text": "while (ex >= EXT_FIRST_EXTENT(eh) &&"
          },
          {
            "line_no": 38,
            "text": "ex_ee_block + ex_ee_len > start) {"
          },
          {
            "line_no": 40,
            "text": "if (ext4_ext_is_unwritten(ex))"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 46,
            "text": "unwritten, ex_ee_len);"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 49,
            "text": "a = ex_ee_block > start ? ex_ee_block : start;"
          },
          {
            "line_no": 50,
            "text": "b = ex_ee_block+ex_ee_len - 1 < end ?"
          },
          {
            "line_no": 51,
            "text": "ex_ee_block+ex_ee_len - 1 : end;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 56,
            "text": "if (end < ex_ee_block) {"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 65,
            "text": "pblk = ext4_ext_pblock(ex);"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 69,
            "text": "ex--;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 71,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 73,
            "text": "} else if (b != ex_ee_block + ex_ee_len - 1) {"
          },
          {
            "line_no": 76,
            "text": "\"on extent %u:%u\","
          },
          {
            "line_no": 77,
            "text": "start, end, ex_ee_block,"
          },
          {
            "line_no": 78,
            "text": "ex_ee_block + ex_ee_len - 1);"
          },
          {
            "line_no": 81,
            "text": "} else if (a != ex_ee_block) {"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 83,
            "text": "num = a - ex_ee_block;"
          },
          {
            "line_no": 85,
            "text": "/* remove whole extent: excellent! */"
          },
          {
            "line_no": 91,
            "text": "* groups plus ex_ee_len/blocks_per_block_group for"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 95,
            "text": "if (ex == EXT_FIRST_EXTENT(eh)) {"
          },
          {
            "line_no": 96,
            "text": "correct_index = 1;"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 103,
            "text": "* by ext4_free_data_revoke_credits()."
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 128,
            "text": "ext4_ext_store_pblock(ex, 0);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          },
          {
            "line_no": 136,
            "text": "ext4_ext_mark_unwritten(ex);"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          },
          {
            "line_no": 148,
            "text": "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "path[depth].p_ext = ex;",
        "variables": [
          "path"
        ],
        "indices": [
          {
            "base": "path",
            "index_expr": "depth"
          }
        ],
        "constraint": "index expression 'depth' on path may be attacker-controlled and cause OOB access",
        "evidence": [
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/* If this extent is beyond the end of the hole, skip it */",
        "variables": [
          "If"
        ],
        "indices": [],
        "constraint": "variable(s) If may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/*",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* We're going to skip this extent and move to another,",
        "variables": [
          "We"
        ],
        "indices": [],
        "constraint": "variable(s) We may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* so note that its first cluster is in use to avoid",
        "variables": [
          "so"
        ],
        "indices": [],
        "constraint": "variable(s) so may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 59,
            "text": "* so note that its first cluster is in use to avoid"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* freeing it when removing blocks.  Eventually, the",
        "variables": [
          "freeing"
        ],
        "indices": [],
        "constraint": "variable(s) freeing may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 60,
            "text": "* freeing it when removing blocks.  Eventually, the"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* right edge of the truncated/punched region will",
        "variables": [
          "right"
        ],
        "indices": [],
        "constraint": "variable(s) right may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 61,
            "text": "* right edge of the truncated/punched region will"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* be just to the left.",
        "variables": [
          "be"
        ],
        "indices": [],
        "constraint": "variable(s) be may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 62,
            "text": "* be just to the left."
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "*/",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "if (sbi->s_cluster_ratio > 1) {",
        "variables": [
          "sbi"
        ],
        "indices": [],
        "constraint": "field(s) s_cluster_ratio may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "partial->pclu = EXT4_B2C(sbi, pblk);",
        "variables": [
          "partial"
        ],
        "indices": [],
        "constraint": "field(s) pclu may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 3,
            "text": "struct partial_cluster *partial,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 102,
            "text": "* punched range. Note that partial clusters are accounted for"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "partial->state = nofree;",
        "variables": [
          "partial"
        ],
        "indices": [],
        "constraint": "field(s) state may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 3,
            "text": "struct partial_cluster *partial,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 102,
            "text": "* punched range. Note that partial clusters are accounted for"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "ex_ee_block = le32_to_cpu(ex->ee_block);",
        "variables": [
          "ex"
        ],
        "indices": [],
        "constraint": "field(s) ee_block may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 4,
            "text": "ext4_lblk_t start, ext4_lblk_t end)"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 7,
            "text": "int err = 0, correct_index = 0;"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 9,
            "text": "struct ext4_extent_header *eh;"
          },
          {
            "line_no": 10,
            "text": "ext4_lblk_t a, b;"
          },
          {
            "line_no": 12,
            "text": "ext4_lblk_t ex_ee_block;"
          },
          {
            "line_no": 13,
            "text": "unsigned short ex_ee_len;"
          },
          {
            "line_no": 15,
            "text": "struct ext4_extent *ex;"
          },
          {
            "line_no": 16,
            "text": "ext4_fsblk_t pblk;"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 29,
            "text": "if (!ex)"
          },
          {
            "line_no": 30,
            "text": "ex = EXT_LAST_EXTENT(eh);"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 33,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 37,
            "text": "while (ex >= EXT_FIRST_EXTENT(eh) &&"
          },
          {
            "line_no": 38,
            "text": "ex_ee_block + ex_ee_len > start) {"
          },
          {
            "line_no": 40,
            "text": "if (ext4_ext_is_unwritten(ex))"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 46,
            "text": "unwritten, ex_ee_len);"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 49,
            "text": "a = ex_ee_block > start ? ex_ee_block : start;"
          },
          {
            "line_no": 50,
            "text": "b = ex_ee_block+ex_ee_len - 1 < end ?"
          },
          {
            "line_no": 51,
            "text": "ex_ee_block+ex_ee_len - 1 : end;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 56,
            "text": "if (end < ex_ee_block) {"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 65,
            "text": "pblk = ext4_ext_pblock(ex);"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 69,
            "text": "ex--;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 71,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 73,
            "text": "} else if (b != ex_ee_block + ex_ee_len - 1) {"
          },
          {
            "line_no": 76,
            "text": "\"on extent %u:%u\","
          },
          {
            "line_no": 77,
            "text": "start, end, ex_ee_block,"
          },
          {
            "line_no": 78,
            "text": "ex_ee_block + ex_ee_len - 1);"
          },
          {
            "line_no": 81,
            "text": "} else if (a != ex_ee_block) {"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 83,
            "text": "num = a - ex_ee_block;"
          },
          {
            "line_no": 85,
            "text": "/* remove whole extent: excellent! */"
          },
          {
            "line_no": 91,
            "text": "* groups plus ex_ee_len/blocks_per_block_group for"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 95,
            "text": "if (ex == EXT_FIRST_EXTENT(eh)) {"
          },
          {
            "line_no": 96,
            "text": "correct_index = 1;"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 103,
            "text": "* by ext4_free_data_revoke_credits()."
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 128,
            "text": "ext4_ext_store_pblock(ex, 0);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          },
          {
            "line_no": 136,
            "text": "ext4_ext_mark_unwritten(ex);"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          },
          {
            "line_no": 148,
            "text": "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/* remove tail of the extent */",
        "variables": [
          "remove"
        ],
        "indices": [],
        "constraint": "variable(s) remove may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 85,
            "text": "/* remove whole extent: excellent! */"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          },
          {
            "line_no": 139,
            "text": "* we need to remove it from the leaf"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/* remove whole extent: excellent! */",
        "variables": [
          "remove"
        ],
        "indices": [],
        "constraint": "variable(s) remove may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 85,
            "text": "/* remove whole extent: excellent! */"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          },
          {
            "line_no": 139,
            "text": "* we need to remove it from the leaf"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/*",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* 3 for leaf, sb, and inode plus 2 (bmap and group",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* descriptor) for each block group; assume two block",
        "variables": [
          "descriptor"
        ],
        "indices": [],
        "constraint": "variable(s) descriptor may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 90,
            "text": "* descriptor) for each block group; assume two block"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* groups plus ex_ee_len/blocks_per_block_group for",
        "variables": [
          "groups"
        ],
        "indices": [],
        "constraint": "variable(s) groups may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 91,
            "text": "* groups plus ex_ee_len/blocks_per_block_group for"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* the worst case",
        "variables": [
          "the"
        ],
        "indices": [],
        "constraint": "variable(s) the may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 60,
            "text": "* freeing it when removing blocks.  Eventually, the"
          },
          {
            "line_no": 61,
            "text": "* right edge of the truncated/punched region will"
          },
          {
            "line_no": 62,
            "text": "* be just to the left."
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 92,
            "text": "* the worst case"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 132,
            "text": "* Do not mark unwritten if all the blocks in the"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          },
          {
            "line_no": 139,
            "text": "* we need to remove it from the leaf"
          },
          {
            "line_no": 144,
            "text": "* For hole punching, we need to scoot all the"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "*/",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));",
        "variables": [
          "inode"
        ],
        "indices": [],
        "constraint": "field(s) i_sb may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 74,
            "text": "EXT4_ERROR_INODE(inode,"
          },
          {
            "line_no": 89,
            "text": "* 3 for leaf, sb, and inode plus 2 (bmap and group"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);",
        "variables": [
          "inode"
        ],
        "indices": [],
        "constraint": "field(s) i_sb may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 74,
            "text": "EXT4_ERROR_INODE(inode,"
          },
          {
            "line_no": 89,
            "text": "* 3 for leaf, sb, and inode plus 2 (bmap and group"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/*",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* We may end up freeing some index blocks and data from the",
        "variables": [
          "We"
        ],
        "indices": [],
        "constraint": "variable(s) We may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* punched range. Note that partial clusters are accounted for",
        "variables": [
          "punched"
        ],
        "indices": [],
        "constraint": "variable(s) punched may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 61,
            "text": "* right edge of the truncated/punched region will"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 102,
            "text": "* punched range. Note that partial clusters are accounted for"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* by ext4_free_data_revoke_credits().",
        "variables": [
          "by"
        ],
        "indices": [],
        "constraint": "variable(s) by may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 103,
            "text": "* by ext4_free_data_revoke_credits()."
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "*/",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "ext4_free_metadata_revoke_credits(inode->i_sb,",
        "variables": [
          "inode"
        ],
        "indices": [],
        "constraint": "field(s) i_sb may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 74,
            "text": "EXT4_ERROR_INODE(inode,"
          },
          {
            "line_no": 89,
            "text": "* 3 for leaf, sb, and inode plus 2 (bmap and group"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/* this extent is removed; mark slot entirely unused */",
        "variables": [
          "this"
        ],
        "indices": [],
        "constraint": "variable(s) this may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "ex->ee_len = cpu_to_le16(num);",
        "variables": [
          "ex"
        ],
        "indices": [],
        "constraint": "field(s) ee_len may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,"
          },
          {
            "line_no": 2,
            "text": "struct ext4_ext_path *path,"
          },
          {
            "line_no": 4,
            "text": "ext4_lblk_t start, ext4_lblk_t end)"
          },
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 7,
            "text": "int err = 0, correct_index = 0;"
          },
          {
            "line_no": 8,
            "text": "int depth = ext_depth(inode), credits, revoke_credits;"
          },
          {
            "line_no": 9,
            "text": "struct ext4_extent_header *eh;"
          },
          {
            "line_no": 10,
            "text": "ext4_lblk_t a, b;"
          },
          {
            "line_no": 12,
            "text": "ext4_lblk_t ex_ee_block;"
          },
          {
            "line_no": 13,
            "text": "unsigned short ex_ee_len;"
          },
          {
            "line_no": 15,
            "text": "struct ext4_extent *ex;"
          },
          {
            "line_no": 16,
            "text": "ext4_fsblk_t pblk;"
          },
          {
            "line_no": 18,
            "text": "/* the header must be checked already in ext4_ext_remove_space() */"
          },
          {
            "line_no": 19,
            "text": "ext_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 29,
            "text": "if (!ex)"
          },
          {
            "line_no": 30,
            "text": "ex = EXT_LAST_EXTENT(eh);"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 33,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 35,
            "text": "trace_ext4_ext_rm_leaf(inode, start, ex, partial);"
          },
          {
            "line_no": 37,
            "text": "while (ex >= EXT_FIRST_EXTENT(eh) &&"
          },
          {
            "line_no": 38,
            "text": "ex_ee_block + ex_ee_len > start) {"
          },
          {
            "line_no": 40,
            "text": "if (ext4_ext_is_unwritten(ex))"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 46,
            "text": "unwritten, ex_ee_len);"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 49,
            "text": "a = ex_ee_block > start ? ex_ee_block : start;"
          },
          {
            "line_no": 50,
            "text": "b = ex_ee_block+ex_ee_len - 1 < end ?"
          },
          {
            "line_no": 51,
            "text": "ex_ee_block+ex_ee_len - 1 : end;"
          },
          {
            "line_no": 53,
            "text": "ext_debug(inode, \"  border %u:%u\\n\", a, b);"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 56,
            "text": "if (end < ex_ee_block) {"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 65,
            "text": "pblk = ext4_ext_pblock(ex);"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 69,
            "text": "ex--;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 71,
            "text": "ex_ee_len = ext4_ext_get_actual_len(ex);"
          },
          {
            "line_no": 73,
            "text": "} else if (b != ex_ee_block + ex_ee_len - 1) {"
          },
          {
            "line_no": 76,
            "text": "\"on extent %u:%u\","
          },
          {
            "line_no": 77,
            "text": "start, end, ex_ee_block,"
          },
          {
            "line_no": 78,
            "text": "ex_ee_block + ex_ee_len - 1);"
          },
          {
            "line_no": 81,
            "text": "} else if (a != ex_ee_block) {"
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 83,
            "text": "num = a - ex_ee_block;"
          },
          {
            "line_no": 85,
            "text": "/* remove whole extent: excellent! */"
          },
          {
            "line_no": 91,
            "text": "* groups plus ex_ee_len/blocks_per_block_group for"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 95,
            "text": "if (ex == EXT_FIRST_EXTENT(eh)) {"
          },
          {
            "line_no": 96,
            "text": "correct_index = 1;"
          },
          {
            "line_no": 97,
            "text": "credits += (ext_depth(inode)) + 1;"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 101,
            "text": "* We may end up freeing some index blocks and data from the"
          },
          {
            "line_no": 103,
            "text": "* by ext4_free_data_revoke_credits()."
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 107,
            "text": "ext_depth(inode)) +"
          },
          {
            "line_no": 108,
            "text": "ext4_free_data_revoke_credits(inode, b - a + 1);"
          },
          {
            "line_no": 110,
            "text": "err = ext4_datasem_ensure_credits(handle, inode, credits,"
          },
          {
            "line_no": 118,
            "text": "err = ext4_ext_get_access(handle, inode, path + depth);"
          },
          {
            "line_no": 122,
            "text": "err = ext4_remove_blocks(handle, inode, ex, partial, a, b);"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 128,
            "text": "ext4_ext_store_pblock(ex, 0);"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          },
          {
            "line_no": 136,
            "text": "ext4_ext_mark_unwritten(ex);"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          },
          {
            "line_no": 148,
            "text": "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/*",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* Do not mark unwritten if all the blocks in the",
        "variables": [
          "Do"
        ],
        "indices": [],
        "constraint": "variable(s) Do may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 132,
            "text": "* Do not mark unwritten if all the blocks in the"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* extent have been removed.",
        "variables": [
          "extent"
        ],
        "indices": [],
        "constraint": "variable(s) extent may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 9,
            "text": "struct ext4_extent_header *eh;"
          },
          {
            "line_no": 15,
            "text": "struct ext4_extent *ex;"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 58,
            "text": "* We're going to skip this extent and move to another,"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 76,
            "text": "\"on extent %u:%u\","
          },
          {
            "line_no": 82,
            "text": "/* remove tail of the extent */"
          },
          {
            "line_no": 85,
            "text": "/* remove whole extent: excellent! */"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 127,
            "text": "/* this extent is removed; mark slot entirely unused */"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 133,
            "text": "* extent have been removed."
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "*/",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/*",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* If the extent was completely released,",
        "variables": [
          "If"
        ],
        "indices": [],
        "constraint": "variable(s) If may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 55,
            "text": "/* If this extent is beyond the end of the hole, skip it */"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 138,
            "text": "* If the extent was completely released,"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* we need to remove it from the leaf",
        "variables": [
          "we"
        ],
        "indices": [],
        "constraint": "variable(s) we may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 139,
            "text": "* we need to remove it from the leaf"
          },
          {
            "line_no": 144,
            "text": "* For hole punching, we need to scoot all the"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "*/",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "/*",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* For hole punching, we need to scoot all the",
        "variables": [
          "For"
        ],
        "indices": [],
        "constraint": "variable(s) For may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 144,
            "text": "* For hole punching, we need to scoot all the"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* extents up when an extent is removed so that",
        "variables": [
          "extents"
        ],
        "indices": [],
        "constraint": "variable(s) extents may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 145,
            "text": "* extents up when an extent is removed so that"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "* we dont have blank extents in the middle",
        "variables": [
          "we"
        ],
        "indices": [],
        "constraint": "variable(s) we may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          },
          {
            "line_no": 139,
            "text": "* we need to remove it from the leaf"
          },
          {
            "line_no": 144,
            "text": "* For hole punching, we need to scoot all the"
          },
          {
            "line_no": 146,
            "text": "* we dont have blank extents in the middle"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "*/",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      },
      {
        "file": "fs/ext4/extents.c",
        "line": 2730,
        "code": "memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *",
        "variables": [],
        "indices": [],
        "constraint": "A pointer or index dereference in the trigger function must be fed attacker-controlled data to reach the crash",
        "evidence": [
          {
            "line_no": 6,
            "text": "struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);"
          },
          {
            "line_no": 20,
            "text": "if (!path[depth].p_hdr)"
          },
          {
            "line_no": 21,
            "text": "path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);"
          },
          {
            "line_no": 22,
            "text": "eh = path[depth].p_hdr;"
          },
          {
            "line_no": 23,
            "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
          },
          {
            "line_no": 24,
            "text": "EXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);"
          },
          {
            "line_no": 28,
            "text": "ex = path[depth].p_ext;"
          },
          {
            "line_no": 32,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 45,
            "text": "ext_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,"
          },
          {
            "line_no": 47,
            "text": "path[depth].p_ext = ex;"
          },
          {
            "line_no": 64,
            "text": "if (sbi->s_cluster_ratio > 1) {"
          },
          {
            "line_no": 66,
            "text": "partial->pclu = EXT4_B2C(sbi, pblk);"
          },
          {
            "line_no": 67,
            "text": "partial->state = nofree;"
          },
          {
            "line_no": 70,
            "text": "ex_ee_block = le32_to_cpu(ex->ee_block);"
          },
          {
            "line_no": 94,
            "text": "credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));"
          },
          {
            "line_no": 99,
            "text": "credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);"
          },
          {
            "line_no": 106,
            "text": "ext4_free_metadata_revoke_credits(inode->i_sb,"
          },
          {
            "line_no": 130,
            "text": "ex->ee_len = cpu_to_le16(num);"
          }
        ]
      }
    ]
  },
  "strong_report": {
    "primitive": "out-of-bounds read",
    "vulnerability": "info-leak (bounded or unbounded read)",
    "confidence": 1.0,
    "preconditions": [
      "Triggering syzkaller syscall(s): error",
      "Triggering syscall(s) from crash text: ioctl, munmap",
      "An externally-controlled syscall input (fuzzer/syzkaller) reached the vulnerable syscall path",
      "Input state: attacker-controlled syscall parameters or user-supplied data must reach the vulnerable code path",
      "Code path: execution reaches function 'ext4_mb_clear_bb' (from crash context)",
      "State: variable(s) like handle, inode, path may point into freed/reclaimed memory (observed in nearby source lines)",
      "path constraint (input): !path[depth].p_hdr -- at fs/ext4/extents.c:2750",
      "path constraint (input): unlikely(path[depth].p_hdr == NULL) -- at fs/ext4/extents.c:2753",
      "path constraint (input): ex >= EXT_FIRST_EXTENT(eh -- at fs/ext4/extents.c:2767",
      "path constraint (input): end < ex_ee_block -- at fs/ext4/extents.c:2786",
      "path constraint (input): sbi->s_cluster_ratio > 1 -- at fs/ext4/extents.c:2794",
      "path constraint (kernel state): return -EFSCORRUPTED; -- at fs/ext4/extents.c:2755",
      "path constraint (kernel state): !ex -- at fs/ext4/extents.c:2759",
      "path constraint (kernel state): ext4_ext_is_unwritten(ex) -- at fs/ext4/extents.c:2770",
      "path constraint (kernel state): goto out; -- at fs/ext4/extents.c:2810",
      "path constraint (kernel state): a != ex_ee_block -- at fs/ext4/extents.c:2811",
      "path constraint (kernel state): ex == EXT_FIRST_EXTENT(eh) -- at fs/ext4/extents.c:2825",
      "path constraint (kernel state): err -- at fs/ext4/extents.c:2842",
      "path constraint (kernel state): goto out; -- at fs/ext4/extents.c:2845",
      "Precondition: attacker must trigger the vulnerable path that allows reading reclaimed or out-of-bounds memory"
    ],
    "postconditions": [
      "KASAN or BUG report emitted indicating invalid memory access",
      "Postcondition: attacker may read sensitive kernel memory (info-leak)"
    ],
    "support": [
      "KASAN reported slab-out-of-bounds (log contains 'slab-out-of-bounds')",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains alloc-like calls near crash site",
      "Source contains alloc-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Control-flow path constraints extracted from stack snippets (if/for/while/switch, returns)",
      "Syscall(s) detected in crash text: ioctl, munmap",
      "Syzkaller repro indicates syscalls: error"
    ],
    "path_constraints": {
      "input_constraints": [
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2750,
          "code": "if (!path[depth].p_hdr)",
          "condition": "!path[depth].p_hdr",
          "variables": [
            "path",
            "depth",
            "p_hdr"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (!path[depth].p_hdr)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2753,
          "code": "if (unlikely(path[depth].p_hdr == NULL)) {",
          "condition": "unlikely(path[depth].p_hdr == NULL)",
          "variables": [
            "unlikely",
            "path",
            "depth",
            "p_hdr",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if (unlikely(path[depth].p_hdr == NULL)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2767,
          "code": "while (ex >= EXT_FIRST_EXTENT(eh) &&",
          "condition": "ex >= EXT_FIRST_EXTENT(eh",
          "variables": [
            "ex",
            "EXT_FIRST_EXTENT",
            "eh"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "while (ex >= EXT_FIRST_EXTENT(eh) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2786,
          "code": "if (end < ex_ee_block) {",
          "condition": "end < ex_ee_block",
          "variables": [
            "end",
            "ex_ee_block"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "if (end < ex_ee_block) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2794,
          "code": "if (sbi->s_cluster_ratio > 1) {",
          "condition": "sbi->s_cluster_ratio > 1",
          "variables": [
            "sbi",
            "s_cluster_ratio"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (sbi->s_cluster_ratio > 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2803,
          "code": "} else if (b != ex_ee_block + ex_ee_len - 1) {",
          "condition": "b != ex_ee_block + ex_ee_len - 1",
          "variables": [
            "b",
            "ex_ee_block",
            "ex_ee_len"
          ],
          "evidence": [
            {
              "line_no": 73,
              "text": "} else if (b != ex_ee_block + ex_ee_len - 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2843,
          "code": "if (err > 0)",
          "condition": "err > 0",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 113,
              "text": "if (err > 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2986,
          "code": "if (end < EXT_MAX_BLOCKS - 1) {",
          "condition": "end < EXT_MAX_BLOCKS - 1",
          "variables": [
            "end",
            "EXT_MAX_BLOCKS"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if (end < EXT_MAX_BLOCKS - 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2994,
          "code": "if (IS_ERR(path)) {",
          "condition": "IS_ERR(path)",
          "variables": [
            "IS_ERR",
            "path"
          ],
          "evidence": [
            {
              "line_no": 42,
              "text": "if (IS_ERR(path)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2996,
          "code": "return PTR_ERR(path);",
          "condition": "return PTR_ERR(path);",
          "variables": [
            "return",
            "PTR_ERR",
            "path"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "return PTR_ERR(path);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3020,
          "code": "if (end >= ee_block && end < ex_end) {",
          "condition": "end >= ee_block && end < ex_end",
          "variables": [
            "end",
            "ee_block",
            "end",
            "ex_end"
          ],
          "evidence": [
            {
              "line_no": 68,
              "text": "if (end >= ee_block && end < ex_end) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3027,
          "code": "if (sbi->s_cluster_ratio > 1) {",
          "condition": "sbi->s_cluster_ratio > 1",
          "variables": [
            "sbi",
            "s_cluster_ratio"
          ],
          "evidence": [
            {
              "line_no": 75,
              "text": "if (sbi->s_cluster_ratio > 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3041,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 89,
              "text": "if (err < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3044,
          "code": "} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&",
          "condition": "} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&",
          "variables": [
            "else",
            "if",
            "sbi",
            "s_cluster_ratio",
            "end",
            "ex_end"
          ],
          "evidence": [
            {
              "line_no": 92,
              "text": "} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3059,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 107,
              "text": "if (err < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3072,
          "code": "if (path) {",
          "condition": "path",
          "variables": [
            "path"
          ],
          "evidence": [
            {
              "line_no": 120,
              "text": "if (path) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3074,
          "code": "while (--k > 0)",
          "condition": "--k > 0",
          "variables": [
            "k"
          ],
          "evidence": [
            {
              "line_no": 122,
              "text": "while (--k > 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3080,
          "code": "if (path == NULL) {",
          "condition": "path == NULL",
          "variables": [
            "path",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 128,
              "text": "if (path == NULL) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3088,
          "code": "if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {",
          "condition": "ext4_ext_check(inode, path[0].p_hdr, depth, 0)",
          "variables": [
            "ext4_ext_check",
            "inode",
            "path",
            "p_hdr",
            "depth"
          ],
          "evidence": [
            {
              "line_no": 136,
              "text": "if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3095,
          "code": "while (i >= 0 && err == 0) {",
          "condition": "i >= 0 && err == 0",
          "variables": [
            "i",
            "err"
          ],
          "evidence": [
            {
              "line_no": 143,
              "text": "while (i >= 0 && err == 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 445,
          "code": "if (current->kunit_test)",
          "condition": "current->kunit_test",
          "variables": [
            "current",
            "kunit_test"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "if (current->kunit_test)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/generic.c",
          "line": 190,
          "code": "return check_region_inline(addr, size, write, ret_ip);",
          "condition": "return check_region_inline(addr, size, write, ret_ip);",
          "variables": [
            "return",
            "check_region_inline",
            "addr",
            "size",
            "write",
            "ret_ip"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return check_region_inline(addr, size, write, ret_ip);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/shadow.c",
          "line": 57,
          "code": "if (!kasan_check_range((unsigned long)src, len, false, _RET_IP_) ||",
          "condition": "!kasan_check_range((unsigned long)src, len, false, _RET_IP_",
          "variables": [
            "kasan_check_range",
            "unsigned",
            "long",
            "src",
            "len",
            "false",
            "_RET_IP_"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "if (!kasan_check_range((unsigned long)src, len, false, _RET_IP_) ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4234,
          "code": "if (offset >= inode->i_size)",
          "condition": "offset >= inode->i_size",
          "variables": [
            "offset",
            "inode",
            "i_size"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "if (offset >= inode->i_size)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4241,
          "code": "if (offset + length > inode->i_size) {",
          "condition": "offset + length > inode->i_size",
          "variables": [
            "offset",
            "length",
            "inode",
            "i_size"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "if (offset + length > inode->i_size) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4252,
          "code": "if (offset + length > max_length)",
          "condition": "offset + length > max_length",
          "variables": [
            "offset",
            "length",
            "max_length"
          ],
          "evidence": [
            {
              "line_no": 47,
              "text": "if (offset + length > max_length)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4255,
          "code": "if (offset & (sb->s_blocksize - 1) ||",
          "condition": "offset & (sb->s_blocksize - 1",
          "variables": [
            "offset",
            "sb",
            "s_blocksize"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (offset & (sb->s_blocksize - 1) ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4262,
          "code": "if (ret < 0)",
          "condition": "ret < 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 57,
              "text": "if (ret < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4288,
          "code": "if (last_block_offset > first_block_offset) {",
          "condition": "last_block_offset > first_block_offset",
          "variables": [
            "last_block_offset",
            "first_block_offset"
          ],
          "evidence": [
            {
              "line_no": 83,
              "text": "if (last_block_offset > first_block_offset) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4317,
          "code": "if (stop_block > first_block) {",
          "condition": "stop_block > first_block",
          "variables": [
            "stop_block",
            "first_block"
          ],
          "evidence": [
            {
              "line_no": 112,
              "text": "if (stop_block > first_block) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4726,
          "code": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "condition": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "variables": [
            "if",
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 316,
          "code": "if (offset < 0 || len <= 0)",
          "condition": "offset < 0 || len <= 0",
          "variables": [
            "offset",
            "len"
          ],
          "evidence": [
            {
              "line_no": 6,
              "text": "if (offset < 0 || len <= 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 348,
          "code": "if (!(file->f_mode & FMODE_WRITE))",
          "condition": "!(file->f_mode & FMODE_WRITE)",
          "variables": [
            "file",
            "f_mode",
            "FMODE_WRITE"
          ],
          "evidence": [
            {
              "line_no": 38,
              "text": "if (!(file->f_mode & FMODE_WRITE))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 354,
          "code": "if ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))",
          "condition": "(mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode)",
          "variables": [
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "IS_APPEND",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "if ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 374,
          "code": "if (S_ISFIFO(inode->i_mode))",
          "condition": "S_ISFIFO(inode->i_mode)",
          "variables": [
            "S_ISFIFO",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (S_ISFIFO(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 377,
          "code": "if (S_ISDIR(inode->i_mode))",
          "condition": "S_ISDIR(inode->i_mode)",
          "variables": [
            "S_ISDIR",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "if (S_ISDIR(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 380,
          "code": "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode",
            "S_ISBLK",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 70,
              "text": "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 384,
          "code": "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))",
          "condition": "((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0)",
          "variables": [
            "offset",
            "len",
            "inode",
            "i_sb",
            "s_maxbytes",
            "offset",
            "len"
          ],
          "evidence": [
            {
              "line_no": 74,
              "text": "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 387,
          "code": "if (!file->f_op->fallocate)",
          "condition": "!file->f_op->fallocate",
          "variables": [
            "file",
            "f_op",
            "fallocate"
          ],
          "evidence": [
            {
              "line_no": 77,
              "text": "if (!file->f_op->fallocate)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 735,
          "code": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "condition": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "variables": [
            "return",
            "copy_to_user",
            "argp",
            "res",
            "sizeof",
            "res"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return copy_to_user(argp, &res, sizeof(res)) ?"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 742,
          "code": "return ioctl_fsfreeze(filp);",
          "condition": "return ioctl_fsfreeze(filp);",
          "variables": [
            "return",
            "ioctl_fsfreeze",
            "filp"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "return ioctl_fsfreeze(filp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 745,
          "code": "return ioctl_fsthaw(filp);",
          "condition": "return ioctl_fsthaw(filp);",
          "variables": [
            "return",
            "ioctl_fsthaw",
            "filp"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "return ioctl_fsthaw(filp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 748,
          "code": "return ioctl_fiemap(filp, argp);",
          "condition": "return ioctl_fiemap(filp, argp);",
          "variables": [
            "return",
            "ioctl_fiemap",
            "filp",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "return ioctl_fiemap(filp, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 752,
          "code": "if (!inode->i_sb->s_blocksize)",
          "condition": "!inode->i_sb->s_blocksize",
          "variables": [
            "inode",
            "i_sb",
            "s_blocksize"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (!inode->i_sb->s_blocksize)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 755,
          "code": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "condition": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "variables": [
            "return",
            "put_user",
            "inode",
            "i_sb",
            "s_blocksize",
            "int",
            "__user",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "condition": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "variables": [
            "return",
            "ioctl_file_clone",
            "filp",
            "arg"
          ],
          "evidence": [
            {
              "line_no": 26,
              "text": "return ioctl_file_clone(filp, arg, 0, 0, 0);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "return ioctl_file_clone_range(filp, argp);",
          "condition": "return ioctl_file_clone_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_clone_range",
            "filp",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "return ioctl_file_clone_range(filp, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 764,
          "code": "return ioctl_file_dedupe_range(filp, argp);",
          "condition": "return ioctl_file_dedupe_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_dedupe_range",
            "filp",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "return ioctl_file_dedupe_range(filp, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 767,
          "code": "if (!S_ISREG(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 35,
              "text": "if (!S_ISREG(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 768,
          "code": "return vfs_ioctl(filp, cmd, arg);",
          "condition": "return vfs_ioctl(filp, cmd, arg);",
          "variables": [
            "return",
            "vfs_ioctl",
            "filp",
            "cmd",
            "arg"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "return vfs_ioctl(filp, cmd, arg);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 770,
          "code": "return put_user(i_size_read(inode) - filp->f_pos,",
          "condition": "return put_user(i_size_read(inode) - filp->f_pos,",
          "variables": [
            "return",
            "put_user",
            "i_size_read",
            "inode",
            "filp",
            "f_pos"
          ],
          "evidence": [
            {
              "line_no": 38,
              "text": "return put_user(i_size_read(inode) - filp->f_pos,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 774,
          "code": "if (S_ISREG(inode->i_mode))",
          "condition": "S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 42,
              "text": "if (S_ISREG(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 775,
          "code": "return file_ioctl(filp, cmd, argp);",
          "condition": "return file_ioctl(filp, cmd, argp);",
          "variables": [
            "return",
            "file_ioctl",
            "filp",
            "cmd",
            "argp"
          ],
          "evidence": [
            {
              "line_no": 43,
              "text": "return file_ioctl(filp, cmd, argp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4298,
          "code": "if (ac->spread_dirty_pages) {",
          "condition": "ac->spread_dirty_pages",
          "variables": [
            "ac",
            "spread_dirty_pages"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "if (ac->spread_dirty_pages) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4299,
          "code": "if (last_pgdat_dirty_limit == zone->zone_pgdat)",
          "condition": "last_pgdat_dirty_limit == zone->zone_pgdat",
          "variables": [
            "last_pgdat_dirty_limit",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [
            {
              "line_no": 45,
              "text": "if (last_pgdat_dirty_limit == zone->zone_pgdat)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4302,
          "code": "if (!node_dirty_ok(zone->zone_pgdat)) {",
          "condition": "!node_dirty_ok(zone->zone_pgdat)",
          "variables": [
            "node_dirty_ok",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (!node_dirty_ok(zone->zone_pgdat)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4308,
          "code": "if (no_fallback && nr_online_nodes > 1 &&",
          "condition": "if (no_fallback && nr_online_nodes > 1 &&",
          "variables": [
            "if",
            "no_fallback",
            "nr_online_nodes"
          ],
          "evidence": [
            {
              "line_no": 54,
              "text": "if (no_fallback && nr_online_nodes > 1 &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1046,
          "code": "return grow_dev_page(bdev, block, index, size, sizebits, gfp);",
          "condition": "return grow_dev_page(bdev, block, index, size, sizebits, gfp);",
          "variables": [
            "return",
            "grow_dev_page",
            "bdev",
            "block",
            "index",
            "size",
            "sizebits",
            "gfp"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return grow_dev_page(bdev, block, index, size, sizebits, gfp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1077,
          "code": "if (unlikely(size & (bdev_logical_block_size(bdev)-1) ||",
          "condition": "unlikely(size & (bdev_logical_block_size(bdev)-1",
          "variables": [
            "unlikely",
            "size",
            "bdev_logical_block_size",
            "bdev"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "if (unlikely(size & (bdev_logical_block_size(bdev)-1) ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/buffer_head.h",
          "line": 369,
          "code": "return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);",
          "condition": "return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);",
          "variables": [
            "return",
            "__getblk_gfp",
            "sb",
            "s_bdev",
            "block",
            "sb",
            "s_blocksize",
            "gfp"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return __getblk_gfp(sb->s_bdev, block, sb->s_blocksize, gfp);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1339,
          "code": "if (goal > le32_to_cpu(es->s_first_data_block)) {",
          "condition": "goal > le32_to_cpu(es->s_first_data_block)",
          "variables": [
            "goal",
            "le32_to_cpu",
            "es",
            "s_first_data_block"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "if (goal > le32_to_cpu(es->s_first_data_block)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1440,
          "code": "while (i > 0 && !EXT_HAS_FREE_INDEX(curp)) {",
          "condition": "i > 0 && !EXT_HAS_FREE_INDEX(curp)",
          "variables": [
            "i",
            "EXT_HAS_FREE_INDEX",
            "curp"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "while (i > 0 && !EXT_HAS_FREE_INDEX(curp)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1458,
          "code": "if (IS_ERR(path))",
          "condition": "IS_ERR(path)",
          "variables": [
            "IS_ERR",
            "path"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if (IS_ERR(path))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2098,
          "code": "} else if ((ex > EXT_FIRST_EXTENT(eh)) &&",
          "condition": "(ex > EXT_FIRST_EXTENT(eh)",
          "variables": [
            "ex",
            "EXT_FIRST_EXTENT",
            "eh"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "} else if ((ex > EXT_FIRST_EXTENT(eh)) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2160,
          "code": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))",
          "condition": "le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)",
          "variables": [
            "le16_to_cpu",
            "eh",
            "eh_entries",
            "le16_to_cpu",
            "eh",
            "eh_max"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2166,
          "code": "if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))",
          "condition": "le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block)",
          "variables": [
            "le32_to_cpu",
            "newext",
            "ee_block",
            "le32_to_cpu",
            "fex",
            "ee_block"
          ],
          "evidence": [
            {
              "line_no": 72,
              "text": "if (le32_to_cpu(newext->ee_block) > le32_to_cpu(fex->ee_block))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2172,
          "code": "if (IS_ERR(npath))",
          "condition": "IS_ERR(npath)",
          "variables": [
            "IS_ERR",
            "npath"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "if (IS_ERR(npath))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2173,
          "code": "return PTR_ERR(npath);",
          "condition": "return PTR_ERR(npath);",
          "variables": [
            "return",
            "PTR_ERR",
            "npath"
          ],
          "evidence": [
            {
              "line_no": 79,
              "text": "return PTR_ERR(npath);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2176,
          "code": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {",
          "condition": "le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)",
          "variables": [
            "le16_to_cpu",
            "eh",
            "eh_entries",
            "le16_to_cpu",
            "eh",
            "eh_max"
          ],
          "evidence": [
            {
              "line_no": 82,
              "text": "if (le16_to_cpu(eh->eh_entries) < le16_to_cpu(eh->eh_max)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4315,
          "code": "if (map->m_len > EXT_INIT_MAX_LEN &&",
          "condition": "if (map->m_len > EXT_INIT_MAX_LEN &&",
          "variables": [
            "if",
            "map",
            "m_len",
            "EXT_INIT_MAX_LEN"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "if (map->m_len > EXT_INIT_MAX_LEN &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4318,
          "code": "else if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&",
          "condition": "else if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&",
          "variables": [
            "else",
            "if",
            "map",
            "m_len",
            "EXT_UNWRITTEN_MAX_LEN"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "else if (map->m_len > EXT_UNWRITTEN_MAX_LEN &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4346,
          "code": "if (S_ISREG(inode->i_mode))",
          "condition": "S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "if (S_ISREG(inode->i_mode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4364,
          "code": "if (ar.len > allocated)",
          "condition": "ar.len > allocated",
          "variables": [
            "ar",
            "len",
            "allocated"
          ],
          "evidence": [
            {
              "line_no": 62,
              "text": "if (ar.len > allocated)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 654,
          "code": "if (retval > map->m_len)",
          "condition": "retval > map->m_len",
          "variables": [
            "retval",
            "map",
            "m_len"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "if (retval > map->m_len)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 660,
          "code": "if (retval > map->m_len)",
          "condition": "retval > map->m_len",
          "variables": [
            "retval",
            "map",
            "m_len"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "if (retval > map->m_len)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 684,
          "code": "if (retval > 0) {",
          "condition": "retval > 0",
          "variables": [
            "retval"
          ],
          "evidence": [
            {
              "line_no": 38,
              "text": "if (retval > 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 687,
          "code": "if (unlikely(retval != map->m_len)) {",
          "condition": "unlikely(retval != map->m_len)",
          "variables": [
            "unlikely",
            "retval",
            "map",
            "m_len"
          ],
          "evidence": [
            {
              "line_no": 41,
              "text": "if (unlikely(retval != map->m_len)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 704,
          "code": "if (ret < 0)",
          "condition": "ret < 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 58,
              "text": "if (ret < 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 710,
          "code": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {",
          "condition": "retval > 0 && map->m_flags & EXT4_MAP_MAPPED",
          "variables": [
            "retval",
            "map",
            "m_flags",
            "EXT4_MAP_MAPPED"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 727,
          "code": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)",
          "condition": "retval > 0 && map->m_flags & EXT4_MAP_MAPPED",
          "variables": [
            "retval",
            "map",
            "m_flags",
            "EXT4_MAP_MAPPED"
          ],
          "evidence": [
            {
              "line_no": 81,
              "text": "if (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1098,
          "code": "if (!page_has_buffers(page))",
          "condition": "!page_has_buffers(page)",
          "variables": [
            "page_has_buffers",
            "page"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (!page_has_buffers(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1107,
          "code": "if (block_end <= from || block_start >= to) {",
          "condition": "block_end <= from || block_start >= to",
          "variables": [
            "block_end",
            "from",
            "block_start",
            "to"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "if (block_end <= from || block_start >= to) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1109,
          "code": "if (!buffer_uptodate(bh))",
          "condition": "!buffer_uptodate(bh)",
          "variables": [
            "buffer_uptodate",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "if (!buffer_uptodate(bh))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1114,
          "code": "if (buffer_new(bh))",
          "condition": "buffer_new(bh)",
          "variables": [
            "buffer_new",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "if (buffer_new(bh))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1116,
          "code": "if (!buffer_mapped(bh)) {",
          "condition": "!buffer_mapped(bh)",
          "variables": [
            "buffer_mapped",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (!buffer_mapped(bh)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 278,
          "code": "if (iocb->ki_flags & IOCB_NOWAIT)",
          "condition": "iocb->ki_flags & IOCB_NOWAIT",
          "variables": [
            "iocb",
            "ki_flags",
            "IOCB_NOWAIT"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (iocb->ki_flags & IOCB_NOWAIT)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 283,
          "code": "if (ret <= 0)",
          "condition": "ret <= 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (ret <= 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 686,
          "code": "return ext4_buffered_write_iter(iocb, from);",
          "condition": "return ext4_buffered_write_iter(iocb, from);",
          "variables": [
            "return",
            "ext4_buffered_write_iter",
            "iocb",
            "from"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return ext4_buffered_write_iter(iocb, from);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1385,
          "code": "for (i = 1; i < (1 << order); i++) {",
          "condition": "i = 1; i < (1 << order); i++",
          "variables": [
            "i",
            "i",
            "order",
            "i"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "for (i = 1; i < (1 << order); i++) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1113,
          "code": "for (i = 0; i < nr; i++) {",
          "condition": "i = 0; i < nr; i++",
          "variables": [
            "i",
            "i",
            "nr",
            "i"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "for (i = 0; i < nr; i++) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmu_gather.c",
          "line": 54,
          "code": "for (batch = &tlb->local; batch && batch->nr; batch = batch->next) {",
          "condition": "batch = &tlb->local; batch && batch->nr; batch = batch->next",
          "variables": [
            "batch",
            "tlb",
            "local",
            "batch",
            "batch",
            "nr",
            "batch",
            "batch",
            "next"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "for (batch = &tlb->local; batch && batch->nr; batch = batch->next) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmu_gather.c",
          "line": 342,
          "code": "if (mm_tlb_flush_nested(tlb->mm)) {",
          "condition": "mm_tlb_flush_nested(tlb->mm)",
          "variables": [
            "mm_tlb_flush_nested",
            "tlb",
            "mm"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "if (mm_tlb_flush_nested(tlb->mm)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 2829,
          "code": "for (cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next) {",
          "condition": "cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next",
          "variables": [
            "cur_vma",
            "vma",
            "cur_vma",
            "cur_vma",
            "cur_vma",
            "vm_next"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "for (cur_vma = vma; cur_vma; cur_vma = cur_vma->vm_next) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 2830,
          "code": "if ((cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0) {",
          "condition": "(cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0",
          "variables": [
            "cur_vma",
            "vm_flags",
            "VM_PFNMAP",
            "VM_MIXEDMAP"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if ((cur_vma->vm_flags & (VM_PFNMAP|VM_MIXEDMAP)) != 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3043,
          "code": "if ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)",
          "condition": "(offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start",
          "variables": [
            "offset_in_page",
            "start",
            "start",
            "TASK_SIZE",
            "len",
            "TASK_SIZE",
            "start"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if ((offset_in_page(start)) || start > TASK_SIZE || len > TASK_SIZE-start)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3048,
          "code": "if (len == 0)",
          "condition": "len == 0",
          "variables": [
            "len"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (len == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3066,
          "code": "if (vma->vm_start >= end)",
          "condition": "vma->vm_start >= end",
          "variables": [
            "vma",
            "vm_start",
            "end"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "if (vma->vm_start >= end)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3076,
          "code": "if (start > vma->vm_start) {",
          "condition": "start > vma->vm_start",
          "variables": [
            "start",
            "vma",
            "vm_start"
          ],
          "evidence": [
            {
              "line_no": 40,
              "text": "if (start > vma->vm_start) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3080,
          "code": "* Make sure that map_count on return from munmap() will",
          "condition": "* Make sure that map_count on return from munmap() will",
          "variables": [
            "Make",
            "sure",
            "that",
            "map_count",
            "on",
            "return",
            "from",
            "munmap",
            "will"
          ],
          "evidence": [
            {
              "line_no": 44,
              "text": "* Make sure that map_count on return from munmap() will"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3084,
          "code": "if (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)",
          "condition": "end < vma->vm_end && mm->map_count >= sysctl_max_map_count",
          "variables": [
            "end",
            "vma",
            "vm_end",
            "mm",
            "map_count",
            "sysctl_max_map_count"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (end < vma->vm_end && mm->map_count >= sysctl_max_map_count)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3095,
          "code": "if (last && end > last->vm_start) {",
          "condition": "last && end > last->vm_start",
          "variables": [
            "last",
            "end",
            "last",
            "vm_start"
          ],
          "evidence": [
            {
              "line_no": 59,
              "text": "if (last && end > last->vm_start) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3120,
          "code": "if (mm->locked_vm) {",
          "condition": "mm->locked_vm",
          "variables": [
            "mm",
            "locked_vm"
          ],
          "evidence": [
            {
              "line_no": 84,
              "text": "if (mm->locked_vm) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3122,
          "code": "while (tmp && tmp->vm_start < end) {",
          "condition": "tmp && tmp->vm_start < end",
          "variables": [
            "tmp",
            "tmp",
            "vm_start",
            "end"
          ],
          "evidence": [
            {
              "line_no": 86,
              "text": "while (tmp && tmp->vm_start < end) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3123,
          "code": "if (tmp->vm_flags & VM_LOCKED) {",
          "condition": "tmp->vm_flags & VM_LOCKED",
          "variables": [
            "tmp",
            "vm_flags",
            "VM_LOCKED"
          ],
          "evidence": [
            {
              "line_no": 87,
              "text": "if (tmp->vm_flags & VM_LOCKED) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3090,
          "code": "return __vm_munmap(addr, len, true);",
          "condition": "return __vm_munmap(addr, len, true);",
          "variables": [
            "return",
            "__vm_munmap",
            "addr",
            "len",
            "true"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "return __vm_munmap(addr, len, true);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        }
      ],
      "kernel_state_constraints": [
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2755,
          "code": "return -EFSCORRUPTED;",
          "condition": "return -EFSCORRUPTED;",
          "variables": [
            "return",
            "EFSCORRUPTED"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "return -EFSCORRUPTED;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2759,
          "code": "if (!ex)",
          "condition": "!ex",
          "variables": [
            "ex"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "if (!ex)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2770,
          "code": "if (ext4_ext_is_unwritten(ex))",
          "condition": "ext4_ext_is_unwritten(ex)",
          "variables": [
            "ext4_ext_is_unwritten",
            "ex"
          ],
          "evidence": [
            {
              "line_no": 40,
              "text": "if (ext4_ext_is_unwritten(ex))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2810,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 80,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2811,
          "code": "} else if (a != ex_ee_block) {",
          "condition": "a != ex_ee_block",
          "variables": [
            "a",
            "ex_ee_block"
          ],
          "evidence": [
            {
              "line_no": 81,
              "text": "} else if (a != ex_ee_block) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2825,
          "code": "if (ex == EXT_FIRST_EXTENT(eh)) {",
          "condition": "ex == EXT_FIRST_EXTENT(eh)",
          "variables": [
            "ex",
            "EXT_FIRST_EXTENT",
            "eh"
          ],
          "evidence": [
            {
              "line_no": 95,
              "text": "if (ex == EXT_FIRST_EXTENT(eh)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2842,
          "code": "if (err) {",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 112,
              "text": "if (err) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2845,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 115,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2849,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 119,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2850,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 120,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2853,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 123,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2854,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 124,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2856,
          "code": "if (num == 0)",
          "condition": "num == 0",
          "variables": [
            "num"
          ],
          "evidence": [
            {
              "line_no": 126,
              "text": "if (num == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2865,
          "code": "if (unwritten && num)",
          "condition": "unwritten && num",
          "variables": [
            "unwritten",
            "num"
          ],
          "evidence": [
            {
              "line_no": 135,
              "text": "if (unwritten && num)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2871,
          "code": "if (num == 0) {",
          "condition": "num == 0",
          "variables": [
            "num"
          ],
          "evidence": [
            {
              "line_no": 141,
              "text": "if (num == 0) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2872,
          "code": "if (end != EXT_MAX_BLOCKS - 1) {",
          "condition": "end != EXT_MAX_BLOCKS - 1",
          "variables": [
            "end",
            "EXT_MAX_BLOCKS"
          ],
          "evidence": [
            {
              "line_no": 142,
              "text": "if (end != EXT_MAX_BLOCKS - 1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2973,
          "code": "if (IS_ERR(handle))",
          "condition": "IS_ERR(handle)",
          "variables": [
            "IS_ERR",
            "handle"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (IS_ERR(handle))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2974,
          "code": "return PTR_ERR(handle);",
          "condition": "return PTR_ERR(handle);",
          "variables": [
            "return",
            "PTR_ERR",
            "handle"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "return PTR_ERR(handle);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3001,
          "code": "if (!ex) {",
          "condition": "!ex",
          "variables": [
            "ex"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "if (!ex) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3002,
          "code": "if (depth) {",
          "condition": "depth",
          "variables": [
            "depth"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (depth) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3008,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3042,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 90,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3060,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 108,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3061,
          "code": "if (pblk) {",
          "condition": "pblk",
          "variables": [
            "pblk"
          ],
          "evidence": [
            {
              "line_no": 109,
              "text": "if (pblk) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3082,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [
            {
              "line_no": 130,
              "text": "return -ENOMEM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3090,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 138,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 3096,
          "code": "if (i == depth) {",
          "condition": "i == depth",
          "variables": [
            "i",
            "depth"
          ],
          "evidence": [
            {
              "line_no": 144,
              "text": "if (i == depth) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 134,
          "code": "if (old == -1) {",
          "condition": "old == -1",
          "variables": [
            "old"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "if (old == -1) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 136,
          "code": "} else if (old == cpu) {",
          "condition": "old == cpu",
          "variables": [
            "old",
            "cpu"
          ],
          "evidence": [
            {
              "line_no": 18,
              "text": "} else if (old == cpu) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 145,
          "code": "do { cpu_relax(); } while (atomic_read(&dump_lock) != -1);",
          "condition": "atomic_read(&dump_lock) != -1",
          "variables": [
            "atomic_read",
            "dump_lock"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "do { cpu_relax(); } while (atomic_read(&dump_lock) != -1);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 146,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "goto retry;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 455,
          "code": "if (addr_has_metadata(untagged_addr))",
          "condition": "addr_has_metadata(untagged_addr)",
          "variables": [
            "addr_has_metadata",
            "untagged_addr"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (addr_has_metadata(untagged_addr))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 467,
          "code": "if (addr_has_metadata(untagged_addr))",
          "condition": "addr_has_metadata(untagged_addr)",
          "variables": [
            "addr_has_metadata",
            "untagged_addr"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "if (addr_has_metadata(untagged_addr))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 471,
          "code": "if (addr_has_metadata(untagged_addr)) {",
          "condition": "addr_has_metadata(untagged_addr)",
          "variables": [
            "addr_has_metadata",
            "untagged_addr"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "if (addr_has_metadata(untagged_addr)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/kasan/report.c",
          "line": 459,
          "code": "if (likely(report_enabled())) {",
          "condition": "likely(report_enabled())",
          "variables": [
            "likely",
            "report_enabled"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (likely(report_enabled())) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4224,
          "code": "if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {",
          "condition": "mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)",
          "variables": [
            "mapping_tagged",
            "mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "evidence": [
            {
              "line_no": 19,
              "text": "if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4227,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4228,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "return ret;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4235,
          "code": "goto out_mutex;",
          "condition": "goto out_mutex;",
          "variables": [
            "goto",
            "out_mutex"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "goto out_mutex;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4263,
          "code": "goto out_mutex;",
          "condition": "goto out_mutex;",
          "variables": [
            "goto",
            "out_mutex"
          ],
          "evidence": [
            {
              "line_no": 58,
              "text": "goto out_mutex;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4271,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4272,
          "code": "goto out_mutex;",
          "condition": "goto out_mutex;",
          "variables": [
            "goto",
            "out_mutex"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "goto out_mutex;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4281,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 76,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4282,
          "code": "goto out_dio;",
          "condition": "goto out_dio;",
          "variables": [
            "goto",
            "out_dio"
          ],
          "evidence": [
            {
              "line_no": 77,
              "text": "goto out_dio;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4290,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 85,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4291,
          "code": "goto out_dio;",
          "condition": "goto out_dio;",
          "variables": [
            "goto",
            "out_dio"
          ],
          "evidence": [
            {
              "line_no": 86,
              "text": "goto out_dio;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4296,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 91,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4301,
          "code": "if (IS_ERR(handle)) {",
          "condition": "IS_ERR(handle)",
          "variables": [
            "IS_ERR",
            "handle"
          ],
          "evidence": [
            {
              "line_no": 96,
              "text": "if (IS_ERR(handle)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4304,
          "code": "goto out_dio;",
          "condition": "goto out_dio;",
          "variables": [
            "goto",
            "out_dio"
          ],
          "evidence": [
            {
              "line_no": 99,
              "text": "goto out_dio;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4309,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 104,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4310,
          "code": "goto out_stop;",
          "condition": "goto out_stop;",
          "variables": [
            "goto",
            "out_stop"
          ],
          "evidence": [
            {
              "line_no": 105,
              "text": "goto out_stop;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4324,
          "code": "if (ret) {",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 119,
              "text": "if (ret) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4326,
          "code": "goto out_stop;",
          "condition": "goto out_stop;",
          "variables": [
            "goto",
            "out_stop"
          ],
          "evidence": [
            {
              "line_no": 121,
              "text": "goto out_stop;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 4329,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 124,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4721,
          "code": "if (IS_ENCRYPTED(inode) &&",
          "condition": "IS_ENCRYPTED(inode",
          "variables": [
            "IS_ENCRYPTED",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 17,
              "text": "if (IS_ENCRYPTED(inode) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4723,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 19,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4729,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4734,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4735,
          "code": "goto exit;",
          "condition": "goto exit;",
          "variables": [
            "goto",
            "exit"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "goto exit;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4737,
          "code": "if (mode & FALLOC_FL_PUNCH_HOLE) {",
          "condition": "mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [
            {
              "line_no": 33,
              "text": "if (mode & FALLOC_FL_PUNCH_HOLE) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 317,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 320,
          "code": "if (mode & ~FALLOC_FL_SUPPORTED_MASK)",
          "condition": "mode & ~FALLOC_FL_SUPPORTED_MASK",
          "variables": [
            "mode",
            "FALLOC_FL_SUPPORTED_MASK"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "if (mode & ~FALLOC_FL_SUPPORTED_MASK)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 321,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 324,
          "code": "if ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==",
          "condition": "(mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE",
            "FALLOC_FL_ZERO_RANGE"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "if ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) =="
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 326,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 329,
          "code": "if ((mode & FALLOC_FL_PUNCH_HOLE) &&",
          "condition": "(mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [
            {
              "line_no": 19,
              "text": "if ((mode & FALLOC_FL_PUNCH_HOLE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 331,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 334,
          "code": "if ((mode & FALLOC_FL_COLLAPSE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_COLLAPSE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_COLLAPSE_RANGE"
          ],
          "evidence": [
            {
              "line_no": 24,
              "text": "if ((mode & FALLOC_FL_COLLAPSE_RANGE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 336,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 26,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 339,
          "code": "if ((mode & FALLOC_FL_INSERT_RANGE) &&",
          "condition": "(mode & FALLOC_FL_INSERT_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_INSERT_RANGE"
          ],
          "evidence": [
            {
              "line_no": 29,
              "text": "if ((mode & FALLOC_FL_INSERT_RANGE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 341,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 344,
          "code": "if ((mode & FALLOC_FL_UNSHARE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_UNSHARE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_UNSHARE_RANGE"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if ((mode & FALLOC_FL_UNSHARE_RANGE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 346,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 349,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "return -EBADF;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 355,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [
            {
              "line_no": 45,
              "text": "return -EPERM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 357,
          "code": "if (IS_IMMUTABLE(inode))",
          "condition": "IS_IMMUTABLE(inode)",
          "variables": [
            "IS_IMMUTABLE",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 47,
              "text": "if (IS_IMMUTABLE(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 358,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "return -EPERM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 363,
          "code": "if (IS_SWAPFILE(inode))",
          "condition": "IS_SWAPFILE(inode)",
          "variables": [
            "IS_SWAPFILE",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "if (IS_SWAPFILE(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 364,
          "code": "return -ETXTBSY;",
          "condition": "return -ETXTBSY;",
          "variables": [
            "return",
            "ETXTBSY"
          ],
          "evidence": [
            {
              "line_no": 54,
              "text": "return -ETXTBSY;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 371,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 61,
              "text": "if (ret)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 372,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [
            {
              "line_no": 62,
              "text": "return ret;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 375,
          "code": "return -ESPIPE;",
          "condition": "return -ESPIPE;",
          "variables": [
            "return",
            "ESPIPE"
          ],
          "evidence": [
            {
              "line_no": 65,
              "text": "return -ESPIPE;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 378,
          "code": "return -EISDIR;",
          "condition": "return -EISDIR;",
          "variables": [
            "return",
            "EISDIR"
          ],
          "evidence": [
            {
              "line_no": 68,
              "text": "return -EISDIR;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 381,
          "code": "return -ENODEV;",
          "condition": "return -ENODEV;",
          "variables": [
            "return",
            "ENODEV"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "return -ENODEV;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 385,
          "code": "return -EFBIG;",
          "condition": "return -EFBIG;",
          "variables": [
            "return",
            "EFBIG"
          ],
          "evidence": [
            {
              "line_no": 75,
              "text": "return -EFBIG;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 388,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 739,
          "code": "return -ENOTTY;",
          "condition": "return -ENOTTY;",
          "variables": [
            "return",
            "ENOTTY"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return -ENOTTY;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 753,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 757,
          "code": "if (!f.file)",
          "condition": "!f.file",
          "variables": [
            "f",
            "file"
          ],
          "evidence": [
            {
              "line_no": 6,
              "text": "if (!f.file)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return -EBADF;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 10,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 762,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4275,
          "code": "if (cpusets_enabled() &&",
          "condition": "cpusets_enabled(",
          "variables": [
            "cpusets_enabled"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (cpusets_enabled() &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4318,
          "code": "if (zone_to_nid(zone) != local_nid) {",
          "condition": "zone_to_nid(zone) != local_nid",
          "variables": [
            "zone_to_nid",
            "zone",
            "local_nid"
          ],
          "evidence": [
            {
              "line_no": 64,
              "text": "if (zone_to_nid(zone) != local_nid) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4320,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "goto retry;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4325,
          "code": "if (!zone_watermark_fast(zone, order, mark,",
          "condition": "if (!zone_watermark_fast(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_fast",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "if (!zone_watermark_fast(zone, order, mark,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4335,
          "code": "if (static_branch_unlikely(&deferred_pages)) {",
          "condition": "static_branch_unlikely(&deferred_pages)",
          "variables": [
            "static_branch_unlikely",
            "deferred_pages"
          ],
          "evidence": [
            {
              "line_no": 81,
              "text": "if (static_branch_unlikely(&deferred_pages)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4336,
          "code": "if (_deferred_grow_zone(zone, order))",
          "condition": "_deferred_grow_zone(zone, order)",
          "variables": [
            "_deferred_grow_zone",
            "zone",
            "order"
          ],
          "evidence": [
            {
              "line_no": 82,
              "text": "if (_deferred_grow_zone(zone, order))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4337,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [
            {
              "line_no": 83,
              "text": "goto try_this_zone;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4342,
          "code": "if (alloc_flags & ALLOC_NO_WATERMARKS)",
          "condition": "alloc_flags & ALLOC_NO_WATERMARKS",
          "variables": [
            "alloc_flags",
            "ALLOC_NO_WATERMARKS"
          ],
          "evidence": [
            {
              "line_no": 88,
              "text": "if (alloc_flags & ALLOC_NO_WATERMARKS)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4343,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [
            {
              "line_no": 89,
              "text": "goto try_this_zone;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4345,
          "code": "if (node_reclaim_mode == 0 ||",
          "condition": "if (node_reclaim_mode == 0 ||",
          "variables": [
            "if",
            "node_reclaim_mode"
          ],
          "evidence": [
            {
              "line_no": 91,
              "text": "if (node_reclaim_mode == 0 ||"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4350,
          "code": "switch (ret) {",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 96,
              "text": "switch (ret) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4359,
          "code": "if (zone_watermark_ok(zone, order, mark,",
          "condition": "if (zone_watermark_ok(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_ok",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [
            {
              "line_no": 105,
              "text": "if (zone_watermark_ok(zone, order, mark,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4361,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [
            {
              "line_no": 107,
              "text": "goto try_this_zone;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4370,
          "code": "if (page) {",
          "condition": "page",
          "variables": [
            "page"
          ],
          "evidence": [
            {
              "line_no": 116,
              "text": "if (page) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5359,
          "code": "if (unlikely(order >= MAX_ORDER)) {",
          "condition": "unlikely(order >= MAX_ORDER)",
          "variables": [
            "unlikely",
            "order",
            "MAX_ORDER"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "if (unlikely(order >= MAX_ORDER)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5361,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 15,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5366,
          "code": "if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))",
          "condition": "!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags)",
          "variables": [
            "prepare_alloc_pages",
            "gfp_mask",
            "order",
            "preferred_nid",
            "nodemask",
            "ac",
            "alloc_mask",
            "alloc_flags"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5367,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 547,
          "code": "return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);",
          "condition": "return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);",
          "variables": [
            "return",
            "__alloc_pages_nodemask",
            "gfp_mask",
            "order",
            "preferred_nid",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return __alloc_pages_nodemask(gfp_mask, order, preferred_nid, NULL);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 563,
          "code": "return __alloc_pages(gfp_mask, order, nid);",
          "condition": "return __alloc_pages(gfp_mask, order, nid);",
          "variables": [
            "return",
            "__alloc_pages",
            "gfp_mask",
            "order",
            "nid"
          ],
          "evidence": [
            {
              "line_no": 6,
              "text": "return __alloc_pages(gfp_mask, order, nid);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 575,
          "code": "if (nid == NUMA_NO_NODE)",
          "condition": "nid == NUMA_NO_NODE",
          "variables": [
            "nid",
            "NUMA_NO_NODE"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "if (nid == NUMA_NO_NODE)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 578,
          "code": "return __alloc_pages_node(nid, gfp_mask, order);",
          "condition": "return __alloc_pages_node(nid, gfp_mask, order);",
          "variables": [
            "return",
            "__alloc_pages_node",
            "nid",
            "gfp_mask",
            "order"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "return __alloc_pages_node(nid, gfp_mask, order);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/gfp.h",
          "line": 593,
          "code": "return alloc_pages_node(numa_node_id(), gfp_mask, order);",
          "condition": "return alloc_pages_node(numa_node_id(), gfp_mask, order);",
          "variables": [
            "return",
            "alloc_pages_node",
            "numa_node_id",
            "gfp_mask",
            "order"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return alloc_pages_node(numa_node_id(), gfp_mask, order);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/pagemap.h",
          "line": 291,
          "code": "return alloc_pages(gfp, 0);",
          "condition": "return alloc_pages(gfp, 0);",
          "variables": [
            "return",
            "alloc_pages",
            "gfp"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return alloc_pages(gfp, 0);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1856,
          "code": "if (xa_is_value(page))",
          "condition": "xa_is_value(page)",
          "variables": [
            "xa_is_value",
            "page"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "if (xa_is_value(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1861,
          "code": "if (!page)",
          "condition": "!page",
          "variables": [
            "page"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "if (!page)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1862,
          "code": "goto no_page;",
          "condition": "goto no_page;",
          "variables": [
            "goto",
            "no_page"
          ],
          "evidence": [
            {
              "line_no": 14,
              "text": "goto no_page;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1864,
          "code": "if (fgp_flags & FGP_LOCK) {",
          "condition": "fgp_flags & FGP_LOCK",
          "variables": [
            "fgp_flags",
            "FGP_LOCK"
          ],
          "evidence": [
            {
              "line_no": 16,
              "text": "if (fgp_flags & FGP_LOCK) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1865,
          "code": "if (fgp_flags & FGP_NOWAIT) {",
          "condition": "fgp_flags & FGP_NOWAIT",
          "variables": [
            "fgp_flags",
            "FGP_NOWAIT"
          ],
          "evidence": [
            {
              "line_no": 17,
              "text": "if (fgp_flags & FGP_NOWAIT) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1866,
          "code": "if (!trylock_page(page)) {",
          "condition": "!trylock_page(page)",
          "variables": [
            "trylock_page",
            "page"
          ],
          "evidence": [
            {
              "line_no": 18,
              "text": "if (!trylock_page(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1868,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 20,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1875,
          "code": "if (unlikely(page->mapping != mapping)) {",
          "condition": "unlikely(page->mapping != mapping)",
          "variables": [
            "unlikely",
            "page",
            "mapping",
            "mapping"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (unlikely(page->mapping != mapping)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1878,
          "code": "goto repeat;",
          "condition": "goto repeat;",
          "variables": [
            "goto",
            "repeat"
          ],
          "evidence": [
            {
              "line_no": 30,
              "text": "goto repeat;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1883,
          "code": "if (fgp_flags & FGP_ACCESSED)",
          "condition": "fgp_flags & FGP_ACCESSED",
          "variables": [
            "fgp_flags",
            "FGP_ACCESSED"
          ],
          "evidence": [
            {
              "line_no": 35,
              "text": "if (fgp_flags & FGP_ACCESSED)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1885,
          "code": "else if (fgp_flags & FGP_WRITE) {",
          "condition": "fgp_flags & FGP_WRITE",
          "variables": [
            "fgp_flags",
            "FGP_WRITE"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "else if (fgp_flags & FGP_WRITE) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1887,
          "code": "if (page_is_idle(page))",
          "condition": "page_is_idle(page)",
          "variables": [
            "page_is_idle",
            "page"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (page_is_idle(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1890,
          "code": "if (!(fgp_flags & FGP_HEAD))",
          "condition": "!(fgp_flags & FGP_HEAD)",
          "variables": [
            "fgp_flags",
            "FGP_HEAD"
          ],
          "evidence": [
            {
              "line_no": 42,
              "text": "if (!(fgp_flags & FGP_HEAD))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1894,
          "code": "if (!page && (fgp_flags & FGP_CREAT)) {",
          "condition": "!page && (fgp_flags & FGP_CREAT)",
          "variables": [
            "page",
            "fgp_flags",
            "FGP_CREAT"
          ],
          "evidence": [
            {
              "line_no": 46,
              "text": "if (!page && (fgp_flags & FGP_CREAT)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1896,
          "code": "if ((fgp_flags & FGP_WRITE) && mapping_can_writeback(mapping))",
          "condition": "(fgp_flags & FGP_WRITE) && mapping_can_writeback(mapping)",
          "variables": [
            "fgp_flags",
            "FGP_WRITE",
            "mapping_can_writeback",
            "mapping"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if ((fgp_flags & FGP_WRITE) && mapping_can_writeback(mapping))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 1898,
          "code": "if (fgp_flags & FGP_NOFS)",
          "condition": "fgp_flags & FGP_NOFS",
          "variables": [
            "fgp_flags",
            "FGP_NOFS"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (fgp_flags & FGP_NOFS)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "include/linux/pagemap.h",
          "line": 406,
          "code": "return pagecache_get_page(mapping, index,",
          "condition": "return pagecache_get_page(mapping, index,",
          "variables": [
            "return",
            "pagecache_get_page",
            "mapping",
            "index"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "return pagecache_get_page(mapping, index,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1085,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "return NULL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1088,
          "code": "for (;;) {",
          "condition": ";;",
          "variables": [],
          "evidence": [
            {
              "line_no": 16,
              "text": "for (;;) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1093,
          "code": "if (bh)",
          "condition": "bh",
          "variables": [
            "bh"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (bh)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1094,
          "code": "return bh;",
          "condition": "return bh;",
          "variables": [
            "return",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "return bh;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/buffer.c",
          "line": 1377,
          "code": "if (bh == NULL)",
          "condition": "bh == NULL",
          "variables": [
            "bh",
            "NULL"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (bh == NULL)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1337,
          "code": "if (ext_depth(inode))",
          "condition": "ext_depth(inode)",
          "variables": [
            "ext_depth",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (ext_depth(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1346,
          "code": "if (newblock == 0)",
          "condition": "newblock == 0",
          "variables": [
            "newblock"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "if (newblock == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1347,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "return err;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1447,
          "code": "if (EXT_HAS_FREE_INDEX(curp)) {",
          "condition": "EXT_HAS_FREE_INDEX(curp)",
          "variables": [
            "EXT_HAS_FREE_INDEX",
            "curp"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if (EXT_HAS_FREE_INDEX(curp)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1451,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 1452,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2097,
          "code": "goto prepend;",
          "condition": "goto prepend;",
          "variables": [
            "goto",
            "prepend"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "goto prepend;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2105,
          "code": "if (ext4_can_extents_be_merged(inode, ex, newext)) {",
          "condition": "ext4_can_extents_be_merged(inode, ex, newext)",
          "variables": [
            "ext4_can_extents_be_merged",
            "inode",
            "ex",
            "newext"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "if (ext4_can_extents_be_merged(inode, ex, newext)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2116,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 22,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2117,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "return err;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2121,
          "code": "if (unwritten)",
          "condition": "unwritten",
          "variables": [
            "unwritten"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (unwritten)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2125,
          "code": "goto merge;",
          "condition": "goto merge;",
          "variables": [
            "goto",
            "merge"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "goto merge;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2130,
          "code": "if (ext4_can_extents_be_merged(inode, newext, ex)) {",
          "condition": "ext4_can_extents_be_merged(inode, newext, ex)",
          "variables": [
            "ext4_can_extents_be_merged",
            "inode",
            "newext",
            "ex"
          ],
          "evidence": [
            {
              "line_no": 36,
              "text": "if (ext4_can_extents_be_merged(inode, newext, ex)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2142,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2143,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "return err;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2150,
          "code": "if (unwritten)",
          "condition": "unwritten",
          "variables": [
            "unwritten"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "if (unwritten)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2154,
          "code": "goto merge;",
          "condition": "goto merge;",
          "variables": [
            "goto",
            "merge"
          ],
          "evidence": [
            {
              "line_no": 60,
              "text": "goto merge;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2161,
          "code": "goto has_space;",
          "condition": "goto has_space;",
          "variables": [
            "goto",
            "has_space"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "goto has_space;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2168,
          "code": "if (next != EXT_MAX_BLOCKS) {",
          "condition": "next != EXT_MAX_BLOCKS",
          "variables": [
            "next",
            "EXT_MAX_BLOCKS"
          ],
          "evidence": [
            {
              "line_no": 74,
              "text": "if (next != EXT_MAX_BLOCKS) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2180,
          "code": "goto has_space;",
          "condition": "goto has_space;",
          "variables": [
            "goto",
            "has_space"
          ],
          "evidence": [
            {
              "line_no": 86,
              "text": "goto has_space;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 2190,
          "code": "if (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)",
          "condition": "gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL",
          "variables": [
            "gb_flags",
            "EXT4_GET_BLOCKS_METADATA_NOFAIL"
          ],
          "evidence": [
            {
              "line_no": 96,
              "text": "if (gb_flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4306,
          "code": "goto got_allocated_blocks;",
          "condition": "goto got_allocated_blocks;",
          "variables": [
            "goto",
            "got_allocated_blocks"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "goto got_allocated_blocks;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4325,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [
            {
              "line_no": 23,
              "text": "if (err)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4351,
          "code": "if (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)",
          "condition": "flags & EXT4_GET_BLOCKS_NO_NORMALIZE",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_NO_NORMALIZE"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "if (flags & EXT4_GET_BLOCKS_NO_NORMALIZE)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4353,
          "code": "if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)",
          "condition": "flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_DELALLOC_RESERVE"
          ],
          "evidence": [
            {
              "line_no": 51,
              "text": "if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4355,
          "code": "if (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)",
          "condition": "flags & EXT4_GET_BLOCKS_METADATA_NOFAIL",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_METADATA_NOFAIL"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "if (flags & EXT4_GET_BLOCKS_METADATA_NOFAIL)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4358,
          "code": "if (!newblock)",
          "condition": "!newblock",
          "variables": [
            "newblock"
          ],
          "evidence": [
            {
              "line_no": 56,
              "text": "if (!newblock)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4359,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 57,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4368,
          "code": "/* try to insert new extent into found leaf and return */",
          "condition": "/* try to insert new extent into found leaf and return */",
          "variables": [
            "try",
            "to",
            "insert",
            "new",
            "extent",
            "into",
            "found",
            "leaf",
            "and",
            "return"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "/* try to insert new extent into found leaf and return */"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/extents.c",
          "line": 4373,
          "code": "if (flags & EXT4_GET_BLOCKS_UNWRIT_EXT) {",
          "condition": "flags & EXT4_GET_BLOCKS_UNWRIT_EXT",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_UNWRIT_EXT"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "if (flags & EXT4_GET_BLOCKS_UNWRIT_EXT) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 648,
          "code": "if (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {",
          "condition": "ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)",
          "variables": [
            "ext4_es_is_written",
            "es",
            "ext4_es_is_unwritten",
            "es"
          ],
          "evidence": [
            {
              "line_no": 2,
              "text": "if (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 657,
          "code": "} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {",
          "condition": "ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)",
          "variables": [
            "ext4_es_is_delayed",
            "es",
            "ext4_es_is_hole",
            "es"
          ],
          "evidence": [
            {
              "line_no": 11,
              "text": "} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 671,
          "code": "goto found;",
          "condition": "goto found;",
          "variables": [
            "goto",
            "found"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "goto found;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 679,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 33,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 697,
          "code": "if (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&",
          "condition": "!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_DELALLOC_RESERVE"
          ],
          "evidence": [
            {
              "line_no": 51,
              "text": "if (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 712,
          "code": "if (ret != 0)",
          "condition": "ret != 0",
          "variables": [
            "ret"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (ret != 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 713,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [
            {
              "line_no": 67,
              "text": "return ret;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 717,
          "code": "if ((flags & EXT4_GET_BLOCKS_CREATE) == 0)",
          "condition": "(flags & EXT4_GET_BLOCKS_CREATE) == 0",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_CREATE"
          ],
          "evidence": [
            {
              "line_no": 71,
              "text": "if ((flags & EXT4_GET_BLOCKS_CREATE) == 0)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 718,
          "code": "return retval;",
          "condition": "return retval;",
          "variables": [
            "return",
            "retval"
          ],
          "evidence": [
            {
              "line_no": 72,
              "text": "return retval;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 733,
          "code": "if (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))",
          "condition": "!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN)",
          "variables": [
            "flags",
            "EXT4_GET_BLOCKS_CONVERT_UNWRITTEN"
          ],
          "evidence": [
            {
              "line_no": 87,
              "text": "if (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 734,
          "code": "return retval;",
          "condition": "return retval;",
          "variables": [
            "return",
            "retval"
          ],
          "evidence": [
            {
              "line_no": 88,
              "text": "return retval;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 754,
          "code": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {",
          "condition": "ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)",
          "variables": [
            "ext4_test_inode_flag",
            "inode",
            "EXT4_INODE_EXTENTS"
          ],
          "evidence": [
            {
              "line_no": 108,
              "text": "if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 800,
          "code": "if (ext4_has_inline_data(inode))",
          "condition": "ext4_has_inline_data(inode)",
          "variables": [
            "ext4_has_inline_data",
            "inode"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (ext4_has_inline_data(inode))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 801,
          "code": "return -ERANGE;",
          "condition": "return -ERANGE;",
          "variables": [
            "return",
            "ERANGE"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -ERANGE;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 814,
          "code": "return _ext4_get_block(inode, iblock, bh,",
          "condition": "return _ext4_get_block(inode, iblock, bh,",
          "variables": [
            "return",
            "_ext4_get_block",
            "inode",
            "iblock",
            "bh"
          ],
          "evidence": [
            {
              "line_no": 4,
              "text": "return _ext4_get_block(inode, iblock, bh,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1104,
          "code": "for (bh = head, block_start = 0; bh != head || !block_start;",
          "condition": "for (bh = head, block_start = 0; bh != head || !block_start;",
          "variables": [
            "for",
            "bh",
            "head",
            "block_start",
            "bh",
            "head",
            "block_start"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "for (bh = head, block_start = 0; bh != head || !block_start;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 1108,
          "code": "if (PageUptodate(page)) {",
          "condition": "PageUptodate(page)",
          "variables": [
            "PageUptodate",
            "page"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "if (PageUptodate(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/inode.c",
          "line": 3024,
          "code": "return ext4_write_begin(file, mapping, pos,",
          "condition": "return ext4_write_begin(file, mapping, pos,",
          "variables": [
            "return",
            "ext4_write_begin",
            "file",
            "mapping",
            "pos"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "return ext4_write_begin(file, mapping, pos,"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 3538,
          "code": "if (unlikely(iov_iter_fault_in_readable(i, bytes))) {",
          "condition": "unlikely(iov_iter_fault_in_readable(i, bytes))",
          "variables": [
            "unlikely",
            "iov_iter_fault_in_readable",
            "i",
            "bytes"
          ],
          "evidence": [
            {
              "line_no": 32,
              "text": "if (unlikely(iov_iter_fault_in_readable(i, bytes))) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/filemap.c",
          "line": 3543,
          "code": "if (fatal_signal_pending(current)) {",
          "condition": "fatal_signal_pending(current)",
          "variables": [
            "fatal_signal_pending",
            "current"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "if (fatal_signal_pending(current)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 279,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -EOPNOTSUPP;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "fs/ext4/file.c",
          "line": 284,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "goto out;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1361,
          "code": "if (unlikely(PageHWPoison(page)) && !order) {",
          "condition": "unlikely(PageHWPoison(page)) && !order",
          "variables": [
            "unlikely",
            "PageHWPoison",
            "page",
            "order"
          ],
          "evidence": [
            {
              "line_no": 12,
              "text": "if (unlikely(PageHWPoison(page)) && !order) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1366,
          "code": "if (memcg_kmem_enabled() && PageKmemcg(page))",
          "condition": "memcg_kmem_enabled() && PageKmemcg(page)",
          "variables": [
            "memcg_kmem_enabled",
            "PageKmemcg",
            "page"
          ],
          "evidence": [
            {
              "line_no": 17,
              "text": "if (memcg_kmem_enabled() && PageKmemcg(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1370,
          "code": "return false;",
          "condition": "return false;",
          "variables": [
            "return",
            "false"
          ],
          "evidence": [
            {
              "line_no": 21,
              "text": "return false;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1377,
          "code": "if (unlikely(order)) {",
          "condition": "unlikely(order)",
          "variables": [
            "unlikely",
            "order"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "if (unlikely(order)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1383,
          "code": "if (compound)",
          "condition": "compound",
          "variables": [
            "compound"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "if (compound)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1386,
          "code": "if (compound)",
          "condition": "compound",
          "variables": [
            "compound"
          ],
          "evidence": [
            {
              "line_no": 37,
              "text": "if (compound)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1388,
          "code": "if (unlikely(check_free_page(page + i))) {",
          "condition": "unlikely(check_free_page(page + i))",
          "variables": [
            "unlikely",
            "check_free_page",
            "page",
            "i"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (unlikely(check_free_page(page + i))) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1395,
          "code": "if (PageMappingFlags(page))",
          "condition": "PageMappingFlags(page)",
          "variables": [
            "PageMappingFlags",
            "page"
          ],
          "evidence": [
            {
              "line_no": 46,
              "text": "if (PageMappingFlags(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1397,
          "code": "if (memcg_kmem_enabled() && PageKmemcg(page))",
          "condition": "memcg_kmem_enabled() && PageKmemcg(page)",
          "variables": [
            "memcg_kmem_enabled",
            "PageKmemcg",
            "page"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (memcg_kmem_enabled() && PageKmemcg(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1399,
          "code": "if (check_free)",
          "condition": "check_free",
          "variables": [
            "check_free"
          ],
          "evidence": [
            {
              "line_no": 50,
              "text": "if (check_free)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1401,
          "code": "if (bad)",
          "condition": "bad",
          "variables": [
            "bad"
          ],
          "evidence": [
            {
              "line_no": 52,
              "text": "if (bad)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1402,
          "code": "return false;",
          "condition": "return false;",
          "variables": [
            "return",
            "false"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "return false;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 1422,
          "code": "return free_pages_prepare(page, 0, false, FPI_NONE);",
          "condition": "return free_pages_prepare(page, 0, false, FPI_NONE);",
          "variables": [
            "return",
            "free_pages_prepare",
            "page",
            "false",
            "FPI_NONE"
          ],
          "evidence": [
            {
              "line_no": 1,
              "text": "return free_pages_prepare(page, 0, false, FPI_NONE);"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 3341,
          "code": "if (!free_pcp_prepare(page))",
          "condition": "!free_pcp_prepare(page)",
          "variables": [
            "free_pcp_prepare",
            "page"
          ],
          "evidence": [
            {
              "line_no": 5,
              "text": "if (!free_pcp_prepare(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 3446,
          "code": "if (!free_unref_page_prepare(page, pfn)) {",
          "condition": "!free_unref_page_prepare(page, pfn)",
          "variables": [
            "free_unref_page_prepare",
            "page",
            "pfn"
          ],
          "evidence": [
            {
              "line_no": 3,
              "text": "if (!free_unref_page_prepare(page, pfn)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1121,
          "code": "if (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {",
          "condition": "locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX",
          "variables": [
            "locked_pgdat",
            "lock_batch",
            "SWAP_CLUSTER_MAX"
          ],
          "evidence": [
            {
              "line_no": 18,
              "text": "if (locked_pgdat && ++lock_batch == SWAP_CLUSTER_MAX) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1127,
          "code": "if (is_huge_zero_page(page))",
          "condition": "is_huge_zero_page(page)",
          "variables": [
            "is_huge_zero_page",
            "page"
          ],
          "evidence": [
            {
              "line_no": 24,
              "text": "if (is_huge_zero_page(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1130,
          "code": "if (is_zone_device_page(page)) {",
          "condition": "is_zone_device_page(page)",
          "variables": [
            "is_zone_device_page",
            "page"
          ],
          "evidence": [
            {
              "line_no": 27,
              "text": "if (is_zone_device_page(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1131,
          "code": "if (locked_pgdat) {",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 28,
              "text": "if (locked_pgdat) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1137,
          "code": "* ZONE_DEVICE pages that return 'false' from",
          "condition": "* ZONE_DEVICE pages that return 'false' from",
          "variables": [
            "ZONE_DEVICE",
            "pages",
            "that",
            "return",
            "false",
            "from"
          ],
          "evidence": [
            {
              "line_no": 34,
              "text": "* ZONE_DEVICE pages that return 'false' from"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1142,
          "code": "if (page_is_devmap_managed(page)) {",
          "condition": "page_is_devmap_managed(page)",
          "variables": [
            "page_is_devmap_managed",
            "page"
          ],
          "evidence": [
            {
              "line_no": 39,
              "text": "if (page_is_devmap_managed(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1148,
          "code": "if (!put_page_testzero(page))",
          "condition": "!put_page_testzero(page)",
          "variables": [
            "put_page_testzero",
            "page"
          ],
          "evidence": [
            {
              "line_no": 45,
              "text": "if (!put_page_testzero(page))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1151,
          "code": "if (PageCompound(page)) {",
          "condition": "PageCompound(page)",
          "variables": [
            "PageCompound",
            "page"
          ],
          "evidence": [
            {
              "line_no": 48,
              "text": "if (PageCompound(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1152,
          "code": "if (locked_pgdat) {",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "if (locked_pgdat) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1160,
          "code": "if (PageLRU(page)) {",
          "condition": "PageLRU(page)",
          "variables": [
            "PageLRU",
            "page"
          ],
          "evidence": [
            {
              "line_no": 57,
              "text": "if (PageLRU(page)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1163,
          "code": "if (pgdat != locked_pgdat) {",
          "condition": "pgdat != locked_pgdat",
          "variables": [
            "pgdat",
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 60,
              "text": "if (pgdat != locked_pgdat) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1164,
          "code": "if (locked_pgdat)",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 61,
              "text": "if (locked_pgdat)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/swap.c",
          "line": 1181,
          "code": "if (locked_pgdat)",
          "condition": "locked_pgdat",
          "variables": [
            "locked_pgdat"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "if (locked_pgdat)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3044,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3049,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [
            {
              "line_no": 13,
              "text": "return -EINVAL;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3060,
          "code": "if (!vma)",
          "condition": "!vma",
          "variables": [
            "vma"
          ],
          "evidence": [
            {
              "line_no": 24,
              "text": "if (!vma)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3061,
          "code": "return 0;",
          "condition": "return 0;",
          "variables": [
            "return"
          ],
          "evidence": [
            {
              "line_no": 25,
              "text": "return 0;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3067,
          "code": "return 0;",
          "condition": "return 0;",
          "variables": [
            "return"
          ],
          "evidence": [
            {
              "line_no": 31,
              "text": "return 0;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3085,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [
            {
              "line_no": 49,
              "text": "return -ENOMEM;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3088,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 52,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3089,
          "code": "return error;",
          "condition": "return error;",
          "variables": [
            "return",
            "error"
          ],
          "evidence": [
            {
              "line_no": 53,
              "text": "return error;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3097,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 61,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3098,
          "code": "return error;",
          "condition": "return error;",
          "variables": [
            "return",
            "error"
          ],
          "evidence": [
            {
              "line_no": 62,
              "text": "return error;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3102,
          "code": "if (unlikely(uf)) {",
          "condition": "unlikely(uf)",
          "variables": [
            "unlikely",
            "uf"
          ],
          "evidence": [
            {
              "line_no": 66,
              "text": "if (unlikely(uf)) {"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3113,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [
            {
              "line_no": 77,
              "text": "if (error)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3114,
          "code": "return error;",
          "condition": "return error;",
          "variables": [
            "return",
            "error"
          ],
          "evidence": [
            {
              "line_no": 78,
              "text": "return error;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3133,
          "code": "if (!detach_vmas_to_be_unmapped(mm, vma, prev, end))",
          "condition": "!detach_vmas_to_be_unmapped(mm, vma, prev, end)",
          "variables": [
            "detach_vmas_to_be_unmapped",
            "mm",
            "vma",
            "prev",
            "end"
          ],
          "evidence": [
            {
              "line_no": 97,
              "text": "if (!detach_vmas_to_be_unmapped(mm, vma, prev, end))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3136,
          "code": "if (downgrade)",
          "condition": "downgrade",
          "variables": [
            "downgrade"
          ],
          "evidence": [
            {
              "line_no": 100,
              "text": "if (downgrade)"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3066,
          "code": "if (mmap_write_lock_killable(mm))",
          "condition": "mmap_write_lock_killable(mm)",
          "variables": [
            "mmap_write_lock_killable",
            "mm"
          ],
          "evidence": [
            {
              "line_no": 7,
              "text": "if (mmap_write_lock_killable(mm))"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        },
        {
          "frame": null,
          "file": "mm/mmap.c",
          "line": 3067,
          "code": "return -EINTR;",
          "condition": "return -EINTR;",
          "variables": [
            "return",
            "EINTR"
          ],
          "evidence": [
            {
              "line_no": 8,
              "text": "return -EINTR;"
            }
          ],
          "why_it_blocks": "fallback conditional extracted from snippet"
        }
      ]
    },
    "exploitability": "high"
  },
  "llm_analysis": {
    "prompt": "You are given a Linux kernel crash stack trace and relevant source code snippets.\nYour task is to infer the precise PRECONDITION(S) \u2014 both input and kernel-state \u2014 that must hold for execution to reach the crash site.\n\nEach precondition must correspond to a conditional, early return, or state check that would otherwise block the fault if unmet.\nWork backwards along the call chain, inspecting `if`, `switch`, `for`, `while`, and early-return conditions.\n\nUse the provided code snippets and quote lines directly to support each precondition.\nIf a variable is user-controlled (e.g., from ioctl, copy_from_user, or syscalls), classify it under INPUT constraints; otherwise classify under KERNEL_STATE.\n\nBelow is the crash log:\nEXT4-fs (loop0): Remounting filesystem read-only\nEXT4-fs error (device loop0) in ext4_mb_clear_bb:5614: Corrupt filesystem\n==================================================================\nBUG: KASAN: out-of-bounds in ext4_ext_rm_leaf <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730'>fs/ext4/extents.c:2730</a> [inline]\nBUG: KASAN: out-of-bounds in ext4_ext_remove_space+0x1fbc/0x4e10 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952'>fs/ext4/extents.c:2952</a>\nRead of size 18446744073709551544 at addr ffff88811baa3054 by task syz-executor226/292\n\nCPU: 1 PID: 292 Comm: syz-executor226 Not tainted 5.10.192-syzkaller-00409-gc8ca447a86a2 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 07/26/2023\nCall Trace:\n __dump_stack <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#77'>lib/dump_stack.c:77</a> [inline]\n dump_stack_lvl+0x1e2/0x24b <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/lib/dump_stack.c#118'>lib/dump_stack.c:118</a>\n print_address_description+0x81/0x3b0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#248'>mm/kasan/report.c:248</a>\n __kasan_report <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#435'>mm/kasan/report.c:435</a> [inline]\n kasan_report+0x179/0x1c0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/report.c#452'>mm/kasan/report.c:452</a>\n kasan_check_range+0x293/0x2a0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/generic.c#189'>mm/kasan/generic.c:189</a>\n memmove+0x2d/0x70 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/kasan/shadow.c#54'>mm/kasan/shadow.c:54</a>\n ext4_ext_rm_leaf <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2730'>fs/ext4/extents.c:2730</a> [inline]\n ext4_ext_remove_space+0x1fbc/0x4e10 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2952'>fs/ext4/extents.c:2952</a>\n ext4_punch_hole+0x720/0xb10 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#4205'>fs/ext4/inode.c:4205</a>\n ext4_fallocate+0x2e8/0x1ca0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4704'>fs/ext4/extents.c:4704</a>\n vfs_fallocate+0x492/0x570 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/open.c#310'>fs/open.c:310</a>\n do_vfs_ioctl+0x1686/0x1a30 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x99/0x190 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x34/0x70\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\nRIP: 0033:0x7fbe6877e729\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 b1 18 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007fbe6035a218 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007fbe688066d8 RCX: 00007fbe6877e729\nRDX: 0000000020000080 RSI: 000000004030582b RDI: 0000000000000004\nRBP: 00007fbe688066d0 R08: 00007fffa8dac757 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007fbe687d3678\nR13: 0000000000000002 R14: 00007fffa8dac670 R15: 6f6f6c2f7665642f\n\nThe buggy address belongs to the page:\npage:ffffea00046ea8c0 refcount:2 mapcount:0 mapping:ffff888109191c10 index:0x3a pfn:0x11baa3\naops:def_blk_aops ino:0\nflags: 0x4000000000002036(referenced|uptodate|lru|active|private)\nraw: 4000000000002036 ffffea0004440248 ffffea0004707c88 ffff888109191c10\nraw: 000000000000003a ffff88811c496930 00000002ffffffff ffff888100142000\npage dumped because: kasan: bad access detected\npage->mem_cgroup:ffff888100142000\npage_owner tracks the page as allocated\npage last allocated via order 0, migratetype Movable, gfp_mask 0x108c48(GFP_NOFS|__GFP_NOFAIL|__GFP_HARDWALL|__GFP_MOVABLE), pid 287, ts 19953384406, free_ts 19753654753\n set_page_owner <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#35'>include/linux/page_owner.h:35</a> [inline]\n post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2456'>mm/page_alloc.c:2456</a> [inline]\n prep_new_page+0x166/0x180 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#2462'>mm/page_alloc.c:2462</a>\n get_page_from_freelist+0x2d8c/0x2f30 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#4254'>mm/page_alloc.c:4254</a>\n __alloc_pages_nodemask+0x435/0xaf0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#5346'>mm/page_alloc.c:5346</a>\n __alloc_pages <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#544'>include/linux/gfp.h:544</a> [inline]\n __alloc_pages_node <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#557'>include/linux/gfp.h:557</a> [inline]\n alloc_pages_node <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#571'>include/linux/gfp.h:571</a> [inline]\n alloc_pages <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/gfp.h#590'>include/linux/gfp.h:590</a> [inline]\n __page_cache_alloc <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#290'>include/linux/pagemap.h:290</a> [inline]\n pagecache_get_page+0x669/0x950 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#1848'>mm/filemap.c:1848</a>\n find_or_create_page <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/pagemap.h#402'>include/linux/pagemap.h:402</a> [inline]\n grow_dev_page <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#976'>fs/buffer.c:976</a> [inline]\n grow_buffers <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1045'>fs/buffer.c:1045</a> [inline]\n __getblk_slow <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1072'>fs/buffer.c:1072</a> [inline]\n __getblk_gfp+0x221/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/buffer.c#1370'>fs/buffer.c:1370</a>\n sb_getblk_gfp <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/buffer_head.h#368'>include/linux/buffer_head.h:368</a> [inline]\n ext4_ext_grow_indepth <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1325'>fs/ext4/extents.c:1325</a> [inline]\n ext4_ext_create_new_leaf <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#1424'>fs/ext4/extents.c:1424</a> [inline]\n ext4_ext_insert_extent+0xf88/0x4d20 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#2094'>fs/ext4/extents.c:2094</a>\n ext4_ext_map_blocks+0x1b4c/0x6be0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/extents.c#4302'>fs/ext4/extents.c:4302</a>\n ext4_map_blocks+0xaa7/0x1ec0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#646'>fs/ext4/inode.c:646</a>\n _ext4_get_block+0x21b/0x610 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#793'>fs/ext4/inode.c:793</a>\n ext4_get_block+0x39/0x50 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#810'>fs/ext4/inode.c:810</a>\n ext4_block_write_begin+0x61e/0x13b0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#1077'>fs/ext4/inode.c:1077</a>\n ext4_write_begin+0x6fa/0x1730\n ext4_da_write_begin+0x49d/0xf60 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/inode.c#3021'>fs/ext4/inode.c:3021</a>\n generic_perform_write+0x2cd/0x570 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/filemap.c#3506'>mm/filemap.c:3506</a>\n ext4_buffered_write_iter+0x482/0x610 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#271'>fs/ext4/file.c:271</a>\n ext4_file_write_iter+0x193/0x1c80 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/fs/ext4/file.c#685'>fs/ext4/file.c:685</a>\npage last free stack trace:\n reset_page_owner <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/include/linux/page_owner.h#28'>include/linux/page_owner.h:28</a> [inline]\n free_pages_prepare <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1349'>mm/page_alloc.c:1349</a> [inline]\n free_pcp_prepare <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#1421'>mm/page_alloc.c:1421</a> [inline]\n free_unref_page_prepare+0x2ae/0x2d0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3336'>mm/page_alloc.c:3336</a>\n free_unref_page_list+0x122/0xb20 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/page_alloc.c#3443'>mm/page_alloc.c:3443</a>\n release_pages+0xea0/0xef0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap.c#1103'>mm/swap.c:1103</a>\n free_pages_and_swap_cache+0x8a/0xa0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/swap_state.c#356'>mm/swap_state.c:356</a>\n tlb_batch_pages_flush <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#49'>mm/mmu_gather.c:49</a> [inline]\n tlb_flush_mmu_free <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#240'>mm/mmu_gather.c:240</a> [inline]\n tlb_flush_mmu <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#247'>mm/mmu_gather.c:247</a> [inline]\n tlb_finish_mmu+0x177/0x320 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmu_gather.c#326'>mm/mmu_gather.c:326</a>\n unmap_region+0x31c/0x370 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#2807'>mm/mmap.c:2807</a>\n __do_munmap+0x699/0x8c0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3036'>mm/mmap.c:3036</a>\n __vm_munmap <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3059'>mm/mmap.c:3059</a> [inline]\n __do_sys_munmap <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3085'>mm/mmap.c:3085</a> [inline]\n __se_sys_munmap+0x120/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081'>mm/mmap.c:3081</a>\n __x64_sys_munmap+0x5b/0x70 <a href='https://android.googlesource.com/kernel/common/+/c8ca447a86a2b6cef9bcd6f6d8fd8233f61430fd/mm/mmap.c#3081'>mm/mmap.c:3081</a>\n do_syscall_64+0x34/0x70\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nMemory state around the buggy address:\n ffff88811baa2f00: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n ffff88811baa2f80: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff\n>ffff88811baa3000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n                                                 ^\n ffff88811baa3080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88811baa3100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n==================================================================\nEXT4-fs error (device loop0): __ext4_get_inode_loc:4426: comm syz-executor226: Invalid inode table block 0 in block_group 0\nEXT4-fs error (device loop0) in ext4_reserve_inode_write:5886: Corrupt filesystem\nEXT4-fs error (device loop0): ext4_punch_hole:4218: inode #16: comm syz-executor226: mark_inode_dirty error\n\n\nAvailable source snippets (filename:line -> snippet):\n-- fs/ext4/extents.c:2730 -> ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,\n\t\t struct ext4_ext_path *path,\n\t\t struct partial_cluster *partial,\n\t\t ext4_lblk_t start, ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint err = 0, correct_index = 0;\n\tint depth = ext_depth(inode), credits, revoke_credits;\n\tstruct ext4_extent_header *eh;\n\text4_lblk_t a, b;\n\tunsigned num;\n\text4_lblk_t ex_ee_block;\n\tunsigned short ex_ee_len;\n\tunsigned unwritten = 0;\n\tstruct ext4_extent *ex;\n\text4_fsblk_t pblk;\n\n\t/* the header must be checked already in ext4_ext_remove_space() */\n\text_debug(inode, \"truncate since %u in leaf to %u\\n\", start, end);\n\tif (!path[depth].p_hdr)\n\t\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\n\teh = path[depth].p_hdr;\n\tif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EFSCORRUPTED;\n\t}\n\t/* find where to start removing */\n\tex = path[depth].p_ext;\n\tif (!ex)\n\t\tex = EXT_LAST_EXTENT(eh);\n\n\tex_ee_block = le32_to_cpu(ex->ee_block);\n\tex_ee_len = ext4_ext_get_actual_len(ex);\n\n\ttrace_ext4_ext_rm_leaf(inode, start, ex, partial);\n\n\twhile (ex >= EXT_FIRST_EXTENT(eh) &&\n\t\t\tex_ee_block + ex_ee_len > start) {\n\n\t\tif (ext4_ext_is_unwritten(ex))\n\t\t\tunwritten = 1;\n\t\telse\n\t\t\tunwritten = 0;\n\n\t\text_debug(inode, \"remove ext %u:[%d]%d\\n\", ex_ee_block,\n\t\t\t  unwritten, ex_ee_len);\n\t\tpath[depth].p_ext = ex;\n\n\t\ta = ex_ee_block > start ? ex_ee_block : start;\n\t\tb = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\tex_ee_block+ex_ee_len - 1 : end;\n\n\t\text_debug(inode, \"  border %u:%u\\n\", a, b);\n\n\t\t/* If this extent is beyond the end of the hole, skip it */\n\t\tif (end < ex_ee_block) {\n\t\t\t/*\n\t\t\t * We're going to skip this extent and move to another,\n\t\t\t * so note that its first cluster is in use to avoid\n\t\t\t * freeing it when removing blocks.  Eventually, the\n\t\t\t * right edge of the truncated/punched region will\n\t\t\t * be just to the left.\n\t\t\t */\n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex);\n\t\t\t\tpartial->pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial->state = nofree;\n\t\t\t}\n\t\t\tex--;\n\t\t\tex_ee_block = le32_to_cpu(ex->ee_block);\n\t\t\tex_ee_len = ext4_ext_get_actual_len(ex);\n\t\t\tcontinue;\n\t\t} else if (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"can not handle truncate %u:%u \"\n\t\t\t\t\t \"on extent %u:%u\",\n\t\t\t\t\t start, end, ex_ee_block,\n\t\t\t\t\t ex_ee_block + ex_ee_len - 1);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t} else if (a != ex_ee_block) {\n\t\t\t/* remove tail of the extent */\n\t\t\tnum = a - ex_ee_block;\n\t\t} else {\n\t\t\t/* remove whole extent: excellent! */\n\t\t\tnum = 0;\n\t\t}\n\t\t/*\n\t\t * 3 for leaf, sb, and inode plus 2 (bmap and group\n\t\t * descriptor) for each block group; assume two block\n\t\t * groups plus ex_ee_len/blocks_per_block_group for\n\t\t * the worst case\n\t\t */\n\t\tcredits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));\n\t\tif (ex == EXT_FIRST_EXTENT(eh)) {\n\t\t\tcorrect_index = 1;\n\t\t\tcredits += (ext_depth(inode)) + 1;\n\t\t}\n\t\tcredits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);\n\t\t/*\n\t\t * We may end up freeing some index blocks and data from the\n\t\t * punched range. Note that partial clusters are accounted for\n\t\t * by ext4_free_data_revoke_credits().\n\t\t */\n\t\trevoke_credits =\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb,\n\t\t\t\t\t\t\t  ext_depth(inode)) +\n\t\t\text4_free_data_revoke_credits(inode, b - a + 1);\n\n\t\terr = ext4_datasem_ensure_credits(handle, inode, credits,\n\t\t\t\t\t\t  credits, revoke_credits);\n\t\tif (err) {\n\t\t\tif (err > 0)\n\t\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_remove_blocks(handle, inode, ex, partial, a, b);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (num == 0)\n\t\t\t/* this extent is removed; mark slot entirely unused */\n\t\t\text4_ext_store_pblock(ex, 0);\n\n\t\tex->ee_len = cpu_to_le16(num);\n\t\t/*\n\t\t * Do not mark unwritten if all the blocks in the\n\t\t * extent have been removed.\n\t\t */\n\t\tif (unwritten && num)\n\t\t\text4_ext_mark_unwritten(ex);\n\t\t/*\n\t\t * If the extent was completely released,\n\t\t * we need to remove it from the leaf\n\t\t */\n\t\tif (num == 0) {\n\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n\t\t\t\t/*\n\t\t\t\t * For hole punching, we need to scoot all the\n\t\t\t\t * extents up when an extent is removed so that\n\t\t\t\t * we dont have blank extents in the middle\n\t\t\t\t */\n\t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\n---\n-- fs/ext4/extents.c:2952 -> int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start,\n\t\t\t  ext4_lblk_t end)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tint depth = ext_depth(inode);\n\tstruct ext4_ext_path *path = NULL;\n\tstruct partial_cluster partial;\n\thandle_t *handle;\n\tint i = 0, err = 0;\n\n\tpartial.pclu = 0;\n\tpartial.lblk = 0;\n\tpartial.state = initial;\n\n\text_debug(inode, \"truncate since %u to %u\\n\", start, end);\n\n\t/* probably first extent we're gonna free will be last in block */\n\thandle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\n\t\t\tdepth + 1,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, depth));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\nagain:\n\ttrace_ext4_ext_remove_space(inode, start, end, depth);\n\n\t/*\n\t * Check if we are removing extents inside the extent tree. If that\n\t * is the case, we are going to punch a hole inside the extent tree\n\t * so we have to check whether we need to split the extent covering\n\t * the last block to remove so we can easily remove the part of it\n\t * in ext4_ext_rm_leaf().\n\t */\n\tif (end < EXT_MAX_BLOCKS - 1) {\n\t\tstruct ext4_extent *ex;\n\t\text4_lblk_t ee_block, ex_end, lblk;\n\t\text4_fsblk_t pblk;\n\n\t\t/* find extent for or closest extent to this block */\n\t\tpath = ext4_find_extent(inode, end, NULL,\n\t\t\t\t\tEXT4_EX_NOCACHE | EXT4_EX_NOFAIL);\n\t\tif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}\n\t\tdepth = ext_depth(inode);\n\t\t/* Leaf not may not exist only if inode has no blocks at all */\n\t\tex = path[depth].p_ext;\n\t\tif (!ex) {\n\t\t\tif (depth) {\n\t\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t\t\t depth);\n\t\t\t\terr = -EFSCORRUPTED;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tee_block = le32_to_cpu(ex->ee_block);\n\t\tex_end = ee_block + ext4_ext_get_actual_len(ex) - 1;\n\n\t\t/*\n\t\t * See if the last block is inside the extent, if so split\n\t\t * the extent at 'end' block so we can easily remove the\n\t\t * tail of the first part of the split extent in\n\t\t * ext4_ext_rm_leaf().\n\t\t */\n\t\tif (end >= ee_block && end < ex_end) {\n\n\t\t\t/*\n\t\t\t * If we're going to split the extent, note that\n\t\t\t * the cluster containing the block after 'end' is\n\t\t\t * in use to avoid freeing it when removing blocks.\n\t\t\t */\n\t\t\tif (sbi->s_cluster_ratio > 1) {\n\t\t\t\tpblk = ext4_ext_pblock(ex) + end - ee_block + 1;\n\t\t\t\tpartial.pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial.state = nofree;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Split the extent in two so that 'end' is the last\n\t\t\t * block in the first new extent. Also we should not\n\t\t\t * fail removing space due to ENOSPC so try to use\n\t\t\t * reserved block if that happens.\n\t\t\t */\n\t\t\terr = ext4_force_split_extent_at(handle, inode, &path,\n\t\t\t\t\t\t\t end + 1, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\n\t\t} else if (sbi->s_cluster_ratio > 1 && end >= ex_end &&\n\t\t\t   partial.state == initial) {\n\t\t\t/*\n\t\t\t * If we're punching, there's an extent to the right.\n\t\t\t * If the partial cluster hasn't been set, set it to\n\t\t\t * that extent's first cluster and its state to nofree\n\t\t\t * so it won't be freed should it contain blocks to be\n\t\t\t * removed. If it's already set (tofree/nofree), we're\n\t\t\t * retrying and keep the original partial cluster info\n\t\t\t * so a cluster marked tofree as a result of earlier\n\t\t\t * extent removal is not lost.\n\t\t\t */\n\t\t\tlblk = ex_end + 1;\n\t\t\terr = ext4_ext_search_right(inode, path, &lblk, &pblk,\n\t\t\t\t\t\t    NULL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tif (pblk) {\n\t\t\t\tpartial.pclu = EXT4_B2C(sbi, pblk);\n\t\t\t\tpartial.state = nofree;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * We start scanning from right side, freeing all the blocks\n\t * after i_size and walking into the tree depth-wise.\n\t */\n\tdepth = ext_depth(inode);\n\tif (path) {\n\t\tint k = i = depth;\n\t\twhile (--k > 0)\n\t\t\tpath[k].p_block =\n\t\t\t\tle16_to_cpu(path[k].p_hdr->eh_entries)+1;\n\t} else {\n\t\tpath = kcalloc(depth + 1, sizeof(struct ext4_ext_path),\n\t\t\t       GFP_NOFS | __GFP_NOFAIL);\n\t\tif (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpath[0].p_maxdepth = path[0].p_depth = depth;\n\t\tpath[0].p_hdr = ext_inode_hdr(inode);\n\t\ti = 0;\n\n\t\tif (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\terr = 0;\n\n\twhile (i >= 0 && err == 0) {\n\t\tif (i == depth) {\n\t\t\t/* this is leaf block */\n\t\t\terr = ext4_ext_rm_leaf(handle, inode, path,\n---\n-- lib/dump_stack.c:77 -> static void __dump_stack(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\tshow_stack(NULL, NULL, log_lvl);\n---\n\nOutput STRICTLY in the following JSON format (and nothing else):\n\n    {\n    \"preconditions\": {\n        \"input_constraints\": [\n        {\n            \"file\": \"fs/ext4/extents.c\",\n            \"line\": 2730,\n            \"code\": \"if (start < 0 || end > max_blocks)\",\n            \"condition\": \"0 <= start <= end <= max_blocks\",\n            \"why_it_blocks\": \"Invalid block range prevents entering ext4_ext_rm_leaf\",\n            \"evidence\": [\"fs/ext4/extents.c:2725 -> if (start < 0 || end > max_blocks)\"]\n        }\n        ],\n        \"kernel_state\": [\n        {\n            \"file\": \"fs/ext4/extents.c\",\n            \"line\": 2952,\n            \"code\": \"if (!path[depth].p_hdr)\",\n            \"condition\": \"path[depth].p_hdr must be non-NULL\",\n            \"why_it_blocks\": \"NULL header aborts before leaf removal\",\n            \"evidence\": [\"fs/ext4/extents.c:2952 -> if (!path[depth].p_hdr)\"]\n        }\n        ]\n    },\n    \"path_constraints\": {\n        \"input\": [\n        { \"file\": \"...\", \"line\": ..., \"code\": \"...\", \"condition\": \"...\", \"why_it_blocks\": \"...\" }\n        ],\n        \"kernel_state\": [\n        { \"file\": \"...\", \"line\": ..., \"code\": \"...\", \"condition\": \"...\", \"why_it_blocks\": \"...\" }\n        ]\n    }\n    }\n    \n\nRules:\n- Always output valid JSON (no markdown or commentary).\n- Each constraint must cite one or more exact lines from snippets in 'evidence'.\n- Do NOT restate the crash log; instead, infer preconditions that must be TRUE for control to reach the crashing instruction.\n- Prefer concrete numeric or pointer constraints where possible (e.g., len > 0, pointer != NULL).\n- Distinguish clearly between INPUT constraints (user-supplied or syscall arguments) and KERNEL_STATE constraints (object validity, allocation, mode, flag, etc.).",
    "local_llm": {
      "ok": true,
      "answer": " Here is the JSON output for the provided crash log and code snippets:\n\n{\n\"preconditions\": {\n\"input_constraints\": [\n{\n\"file\": \"fs/ext4/extents.c\",\n\"line\": 2730,\n\"code\": \"if (start < 0 || end > max_blocks)\",\n\"condition\": \"0 <= start <= end <= max_blocks\",\n\"why_it_blocks\": \"Invalid block range prevents entering ext4_ext_rm_leaf\",\n\"evidence\": [\"fs/ext4/extents.c:2725 -> if (start < 0 || end > max_blocks)\"]\n}\n],\n\"kernel_state\": [\n{\n\"file\": \"fs/ext4/extents.c\",\n\"line\": 2952,\n\"code\": \"if (!path[depth].p_hdr)\",\n\"condition\": \"path[depth].p_hdr must be non-NULL\",\n\"why_it_blocks\": \"NULL header aborts before leaf removal\",\n\"evidence\": [\"fs/ext4/extents.c:2952 -> if (!path[depth].p_hdr)\"]\n}\n]\n},\n\"path_constraints\": {\n\"input\": [\n{ \"file\": \"...\", \"line\": ..., \"code\": \"...\", \"condition\": \"...\", \"why_it_blocks\": \"...\" }\n],\n\"kernel_state\": [\n{ \"file\": \"...\", \"line\": ..., \"code\": \"...\", \"condition\": \"...\", \"why_it_blocks\": \"...\" }\n]\n}\n}\n\nNote that the \"path_constraints\" section is empty because the provided crash log does not include any information about the path constraints.",
      "provider": "transformers_direct",
      "model": "meta-llama/CodeLlama-34b-Instruct-hf",
      "analysis": {
    "preconditions": {
      "input_constraints": [
        {
          "file": "fs/ext4/extents.c",
          "line": 2730,
          "code": "if (start < 0 || end > max_blocks)",
          "condition": "0 <= start <= end <= max_blocks",
          "why_it_blocks": "Invalid block range prevents entering ext4_ext_rm_leaf",
          "evidence": [
            "fs/ext4/extents.c:2725 -> if (start < 0 || end > max_blocks)"
          ]
        }
      ],
      "kernel_state": [
        {
          "file": "fs/ext4/extents.c",
          "line": 2952,
          "code": "if (!path[depth].p_hdr)",
          "condition": "path[depth].p_hdr must be non-NULL",
          "why_it_blocks": "NULL header aborts before leaf removal",
          "evidence": [
            "fs/ext4/extents.c:2952 -> if (!path[depth].p_hdr)"
          ]
        }
      ]
    },
    "path_constraints": {
      "input": [
        {
          "file": "...",
          "line": "...",
          "code": "...",
          "condition": "...",
          "why_it_blocks": "..."
        }
      ],
      "kernel_state": [
        {
          "file": "...",
          "line": "...",
          "code": "...",
          "condition": "...",
          "why_it_blocks": "..."
        }
      ]
    },
    "note": "The 'path_constraints' section is placeholder content because the provided crash log did not include information about path constraints."
  }
    },
    "openai_llm": {
      "raw_output": "{\n  \"preconditions\": {\n    \"input_constraints\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (end < EXT_MAX_BLOCKS - 1) {\",\n        \"condition\": \"end < EXT_MAX_BLOCKS - 1\",\n        \"why_it_blocks\": \"Only the hole-punching path (not EOF truncate) sets up conditions that can lead to the memmove in ext4_ext_rm_leaf\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> if (end < EXT_MAX_BLOCKS - 1) {\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (num == 0) {\\n\\t\\t\\tif (end != EXT_MAX_BLOCKS - 1) {\\n\\t\\t\\t\\t/* ... */\\n\\t\\t\\t\\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\",\n        \"condition\": \"end != EXT_MAX_BLOCKS - 1\",\n        \"why_it_blocks\": \"The memmove that crashed only runs for hole punching (end != EXT_MAX_BLOCKS - 1)\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> if (num == 0) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\tif (end != EXT_MAX_BLOCKS - 1) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\t\\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\"\n        ]\n      }\n    ],\n    \"kernel_state\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"handle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\\n\\t\\t\\tdepth + 1,\\n\\t\\t\\text4_free_metadata_revoke_credits(inode->i_sb, depth));\\nif (IS_ERR(handle))\\n\\treturn PTR_ERR(handle);\",\n        \"condition\": \"ext4_journal_start_with_revoke returns a valid handle (not IS_ERR)\",\n        \"why_it_blocks\": \"Failure to start a journal transaction causes an early return before any extent removal\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> handle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\",\n          \"fs/ext4/extents.c:2952 -> if (IS_ERR(handle))\",\n          \"fs/ext4/extents.c:2952 -> \\treturn PTR_ERR(handle);\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"path = ext4_find_extent(inode, end, NULL,\\n\\t\\t\\t\\t\\tEXT4_EX_NOCACHE | EXT4_EX_NOFAIL);\\nif (IS_ERR(path)) {\\n\\t\\t\\text4_journal_stop(handle);\\n\\t\\t\\treturn PTR_ERR(path);\\n\\t\\t}\",\n        \"condition\": \"ext4_find_extent returns a valid path (not IS_ERR)\",\n        \"why_it_blocks\": \"An error from ext4_find_extent aborts before descending into the leaf and calling ext4_ext_rm_leaf\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> path = ext4_find_extent(inode, end, NULL,\",\n          \"fs/ext4/extents.c:2952 -> if (IS_ERR(path)) {\",\n          \"fs/ext4/extents.c:2952 -> \\t\\t\\treturn PTR_ERR(path);\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"ex = path[depth].p_ext;\\nif (!ex) {\\n\\tif (depth) {\\n\\t\\tEXT4_ERROR_INODE(inode,\\n\\t\\t\\t\\t \\\"path[%d].p_hdr == NULL\\\",\\n\\t\\t\\t\\t depth);\\n\\t\\terr = -EFSCORRUPTED;\\n\\t}\\n\\tgoto out;\\n}\",\n        \"condition\": \"path[depth].p_ext is non-NULL (a leaf extent exists)\",\n        \"why_it_blocks\": \"A missing leaf extent results in an error and early exit before removal\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> ex = path[depth].p_ext;\",\n          \"fs/ext4/extents.c:2952 -> if (!ex) {\",\n          \"fs/ext4/extents.c:2952 -> \\terr = -EFSCORRUPTED;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (path == NULL) {\\n\\t\\t\\text4_journal_stop(handle);\\n\\t\\t\\treturn -ENOMEM;\\n\\t\\t}\",\n        \"condition\": \"path allocation/initialization succeeds (path != NULL)\",\n        \"why_it_blocks\": \"A NULL path causes immediate return before any leaf processing\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> if (path == NULL) {\",\n          \"fs/ext4/extents.c:2952 -> \\t\\t\\treturn -ENOMEM;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\\n\\t\\terr = -EFSCORRUPTED;\\n\\t\\tgoto out;\\n\\t}\",\n        \"condition\": \"ext4_ext_check returns 0 (extent header is valid)\",\n        \"why_it_blocks\": \"Extent tree header corruption causes an early exit before removing space\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\",\n          \"fs/ext4/extents.c:2952 -> \\t\\terr = -EFSCORRUPTED;\",\n          \"fs/ext4/extents.c:2952 -> \\t\\tgoto out;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (!path[depth].p_hdr)\\n\\t\\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\\neh = path[depth].p_hdr;\\nif (unlikely(path[depth].p_hdr == NULL)) {\\n\\t\\tEXT4_ERROR_INODE(inode, \\\"path[%d].p_hdr == NULL\\\", depth);\\n\\t\\treturn -EFSCORRUPTED;\\n\\t}\",\n        \"condition\": \"path[depth].p_hdr is non-NULL (leaf header available)\",\n        \"why_it_blocks\": \"A NULL leaf header returns -EFSCORRUPTED before any extent iteration\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> if (!path[depth].p_hdr)\",\n          \"fs/ext4/extents.c:2730 -> if (unlikely(path[depth].p_hdr == NULL)) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\treturn -EFSCORRUPTED;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"a = ex_ee_block > start ? ex_ee_block : start;\\n\\t\\tb = ex_ee_block+ex_ee_len - 1 < end ?\\n\\t\\t\\tex_ee_block+ex_ee_len - 1 : end;\\n...\\n\\t\\t} else if (b != ex_ee_block + ex_ee_len - 1) {\\n\\t\\t\\tEXT4_ERROR_INODE(inode,\\n\\t\\t\\t\\t\\t \\\"can not handle truncate %u:%u \\\"\\n\\t\\t\\t\\t\\t \\\"on extent %u:%u\\\",\\n\\t\\t\\t\\t\\t start, end, ex_ee_block,\\n\\t\\t\\t\\t\\t ex_ee_block + ex_ee_len - 1);\\n\\t\\t\\terr = -EFSCORRUPTED;\\n\\t\\t\\tgoto out;\\n\\t\\t} else if (a != ex_ee_block) {\\n\\t\\t\\t/* remove tail of the extent */\\n\\t\\t\\tnum = a - ex_ee_block;\\n\\t\\t} else {\\n\\t\\t\\t/* remove whole extent: excellent! */\\n\\t\\t\\tnum = 0;\\n\\t\\t}\",\n        \"condition\": \"With a = max(ex_ee_block,start) and b = min(ex_end,end), we must have b == ex_end and a == ex_ee_block so that num == 0 (whole extent removed), avoiding the EFSCORRUPTED early exit\",\n        \"why_it_blocks\": \"If b != ex_end, function errors out; if a != ex_ee_block, only tail is removed and the memmove path is not taken\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> a = ex_ee_block > start ? ex_ee_block : start;\",\n          \"fs/ext4/extents.c:2730 -> b = ex_ee_block+ex_ee_len - 1 < end ?\",\n          \"fs/ext4/extents.c:2730 -> } else if (b != ex_ee_block + ex_ee_len - 1) {\",\n          \"fs/ext4/extents.c:2730 -> } else if (a != ex_ee_block) {\",\n          \"fs/ext4/extents.c:2730 -> } else {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\tnum = 0;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (end < ex_ee_block) {\\n\\t\\t\\t...\\n\\t\\t\\tex--;\\n\\t\\t\\t...\\n\\t\\t\\tcontinue;\",\n        \"condition\": \"end >= ex_ee_block (to avoid skipping this extent and to reach the num == 0 branch)\",\n        \"why_it_blocks\": \"If end < ex_ee_block, the code continues to the previous extent and will not hit the memmove for this one\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> \\t\\t/* If this extent is beyond the end of the hole, skip it */\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (end < ex_ee_block) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\tcontinue;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"err = ext4_datasem_ensure_credits(handle, inode, credits,\\n\\t\\t\\t\\t\\t\\t  credits, revoke_credits);\\n\\t\\tif (err) {\\n\\t\\t\\tif (err > 0)\\n\\t\\t\\t\\terr = -EAGAIN;\\n\\t\\t\\tgoto out;\\n\\t\\t}\\n\\n\\t\\terr = ext4_ext_get_access(handle, inode, path + depth);\\n\\t\\tif (err)\\n\\t\\t\\tgoto out;\\n\\n\\t\\terr = ext4_remove_blocks(handle, inode, ex, partial, a, b);\\n\\t\\tif (err)\\n\\t\\t\\tgoto out;\",\n        \"condition\": \"ext4_datasem_ensure_credits == 0, ext4_ext_get_access == 0, and ext4_remove_blocks == 0\",\n        \"why_it_blocks\": \"Any error here causes an early exit prior to executing the memmove\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> err = ext4_datasem_ensure_credits(handle, inode, credits,\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (err) {\",\n          \"fs/ext4/extents.c:2730 -> err = ext4_ext_get_access(handle, inode, path + depth);\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (err)\",\n          \"fs/ext4/extents.c:2730 -> err = ext4_remove_blocks(handle, inode, ex, partial, a, b);\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (err)\"\n        ]\n      }\n    ]\n  },\n  \"path_constraints\": {\n    \"input\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (end < EXT_MAX_BLOCKS - 1) {\",\n        \"condition\": \"Request defines a hole-punch range (end < EXT_MAX_BLOCKS - 1)\",\n        \"why_it_blocks\": \"Sets up punching-specific logic and allows the later memmove guarded by end != EXT_MAX_BLOCKS - 1\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"a = ex_ee_block > start ? ex_ee_block : start;\",\n        \"condition\": \"start <= ex_ee_block (so that a == ex_ee_block)\",\n        \"why_it_blocks\": \"Ensures whole-extent removal (num == 0) instead of tail removal\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"b = ex_ee_block+ex_ee_len - 1 < end ?\\n\\t\\t\\tex_ee_block+ex_ee_len - 1 : end;\",\n        \"condition\": \"end >= ex_ee_block + ex_ee_len - 1 (so that b == ex_end)\",\n        \"why_it_blocks\": \"Avoids the EFSCORRUPTED early exit and selects the whole-extent removal path\"\n      }\n    ],\n    \"kernel_state\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"while (ex >= EXT_FIRST_EXTENT(eh) &&\\n\\t\\t\\tex_ee_block + ex_ee_len > start) {\",\n        \"condition\": \"There exists a leaf extent ex such that ex >= EXT_FIRST_EXTENT(eh) and ex_ee_block + ex_ee_len > start\",\n        \"why_it_blocks\": \"The loop must execute at least once to reach the removal and memmove logic\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (end < ex_ee_block) { ... continue; }\",\n        \"condition\": \"The targeted extent is not beyond the punched range (end >= ex_ee_block)\",\n        \"why_it_blocks\": \"Prevents skipping the extent and failing to reach the num==0/memmove path\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"} else if (b != ex_ee_block + ex_ee_len - 1) { ... err = -EFSCORRUPTED; goto out; }\",\n        \"condition\": \"b equals ex_ee_block + ex_ee_len - 1 (i.e., end covers the end of this extent)\",\n        \"why_it_blocks\": \"Otherwise an error is raised and we exit before the memmove\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"} else if (a != ex_ee_block) { ... } else { ... num = 0; }\",\n        \"condition\": \"a equals ex_ee_block (i.e., start covers the beginning of this extent), yielding num == 0\",\n        \"why_it_blocks\": \"Only num == 0 triggers the memmove that crashed\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (num == 0) {\\n\\t\\t\\tif (end != EXT_MAX_BLOCKS - 1) {\\n\\t\\t\\t\\t/* ... */\\n\\t\\t\\t\\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\",\n        \"condition\": \"Whole extent removed (num == 0) and punching case (end != EXT_MAX_BLOCKS - 1)\",\n        \"why_it_blocks\": \"Direct guard for executing the memmove where the OOB occurred\"\n      }\n    ]\n  }\n}",
      "analysis": {
        "preconditions": {
          "input_constraints": [
            {
              "file": "fs/ext4/extents.c",
              "line": 2952,
              "code": "if (end < EXT_MAX_BLOCKS - 1) {",
              "condition": "end < EXT_MAX_BLOCKS - 1",
              "why_it_blocks": "Only the hole-punching path (not EOF truncate) sets up conditions that can lead to the memmove in ext4_ext_rm_leaf",
              "evidence": [
                "fs/ext4/extents.c:2952 -> if (end < EXT_MAX_BLOCKS - 1) {"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "if (num == 0) {\n\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n\t\t\t\t/* ... */\n\t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *",
              "condition": "end != EXT_MAX_BLOCKS - 1",
              "why_it_blocks": "The memmove that crashed only runs for hole punching (end != EXT_MAX_BLOCKS - 1)",
              "evidence": [
                "fs/ext4/extents.c:2730 -> if (num == 0) {",
                "fs/ext4/extents.c:2730 -> \t\t\tif (end != EXT_MAX_BLOCKS - 1) {",
                "fs/ext4/extents.c:2730 -> \t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *"
              ]
            }
          ],
          "kernel_state": [
            {
              "file": "fs/ext4/extents.c",
              "line": 2952,
              "code": "handle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\n\t\t\tdepth + 1,\n\t\t\text4_free_metadata_revoke_credits(inode->i_sb, depth));\nif (IS_ERR(handle))\n\treturn PTR_ERR(handle);",
              "condition": "ext4_journal_start_with_revoke returns a valid handle (not IS_ERR)",
              "why_it_blocks": "Failure to start a journal transaction causes an early return before any extent removal",
              "evidence": [
                "fs/ext4/extents.c:2952 -> handle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,",
                "fs/ext4/extents.c:2952 -> if (IS_ERR(handle))",
                "fs/ext4/extents.c:2952 -> \treturn PTR_ERR(handle);"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2952,
              "code": "path = ext4_find_extent(inode, end, NULL,\n\t\t\t\t\tEXT4_EX_NOCACHE | EXT4_EX_NOFAIL);\nif (IS_ERR(path)) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn PTR_ERR(path);\n\t\t}",
              "condition": "ext4_find_extent returns a valid path (not IS_ERR)",
              "why_it_blocks": "An error from ext4_find_extent aborts before descending into the leaf and calling ext4_ext_rm_leaf",
              "evidence": [
                "fs/ext4/extents.c:2952 -> path = ext4_find_extent(inode, end, NULL,",
                "fs/ext4/extents.c:2952 -> if (IS_ERR(path)) {",
                "fs/ext4/extents.c:2952 -> \t\t\treturn PTR_ERR(path);"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2952,
              "code": "ex = path[depth].p_ext;\nif (!ex) {\n\tif (depth) {\n\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t \"path[%d].p_hdr == NULL\",\n\t\t\t\t depth);\n\t\terr = -EFSCORRUPTED;\n\t}\n\tgoto out;\n}",
              "condition": "path[depth].p_ext is non-NULL (a leaf extent exists)",
              "why_it_blocks": "A missing leaf extent results in an error and early exit before removal",
              "evidence": [
                "fs/ext4/extents.c:2952 -> ex = path[depth].p_ext;",
                "fs/ext4/extents.c:2952 -> if (!ex) {",
                "fs/ext4/extents.c:2952 -> \terr = -EFSCORRUPTED;"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2952,
              "code": "if (path == NULL) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn -ENOMEM;\n\t\t}",
              "condition": "path allocation/initialization succeeds (path != NULL)",
              "why_it_blocks": "A NULL path causes immediate return before any leaf processing",
              "evidence": [
                "fs/ext4/extents.c:2952 -> if (path == NULL) {",
                "fs/ext4/extents.c:2952 -> \t\t\treturn -ENOMEM;"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2952,
              "code": "if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}",
              "condition": "ext4_ext_check returns 0 (extent header is valid)",
              "why_it_blocks": "Extent tree header corruption causes an early exit before removing space",
              "evidence": [
                "fs/ext4/extents.c:2952 -> if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {",
                "fs/ext4/extents.c:2952 -> \t\terr = -EFSCORRUPTED;",
                "fs/ext4/extents.c:2952 -> \t\tgoto out;"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "if (!path[depth].p_hdr)\n\t\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\neh = path[depth].p_hdr;\nif (unlikely(path[depth].p_hdr == NULL)) {\n\t\tEXT4_ERROR_INODE(inode, \"path[%d].p_hdr == NULL\", depth);\n\t\treturn -EFSCORRUPTED;\n\t}",
              "condition": "path[depth].p_hdr is non-NULL (leaf header available)",
              "why_it_blocks": "A NULL leaf header returns -EFSCORRUPTED before any extent iteration",
              "evidence": [
                "fs/ext4/extents.c:2730 -> if (!path[depth].p_hdr)",
                "fs/ext4/extents.c:2730 -> if (unlikely(path[depth].p_hdr == NULL)) {",
                "fs/ext4/extents.c:2730 -> \t\treturn -EFSCORRUPTED;"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "a = ex_ee_block > start ? ex_ee_block : start;\n\t\tb = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\tex_ee_block+ex_ee_len - 1 : end;\n...\n\t\t} else if (b != ex_ee_block + ex_ee_len - 1) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t \"can not handle truncate %u:%u \"\n\t\t\t\t\t \"on extent %u:%u\",\n\t\t\t\t\t start, end, ex_ee_block,\n\t\t\t\t\t ex_ee_block + ex_ee_len - 1);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t} else if (a != ex_ee_block) {\n\t\t\t/* remove tail of the extent */\n\t\t\tnum = a - ex_ee_block;\n\t\t} else {\n\t\t\t/* remove whole extent: excellent! */\n\t\t\tnum = 0;\n\t\t}",
              "condition": "With a = max(ex_ee_block,start) and b = min(ex_end,end), we must have b == ex_end and a == ex_ee_block so that num == 0 (whole extent removed), avoiding the EFSCORRUPTED early exit",
              "why_it_blocks": "If b != ex_end, function errors out; if a != ex_ee_block, only tail is removed and the memmove path is not taken",
              "evidence": [
                "fs/ext4/extents.c:2730 -> a = ex_ee_block > start ? ex_ee_block : start;",
                "fs/ext4/extents.c:2730 -> b = ex_ee_block+ex_ee_len - 1 < end ?",
                "fs/ext4/extents.c:2730 -> } else if (b != ex_ee_block + ex_ee_len - 1) {",
                "fs/ext4/extents.c:2730 -> } else if (a != ex_ee_block) {",
                "fs/ext4/extents.c:2730 -> } else {",
                "fs/ext4/extents.c:2730 -> \t\t\tnum = 0;"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "if (end < ex_ee_block) {\n\t\t\t...\n\t\t\tex--;\n\t\t\t...\n\t\t\tcontinue;",
              "condition": "end >= ex_ee_block (to avoid skipping this extent and to reach the num == 0 branch)",
              "why_it_blocks": "If end < ex_ee_block, the code continues to the previous extent and will not hit the memmove for this one",
              "evidence": [
                "fs/ext4/extents.c:2730 -> \t\t/* If this extent is beyond the end of the hole, skip it */",
                "fs/ext4/extents.c:2730 -> \t\tif (end < ex_ee_block) {",
                "fs/ext4/extents.c:2730 -> \t\t\tcontinue;"
              ]
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "err = ext4_datasem_ensure_credits(handle, inode, credits,\n\t\t\t\t\t\t\t credits, revoke_credits);\n\t\tif (err) {\n\t\t\tif (err > 0)\n\t\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = ext4_remove_blocks(handle, inode, ex, partial, a, b);\n\t\tif (err)\n\t\t\tgoto out;",
              "condition": "ext4_datasem_ensure_credits == 0, ext4_ext_get_access == 0, and ext4_remove_blocks == 0",
              "why_it_blocks": "Any error here causes an early exit prior to executing the memmove",
              "evidence": [
                "fs/ext4/extents.c:2730 -> err = ext4_datasem_ensure_credits(handle, inode, credits,",
                "fs/ext4/extents.c:2730 -> \t\tif (err) {",
                "fs/ext4/extents.c:2730 -> err = ext4_ext_get_access(handle, inode, path + depth);",
                "fs/ext4/extents.c:2730 -> \t\tif (err)",
                "fs/ext4/extents.c:2730 -> err = ext4_remove_blocks(handle, inode, ex, partial, a, b);",
                "fs/ext4/extents.c:2730 -> \t\tif (err)"
              ]
            }
          ]
        },
        "path_constraints": {
          "input": [
            {
              "file": "fs/ext4/extents.c",
              "line": 2952,
              "code": "if (end < EXT_MAX_BLOCKS - 1) {",
              "condition": "Request defines a hole-punch range (end < EXT_MAX_BLOCKS - 1)",
              "why_it_blocks": "Sets up punching-specific logic and allows the later memmove guarded by end != EXT_MAX_BLOCKS - 1"
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "a = ex_ee_block > start ? ex_ee_block : start;",
              "condition": "start <= ex_ee_block (so that a == ex_ee_block)",
              "why_it_blocks": "Ensures whole-extent removal (num == 0) instead of tail removal"
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "b = ex_ee_block+ex_ee_len - 1 < end ?\n\t\t\tex_ee_block+ex_ee_len - 1 : end;",
              "condition": "end >= ex_ee_block + ex_ee_len - 1 (so that b == ex_end)",
              "why_it_blocks": "Avoids the EFSCORRUPTED early exit and selects the whole-extent removal path"
            }
          ],
          "kernel_state": [
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "while (ex >= EXT_FIRST_EXTENT(eh) &&\n\t\t\tex_ee_block + ex_ee_len > start) {",
              "condition": "There exists a leaf extent ex such that ex >= EXT_FIRST_EXTENT(eh) and ex_ee_block + ex_ee_len > start",
              "why_it_blocks": "The loop must execute at least once to reach the removal and memmove logic"
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "if (end < ex_ee_block) { ... continue; }",
              "condition": "The targeted extent is not beyond the punched range (end >= ex_ee_block)",
              "why_it_blocks": "Prevents skipping the extent and failing to reach the num==0/memmove path"
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "} else if (b != ex_ee_block + ex_ee_len - 1) { ... err = -EFSCORRUPTED; goto out; }",
              "condition": "b equals ex_ee_block + ex_ee_len - 1 (i.e., end covers the end of this extent)",
              "why_it_blocks": "Otherwise an error is raised and we exit before the memmove"
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "} else if (a != ex_ee_block) { ... } else { ... num = 0; }",
              "condition": "a equals ex_ee_block (i.e., start covers the beginning of this extent), yielding num == 0",
              "why_it_blocks": "Only num == 0 triggers the memmove that crashed"
            },
            {
              "file": "fs/ext4/extents.c",
              "line": 2730,
              "code": "if (num == 0) {\n\t\t\tif (end != EXT_MAX_BLOCKS - 1) {\n\t\t\t\t/* ... */\n\t\t\t\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *",
              "condition": "Whole extent removed (num == 0) and punching case (end != EXT_MAX_BLOCKS - 1)",
              "why_it_blocks": "Direct guard for executing the memmove where the OOB occurred"
            }
          ]
        }
      }
    },
    "summary": null,
    "combined": {
      "local": {
        "ok": true,
        "answer": " Here is the JSON output for the provided crash log and code snippets:\n\n{\n\"preconditions\": {\n\"input_constraints\": [\n{\n\"file\": \"fs/ext4/extents.c\",\n\"line\": 2730,\n\"code\": \"if (start < 0 || end > max_blocks)\",\n\"condition\": \"0 <= start <= end <= max_blocks\",\n\"why_it_blocks\": \"Invalid block range prevents entering ext4_ext_rm_leaf\",\n\"evidence\": [\"fs/ext4/extents.c:2725 -> if (start < 0 || end > max_blocks)\"]\n}\n],\n\"kernel_state\": [\n{\n\"file\": \"fs/ext4/extents.c\",\n\"line\": 2952,\n\"code\": \"if (!path[depth].p_hdr)\",\n\"condition\": \"path[depth].p_hdr must be non-NULL\",\n\"why_it_blocks\": \"NULL header aborts before leaf removal\",\n\"evidence\": [\"fs/ext4/extents.c:2952 -> if (!path[depth].p_hdr)\"]\n}\n]\n},\n\"path_constraints\": {\n\"input\": [\n{ \"file\": \"...\", \"line\": ..., \"code\": \"...\", \"condition\": \"...\", \"why_it_blocks\": \"...\" }\n],\n\"kernel_state\": [\n{ \"file\": \"...\", \"line\": ..., \"code\": \"...\", \"condition\": \"...\", \"why_it_blocks\": \"...\" }\n]\n}\n}\n\nNote that the \"path_constraints\" section is empty because the provided crash log does not include any information about the path constraints.",
        "provider": "transformers_direct",
        "model": "meta-llama/CodeLlama-34b-Instruct-hf",
        "analysis": null
      },
      "openai": "{\n  \"preconditions\": {\n    \"input_constraints\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (end < EXT_MAX_BLOCKS - 1) {\",\n        \"condition\": \"end < EXT_MAX_BLOCKS - 1\",\n        \"why_it_blocks\": \"Only the hole-punching path (not EOF truncate) sets up conditions that can lead to the memmove in ext4_ext_rm_leaf\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> if (end < EXT_MAX_BLOCKS - 1) {\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (num == 0) {\\n\\t\\t\\tif (end != EXT_MAX_BLOCKS - 1) {\\n\\t\\t\\t\\t/* ... */\\n\\t\\t\\t\\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\",\n        \"condition\": \"end != EXT_MAX_BLOCKS - 1\",\n        \"why_it_blocks\": \"The memmove that crashed only runs for hole punching (end != EXT_MAX_BLOCKS - 1)\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> if (num == 0) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\tif (end != EXT_MAX_BLOCKS - 1) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\t\\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\"\n        ]\n      }\n    ],\n    \"kernel_state\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"handle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\\n\\t\\t\\tdepth + 1,\\n\\t\\t\\text4_free_metadata_revoke_credits(inode->i_sb, depth));\\nif (IS_ERR(handle))\\n\\treturn PTR_ERR(handle);\",\n        \"condition\": \"ext4_journal_start_with_revoke returns a valid handle (not IS_ERR)\",\n        \"why_it_blocks\": \"Failure to start a journal transaction causes an early return before any extent removal\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> handle = ext4_journal_start_with_revoke(inode, EXT4_HT_TRUNCATE,\",\n          \"fs/ext4/extents.c:2952 -> if (IS_ERR(handle))\",\n          \"fs/ext4/extents.c:2952 -> \\treturn PTR_ERR(handle);\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"path = ext4_find_extent(inode, end, NULL,\\n\\t\\t\\t\\t\\tEXT4_EX_NOCACHE | EXT4_EX_NOFAIL);\\nif (IS_ERR(path)) {\\n\\t\\t\\text4_journal_stop(handle);\\n\\t\\t\\treturn PTR_ERR(path);\\n\\t\\t}\",\n        \"condition\": \"ext4_find_extent returns a valid path (not IS_ERR)\",\n        \"why_it_blocks\": \"An error from ext4_find_extent aborts before descending into the leaf and calling ext4_ext_rm_leaf\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> path = ext4_find_extent(inode, end, NULL,\",\n          \"fs/ext4/extents.c:2952 -> if (IS_ERR(path)) {\",\n          \"fs/ext4/extents.c:2952 -> \\t\\t\\treturn PTR_ERR(path);\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"ex = path[depth].p_ext;\\nif (!ex) {\\n\\tif (depth) {\\n\\t\\tEXT4_ERROR_INODE(inode,\\n\\t\\t\\t\\t \\\"path[%d].p_hdr == NULL\\\",\\n\\t\\t\\t\\t depth);\\n\\t\\terr = -EFSCORRUPTED;\\n\\t}\\n\\tgoto out;\\n}\",\n        \"condition\": \"path[depth].p_ext is non-NULL (a leaf extent exists)\",\n        \"why_it_blocks\": \"A missing leaf extent results in an error and early exit before removal\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> ex = path[depth].p_ext;\",\n          \"fs/ext4/extents.c:2952 -> if (!ex) {\",\n          \"fs/ext4/extents.c:2952 -> \\terr = -EFSCORRUPTED;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (path == NULL) {\\n\\t\\t\\text4_journal_stop(handle);\\n\\t\\t\\treturn -ENOMEM;\\n\\t\\t}\",\n        \"condition\": \"path allocation/initialization succeeds (path != NULL)\",\n        \"why_it_blocks\": \"A NULL path causes immediate return before any leaf processing\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> if (path == NULL) {\",\n          \"fs/ext4/extents.c:2952 -> \\t\\t\\treturn -ENOMEM;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\\n\\t\\terr = -EFSCORRUPTED;\\n\\t\\tgoto out;\\n\\t}\",\n        \"condition\": \"ext4_ext_check returns 0 (extent header is valid)\",\n        \"why_it_blocks\": \"Extent tree header corruption causes an early exit before removing space\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2952 -> if (ext4_ext_check(inode, path[0].p_hdr, depth, 0)) {\",\n          \"fs/ext4/extents.c:2952 -> \\t\\terr = -EFSCORRUPTED;\",\n          \"fs/ext4/extents.c:2952 -> \\t\\tgoto out;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (!path[depth].p_hdr)\\n\\t\\tpath[depth].p_hdr = ext_block_hdr(path[depth].p_bh);\\neh = path[depth].p_hdr;\\nif (unlikely(path[depth].p_hdr == NULL)) {\\n\\t\\tEXT4_ERROR_INODE(inode, \\\"path[%d].p_hdr == NULL\\\", depth);\\n\\t\\treturn -EFSCORRUPTED;\\n\\t}\",\n        \"condition\": \"path[depth].p_hdr is non-NULL (leaf header available)\",\n        \"why_it_blocks\": \"A NULL leaf header returns -EFSCORRUPTED before any extent iteration\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> if (!path[depth].p_hdr)\",\n          \"fs/ext4/extents.c:2730 -> if (unlikely(path[depth].p_hdr == NULL)) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\treturn -EFSCORRUPTED;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"a = ex_ee_block > start ? ex_ee_block : start;\\n\\t\\tb = ex_ee_block+ex_ee_len - 1 < end ?\\n\\t\\t\\tex_ee_block+ex_ee_len - 1 : end;\\n...\\n\\t\\t} else if (b != ex_ee_block + ex_ee_len - 1) {\\n\\t\\t\\tEXT4_ERROR_INODE(inode,\\n\\t\\t\\t\\t\\t \\\"can not handle truncate %u:%u \\\"\\n\\t\\t\\t\\t\\t \\\"on extent %u:%u\\\",\\n\\t\\t\\t\\t\\t start, end, ex_ee_block,\\n\\t\\t\\t\\t\\t ex_ee_block + ex_ee_len - 1);\\n\\t\\t\\terr = -EFSCORRUPTED;\\n\\t\\t\\tgoto out;\\n\\t\\t} else if (a != ex_ee_block) {\\n\\t\\t\\t/* remove tail of the extent */\\n\\t\\t\\tnum = a - ex_ee_block;\\n\\t\\t} else {\\n\\t\\t\\t/* remove whole extent: excellent! */\\n\\t\\t\\tnum = 0;\\n\\t\\t}\",\n        \"condition\": \"With a = max(ex_ee_block,start) and b = min(ex_end,end), we must have b == ex_end and a == ex_ee_block so that num == 0 (whole extent removed), avoiding the EFSCORRUPTED early exit\",\n        \"why_it_blocks\": \"If b != ex_end, function errors out; if a != ex_ee_block, only tail is removed and the memmove path is not taken\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> a = ex_ee_block > start ? ex_ee_block : start;\",\n          \"fs/ext4/extents.c:2730 -> b = ex_ee_block+ex_ee_len - 1 < end ?\",\n          \"fs/ext4/extents.c:2730 -> } else if (b != ex_ee_block + ex_ee_len - 1) {\",\n          \"fs/ext4/extents.c:2730 -> } else if (a != ex_ee_block) {\",\n          \"fs/ext4/extents.c:2730 -> } else {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\tnum = 0;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (end < ex_ee_block) {\\n\\t\\t\\t...\\n\\t\\t\\tex--;\\n\\t\\t\\t...\\n\\t\\t\\tcontinue;\",\n        \"condition\": \"end >= ex_ee_block (to avoid skipping this extent and to reach the num == 0 branch)\",\n        \"why_it_blocks\": \"If end < ex_ee_block, the code continues to the previous extent and will not hit the memmove for this one\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> \\t\\t/* If this extent is beyond the end of the hole, skip it */\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (end < ex_ee_block) {\",\n          \"fs/ext4/extents.c:2730 -> \\t\\t\\tcontinue;\"\n        ]\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"err = ext4_datasem_ensure_credits(handle, inode, credits,\\n\\t\\t\\t\\t\\t\\t  credits, revoke_credits);\\n\\t\\tif (err) {\\n\\t\\t\\tif (err > 0)\\n\\t\\t\\t\\terr = -EAGAIN;\\n\\t\\t\\tgoto out;\\n\\t\\t}\\n\\n\\t\\terr = ext4_ext_get_access(handle, inode, path + depth);\\n\\t\\tif (err)\\n\\t\\t\\tgoto out;\\n\\n\\t\\terr = ext4_remove_blocks(handle, inode, ex, partial, a, b);\\n\\t\\tif (err)\\n\\t\\t\\tgoto out;\",\n        \"condition\": \"ext4_datasem_ensure_credits == 0, ext4_ext_get_access == 0, and ext4_remove_blocks == 0\",\n        \"why_it_blocks\": \"Any error here causes an early exit prior to executing the memmove\",\n        \"evidence\": [\n          \"fs/ext4/extents.c:2730 -> err = ext4_datasem_ensure_credits(handle, inode, credits,\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (err) {\",\n          \"fs/ext4/extents.c:2730 -> err = ext4_ext_get_access(handle, inode, path + depth);\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (err)\",\n          \"fs/ext4/extents.c:2730 -> err = ext4_remove_blocks(handle, inode, ex, partial, a, b);\",\n          \"fs/ext4/extents.c:2730 -> \\t\\tif (err)\"\n        ]\n      }\n    ]\n  },\n  \"path_constraints\": {\n    \"input\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2952,\n        \"code\": \"if (end < EXT_MAX_BLOCKS - 1) {\",\n        \"condition\": \"Request defines a hole-punch range (end < EXT_MAX_BLOCKS - 1)\",\n        \"why_it_blocks\": \"Sets up punching-specific logic and allows the later memmove guarded by end != EXT_MAX_BLOCKS - 1\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"a = ex_ee_block > start ? ex_ee_block : start;\",\n        \"condition\": \"start <= ex_ee_block (so that a == ex_ee_block)\",\n        \"why_it_blocks\": \"Ensures whole-extent removal (num == 0) instead of tail removal\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"b = ex_ee_block+ex_ee_len - 1 < end ?\\n\\t\\t\\tex_ee_block+ex_ee_len - 1 : end;\",\n        \"condition\": \"end >= ex_ee_block + ex_ee_len - 1 (so that b == ex_end)\",\n        \"why_it_blocks\": \"Avoids the EFSCORRUPTED early exit and selects the whole-extent removal path\"\n      }\n    ],\n    \"kernel_state\": [\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"while (ex >= EXT_FIRST_EXTENT(eh) &&\\n\\t\\t\\tex_ee_block + ex_ee_len > start) {\",\n        \"condition\": \"There exists a leaf extent ex such that ex >= EXT_FIRST_EXTENT(eh) and ex_ee_block + ex_ee_len > start\",\n        \"why_it_blocks\": \"The loop must execute at least once to reach the removal and memmove logic\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (end < ex_ee_block) { ... continue; }\",\n        \"condition\": \"The targeted extent is not beyond the punched range (end >= ex_ee_block)\",\n        \"why_it_blocks\": \"Prevents skipping the extent and failing to reach the num==0/memmove path\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"} else if (b != ex_ee_block + ex_ee_len - 1) { ... err = -EFSCORRUPTED; goto out; }\",\n        \"condition\": \"b equals ex_ee_block + ex_ee_len - 1 (i.e., end covers the end of this extent)\",\n        \"why_it_blocks\": \"Otherwise an error is raised and we exit before the memmove\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"} else if (a != ex_ee_block) { ... } else { ... num = 0; }\",\n        \"condition\": \"a equals ex_ee_block (i.e., start covers the beginning of this extent), yielding num == 0\",\n        \"why_it_blocks\": \"Only num == 0 triggers the memmove that crashed\"\n      },\n      {\n        \"file\": \"fs/ext4/extents.c\",\n        \"line\": 2730,\n        \"code\": \"if (num == 0) {\\n\\t\\t\\tif (end != EXT_MAX_BLOCKS - 1) {\\n\\t\\t\\t\\t/* ... */\\n\\t\\t\\t\\tmemmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *\",\n        \"condition\": \"Whole extent removed (num == 0) and punching case (end != EXT_MAX_BLOCKS - 1)\",\n        \"why_it_blocks\": \"Direct guard for executing the memmove where the OOB occurred\"\n      }\n    ]\n  }\n}"
    }
  }
}