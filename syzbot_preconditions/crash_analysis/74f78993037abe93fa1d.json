{
  "parsed": {
    "kind": "KASAN: slab-out-of-bounds in __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]",
    "access": {
      "op": "read",
      "size": 4,
      "addr": "ffff88811471cbc0"
    },
    "object_info": {
      "obj_addr": "ffff88811471c800",
      "cache": "kmalloc-1k",
      "obj_size": 1024,
      "offset": 960,
      "region": {
        "start": "ffff88811471c800",
        "end": "ffff88811471cc00"
      }
    },
    "allocated_by": [
      "Allocated by task 817:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#45'>mm/kasan/common.c:45</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#430'>mm/kasan/common.c:430</a> [inline]\n ____kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#509'>mm/kasan/common.c:509</a> [inline]\n __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>\n kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/kasan.h#254'>include/linux/kasan.h:254</a> [inline]\n __kmalloc+0x1a7/0x330 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033'>mm/slub.c:4033</a>\n __kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418'>include/linux/slab.h:418</a> [inline]\n kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575'>include/linux/slab.h:575</a> [inline]\n kvmalloc_node+0x88/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612'>mm/util.c:612</a>\n kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833'>include/linux/mm.h:833</a> [inline]\n f2fs_kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374'>fs/f2fs/f2fs.h:3374</a> [inline]\n f2fs_kvzalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380'>fs/f2fs/f2fs.h:3380</a> [inline]\n build_sit_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395'>fs/f2fs/segment.c:4395</a> [inline]\n f2fs_build_segment_manager+0xdba/0x48f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258'>fs/f2fs/segment.c:5258</a>\n f2fs_fill_super+0x42d1/0x6c70 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315'>fs/f2fs/super.c:4315</a>\n mount_bdev+0x28b/0x3a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442'>fs/super.c:1442</a>\n f2fs_mount+0x34/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595'>fs/f2fs/super.c:4595</a>\n legacy_get_tree+0xed/0x190 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593'>fs/fs_context.c:593</a>\n vfs_get_tree+0x89/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572'>fs/super.c:1572</a>\n do_new_mount+0x25a/0xa20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997'>fs/namespace.c:2997</a>\n path_mount+0x572/0xc80 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327'>fs/namespace.c:3327</a>\n do_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340'>fs/namespace.c:3340</a> [inline]\n __do_sys_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548'>fs/namespace.c:3548</a> [inline]\n __se_sys_mount+0x318/0x380 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n __x64_sys_mount+0xbf/0xd0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb"
    ],
    "freed_by": [],
    "link_frames": [
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257",
        "file": "fs/f2fs/segment.c",
        "line": 2257
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663",
        "file": "fs/f2fs/segment.c",
        "line": 2663
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77",
        "file": "lib/dump_stack.c",
        "line": 77
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118",
        "file": "lib/dump_stack.c",
        "line": 118
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257",
        "file": "fs/f2fs/segment.c",
        "line": 2257
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663",
        "file": "fs/f2fs/segment.c",
        "line": 2663
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723",
        "file": "fs/f2fs/segment.c",
        "line": 2723
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039",
        "file": "fs/f2fs/segment.c",
        "line": 3039
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047",
        "file": "fs/f2fs/segment.c",
        "line": 3047
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054",
        "file": "fs/f2fs/segment.c",
        "line": 3054
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720",
        "file": "fs/f2fs/file.c",
        "line": 1720
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825",
        "file": "fs/f2fs/file.c",
        "line": 1825
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310",
        "file": "fs/open.c",
        "line": 310
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494",
        "file": "fs/ioctl.c",
        "line": 494
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732",
        "file": "fs/ioctl.c",
        "line": 732
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751",
        "file": "fs/ioctl.c",
        "line": 751
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033",
        "file": "mm/slub.c",
        "line": 4033
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418",
        "file": "include/linux/slab.h",
        "line": 418
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575",
        "file": "include/linux/slab.h",
        "line": 575
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612",
        "file": "mm/util.c",
        "line": 612
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833",
        "file": "include/linux/mm.h",
        "line": 833
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374",
        "file": "fs/f2fs/f2fs.h",
        "line": 3374
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380",
        "file": "fs/f2fs/f2fs.h",
        "line": 3380
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395",
        "file": "fs/f2fs/segment.c",
        "line": 4395
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258",
        "file": "fs/f2fs/segment.c",
        "line": 5258
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315",
        "file": "fs/f2fs/super.c",
        "line": 4315
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442",
        "file": "fs/super.c",
        "line": 1442
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595",
        "file": "fs/f2fs/super.c",
        "line": 4595
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593",
        "file": "fs/fs_context.c",
        "line": 593
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572",
        "file": "fs/super.c",
        "line": 1572
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997",
        "file": "fs/namespace.c",
        "line": 2997
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327",
        "file": "fs/namespace.c",
        "line": 3327
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340",
        "file": "fs/namespace.c",
        "line": 3340
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548",
        "file": "fs/namespace.c",
        "line": 3548
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525",
        "file": "fs/namespace.c",
        "line": 3525
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525",
        "file": "fs/namespace.c",
        "line": 3525
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35",
        "file": "include/linux/page_owner.h",
        "line": 35
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456",
        "file": "mm/page_alloc.c",
        "line": 2456
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462",
        "file": "mm/page_alloc.c",
        "line": 2462
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254",
        "file": "mm/page_alloc.c",
        "line": 4254
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370",
        "file": "mm/page_alloc.c",
        "line": 5370
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808",
        "file": "mm/slub.c",
        "line": 1808
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869",
        "file": "mm/slub.c",
        "line": 1869
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627",
        "file": "mm/slub.c",
        "line": 2627
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791",
        "file": "mm/slub.c",
        "line": 2791
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831",
        "file": "mm/slub.c",
        "line": 2831
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913",
        "file": "mm/slub.c",
        "line": 2913
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955",
        "file": "mm/slub.c",
        "line": 2955
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536",
        "file": "mm/slub.c",
        "line": 4536
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144",
        "file": "net/core/skbuff.c",
        "line": 144
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212",
        "file": "net/core/skbuff.c",
        "line": 212
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126",
        "file": "include/linux/skbuff.h",
        "line": 1126
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178",
        "file": "net/netlink/af_netlink.c",
        "line": 1178
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889",
        "file": "net/netlink/af_netlink.c",
        "line": 1889
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652",
        "file": "net/socket.c",
        "line": 652
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664",
        "file": "net/socket.c",
        "line": 664
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376",
        "file": "net/socket.c",
        "line": 2376
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430",
        "file": "net/socket.c",
        "line": 2430
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459",
        "file": "net/socket.c",
        "line": 2459
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468",
        "file": "net/socket.c",
        "line": 2468
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466",
        "file": "net/socket.c",
        "line": 2466
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466",
        "file": "net/socket.c",
        "line": 2466
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481",
        "file": "fs/f2fs/segment.c",
        "line": 3481
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407",
        "file": "fs/f2fs/data.c",
        "line": 1407
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575",
        "file": "fs/f2fs/data.c",
        "line": 1575
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724",
        "file": "fs/f2fs/file.c",
        "line": 1724
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825",
        "file": "fs/f2fs/file.c",
        "line": 1825
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310",
        "file": "fs/open.c",
        "line": 310
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494",
        "file": "fs/ioctl.c",
        "line": 494
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732",
        "file": "fs/ioctl.c",
        "line": 732
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751",
        "file": "fs/ioctl.c",
        "line": 751
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      }
    ],
    "frames": [],
    "raw": "R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\n---[ end trace b21af47fc54341fe ]---\n==================================================================\nBUG: KASAN: slab-out-of-bounds in __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]\nBUG: KASAN: slab-out-of-bounds in reset_curseg+0x4dd/0x560 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663'>fs/f2fs/segment.c:2663</a>\nRead of size 4 at addr ffff88811471cbc0 by task syz.6.85/837\n\nCPU: 0 PID: 837 Comm: syz.6.85 Tainted: G        W         syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/14/2025\nCall Trace:\n __dump_stack+0x21/0x24 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77'>lib/dump_stack.c:77</a>\n dump_stack_lvl+0x169/0x1d8 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118'>lib/dump_stack.c:118</a>\n print_address_description+0x7f/0x2c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#248'>mm/kasan/report.c:248</a>\n __kasan_report <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#435'>mm/kasan/report.c:435</a> [inline]\n kasan_report+0xe2/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#452'>mm/kasan/report.c:452</a>\n __asan_report_load4_noabort+0x14/0x20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report_generic.c#308'>mm/kasan/report_generic.c:308</a>\n __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]\n reset_curseg+0x4dd/0x560 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663'>fs/f2fs/segment.c:2663</a>\n new_curseg+0x12f6/0x18a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723'>fs/f2fs/segment.c:2723</a>\n __allocate_new_segment+0x13d/0x810 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039'>fs/f2fs/segment.c:3039</a>\n __allocate_new_section <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047'>fs/f2fs/segment.c:3047</a> [inline]\n f2fs_allocate_new_section+0x1d5/0x280 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054'>fs/f2fs/segment.c:3054</a>\n expand_inode_data+0x5a8/0x930 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720'>fs/f2fs/file.c:1720</a>\n f2fs_fallocate+0x42b/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825'>fs/f2fs/file.c:1825</a>\n vfs_fallocate+0x4b4/0x590 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310'>fs/open.c:310</a>\n ioctl_preallocate <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494'>fs/ioctl.c:494</a> [inline]\n file_ioctl fs/ioctl.c:-1 [inline]\n do_vfs_ioctl+0x12e3/0x1510 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x9f/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\nRIP: 0033:0x7feae1e11be9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007feae1c40038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007feae2049180 RCX: 00007feae1e11be9\nRDX: 00002000000000c0 RSI: 0000000040305828 RDI: 0000000000000005\nRBP: 00007feae1e94e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\n\nAllocated by task 817:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#45'>mm/kasan/common.c:45</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#430'>mm/kasan/common.c:430</a> [inline]\n ____kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#509'>mm/kasan/common.c:509</a> [inline]\n __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>\n kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/kasan.h#254'>include/linux/kasan.h:254</a> [inline]\n __kmalloc+0x1a7/0x330 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033'>mm/slub.c:4033</a>\n __kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418'>include/linux/slab.h:418</a> [inline]\n kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575'>include/linux/slab.h:575</a> [inline]\n kvmalloc_node+0x88/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612'>mm/util.c:612</a>\n kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833'>include/linux/mm.h:833</a> [inline]\n f2fs_kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374'>fs/f2fs/f2fs.h:3374</a> [inline]\n f2fs_kvzalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380'>fs/f2fs/f2fs.h:3380</a> [inline]\n build_sit_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395'>fs/f2fs/segment.c:4395</a> [inline]\n f2fs_build_segment_manager+0xdba/0x48f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258'>fs/f2fs/segment.c:5258</a>\n f2fs_fill_super+0x42d1/0x6c70 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315'>fs/f2fs/super.c:4315</a>\n mount_bdev+0x28b/0x3a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442'>fs/super.c:1442</a>\n f2fs_mount+0x34/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595'>fs/f2fs/super.c:4595</a>\n legacy_get_tree+0xed/0x190 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593'>fs/fs_context.c:593</a>\n vfs_get_tree+0x89/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572'>fs/super.c:1572</a>\n do_new_mount+0x25a/0xa20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997'>fs/namespace.c:2997</a>\n path_mount+0x572/0xc80 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327'>fs/namespace.c:3327</a>\n do_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340'>fs/namespace.c:3340</a> [inline]\n __do_sys_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548'>fs/namespace.c:3548</a> [inline]\n __se_sys_mount+0x318/0x380 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n __x64_sys_mount+0xbf/0xd0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\n\nThe buggy address belongs to the object at ffff88811471c800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 960 bytes inside of\n 1024-byte region [ffff88811471c800, ffff88811471cc00)\nThe buggy address belongs to the page:\npage:ffffea000451c600 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x114718\nhead:ffffea000451c600 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x4000000000010200(slab|head)\nraw: 4000000000010200 ffffea0004522200 0000000300000003 ffff888100042f00\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0xd20c0(__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 95, ts 5090814031, free_ts 0\n set_page_owner <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35'>include/linux/page_owner.h:35</a> [inline]\n post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456'>mm/page_alloc.c:2456</a> [inline]\n prep_new_page+0x179/0x180 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462'>mm/page_alloc.c:2462</a>\n get_page_from_freelist+0x2235/0x23d0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254'>mm/page_alloc.c:4254</a>\n __alloc_pages_nodemask+0x268/0x5f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370'>mm/page_alloc.c:5370</a>\n alloc_slab_page mm/slub.c:-1 [inline]\n allocate_slab <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808'>mm/slub.c:1808</a> [inline]\n new_slab+0x84/0x3f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869'>mm/slub.c:1869</a>\n new_slab_objects <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627'>mm/slub.c:2627</a> [inline]\n ___slab_alloc+0x2a6/0x450 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791'>mm/slub.c:2791</a>\n __slab_alloc+0x63/0xa0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831'>mm/slub.c:2831</a>\n slab_alloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913'>mm/slub.c:2913</a> [inline]\n slab_alloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955'>mm/slub.c:2955</a> [inline]\n __kmalloc_track_caller+0x1ef/0x320 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536'>mm/slub.c:4536</a>\n __kmalloc_reserve <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144'>net/core/skbuff.c:144</a> [inline]\n __alloc_skb+0xdc/0x520 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212'>net/core/skbuff.c:212</a>\n alloc_skb <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126'>include/linux/skbuff.h:1126</a> [inline]\n netlink_alloc_large_skb <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178'>net/netlink/af_netlink.c:1178</a> [inline]\n netlink_sendmsg+0x5f6/0xb30 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889'>net/netlink/af_netlink.c:1889</a>\n sock_sendmsg_nosec <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652'>net/socket.c:652</a> [inline]\n __sock_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664'>net/socket.c:664</a> [inline]\n ____sys_sendmsg+0x5a2/0x8c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376'>net/socket.c:2376</a>\n ___sys_sendmsg+0x1f0/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430'>net/socket.c:2430</a>\n __sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459'>net/socket.c:2459</a> [inline]\n __do_sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468'>net/socket.c:2468</a> [inline]\n __se_sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466'>net/socket.c:2466</a> [inline]\n __x64_sys_sendmsg+0x1e2/0x2a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466'>net/socket.c:2466</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\npage_owner free stack trace missing\n\nMemory state around the buggy address:\n ffff88811471ca80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88811471cb00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88811471cb80: 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc fc\n                                           ^\n ffff88811471cc00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff88811471cc80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n==================================================================\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nCPU: 1 PID: 837 Comm: syz.6.85 Tainted: G    B   W         syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/14/2025\nRIP: 0010:update_sit_entry+0x3eb/0xf50 fs/f2fs/segment.c:-1\nCode: 89 45 a8 49 01 c5 41 f6 d7 41 80 e7 07 44 89 f9 41 bf 01 00 00 00 41 d3 e7 4d 89 ee 49 c1 ee 03 48 b8 00 00 00 00 00 fc ff df <41> 0f b6 04 06 84 c0 0f 85 a5 08 00 00 41 0f b6 5d 00 44 89 f8 41\nRSP: 0018:ffffc90001207350 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88811471cbc8 RCX: 0000000000000007\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88811471cbc8\nRBP: ffffc900012073d0 R08: ffff888115c193c0 R09: 0000000000000003\nR10: 00000000ffffffff R11: 0000000000000000 R12: 0000000000004000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000080\nFS:  00007feae1c406c0(0000) GS:ffff8881f7100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffd90c62f98 CR3: 0000000127a9b000 CR4: 00000000003506a0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n f2fs_allocate_data_block+0x156b/0x3a10 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481'>fs/f2fs/segment.c:3481</a>\n __allocate_data_block+0x52a/0x980 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407'>fs/f2fs/data.c:1407</a>\n f2fs_map_blocks+0xdc8/0x35c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575'>fs/f2fs/data.c:1575</a>\n expand_inode_data+0x5d7/0x930 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724'>fs/f2fs/file.c:1724</a>\n f2fs_fallocate+0x42b/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825'>fs/f2fs/file.c:1825</a>\n vfs_fallocate+0x4b4/0x590 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310'>fs/open.c:310</a>\n ioctl_preallocate <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494'>fs/ioctl.c:494</a> [inline]\n file_ioctl fs/ioctl.c:-1 [inline]\n do_vfs_ioctl+0x12e3/0x1510 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x9f/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\nRIP: 0033:0x7feae1e11be9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007feae1c40038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007feae2049180 RCX: 00007feae1e11be9\nRDX: 00002000000000c0 RSI: 0000000040305828 RDI: 0000000000000005\nRBP: 00007feae1e94e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\nModules linked in:\n---[ end trace b21af47fc54341ff ]---\nRIP: 0010:update_sit_entry+0x3eb/0xf50 fs/f2fs/segment.c:-1\nCode: 89 45 a8 49 01 c5 41 f6 d7 41 80 e7 07 44 89 f9 41 bf 01 00 00 00 41 d3 e7 4d 89 ee 49 c1 ee 03 48 b8 00 00 00 00 00 fc ff df <41> 0f b6 04 06 84 c0 0f 85 a5 08 00 00 41 0f b6 5d 00 44 89 f8 41\nRSP: 0018:ffffc90001207350 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88811471cbc8 RCX: 0000000000000007\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88811471cbc8\nRBP: ffffc900012073d0 R08: ffff888115c193c0 R09: 0000000000000003\nR10: 00000000ffffffff R11: 0000000000000000 R12: 0000000000004000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000080\nFS:  00007feae1c406c0(0000) GS:ffff8881f7100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f0f2e064000 CR3: 0000000127a9b000 CR4: 00000000003506a0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n----------------\nCode disassembly (best guess):\n   0:\t89 45 a8             \tmov    %eax,-0x58(%rbp)\n   3:\t49 01 c5             \tadd    %rax,%r13\n   6:\t41 f6 d7             \tnot    %r15b\n   9:\t41 80 e7 07          \tand    $0x7,%r15b\n   d:\t44 89 f9             \tmov    %r15d,%ecx\n  10:\t41 bf 01 00 00 00    \tmov    $0x1,%r15d\n  16:\t41 d3 e7             \tshl    %cl,%r15d\n  19:\t4d 89 ee             \tmov    %r13,%r14\n  1c:\t49 c1 ee 03          \tshr    $0x3,%r14\n  20:\t48 b8 00 00 00 00 00 \tmovabs $0xdffffc0000000000,%rax\n  27:\tfc ff df\n* 2a:\t41 0f b6 04 06       \tmovzbl (%r14,%rax,1),%eax <-- trapping instruction\n  2f:\t84 c0                \ttest   %al,%al\n  31:\t0f 85 a5 08 00 00    \tjne    0x8dc\n  37:\t41 0f b6 5d 00       \tmovzbl 0x0(%r13),%ebx\n  3c:\t44 89 f8             \tmov    %r15d,%eax\n  3f:\t41                   \trex.B\n"
  },
  "snippets": {
    "urls": {
      "https://android.googlesource.com/kernel/common/": {
        "error": "URL not in expected +/commit/path format"
      }
    },
    "links": {
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257#2257": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257",
        "file": "fs/f2fs/segment.c",
        "line": 2257,
        "function_snippet": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\n\tse->type = type;"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663#2663": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663",
        "file": "fs/f2fs/segment.c",
        "line": 2663,
        "function_snippet": "\t__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77#77": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77",
        "file": "lib/dump_stack.c",
        "line": 77,
        "function_snippet": "static void __dump_stack(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\tshow_stack(NULL, NULL, log_lvl);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118#118": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118",
        "file": "lib/dump_stack.c",
        "line": 118,
        "function_snippet": "asmlinkage __visible void dump_stack_lvl(const char *log_lvl)\n{\n\tunsigned long flags;\n\tint was_locked;\n\tint old;\n\tint cpu;\n\n\t/*\n\t * Permit this cpu to perform nested stack dumps while serialising\n\t * against other CPUs\n\t */\nretry:\n\tlocal_irq_save(flags);\n\tcpu = smp_processor_id();\n\told = atomic_cmpxchg(&dump_lock, -1, cpu);\n\tif (old == -1) {\n\t\twas_locked = 0;\n\t} else if (old == cpu) {\n\t\twas_locked = 1;\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t\t/*\n\t\t * Wait for the lock to release before jumping to\n\t\t * atomic_cmpxchg() in order to mitigate the thundering herd\n\t\t * problem.\n\t\t */\n\t\tdo { cpu_relax(); } while (atomic_read(&dump_lock) != -1);\n\t\tgoto retry;\n\t}\n\n\t__dump_stack(log_lvl);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723#2723": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723",
        "file": "fs/f2fs/segment.c",
        "line": 2723,
        "function_snippet": "static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned short seg_type = curseg->seg_type;\n\tunsigned int segno = curseg->segno;\n\tint dir = ALLOC_LEFT;\n\n\tif (curseg->inited)\n\t\twrite_sum_page(sbi, curseg->sum_blk,\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\n\tif (seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA)\n\t\tdir = ALLOC_RIGHT;\n\n\tif (test_opt(sbi, NOHEAP))\n\t\tdir = ALLOC_RIGHT;\n\n\tsegno = __get_next_segno(sbi, type);\n\tget_new_segment(sbi, &segno, new_sec, dir);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 1);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039#3039": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039",
        "file": "fs/f2fs/segment.c",
        "line": 3039,
        "function_snippet": "static void __allocate_new_segment(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\t\tbool new_sec, bool force)\n{\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned int old_segno;\n\n\tif (!curseg->inited)\n\t\tgoto alloc;\n\n\tif (force || curseg->next_blkoff ||\n\t\tget_valid_blocks(sbi, curseg->segno, new_sec))\n\t\tgoto alloc;\n\n\tif (!get_ckpt_valid_blocks(sbi, curseg->segno, new_sec))\n\t\treturn;\nalloc:\n\told_segno = curseg->segno;\n\tnew_curseg(sbi, type, true);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047#3047": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047",
        "file": "fs/f2fs/segment.c",
        "line": 3047,
        "function_snippet": "\t__allocate_new_segment(sbi, type, true, force);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054#3054": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054",
        "file": "fs/f2fs/segment.c",
        "line": 3054,
        "function_snippet": "\t__allocate_new_section(sbi, type, force);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720#1720": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720",
        "file": "fs/f2fs/file.c",
        "line": 1720,
        "function_snippet": "\t\t\tGET_SEC_FROM_SEG(sbi, overprovision_segments(sbi)))) {\n\t\t\tf2fs_down_write(&sbi->gc_lock);\n\t\t\terr = f2fs_gc(sbi, true, false, false, NULL_SEGNO);\n\t\t\tif (err && err != -ENODATA && err != -EAGAIN)\n\t\t\t\tgoto out_err;\n\t\t}\n\n\t\tf2fs_down_write(&sbi->pin_sem);\n\n\t\tf2fs_lock_op(sbi);\n\t\tf2fs_allocate_new_section(sbi, CURSEG_COLD_DATA_PINNED, false);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825#1825": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825",
        "file": "fs/f2fs/file.c",
        "line": 1825,
        "function_snippet": "static long f2fs_fallocate(struct file *file, int mode,\n\t\t\t\tloff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret = 0;\n\n\tif (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))\n\t\treturn -EIO;\n\tif (!f2fs_is_checkpoint_ready(F2FS_I_SB(inode)))\n\t\treturn -ENOSPC;\n\tif (!f2fs_is_compress_backend_ready(inode))\n\t\treturn -EOPNOTSUPP;\n\n\t/* f2fs only support ->fallocate for regular file */\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (IS_ENCRYPTED(inode) &&\n\t\t(mode & (FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_INSERT_RANGE)))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * Pinned file should not support partial trucation since the block\n\t * can be used by applications.\n\t */\n\tif ((f2fs_compressed_file(inode) || f2fs_is_pinned_file(inode)) &&\n\t\t(mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_COLLAPSE_RANGE |\n\t\t\tFALLOC_FL_ZERO_RANGE | FALLOC_FL_INSERT_RANGE)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n\t\t\tFALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE |\n\t\t\tFALLOC_FL_INSERT_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\tinode_lock(inode);\n\n\tret = file_modified(file);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * wait for inflight dio, blocks should be removed after IO\n\t * completion.\n\t */\n\tinode_dio_wait(inode);\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE) {\n\t\tif (offset >= inode->i_size)\n\t\t\tgoto out;\n\n\t\tret = punch_hole(inode, offset, len);\n\t} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n\t\tret = f2fs_collapse_range(inode, offset, len);\n\t} else if (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tret = f2fs_zero_range(inode, offset, len, mode);\n\t} else if (mode & FALLOC_FL_INSERT_RANGE) {\n\t\tret = f2fs_insert_range(inode, offset, len);\n\t} else {\n\t\tret = expand_inode_data(inode, offset, len, mode);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310#310": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310",
        "file": "fs/open.c",
        "line": 310,
        "function_snippet": "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tlong ret;\n\n\tif (offset < 0 || len <= 0)\n\t\treturn -EINVAL;\n\n\t/* Return error if mode is not supported */\n\tif (mode & ~FALLOC_FL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole and zero range are mutually exclusive */\n\tif ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==\n\t    (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Punch hole must have keep size set */\n\tif ((mode & FALLOC_FL_PUNCH_HOLE) &&\n\t    !(mode & FALLOC_FL_KEEP_SIZE))\n\t\treturn -EOPNOTSUPP;\n\n\t/* Collapse range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_COLLAPSE_RANGE) &&\n\t    (mode & ~FALLOC_FL_COLLAPSE_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Insert range should only be used exclusively. */\n\tif ((mode & FALLOC_FL_INSERT_RANGE) &&\n\t    (mode & ~FALLOC_FL_INSERT_RANGE))\n\t\treturn -EINVAL;\n\n\t/* Unshare range should only be used with allocate mode. */\n\tif ((mode & FALLOC_FL_UNSHARE_RANGE) &&\n\t    (mode & ~(FALLOC_FL_UNSHARE_RANGE | FALLOC_FL_KEEP_SIZE)))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\t/*\n\t * We can only allow pure fallocate on append only files\n\t */\n\tif ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))\n\t\treturn -EPERM;\n\n\tif (IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/*\n\t * We cannot allow any fallocate operation on an active swapfile\n\t */\n\tif (IS_SWAPFILE(inode))\n\t\treturn -ETXTBSY;\n\n\t/*\n\t * Revalidate the write permissions, in case security policy has\n\t * changed since the files were opened.\n\t */\n\tret = security_file_permission(file, MAY_WRITE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (S_ISFIFO(inode->i_mode))\n\t\treturn -ESPIPE;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn -EISDIR;\n\n\tif (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))\n\t\treturn -ENODEV;\n\n\t/* Check for wrap through zero too */\n\tif (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))\n\t\treturn -EFBIG;\n\n\tif (!file->f_op->fallocate)\n\t\treturn -EOPNOTSUPP;\n\n\tfile_start_write(file);\n\tret = file->f_op->fallocate(file, mode, offset, len);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494#494": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494",
        "file": "fs/ioctl.c",
        "line": 494,
        "function_snippet": "static int ioctl_preallocate(struct file *filp, int mode, void __user *argp)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct space_resv sr;\n\n\tif (copy_from_user(&sr, argp, sizeof(sr)))\n\t\treturn -EFAULT;\n\n\tswitch (sr.l_whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tsr.l_start += filp->f_pos;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tsr.l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732#732": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732",
        "file": "fs/ioctl.c",
        "line": 732,
        "function_snippet": "\t\t    S_ISLNK(inode->i_mode)) {\n\t\t\tloff_t res = inode_get_bytes(inode);\n\t\t\treturn copy_to_user(argp, &res, sizeof(res)) ?\n\t\t\t\t\t    -EFAULT : 0;\n\t\t}\n\n\t\treturn -ENOTTY;\n\n\tcase FIFREEZE:\n\t\treturn ioctl_fsfreeze(filp);\n\n\tcase FITHAW:\n\t\treturn ioctl_fsthaw(filp);\n\n\tcase FS_IOC_FIEMAP:\n\t\treturn ioctl_fiemap(filp, argp);\n\n\tcase FIGETBSZ:\n\t\t/* anon_bdev filesystems may not have a block size */\n\t\tif (!inode->i_sb->s_blocksize)\n\t\t\treturn -EINVAL;\n\n\t\treturn put_user(inode->i_sb->s_blocksize, (int __user *)argp);\n\n\tcase FICLONE:\n\t\treturn ioctl_file_clone(filp, arg, 0, 0, 0);\n\n\tcase FICLONERANGE:\n\t\treturn ioctl_file_clone_range(filp, argp);\n\n\tcase FIDEDUPERANGE:\n\t\treturn ioctl_file_dedupe_range(filp, argp);\n\n\tcase FIONREAD:\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\treturn vfs_ioctl(filp, cmd, arg);\n\n\t\treturn put_user(i_size_read(inode) - filp->f_pos,\n\t\t\t\t(int __user *)argp);\n\n\tdefault:\n\t\tif (S_ISREG(inode->i_mode))\n\t\t\treturn file_ioctl(filp, cmd, argp);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751#751": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751",
        "file": "fs/ioctl.c",
        "line": 751,
        "function_snippet": "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)\n{\n\tstruct fd f = fdget(fd);\n\tint error;\n\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\terror = security_file_ioctl(f.file, cmd, arg);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_vfs_ioctl(f.file, fd, cmd, arg);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739#739": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739",
        "file": "fs/ioctl.c",
        "line": 739,
        "function_snippet": "SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46#46": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46,
        "function_snippet": "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)\n{\n\tnr = syscall_enter_from_user_mode(regs, nr);\n\n\tinstrumentation_begin();\n\tif (likely(nr < NR_syscalls)) {\n\t\tnr = array_index_nospec(nr, NR_syscalls);\n\t\tregs->ax = sys_call_table[nr](regs);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033#4033": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033",
        "file": "mm/slub.c",
        "line": 4033,
        "function_snippet": "void *__kmalloc(size_t size, gfp_t flags)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, flags);\n\n\ts = kmalloc_slab(size, flags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, flags, _RET_IP_, size);\n\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, flags);\n\n\tret = kasan_kmalloc(s, ret, size, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418#418": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418",
        "file": "include/linux/slab.h",
        "line": 418,
        "function_snippet": "\treturn __kmalloc(size, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575#575": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575",
        "file": "include/linux/slab.h",
        "line": 575,
        "function_snippet": "static __always_inline void *kmalloc_node(size_t size, gfp_t flags, int node)\n{\n#ifndef CONFIG_SLOB\n\tif (__builtin_constant_p(size) &&\n\t\tsize <= KMALLOC_MAX_CACHE_SIZE) {\n\t\tunsigned int i = kmalloc_index(size);\n\n\t\tif (!i)\n\t\t\treturn ZERO_SIZE_PTR;\n\n\t\treturn kmem_cache_alloc_node_trace(\n\t\t\t\tkmalloc_caches[kmalloc_type(flags)][i],\n\t\t\t\t\t\tflags, node, size);\n\t}\n#endif\n\treturn __kmalloc_node(size, flags, node);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612#612": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612",
        "file": "mm/util.c",
        "line": 612,
        "function_snippet": "void *kvmalloc_node(size_t size, gfp_t flags, int node)\n{\n\tgfp_t kmalloc_flags = flags;\n\tvoid *ret;\n\n\t/*\n\t * vmalloc uses GFP_KERNEL for some internal allocations (e.g page tables)\n\t * so the given set of flags has to be compatible.\n\t */\n\tif ((flags & GFP_KERNEL) != GFP_KERNEL)\n\t\treturn kmalloc_node(size, flags, node);\n\n\t/*\n\t * We want to attempt a large physically contiguous block first because\n\t * it is less likely to fragment multiple larger blocks and therefore\n\t * contribute to a long term fragmentation less than vmalloc fallback.\n\t * However make sure that larger requests are not too disruptive - no\n\t * OOM killer and no allocation failure warnings as we have a fallback.\n\t */\n\tif (size > PAGE_SIZE) {\n\t\tkmalloc_flags |= __GFP_NOWARN;\n\n\t\tif (!(kmalloc_flags & __GFP_RETRY_MAYFAIL))\n\t\t\tkmalloc_flags |= __GFP_NORETRY;\n\t}\n\n\tret = kmalloc_node(size, kmalloc_flags, node);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833#833": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833",
        "file": "include/linux/mm.h",
        "line": 833,
        "function_snippet": "\treturn kvmalloc_node(size, flags, NUMA_NO_NODE);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374#3374": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374",
        "file": "fs/f2fs/f2fs.h",
        "line": 3374,
        "function_snippet": "\treturn kvmalloc(size, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380#3380": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380",
        "file": "fs/f2fs/f2fs.h",
        "line": 3380,
        "function_snippet": "\treturn f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395#4395": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395",
        "file": "fs/f2fs/segment.c",
        "line": 4395,
        "function_snippet": "static int build_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct sit_info *sit_i;\n\tunsigned int sit_segs, start;\n\tchar *src_bitmap, *bitmap;\n\tunsigned int bitmap_size, main_bitmap_size, sit_bitmap_size;\n\tunsigned int discard_map = f2fs_block_unit_discard(sbi) ? 1 : 0;\n\n\t/* allocate memory for SIT information */\n\tsit_i = f2fs_kzalloc(sbi, sizeof(struct sit_info), GFP_KERNEL);\n\tif (!sit_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->sit_info = sit_i;\n\n\tsit_i->sentries =\n\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct seg_entry),"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258#5258": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258",
        "file": "fs/f2fs/segment.c",
        "line": 5258,
        "function_snippet": "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n\tsm_info = f2fs_kzalloc(sbi, sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\tif (!sm_info)\n\t\treturn -ENOMEM;\n\n\t/* init sm info */\n\tsbi->sm_info = sm_info;\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\tsm_info->rec_prefree_segments = sm_info->main_segments *\n\t\t\t\t\tDEF_RECLAIM_PREFREE_SEGMENTS / 100;\n\tif (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)\n\t\tsm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;\n\n\tif (!f2fs_lfs_mode(sbi))\n\t\tsm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;\n\tsm_info->min_ipu_util = DEF_MIN_IPU_UTIL;\n\tsm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;\n\tsm_info->min_seq_blocks = sbi->blocks_per_seg;\n\tsm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;\n\tsm_info->min_ssr_sections = reserved_sections(sbi);\n\n\tINIT_LIST_HEAD(&sm_info->sit_entry_set);\n\n\tinit_f2fs_rwsem(&sm_info->curseg_lock);\n\n\tif (!f2fs_readonly(sbi->sb)) {\n\t\terr = f2fs_create_flush_cmd_control(sbi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = create_discard_cmd_control(sbi);\n\tif (err)\n\t\treturn err;\n\n\terr = build_sit_info(sbi);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315#4315": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315",
        "file": "fs/f2fs/super.c",
        "line": 4315,
        "function_snippet": "\t\t\ttest_opt(sbi, MERGE_CHECKPOINT)) {\n\t\terr = f2fs_start_ckpt_thread(sbi);\n\t\tif (err) {\n\t\t\tf2fs_err(sbi,\n\t\t\t    \"Failed to start F2FS issue_checkpoint_thread (%d)\",\n\t\t\t    err);\n\t\t\tgoto stop_ckpt_thread;\n\t\t}\n\t}\n\n\t/* setup f2fs internal modules */\n\terr = f2fs_build_segment_manager(sbi);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442#1442": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442",
        "file": "fs/super.c",
        "line": 1442,
        "function_snippet": "\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error = 0;\n\n\tif (!(flags & SB_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | SB_NOSEC,\n\t\t bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s))\n\t\tgoto error_s;\n\n\tif (s->s_root) {\n\t\tif ((flags ^ s->s_flags) & SB_RDONLY) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\terror = -EBUSY;\n\t\t\tgoto error_bdev;\n\t\t}\n\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t} else {\n\t\ts->s_mode = mode;\n\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595#4595": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595",
        "file": "fs/f2fs/super.c",
        "line": 4595,
        "function_snippet": "\treturn mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593#593": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593",
        "file": "fs/fs_context.c",
        "line": 593,
        "function_snippet": "static int legacy_get_tree(struct fs_context *fc)\n{\n\tstruct legacy_fs_context *ctx = fc->fs_private;\n\tstruct super_block *sb;\n\tstruct dentry *root;\n\n\troot = fc->fs_type->mount(fc->fs_type, fc->sb_flags,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572#1572": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572",
        "file": "fs/super.c",
        "line": 1572,
        "function_snippet": "int vfs_get_tree(struct fs_context *fc)\n{\n\tstruct super_block *sb;\n\tint error;\n\n\tif (fc->root)\n\t\treturn -EBUSY;\n\n\t/* Get the mountable root in fc->root, with a ref on the root and a ref\n\t * on the superblock.\n\t */\n\terror = fc->ops->get_tree(fc);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997#2997": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997",
        "file": "fs/namespace.c",
        "line": 2997,
        "function_snippet": "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct fs_context *fc;\n\tconst char *subtype = NULL;\n\tint err = 0;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (type->fs_flags & FS_HAS_SUBTYPE) {\n\t\tsubtype = strchr(fstype, '.');\n\t\tif (subtype) {\n\t\t\tsubtype++;\n\t\t\tif (!*subtype) {\n\t\t\t\tput_filesystem(type);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tfc = fs_context_for_mount(type, sb_flags);\n\tput_filesystem(type);\n\tif (IS_ERR(fc))\n\t\treturn PTR_ERR(fc);\n\n\t/*\n\t * Indicate to the filesystem that the mount request is coming\n\t * from the legacy mount system call.\n\t */\n\tfc->oldapi = true;\n\n\tif (subtype)\n\t\terr = vfs_parse_fs_string(fc, \"subtype\",\n\t\t\t\t\t  subtype, strlen(subtype));\n\tif (!err && name)\n\t\terr = vfs_parse_fs_string(fc, \"source\", name, strlen(name));\n\tif (!err)\n\t\terr = parse_monolithic_mount_data(fc, data);\n\tif (!err && !mount_capable(fc))\n\t\terr = -EPERM;\n\tif (!err)\n\t\terr = vfs_get_tree(fc);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327#3327": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327",
        "file": "fs/namespace.c",
        "line": 3327,
        "function_snippet": "\treturn do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340#3340": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340",
        "file": "fs/namespace.c",
        "line": 3340,
        "function_snippet": "long do_mount(const char *dev_name, const char __user *dir_name,\n\t\tconst char *type_page, unsigned long flags, void *data_page)\n{\n\tstruct path path;\n\tint ret;\n\n\tret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ret;\n\tret = path_mount(dev_name, &path, type_page, flags, data_page);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548#3548": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548",
        "file": "fs/namespace.c",
        "line": 3548,
        "function_snippet": "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,\n\t\tchar __user *, type, unsigned long, flags, void __user *, data)\n{\n\tint ret;\n\tchar *kernel_type;\n\tchar *kernel_dev;\n\tvoid *options;\n\n\tkernel_type = copy_mount_string(type);\n\tret = PTR_ERR(kernel_type);\n\tif (IS_ERR(kernel_type))\n\t\tgoto out_type;\n\n\tkernel_dev = copy_mount_string(dev_name);\n\tret = PTR_ERR(kernel_dev);\n\tif (IS_ERR(kernel_dev))\n\t\tgoto out_dev;\n\n\toptions = copy_mount_options(data);\n\tret = PTR_ERR(options);\n\tif (IS_ERR(options))\n\t\tgoto out_data;\n\n\tret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525#3525": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525",
        "file": "fs/namespace.c",
        "line": 3525,
        "function_snippet": "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35#35": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35",
        "file": "include/linux/page_owner.h",
        "line": 35,
        "function_snippet": "\t\t__set_page_owner(page, order, gfp_mask);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456#2456": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456",
        "file": "mm/page_alloc.c",
        "line": 2456,
        "function_snippet": "\tset_page_owner(page, order, gfp_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462#2462": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462",
        "file": "mm/page_alloc.c",
        "line": 2462,
        "function_snippet": "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,\n\t\t\t\t\t\t\tunsigned int alloc_flags)\n{\n\tpost_alloc_hook(page, order, gfp_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254#4254": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254",
        "file": "mm/page_alloc.c",
        "line": 4254,
        "function_snippet": "get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\tbool no_fallback;\n\nretry:\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tno_fallback = alloc_flags & ALLOC_NOFRAGMENT;\n\tz = ac->preferred_zoneref;\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->highest_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (no_fallback && nr_online_nodes > 1 &&\n\t\t    zone != ac->preferred_zoneref->zone) {\n\t\t\tint local_nid;\n\n\t\t\t/*\n\t\t\t * If moving to a remote node, retry but allow\n\t\t\t * fragmenting fallbacks. Locality is more important\n\t\t\t * than fragmentation avoidance.\n\t\t\t */\n\t\t\tlocal_nid = zone_to_nid(ac->preferred_zoneref->zone);\n\t\t\tif (zone_to_nid(zone) != local_nid) {\n\t\t\t\talloc_flags &= ~ALLOC_NOFRAGMENT;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\tmark = wmark_pages(zone, alloc_flags & ALLOC_WMARK_MASK);\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac->highest_zoneidx, alloc_flags,\n\t\t\t\t       gfp_mask)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\tac->highest_zoneidx, alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370#5370": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370",
        "file": "mm/page_alloc.c",
        "line": 5370,
        "function_snippet": "__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\t/*\n\t * Forbid the first pass from falling back to types that fragment\n\t * memory until all local zones are considered.\n\t */\n\talloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref->zone, gfp_mask);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808#1808": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808",
        "file": "mm/slub.c",
        "line": 1808,
        "function_snippet": "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p, *next;\n\tint idx;\n\tbool shuffle;\n\n\tflags &= gfp_allowed_mask;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_enable();\n\n\tflags |= s->allocflags;\n\n\t/*\n\t * Let the initial higher-order allocation fail under memory pressure\n\t * so we fall-back to the minimum order allocation.\n\t */\n\talloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) & ~__GFP_NOFAIL;\n\tif ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))\n\t\talloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n\n\tpage = alloc_slab_page(s, alloc_gfp, node, oo);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869#1869": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869",
        "file": "mm/slub.c",
        "line": 1869,
        "function_snippet": "\treturn allocate_slab(s,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627#2627": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627",
        "file": "mm/slub.c",
        "line": 2627,
        "function_snippet": "static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\tWARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));\n\n\tfreelist = get_partial(s, flags, node, c);\n\n\tif (freelist)\n\t\treturn freelist;\n\n\tpage = new_slab(s, flags, node);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791#2791": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791",
        "file": "mm/slub.c",
        "line": 2791,
        "function_snippet": "static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tstat(s, ALLOC_SLOWPATH);\n\n\tpage = c->page;\n\tif (!page) {\n\t\t/*\n\t\t * if the node is not online or has no normal memory, just\n\t\t * ignore the node constraint\n\t\t */\n\t\tif (unlikely(node != NUMA_NO_NODE &&\n\t\t\t     !node_state(node, N_NORMAL_MEMORY)))\n\t\t\tnode = NUMA_NO_NODE;\n\t\tgoto new_slab;\n\t}\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\t/*\n\t\t * same as above but node_match() being false already\n\t\t * implies node != NUMA_NO_NODE\n\t\t */\n\t\tif (!node_state(node, N_NORMAL_MEMORY)) {\n\t\t\tnode = NUMA_NO_NODE;\n\t\t\tgoto redo;\n\t\t} else {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tc->tid = next_tid(c->tid);\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831#2831": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831",
        "file": "mm/slub.c",
        "line": 2831,
        "function_snippet": "static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *p;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n#ifdef CONFIG_PREEMPTION\n\t/*\n\t * We may have been preempted and rescheduled on a different\n\t * cpu before disabling interrupts. Need to reload cpu area\n\t * pointer.\n\t */\n\tc = this_cpu_ptr(s->cpu_slab);\n#endif\n\n\tp = ___slab_alloc(s, gfpflags, node, addr, c);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913#2913": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913",
        "file": "mm/slub.c",
        "line": 2913,
        "function_snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr, size_t orig_size)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\tstruct obj_cgroup *objcg = NULL;\n\tbool init = false;\n\n\ts = slab_pre_alloc_hook(s, &objcg, 1, gfpflags);\n\tif (!s)\n\t\treturn NULL;\n\n\tobject = kfence_alloc(s, orig_size, gfpflags);\n\tif (unlikely(object))\n\t\tgoto out;\n\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPTION so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPTION) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !page || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955#2955": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955",
        "file": "mm/slub.c",
        "line": 2955,
        "function_snippet": "\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr, orig_size);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536#4536": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536",
        "file": "mm/slub.c",
        "line": 4536,
        "function_snippet": "void *__kmalloc_track_caller(size_t size, gfp_t gfpflags, unsigned long caller)\n{\n\tstruct kmem_cache *s;\n\tvoid *ret;\n\n\tif (unlikely(size > KMALLOC_MAX_CACHE_SIZE))\n\t\treturn kmalloc_large(size, gfpflags);\n\n\ts = kmalloc_slab(size, gfpflags);\n\n\tif (unlikely(ZERO_OR_NULL_PTR(s)))\n\t\treturn s;\n\n\tret = slab_alloc(s, gfpflags, caller, size);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144#144": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144",
        "file": "net/core/skbuff.c",
        "line": 144,
        "function_snippet": "static void *__kmalloc_reserve(size_t size, gfp_t flags, int node,\n\t\t\t       unsigned long ip, bool *pfmemalloc)\n{\n\tvoid *obj;\n\tbool ret_pfmemalloc = false;\n\n\t/*\n\t * Try a regular allocation, when that fails and we're not entitled\n\t * to the reserves, fail.\n\t */\n\tobj = kmalloc_node_track_caller(size,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212#212": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212",
        "file": "net/core/skbuff.c",
        "line": 212,
        "function_snippet": "struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,\n\t\t\t    int flags, int node)\n{\n\tstruct kmem_cache *cache;\n\tstruct skb_shared_info *shinfo;\n\tstruct sk_buff *skb;\n\tu8 *data;\n\tbool pfmemalloc;\n\n\tcache = (flags & SKB_ALLOC_FCLONE)\n\t\t? skbuff_fclone_cache : skbuff_head_cache;\n\n\tif (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))\n\t\tgfp_mask |= __GFP_MEMALLOC;\n\n\t/* Get the HEAD */\n\tskb = kmem_cache_alloc_node(cache, gfp_mask & ~__GFP_DMA, node);\n\tif (!skb)\n\t\tgoto out;\n\tprefetchw(skb);\n\n\t/* We do our best to align skb_shared_info on a separate cache\n\t * line. It usually works because kmalloc(X > SMP_CACHE_BYTES) gives\n\t * aligned memory blocks, unless SLUB/SLAB debug is enabled.\n\t * Both skb->head and skb_shared_info are cache line aligned.\n\t */\n\tsize = SKB_DATA_ALIGN(size);\n\tsize += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));\n\tdata = kmalloc_reserve(size, gfp_mask, node, &pfmemalloc);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126#1126": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126",
        "file": "include/linux/skbuff.h",
        "line": 1126,
        "function_snippet": "static inline struct sk_buff *alloc_skb(unsigned int size,\n\t\t\t\t\tgfp_t priority)\n{\n\treturn __alloc_skb(size, priority, 0, NUMA_NO_NODE);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178#1178": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178",
        "file": "net/netlink/af_netlink.c",
        "line": 1178,
        "function_snippet": "static struct sk_buff *netlink_alloc_large_skb(unsigned int size,\n\t\t\t\t\t       int broadcast)\n{\n\tstruct sk_buff *skb;\n\tvoid *data;\n\n\tif (size <= NLMSG_GOODSIZE || broadcast)\n\t\treturn alloc_skb(size, GFP_KERNEL);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889#1889": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889",
        "file": "net/netlink/af_netlink.c",
        "line": 1889,
        "function_snippet": "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);\n\tu32 dst_portid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\tu32 netlink_skb_flags = 0;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (len == 0) {\n\t\tpr_warn_once(\"Zero length message leads to an empty skb\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\terr = scm_send(sock, msg, &scm, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (msg->msg_namelen < sizeof(struct sockaddr_nl))\n\t\t\tgoto out;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_portid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif ((dst_group || dst_portid) &&\n\t\t    !netlink_allowed(sock, NL_CFG_F_NONROOT_SEND))\n\t\t\tgoto out;\n\t\tnetlink_skb_flags |= NETLINK_SKB_DST;\n\t} else {\n\t\t/* Paired with WRITE_ONCE() in netlink_connect() */\n\t\tdst_portid = READ_ONCE(nlk->dst_portid);\n\t\tdst_group = READ_ONCE(nlk->dst_group);\n\t}\n\n\t/* Paired with WRITE_ONCE() in netlink_insert() */\n\tif (!READ_ONCE(nlk->bound)) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* Ensure nlk is hashed and visible. */\n\t\tsmp_rmb();\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = netlink_alloc_large_skb(len, dst_group);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652#652": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652",
        "file": "net/socket.c",
        "line": 652,
        "function_snippet": "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)\n{\n\tint ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664#664": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664",
        "file": "net/socket.c",
        "line": 664,
        "function_snippet": "static int __sock_sendmsg(struct socket *sock, struct msghdr *msg)\n{\n\tint err = security_socket_sendmsg(sock, msg,\n\t\t\t\t\t  msg_data_left(msg));\n\n\treturn err ?: sock_sendmsg_nosec(sock, msg);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376#2376": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376",
        "file": "net/socket.c",
        "line": 2376,
        "function_snippet": "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,\n\t\t\t   unsigned int flags, struct used_address *used_address,\n\t\t\t   unsigned int allowed_msghdr_flags)\n{\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t\t\t\t__aligned(sizeof(__kernel_size_t));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint ctl_len;\n\tssize_t err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out;\n\tflags |= (msg_sys->msg_flags & allowed_msghdr_flags);\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tBUILD_BUG_ON(sizeof(struct cmsghdr) !=\n\t\t\t     CMSG_ALIGN(sizeof(struct cmsghdr)));\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t\tmsg_sys->msg_control_is_user = false;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n\t * used_address->name_len is initialized to UINT_MAX so that the first\n\t * destination address never matches.\n\t */\n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys);\n\t\tgoto out_freectl;\n\t}\n\terr = __sock_sendmsg(sock, msg_sys);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430#2430": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430",
        "file": "net/socket.c",
        "line": 2430,
        "function_snippet": "static int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned int flags,\n\t\t\t struct used_address *used_address,\n\t\t\t unsigned int allowed_msghdr_flags)\n{\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tssize_t err;\n\n\tmsg_sys->msg_name = &address;\n\n\terr = sendmsg_copy_msghdr(msg_sys, msg, flags, &iov);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ____sys_sendmsg(sock, msg_sys, flags, used_address,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459#2459": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459",
        "file": "net/socket.c",
        "line": 2459,
        "function_snippet": "long __sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,\n\t\t   bool forbid_cmsg_compat)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock;\n\n\tif (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468#2468": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468",
        "file": "net/socket.c",
        "line": 2468,
        "function_snippet": "SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)\n{\n\treturn __sys_sendmsg(fd, msg, flags, true);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466#2466": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466",
        "file": "net/socket.c",
        "line": 2466,
        "function_snippet": "SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481#3481": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481",
        "file": "fs/f2fs/segment.c",
        "line": 3481,
        "function_snippet": "void f2fs_allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type,\n\t\tstruct f2fs_io_info *fio)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\tunsigned long long old_mtime;\n\tbool from_gc = (type == CURSEG_ALL_DATA_ATGC);\n\tstruct seg_entry *se = NULL;\n\n\tf2fs_down_read(&SM_I(sbi)->curseg_lock);\n\n\tmutex_lock(&curseg->curseg_mutex);\n\tdown_write(&sit_i->sentry_lock);\n\n\tif (from_gc) {\n\t\tf2fs_bug_on(sbi, GET_SEGNO(sbi, old_blkaddr) == NULL_SEGNO);\n\t\tse = get_seg_entry(sbi, GET_SEGNO(sbi, old_blkaddr));\n\t\tsanity_check_seg_type(sbi, se->type);\n\t\tf2fs_bug_on(sbi, IS_NODESEG(se->type));\n\t}\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);\n\n\tf2fs_bug_on(sbi, curseg->next_blkoff >= sbi->blocks_per_seg);\n\n\tf2fs_wait_discard_bio(sbi, *new_blkaddr);\n\n\t/*\n\t * __add_sum_entry should be resided under the curseg_mutex\n\t * because, this function updates a summary entry in the\n\t * current summary block.\n\t */\n\t__add_sum_entry(sbi, type, sum);\n\n\t__refresh_next_blkoff(sbi, curseg);\n\n\tstat_inc_block_count(sbi, curseg);\n\n\tif (from_gc) {\n\t\told_mtime = get_segment_mtime(sbi, old_blkaddr);\n\t} else {\n\t\tupdate_segment_mtime(sbi, old_blkaddr, 0);\n\t\told_mtime = 0;\n\t}\n\tupdate_segment_mtime(sbi, *new_blkaddr, old_mtime);\n\n\t/*\n\t * SIT information should be updated before segment allocation,\n\t * since SSR needs latest valid block information.\n\t */\n\tupdate_sit_entry(sbi, *new_blkaddr, 1);"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407#1407": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407",
        "file": "fs/f2fs/data.c",
        "line": 1407,
        "function_snippet": "static int __allocate_data_block(struct dnode_of_data *dn, int seg_type)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\tblock_t old_blkaddr;\n\tblkcnt_t count = 1;\n\tint err;\n\n\tif (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))\n\t\treturn -EPERM;\n\n\terr = f2fs_get_node_info(sbi, dn->nid, &ni, false);\n\tif (err)\n\t\treturn err;\n\n\tdn->data_blkaddr = f2fs_data_blkaddr(dn);\n\tif (dn->data_blkaddr != NULL_ADDR)\n\t\tgoto alloc;\n\n\tif (unlikely((err = inc_valid_block_count(sbi, dn->inode, &count))))\n\t\treturn err;\n\nalloc:\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\told_blkaddr = dn->data_blkaddr;\n\tf2fs_allocate_data_block(sbi, NULL, old_blkaddr, &dn->data_blkaddr,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575#1575": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575",
        "file": "fs/f2fs/data.c",
        "line": 1575,
        "function_snippet": "\t\t\t\tf2fs_cp_error(sbi))) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto unlock_out;\n\t\t\t}\n\n\t\t\terr = 0;\n\t\t\tif (map->m_next_pgofs)\n\t\t\t\t*map->m_next_pgofs =\n\t\t\t\t\tf2fs_get_next_page_offset(&dn, pgofs);\n\t\t\tif (map->m_next_extent)\n\t\t\t\t*map->m_next_extent =\n\t\t\t\t\tf2fs_get_next_page_offset(&dn, pgofs);\n\t\t}\n\t\tgoto unlock_out;\n\t}\n\n\tstart_pgofs = pgofs;\n\tprealloc = 0;\n\tlast_ofs_in_node = ofs_in_node = dn.ofs_in_node;\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\nnext_block:\n\tblkaddr = f2fs_data_blkaddr(&dn);\n\n\tif (__is_valid_data_blkaddr(blkaddr) &&\n\t\t!f2fs_is_valid_blkaddr(sbi, blkaddr, DATA_GENERIC_ENHANCE)) {\n\t\terr = -EFSCORRUPTED;\n\t\tgoto sync_out;\n\t}\n\n\tif (__is_valid_data_blkaddr(blkaddr)) {\n\t\t/* use out-place-update for driect IO under LFS mode */\n\t\tif (f2fs_lfs_mode(sbi) && flag == F2FS_GET_BLOCK_DIO &&\n\t\t\t\t\t\t\tmap->m_may_create) {\n\t\t\terr = __allocate_data_block(&dn, map->m_seg_type);\n\t\t\tif (err)\n\t\t\t\tgoto sync_out;\n\t\t\tblkaddr = dn.data_blkaddr;\n\t\t\tset_inode_flag(inode, FI_APPEND_WRITE);\n\t\t}\n\t} else {\n\t\tif (create) {\n\t\t\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto sync_out;\n\t\t\t}\n\t\t\tif (flag == F2FS_GET_BLOCK_PRE_AIO) {\n\t\t\t\tif (blkaddr == NULL_ADDR) {\n\t\t\t\t\tprealloc++;\n\t\t\t\t\tlast_ofs_in_node = dn.ofs_in_node;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tWARN_ON(flag != F2FS_GET_BLOCK_PRE_DIO &&\n\t\t\t\t\tflag != F2FS_GET_BLOCK_DIO);\n\t\t\t\terr = __allocate_data_block(&dn,"
      },
      "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724#1724": {
        "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724",
        "file": "fs/f2fs/file.c",
        "line": 1724,
        "function_snippet": "\t\t\tGET_SEC_FROM_SEG(sbi, overprovision_segments(sbi)))) {\n\t\t\tf2fs_down_write(&sbi->gc_lock);\n\t\t\terr = f2fs_gc(sbi, true, false, false, NULL_SEGNO);\n\t\t\tif (err && err != -ENODATA && err != -EAGAIN)\n\t\t\t\tgoto out_err;\n\t\t}\n\n\t\tf2fs_down_write(&sbi->pin_sem);\n\n\t\tf2fs_lock_op(sbi);\n\t\tf2fs_allocate_new_section(sbi, CURSEG_COLD_DATA_PINNED, false);\n\t\tf2fs_unlock_op(sbi);\n\n\t\tmap.m_seg_type = CURSEG_COLD_DATA_PINNED;\n\t\terr = f2fs_map_blocks(inode, &map, 1, F2FS_GET_BLOCK_PRE_DIO);"
      }
    }
  },
  "evidence": {
    "https://android.googlesource.com/kernel/common/": {
      "error": "URL not in expected +/commit/path format"
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257#2257": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,"
        ],
        [
          4,
          "struct seg_entry *se = get_seg_entry(sbi, segno);"
        ],
        [
          6,
          "se->type = type;"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 0,
      "deref_exprs": [
        "se->type"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 2257
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663#2663": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "deref_exprs": [
        "curseg->segno"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 2663
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77#77": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void __dump_stack(const char *log_lvl)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77",
      "source_file": "lib/dump_stack.c",
      "source_line": 77
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118#118": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "asmlinkage __visible void dump_stack_lvl(const char *log_lvl)"
        ],
        [
          8,
          "/*"
        ],
        [
          9,
          "* Permit this cpu to perform nested stack dumps while serialising"
        ],
        [
          10,
          "* against other CPUs"
        ],
        [
          11,
          "*/"
        ],
        [
          22,
          "/*"
        ],
        [
          23,
          "* Wait for the lock to release before jumping to"
        ],
        [
          24,
          "* atomic_cmpxchg() in order to mitigate the thundering herd"
        ],
        [
          26,
          "*/"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118",
      "source_file": "lib/dump_stack.c",
      "source_line": 118
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723#2723": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)"
        ],
        [
          3,
          "struct curseg_info *curseg = CURSEG_I(sbi, type);"
        ],
        [
          4,
          "unsigned short seg_type = curseg->seg_type;"
        ],
        [
          5,
          "unsigned int segno = curseg->segno;"
        ],
        [
          8,
          "if (curseg->inited)"
        ],
        [
          9,
          "write_sum_page(sbi, curseg->sum_blk,"
        ],
        [
          19,
          "curseg->next_segno = segno;"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 4,
      "deref_exprs": [
        "curseg->seg_type",
        "curseg->segno",
        "curseg->inited",
        "curseg->sum_blk",
        "curseg->next_segno"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 2723
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039#3039": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void __allocate_new_segment(struct f2fs_sb_info *sbi, int type,"
        ],
        [
          4,
          "struct curseg_info *curseg = CURSEG_I(sbi, type);"
        ],
        [
          7,
          "if (!curseg->inited)"
        ],
        [
          10,
          "if (force || curseg->next_blkoff ||"
        ],
        [
          11,
          "get_valid_blocks(sbi, curseg->segno, new_sec))"
        ],
        [
          14,
          "if (!get_ckpt_valid_blocks(sbi, curseg->segno, new_sec))"
        ],
        [
          17,
          "old_segno = curseg->segno;"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 5,
      "deref_exprs": [
        "curseg->inited",
        "curseg->next_blkoff",
        "curseg->segno"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 3039
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047#3047": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 3047
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054#3054": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 3054
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720#1720": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "f2fs_down_write(&sbi->gc_lock);"
        ],
        [
          8,
          "f2fs_down_write(&sbi->pin_sem);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 2,
      "deref_exprs": [
        "sbi->gc_lock",
        "sbi->pin_sem"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720",
      "source_file": "fs/f2fs/file.c",
      "source_line": 1720
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825#1825": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static long f2fs_fallocate(struct file *file, int mode,"
        ],
        [
          4,
          "struct inode *inode = file_inode(file);"
        ],
        [
          14,
          "/* f2fs only support ->fallocate for regular file */"
        ],
        [
          15,
          "if (!S_ISREG(inode->i_mode))"
        ],
        [
          22,
          "/*"
        ],
        [
          23,
          "* Pinned file should not support partial trucation since the block"
        ],
        [
          25,
          "*/"
        ],
        [
          42,
          "/*"
        ],
        [
          43,
          "* wait for inflight dio, blocks should be removed after IO"
        ],
        [
          45,
          "*/"
        ],
        [
          49,
          "if (offset >= inode->i_size)"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 3,
      "deref_exprs": [
        "inode->i_mode",
        "inode->i_size"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825",
      "source_file": "fs/f2fs/file.c",
      "source_line": 1825
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310#310": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int vfs_fallocate(struct file *file, int mode, loff_t offset, loff_t len)"
        ],
        [
          3,
          "struct inode *inode = file_inode(file);"
        ],
        [
          9,
          "/* Return error if mode is not supported */"
        ],
        [
          13,
          "/* Punch hole and zero range are mutually exclusive */"
        ],
        [
          18,
          "/* Punch hole must have keep size set */"
        ],
        [
          38,
          "if (!(file->f_mode & FMODE_WRITE))"
        ],
        [
          41,
          "/*"
        ],
        [
          42,
          "* We can only allow pure fallocate on append only files"
        ],
        [
          43,
          "*/"
        ],
        [
          50,
          "/*"
        ],
        [
          51,
          "* We cannot allow any fallocate operation on an active swapfile"
        ],
        [
          52,
          "*/"
        ],
        [
          56,
          "/*"
        ],
        [
          57,
          "* Revalidate the write permissions, in case security policy has"
        ],
        [
          59,
          "*/"
        ],
        [
          64,
          "if (S_ISFIFO(inode->i_mode))"
        ],
        [
          67,
          "if (S_ISDIR(inode->i_mode))"
        ],
        [
          70,
          "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))"
        ],
        [
          73,
          "/* Check for wrap through zero too */"
        ],
        [
          74,
          "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))"
        ],
        [
          77,
          "if (!file->f_op->fallocate)"
        ],
        [
          81,
          "ret = file->f_op->fallocate(file, mode, offset, len);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 8,
      "deref_exprs": [
        "file->f_mode",
        "inode->i_mode",
        "inode->i_sb->s_maxbytes",
        "file->f_op->fallocate"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310",
      "source_file": "fs/open.c",
      "source_line": 310
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494#494": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ioctl_preallocate(struct file *filp, int mode, void __user *argp)"
        ],
        [
          3,
          "struct inode *inode = file_inode(filp);"
        ],
        [
          6,
          "if (copy_from_user(&sr, argp, sizeof(sr)))"
        ],
        [
          13,
          "sr.l_start += filp->f_pos;"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 1,
      "deref_exprs": [
        "filp->f_pos"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494",
      "source_file": "fs/ioctl.c",
      "source_line": 494
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732#732": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "S_ISLNK(inode->i_mode)) {"
        ],
        [
          3,
          "return copy_to_user(argp, &res, sizeof(res)) ?"
        ],
        [
          19,
          "/* anon_bdev filesystems may not have a block size */"
        ],
        [
          20,
          "if (!inode->i_sb->s_blocksize)"
        ],
        [
          23,
          "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);"
        ],
        [
          35,
          "if (!S_ISREG(inode->i_mode))"
        ],
        [
          38,
          "return put_user(i_size_read(inode) - filp->f_pos,"
        ],
        [
          39,
          "(int __user *)argp);"
        ],
        [
          42,
          "if (S_ISREG(inode->i_mode))"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 7,
      "deref_exprs": [
        "inode->i_mode",
        "inode->i_sb->s_blocksize",
        "filp->f_pos"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732",
      "source_file": "fs/ioctl.c",
      "source_line": 732
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751#751": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751",
      "source_file": "fs/ioctl.c",
      "source_line": 751
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739#739": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739",
      "source_file": "fs/ioctl.c",
      "source_line": 739
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46#46": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)"
        ],
        [
          8,
          "regs->ax = sys_call_table[nr](regs);"
        ],
        [
          8,
          "regs->ax = sys_call_table[nr](regs);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 1,
      "deref_exprs": [
        "regs->ax"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46",
      "source_file": "arch/x86/entry/common.c",
      "source_line": 46
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033#4033": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void *__kmalloc(size_t size, gfp_t flags)"
        ],
        [
          3,
          "struct kmem_cache *s;"
        ],
        [
          4,
          "void *ret;"
        ],
        [
          16,
          "trace_kmalloc(_RET_IP_, ret, size, s->size, flags);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "deref_exprs": [
        "s->size"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033",
      "source_file": "mm/slub.c",
      "source_line": 4033
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418#418": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418",
      "source_file": "include/linux/slab.h",
      "source_line": 418
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575#575": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline void *kmalloc_node(size_t size, gfp_t flags, int node)"
        ],
        [
          12,
          "kmalloc_caches[kmalloc_type(flags)][i],"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575",
      "source_file": "include/linux/slab.h",
      "source_line": 575
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612#612": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void *kvmalloc_node(size_t size, gfp_t flags, int node)"
        ],
        [
          4,
          "void *ret;"
        ],
        [
          6,
          "/*"
        ],
        [
          9,
          "*/"
        ],
        [
          13,
          "/*"
        ],
        [
          14,
          "* We want to attempt a large physically contiguous block first because"
        ],
        [
          15,
          "* it is less likely to fragment multiple larger blocks and therefore"
        ],
        [
          17,
          "* However make sure that larger requests are not too disruptive - no"
        ],
        [
          19,
          "*/"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612",
      "source_file": "mm/util.c",
      "source_line": 612
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833#833": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833",
      "source_file": "include/linux/mm.h",
      "source_line": 833
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374#3374": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374",
      "source_file": "fs/f2fs/f2fs.h",
      "source_line": 3374
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380#3380": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380",
      "source_file": "fs/f2fs/f2fs.h",
      "source_line": 3380
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395#4395": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int build_sit_info(struct f2fs_sb_info *sbi)"
        ],
        [
          3,
          "struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);"
        ],
        [
          4,
          "struct sit_info *sit_i;"
        ],
        [
          6,
          "char *src_bitmap, *bitmap;"
        ],
        [
          10,
          "/* allocate memory for SIT information */"
        ],
        [
          15,
          "SM_I(sbi)->sit_info = sit_i;"
        ],
        [
          17,
          "sit_i->sentries ="
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 1,
      "deref_exprs": [
        "sit_i->sentries"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 4395
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258#5258": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int f2fs_build_segment_manager(struct f2fs_sb_info *sbi)"
        ],
        [
          3,
          "struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);"
        ],
        [
          4,
          "struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);"
        ],
        [
          5,
          "struct f2fs_sm_info *sm_info;"
        ],
        [
          12,
          "/* init sm info */"
        ],
        [
          13,
          "sbi->sm_info = sm_info;"
        ],
        [
          14,
          "sm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);"
        ],
        [
          15,
          "sm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);"
        ],
        [
          16,
          "sm_info->segment_count = le32_to_cpu(raw_super->segment_count);"
        ],
        [
          17,
          "sm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);"
        ],
        [
          18,
          "sm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);"
        ],
        [
          19,
          "sm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);"
        ],
        [
          20,
          "sm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);"
        ],
        [
          21,
          "sm_info->rec_prefree_segments = sm_info->main_segments *"
        ],
        [
          23,
          "if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)"
        ],
        [
          24,
          "sm_info->rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS;"
        ],
        [
          27,
          "sm_info->ipu_policy = 1 << F2FS_IPU_FSYNC;"
        ],
        [
          28,
          "sm_info->min_ipu_util = DEF_MIN_IPU_UTIL;"
        ],
        [
          29,
          "sm_info->min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS;"
        ],
        [
          30,
          "sm_info->min_seq_blocks = sbi->blocks_per_seg;"
        ],
        [
          31,
          "sm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;"
        ],
        [
          32,
          "sm_info->min_ssr_sections = reserved_sections(sbi);"
        ],
        [
          34,
          "INIT_LIST_HEAD(&sm_info->sit_entry_set);"
        ],
        [
          36,
          "init_f2fs_rwsem(&sm_info->curseg_lock);"
        ],
        [
          38,
          "if (!f2fs_readonly(sbi->sb)) {"
        ]
      ],
      "deref_writes": 18,
      "deref_reads": 13,
      "deref_exprs": [
        "sbi->sm_info",
        "sm_info->seg0_blkaddr",
        "raw_super->segment0_blkaddr",
        "sm_info->main_blkaddr",
        "raw_super->main_blkaddr",
        "sm_info->segment_count",
        "raw_super->segment_count",
        "sm_info->reserved_segments",
        "ckpt->rsvd_segment_count",
        "sm_info->ovp_segments",
        "ckpt->overprov_segment_count",
        "sm_info->main_segments",
        "raw_super->segment_count_main",
        "sm_info->ssa_blkaddr",
        "raw_super->ssa_blkaddr",
        "sm_info->rec_prefree_segments",
        "sm_info->ipu_policy",
        "sm_info->min_ipu_util",
        "sm_info->min_fsync_blocks",
        "sm_info->min_seq_blocks",
        "sbi->blocks_per_seg",
        "sm_info->min_hot_blocks",
        "sm_info->min_ssr_sections",
        "sm_info->sit_entry_set",
        "sm_info->curseg_lock",
        "sbi->sb"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 5258
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315#4315": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          11,
          "/* setup f2fs internal modules */"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315",
      "source_file": "fs/f2fs/super.c",
      "source_line": 4315
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442#1442": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int (*fill_super)(struct super_block *, void *, int))"
        ],
        [
          3,
          "struct block_device *bdev;"
        ],
        [
          4,
          "struct super_block *s;"
        ],
        [
          15,
          "/*"
        ],
        [
          16,
          "* once the super is inserted into the list by sget, s_umount"
        ],
        [
          17,
          "* will protect the lockfs code from trying to start a snapshot"
        ],
        [
          18,
          "* while we are mounting"
        ],
        [
          19,
          "*/"
        ],
        [
          20,
          "mutex_lock(&bdev->bd_fsfreeze_mutex);"
        ],
        [
          21,
          "if (bdev->bd_fsfreeze_count > 0) {"
        ],
        [
          22,
          "mutex_unlock(&bdev->bd_fsfreeze_mutex);"
        ],
        [
          28,
          "mutex_unlock(&bdev->bd_fsfreeze_mutex);"
        ],
        [
          32,
          "if (s->s_root) {"
        ],
        [
          33,
          "if ((flags ^ s->s_flags) & SB_RDONLY) {"
        ],
        [
          39,
          "/*"
        ],
        [
          40,
          "* s_umount nests inside bd_mutex during"
        ],
        [
          45,
          "*/"
        ],
        [
          46,
          "up_write(&s->s_umount);"
        ],
        [
          48,
          "down_write(&s->s_umount);"
        ],
        [
          50,
          "s->s_mode = mode;"
        ],
        [
          51,
          "snprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 9,
      "deref_exprs": [
        "bdev->bd_fsfreeze_mutex",
        "bdev->bd_fsfreeze_count",
        "s->s_root",
        "s->s_flags",
        "s->s_umount",
        "s->s_mode",
        "s->s_id"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442",
      "source_file": "fs/super.c",
      "source_line": 1442
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595#4595": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595",
      "source_file": "fs/f2fs/super.c",
      "source_line": 4595
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593#593": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int legacy_get_tree(struct fs_context *fc)"
        ],
        [
          3,
          "struct legacy_fs_context *ctx = fc->fs_private;"
        ],
        [
          4,
          "struct super_block *sb;"
        ],
        [
          5,
          "struct dentry *root;"
        ],
        [
          7,
          "root = fc->fs_type->mount(fc->fs_type, fc->sb_flags,"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 2,
      "deref_exprs": [
        "fc->fs_private",
        "fc->fs_type->mount",
        "fc->fs_type",
        "fc->sb_flags"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593",
      "source_file": "fs/fs_context.c",
      "source_line": 593
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572#1572": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int vfs_get_tree(struct fs_context *fc)"
        ],
        [
          3,
          "struct super_block *sb;"
        ],
        [
          6,
          "if (fc->root)"
        ],
        [
          9,
          "/* Get the mountable root in fc->root, with a ref on the root and a ref"
        ],
        [
          11,
          "*/"
        ],
        [
          12,
          "error = fc->ops->get_tree(fc);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 3,
      "deref_exprs": [
        "fc->root",
        "fc->ops->get_tree"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572",
      "source_file": "fs/super.c",
      "source_line": 1572
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997#2997": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int do_new_mount(struct path *path, const char *fstype, int sb_flags,"
        ],
        [
          2,
          "int mnt_flags, const char *name, void *data)"
        ],
        [
          4,
          "struct file_system_type *type;"
        ],
        [
          5,
          "struct fs_context *fc;"
        ],
        [
          6,
          "const char *subtype = NULL;"
        ],
        [
          16,
          "if (type->fs_flags & FS_HAS_SUBTYPE) {"
        ],
        [
          20,
          "if (!*subtype) {"
        ],
        [
          32,
          "/*"
        ],
        [
          33,
          "* Indicate to the filesystem that the mount request is coming"
        ],
        [
          35,
          "*/"
        ],
        [
          36,
          "fc->oldapi = true;"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 2,
      "deref_exprs": [
        "type->fs_flags",
        "fc->oldapi"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997",
      "source_file": "fs/namespace.c",
      "source_line": 2997
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327#3327": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327",
      "source_file": "fs/namespace.c",
      "source_line": 3327
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340#3340": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "long do_mount(const char *dev_name, const char __user *dir_name,"
        ],
        [
          2,
          "const char *type_page, unsigned long flags, void *data_page)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340",
      "source_file": "fs/namespace.c",
      "source_line": 3340
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548#3548": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,"
        ],
        [
          2,
          "char __user *, type, unsigned long, flags, void __user *, data)"
        ],
        [
          5,
          "char *kernel_type;"
        ],
        [
          6,
          "char *kernel_dev;"
        ],
        [
          7,
          "void *options;"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548",
      "source_file": "fs/namespace.c",
      "source_line": 3548
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525#3525": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name,"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525",
      "source_file": "fs/namespace.c",
      "source_line": 3525
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35#35": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35",
      "source_file": "include/linux/page_owner.h",
      "source_line": 35
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456#2456": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456",
      "source_file": "mm/page_alloc.c",
      "source_line": 2456
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462#2462": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462",
      "source_file": "mm/page_alloc.c",
      "source_line": 2462
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254#4254": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "const struct alloc_context *ac)"
        ],
        [
          4,
          "struct zoneref *z;"
        ],
        [
          5,
          "struct zone *zone;"
        ],
        [
          6,
          "struct pglist_data *last_pgdat_dirty_limit = NULL;"
        ],
        [
          10,
          "/*"
        ],
        [
          13,
          "*/"
        ],
        [
          15,
          "z = ac->preferred_zoneref;"
        ],
        [
          16,
          "for_next_zone_zonelist_nodemask(zone, z, ac->highest_zoneidx,"
        ],
        [
          17,
          "ac->nodemask) {"
        ],
        [
          18,
          "struct page *page;"
        ],
        [
          25,
          "/*"
        ],
        [
          26,
          "* When allocating a page cache page for writing, we"
        ],
        [
          27,
          "* want to get it from a node that is within its dirty"
        ],
        [
          28,
          "* limit, such that no single node holds more than its"
        ],
        [
          30,
          "* The dirty limits take into account the node's"
        ],
        [
          31,
          "* lowmem reserves and high watermark so that kswapd"
        ],
        [
          32,
          "* should be able to balance it without having to"
        ],
        [
          34,
          "*"
        ],
        [
          35,
          "* XXX: For now, allow allocations to potentially"
        ],
        [
          36,
          "* exceed the per-node dirty limit in the slowpath"
        ],
        [
          37,
          "* (spread_dirty_pages unset) before going into reclaim,"
        ],
        [
          38,
          "* which is important when on a NUMA setup the allowed"
        ],
        [
          39,
          "* nodes are together not big enough to reach the"
        ],
        [
          41,
          "* will require awareness of nodes in the"
        ],
        [
          43,
          "*/"
        ],
        [
          44,
          "if (ac->spread_dirty_pages) {"
        ],
        [
          45,
          "if (last_pgdat_dirty_limit == zone->zone_pgdat)"
        ],
        [
          48,
          "if (!node_dirty_ok(zone->zone_pgdat)) {"
        ],
        [
          49,
          "last_pgdat_dirty_limit = zone->zone_pgdat;"
        ],
        [
          55,
          "zone != ac->preferred_zoneref->zone) {"
        ],
        [
          58,
          "/*"
        ],
        [
          59,
          "* If moving to a remote node, retry but allow"
        ],
        [
          62,
          "*/"
        ],
        [
          63,
          "local_nid = zone_to_nid(ac->preferred_zoneref->zone);"
        ],
        [
          72,
          "ac->highest_zoneidx, alloc_flags,"
        ],
        [
          77,
          "/*"
        ],
        [
          78,
          "* Watermark failed for this zone, but see if we can"
        ],
        [
          80,
          "*/"
        ],
        [
          86,
          "/* Checked here to keep the fast path fast */"
        ],
        [
          92,
          "!zone_allows_reclaim(ac->preferred_zoneref->zone, zone))"
        ],
        [
          95,
          "ret = node_reclaim(zone->zone_pgdat, gfp_mask, order);"
        ],
        [
          98,
          "/* did not scan */"
        ],
        [
          101,
          "/* scanned but unreclaimable */"
        ],
        [
          104,
          "/* did we reclaim enough */"
        ],
        [
          106,
          "ac->highest_zoneidx, alloc_flags))"
        ],
        [
          114,
          "page = rmqueue(ac->preferred_zoneref->zone, zone, order,"
        ],
        [
          115,
          "gfp_mask, alloc_flags, ac->migratetype);"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 16,
      "deref_exprs": [
        "ac->preferred_zoneref",
        "ac->highest_zoneidx",
        "ac->nodemask",
        "ac->spread_dirty_pages",
        "zone->zone_pgdat",
        "ac->preferred_zoneref->zone",
        "ac->migratetype"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254",
      "source_file": "mm/page_alloc.c",
      "source_line": 4254
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370#5370": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "nodemask_t *nodemask)"
        ],
        [
          4,
          "struct page *page;"
        ],
        [
          6,
          "gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */"
        ],
        [
          9,
          "/*"
        ],
        [
          10,
          "* There are several places where we assume that the order value is sane"
        ],
        [
          12,
          "*/"
        ],
        [
          23,
          "/*"
        ],
        [
          24,
          "* Forbid the first pass from falling back to types that fragment"
        ],
        [
          26,
          "*/"
        ],
        [
          27,
          "alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref->zone, gfp_mask);"
        ],
        [
          29,
          "/* First allocation attempt */"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "deref_exprs": [
        "preferred_zoneref->zone"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370",
      "source_file": "mm/page_alloc.c",
      "source_line": 5370
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808#1808": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)"
        ],
        [
          3,
          "struct page *page;"
        ],
        [
          4,
          "struct kmem_cache_order_objects oo = s->oo;"
        ],
        [
          6,
          "void *start, *p, *next;"
        ],
        [
          15,
          "flags |= s->allocflags;"
        ],
        [
          17,
          "/*"
        ],
        [
          18,
          "* Let the initial higher-order allocation fail under memory pressure"
        ],
        [
          20,
          "*/"
        ],
        [
          22,
          "if ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 3,
      "deref_exprs": [
        "s->oo",
        "s->allocflags",
        "s->min"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808",
      "source_file": "mm/slub.c",
      "source_line": 1808
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869#1869": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869",
      "source_file": "mm/slub.c",
      "source_line": 1869
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627#2627": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,"
        ],
        [
          2,
          "int node, struct kmem_cache_cpu **pc)"
        ],
        [
          4,
          "void *freelist;"
        ],
        [
          5,
          "struct kmem_cache_cpu *c = *pc;"
        ],
        [
          6,
          "struct page *page;"
        ],
        [
          8,
          "WARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 2,
      "deref_exprs": [
        "s->ctor"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627",
      "source_file": "mm/slub.c",
      "source_line": 2627
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791#2791": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,"
        ],
        [
          2,
          "unsigned long addr, struct kmem_cache_cpu *c)"
        ],
        [
          4,
          "void *freelist;"
        ],
        [
          5,
          "struct page *page;"
        ],
        [
          9,
          "page = c->page;"
        ],
        [
          11,
          "/*"
        ],
        [
          12,
          "* if the node is not online or has no normal memory, just"
        ],
        [
          13,
          "* ignore the node constraint"
        ],
        [
          14,
          "*/"
        ],
        [
          23,
          "/*"
        ],
        [
          24,
          "* same as above but node_match() being false already"
        ],
        [
          25,
          "* implies node != NUMA_NO_NODE"
        ],
        [
          26,
          "*/"
        ],
        [
          32,
          "deactivate_slab(s, page, c->freelist, c);"
        ],
        [
          37,
          "/*"
        ],
        [
          38,
          "* By rights, we should be searching for a slab page that was"
        ],
        [
          39,
          "* PFMEMALLOC but right now, we are losing the pfmemalloc"
        ],
        [
          40,
          "* information when the page leaves the per-cpu allocator"
        ],
        [
          41,
          "*/"
        ],
        [
          43,
          "deactivate_slab(s, page, c->freelist, c);"
        ],
        [
          47,
          "/* must check again c->freelist in case of cpu migration or IRQ */"
        ],
        [
          48,
          "freelist = c->freelist;"
        ],
        [
          55,
          "c->page = NULL;"
        ],
        [
          56,
          "c->tid = next_tid(c->tid);"
        ],
        [
          64,
          "/*"
        ],
        [
          68,
          "*/"
        ],
        [
          69,
          "VM_BUG_ON(!c->page->frozen);"
        ],
        [
          70,
          "c->freelist = get_freepointer(s, freelist);"
        ],
        [
          71,
          "c->tid = next_tid(c->tid);"
        ],
        [
          77,
          "page = c->page = slub_percpu_partial(c);"
        ]
      ],
      "deref_writes": 5,
      "deref_reads": 10,
      "deref_exprs": [
        "c->page",
        "c->freelist",
        "c->tid",
        "c->page->frozen"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791",
      "source_file": "mm/slub.c",
      "source_line": 2791
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831#2831": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,"
        ],
        [
          2,
          "unsigned long addr, struct kmem_cache_cpu *c)"
        ],
        [
          4,
          "void *p;"
        ],
        [
          9,
          "/*"
        ],
        [
          10,
          "* We may have been preempted and rescheduled on a different"
        ],
        [
          13,
          "*/"
        ],
        [
          14,
          "c = this_cpu_ptr(s->cpu_slab);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "deref_exprs": [
        "s->cpu_slab"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831",
      "source_file": "mm/slub.c",
      "source_line": 2831
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913#2913": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline void *slab_alloc_node(struct kmem_cache *s,"
        ],
        [
          4,
          "void *object;"
        ],
        [
          5,
          "struct kmem_cache_cpu *c;"
        ],
        [
          6,
          "struct page *page;"
        ],
        [
          8,
          "struct obj_cgroup *objcg = NULL;"
        ],
        [
          20,
          "/*"
        ],
        [
          25,
          "*"
        ],
        [
          26,
          "* We should guarantee that tid and kmem_cache are retrieved on"
        ],
        [
          29,
          "*/"
        ],
        [
          31,
          "tid = this_cpu_read(s->cpu_slab->tid);"
        ],
        [
          32,
          "c = raw_cpu_ptr(s->cpu_slab);"
        ],
        [
          34,
          "unlikely(tid != READ_ONCE(c->tid)));"
        ],
        [
          36,
          "/*"
        ],
        [
          37,
          "* Irqless object alloc/free algorithm used here depends on sequence"
        ],
        [
          39,
          "* on c to guarantee that object and page associated with previous tid"
        ],
        [
          41,
          "* page could be one associated with next tid and our alloc/free"
        ],
        [
          43,
          "*/"
        ],
        [
          46,
          "/*"
        ],
        [
          47,
          "* The transaction ids are globally unique per cpu and per operation on"
        ],
        [
          49,
          "* occurs on the right processor and that there was no operation on the"
        ],
        [
          51,
          "*/"
        ],
        [
          53,
          "object = c->freelist;"
        ],
        [
          54,
          "page = c->page;"
        ]
      ],
      "deref_writes": 1,
      "deref_reads": 5,
      "deref_exprs": [
        "s->cpu_slab->tid",
        "s->cpu_slab",
        "c->tid",
        "c->freelist",
        "c->page"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913",
      "source_file": "mm/slub.c",
      "source_line": 2913
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955#2955": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955",
      "source_file": "mm/slub.c",
      "source_line": 2955
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536#4536": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void *__kmalloc_track_caller(size_t size, gfp_t gfpflags, unsigned long caller)"
        ],
        [
          3,
          "struct kmem_cache *s;"
        ],
        [
          4,
          "void *ret;"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536",
      "source_file": "mm/slub.c",
      "source_line": 4536
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144#144": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void *__kmalloc_reserve(size_t size, gfp_t flags, int node,"
        ],
        [
          2,
          "unsigned long ip, bool *pfmemalloc)"
        ],
        [
          4,
          "void *obj;"
        ],
        [
          7,
          "/*"
        ],
        [
          8,
          "* Try a regular allocation, when that fails and we're not entitled"
        ],
        [
          10,
          "*/"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144",
      "source_file": "net/core/skbuff.c",
      "source_line": 144
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212#212": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [
        [
          23,
          "* line. It usually works because kmalloc(X > SMP_CACHE_BYTES) gives"
        ]
      ],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,"
        ],
        [
          4,
          "struct kmem_cache *cache;"
        ],
        [
          5,
          "struct skb_shared_info *shinfo;"
        ],
        [
          6,
          "struct sk_buff *skb;"
        ],
        [
          7,
          "u8 *data;"
        ],
        [
          16,
          "/* Get the HEAD */"
        ],
        [
          22,
          "/* We do our best to align skb_shared_info on a separate cache"
        ],
        [
          25,
          "* Both skb->head and skb_shared_info are cache line aligned."
        ],
        [
          26,
          "*/"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "deref_exprs": [
        "skb->head"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212",
      "source_file": "net/core/skbuff.c",
      "source_line": 212
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126#1126": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline struct sk_buff *alloc_skb(unsigned int size,"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126",
      "source_file": "include/linux/skbuff.h",
      "source_line": 1126
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178#1178": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static struct sk_buff *netlink_alloc_large_skb(unsigned int size,"
        ],
        [
          4,
          "struct sk_buff *skb;"
        ],
        [
          5,
          "void *data;"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178",
      "source_file": "net/netlink/af_netlink.c",
      "source_line": 1178
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889#1889": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int netlink_sendmsg(struct socket *sock, struct msghdr *msg, size_t len)"
        ],
        [
          3,
          "struct sock *sk = sock->sk;"
        ],
        [
          4,
          "struct netlink_sock *nlk = nlk_sk(sk);"
        ],
        [
          5,
          "DECLARE_SOCKADDR(struct sockaddr_nl *, addr, msg->msg_name);"
        ],
        [
          8,
          "struct sk_buff *skb;"
        ],
        [
          13,
          "if (msg->msg_flags & MSG_OOB)"
        ],
        [
          25,
          "if (msg->msg_namelen) {"
        ],
        [
          27,
          "if (msg->msg_namelen < sizeof(struct sockaddr_nl))"
        ],
        [
          29,
          "if (addr->nl_family != AF_NETLINK)"
        ],
        [
          31,
          "dst_portid = addr->nl_pid;"
        ],
        [
          32,
          "dst_group = ffs(addr->nl_groups);"
        ],
        [
          39,
          "/* Paired with WRITE_ONCE() in netlink_connect() */"
        ],
        [
          40,
          "dst_portid = READ_ONCE(nlk->dst_portid);"
        ],
        [
          41,
          "dst_group = READ_ONCE(nlk->dst_group);"
        ],
        [
          44,
          "/* Paired with WRITE_ONCE() in netlink_insert() */"
        ],
        [
          45,
          "if (!READ_ONCE(nlk->bound)) {"
        ],
        [
          55,
          "if (len > sk->sk_sndbuf - 32)"
        ]
      ],
      "deref_writes": 3,
      "deref_reads": 11,
      "deref_exprs": [
        "sock->sk",
        "msg->msg_name",
        "msg->msg_flags",
        "msg->msg_namelen",
        "addr->nl_family",
        "addr->nl_pid",
        "addr->nl_groups",
        "nlk->dst_portid",
        "nlk->dst_group",
        "nlk->bound",
        "sk->sk_sndbuf"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889",
      "source_file": "net/netlink/af_netlink.c",
      "source_line": 1889
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652#652": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg)"
        ],
        [
          3,
          "int ret = INDIRECT_CALL_INET(sock->ops->sendmsg, inet6_sendmsg,"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 1,
      "deref_exprs": [
        "sock->ops->sendmsg"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652",
      "source_file": "net/socket.c",
      "source_line": 652
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664#664": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int __sock_sendmsg(struct socket *sock, struct msghdr *msg)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664",
      "source_file": "net/socket.c",
      "source_line": 664
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376#2376": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys,"
        ],
        [
          2,
          "unsigned int flags, struct used_address *used_address,"
        ],
        [
          5,
          "unsigned char ctl[sizeof(struct cmsghdr) + 20]"
        ],
        [
          7,
          "/* 20 is size of ipv6_pktinfo */"
        ],
        [
          8,
          "unsigned char *ctl_buf = ctl;"
        ],
        [
          14,
          "if (msg_sys->msg_controllen > INT_MAX)"
        ],
        [
          16,
          "flags |= (msg_sys->msg_flags & allowed_msghdr_flags);"
        ],
        [
          17,
          "ctl_len = msg_sys->msg_controllen;"
        ],
        [
          20,
          "cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,"
        ],
        [
          24,
          "ctl_buf = msg_sys->msg_control;"
        ],
        [
          25,
          "ctl_len = msg_sys->msg_controllen;"
        ],
        [
          30,
          "ctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);"
        ],
        [
          35,
          "if (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))"
        ],
        [
          35,
          "if (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))"
        ],
        [
          37,
          "msg_sys->msg_control = ctl_buf;"
        ],
        [
          38,
          "msg_sys->msg_control_is_user = false;"
        ],
        [
          40,
          "msg_sys->msg_flags = flags;"
        ],
        [
          42,
          "if (sock->file->f_flags & O_NONBLOCK)"
        ],
        [
          43,
          "msg_sys->msg_flags |= MSG_DONTWAIT;"
        ],
        [
          44,
          "/*"
        ],
        [
          45,
          "* If this is sendmmsg() and current destination address is same as"
        ],
        [
          47,
          "* used_address->name_len is initialized to UINT_MAX so that the first"
        ],
        [
          49,
          "*/"
        ],
        [
          50,
          "if (used_address && msg_sys->msg_name &&"
        ],
        [
          51,
          "used_address->name_len == msg_sys->msg_namelen &&"
        ],
        [
          52,
          "!memcmp(&used_address->name, msg_sys->msg_name,"
        ],
        [
          53,
          "used_address->name_len)) {"
        ]
      ],
      "deref_writes": 7,
      "deref_reads": 14,
      "deref_exprs": [
        "msg_sys->msg_controllen",
        "msg_sys->msg_flags",
        "sock->sk",
        "msg_sys->msg_control",
        "msg_sys->msg_control_user",
        "msg_sys->msg_control_is_user",
        "sock->file->f_flags",
        "used_address->name_len",
        "msg_sys->msg_name",
        "msg_sys->msg_namelen",
        "used_address->name"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376",
      "source_file": "net/socket.c",
      "source_line": 2376
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430#2430": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ___sys_sendmsg(struct socket *sock, struct user_msghdr __user *msg,"
        ],
        [
          2,
          "struct msghdr *msg_sys, unsigned int flags,"
        ],
        [
          3,
          "struct used_address *used_address,"
        ],
        [
          7,
          "struct iovec iovstack[UIO_FASTIOV], *iov = iovstack;"
        ],
        [
          7,
          "struct iovec iovstack[UIO_FASTIOV], *iov = iovstack;"
        ],
        [
          10,
          "msg_sys->msg_name = &address;"
        ]
      ],
      "deref_writes": 2,
      "deref_reads": 0,
      "deref_exprs": [
        "msg_sys->msg_name"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430",
      "source_file": "net/socket.c",
      "source_line": 2430
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459#2459": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "long __sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned int flags,"
        ],
        [
          6,
          "struct socket *sock;"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459",
      "source_file": "net/socket.c",
      "source_line": 2459
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468#2468": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468",
      "source_file": "net/socket.c",
      "source_line": 2468
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466#2466": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags)"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 0,
      "deref_exprs": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466",
      "source_file": "net/socket.c",
      "source_line": 2466
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481#3481": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void f2fs_allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,"
        ],
        [
          2,
          "block_t old_blkaddr, block_t *new_blkaddr,"
        ],
        [
          3,
          "struct f2fs_summary *sum, int type,"
        ],
        [
          4,
          "struct f2fs_io_info *fio)"
        ],
        [
          6,
          "struct sit_info *sit_i = SIT_I(sbi);"
        ],
        [
          7,
          "struct curseg_info *curseg = CURSEG_I(sbi, type);"
        ],
        [
          10,
          "struct seg_entry *se = NULL;"
        ],
        [
          12,
          "f2fs_down_read(&SM_I(sbi)->curseg_lock);"
        ],
        [
          14,
          "mutex_lock(&curseg->curseg_mutex);"
        ],
        [
          15,
          "down_write(&sit_i->sentry_lock);"
        ],
        [
          20,
          "sanity_check_seg_type(sbi, se->type);"
        ],
        [
          21,
          "f2fs_bug_on(sbi, IS_NODESEG(se->type));"
        ],
        [
          23,
          "*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);"
        ],
        [
          25,
          "f2fs_bug_on(sbi, curseg->next_blkoff >= sbi->blocks_per_seg);"
        ],
        [
          27,
          "f2fs_wait_discard_bio(sbi, *new_blkaddr);"
        ],
        [
          29,
          "/*"
        ],
        [
          30,
          "* __add_sum_entry should be resided under the curseg_mutex"
        ],
        [
          31,
          "* because, this function updates a summary entry in the"
        ],
        [
          33,
          "*/"
        ],
        [
          46,
          "update_segment_mtime(sbi, *new_blkaddr, old_mtime);"
        ],
        [
          48,
          "/*"
        ],
        [
          49,
          "* SIT information should be updated before segment allocation,"
        ],
        [
          51,
          "*/"
        ],
        [
          52,
          "update_sit_entry(sbi, *new_blkaddr, 1);"
        ]
      ],
      "deref_writes": 5,
      "deref_reads": 6,
      "deref_exprs": [
        "curseg->curseg_mutex",
        "sit_i->sentry_lock",
        "se->type",
        "curseg->next_blkoff",
        "sbi->blocks_per_seg"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481",
      "source_file": "fs/f2fs/segment.c",
      "source_line": 3481
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407#1407": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int __allocate_data_block(struct dnode_of_data *dn, int seg_type)"
        ],
        [
          3,
          "struct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);"
        ],
        [
          10,
          "if (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))"
        ],
        [
          13,
          "err = f2fs_get_node_info(sbi, dn->nid, &ni, false);"
        ],
        [
          17,
          "dn->data_blkaddr = f2fs_data_blkaddr(dn);"
        ],
        [
          18,
          "if (dn->data_blkaddr != NULL_ADDR)"
        ],
        [
          21,
          "if (unlikely((err = inc_valid_block_count(sbi, dn->inode, &count))))"
        ],
        [
          25,
          "set_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);"
        ],
        [
          26,
          "old_blkaddr = dn->data_blkaddr;"
        ],
        [
          27,
          "f2fs_allocate_data_block(sbi, NULL, old_blkaddr, &dn->data_blkaddr,"
        ]
      ],
      "deref_writes": 3,
      "deref_reads": 7,
      "deref_exprs": [
        "dn->inode",
        "dn->nid",
        "dn->data_blkaddr",
        "dn->ofs_in_node"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407",
      "source_file": "fs/f2fs/data.c",
      "source_line": 1407
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575#1575": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          7,
          "if (map->m_next_pgofs)"
        ],
        [
          8,
          "*map->m_next_pgofs ="
        ],
        [
          10,
          "if (map->m_next_extent)"
        ],
        [
          11,
          "*map->m_next_extent ="
        ],
        [
          32,
          "/* use out-place-update for driect IO under LFS mode */"
        ],
        [
          34,
          "map->m_may_create) {"
        ],
        [
          35,
          "err = __allocate_data_block(&dn, map->m_seg_type);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 6,
      "deref_exprs": [
        "map->m_next_pgofs",
        "map->m_next_extent",
        "map->m_may_create",
        "map->m_seg_type"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575",
      "source_file": "fs/f2fs/data.c",
      "source_line": 1575
    },
    "link:https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724#1724": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "f2fs_down_write(&sbi->gc_lock);"
        ],
        [
          8,
          "f2fs_down_write(&sbi->pin_sem);"
        ]
      ],
      "deref_writes": 0,
      "deref_reads": 2,
      "deref_exprs": [
        "sbi->gc_lock",
        "sbi->pin_sem"
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724",
      "source_file": "fs/f2fs/file.c",
      "source_line": 1724
    }
  },
  "classification": {
    "primitive": "null-pointer-deref",
    "vulnerability": "denial-of-service (kernel crash)",
    "confidence": 1.0,
    "preconditions": [
      "Triggering syzkaller syscall(s): ffff8881f7100000, disassembly, movzbl",
      "Triggering syscall(s) from crash text: ioctl, mount, sendmsg",
      "How to create: allocate the object via code path that calls: __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>",
      "How to create hint: Allocation from slab/kmalloc: create objects via normal kernel paths (file ops, network ops, or module-specific APIs)",
      "Object details: type 'kmalloc-1k', address ffff88811471c800, size 1024",
      "Object: cache 'kmalloc-1k', address ffff88811471c800, size 1024, offset 960",
      "State: dentry pointer may be NULL or invalid leading to null-pointer deref in dcache/namei code paths",
      "An externally-controlled syscall input (fuzzer/syzkaller) reached the vulnerable syscall path",
      "Input state: attacker-controlled syscall parameters or user-supplied data must reach the vulnerable code path",
      "Code path: execution reaches function '__set_sit_entry_type' (from crash context)",
      "State: variable(s) like sbi, se, curseg may point into freed/reclaimed memory (observed in nearby source lines)",
      "path constraint (input): err && err != -ENODATA && err != -EAGAIN -- at fs/f2fs/file.c:1724",
      "path constraint (input): if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE | -- at fs/f2fs/file.c:1856",
      "path constraint (input): offset >= inode->i_size -- at fs/f2fs/file.c:1874",
      "path constraint (input): offset < 0 || len <= 0 -- at fs/open.c:316",
      "path constraint (input): (mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode) -- at fs/open.c:354",
      "path constraint (kernel state): old == -1 -- at lib/dump_stack.c:134",
      "path constraint (kernel state): old == cpu -- at lib/dump_stack.c:136",
      "path constraint (kernel state): atomic_read(&dump_lock) != -1 -- at lib/dump_stack.c:145",
      "path constraint (kernel state): goto retry; -- at lib/dump_stack.c:146",
      "path constraint (kernel state): curseg->inited -- at fs/f2fs/segment.c:2731",
      "path constraint (kernel state): seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA -- at fs/f2fs/segment.c:2734",
      "path constraint (kernel state): test_opt(sbi, NOHEAP) -- at fs/f2fs/segment.c:2737",
      "path constraint (kernel state): !curseg->inited -- at fs/f2fs/segment.c:3046"
    ],
    "postconditions": [
      "KASAN or BUG report emitted indicating invalid memory access"
    ],
    "support": [
      "KASAN reported slab-out-of-bounds (log contains 'slab-out-of-bounds')",
      "Access offset 960 inside object size 1024",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains alloc-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Control-flow path constraints extracted from stack snippets (if/for/while/switch, returns)",
      "KASAN reported null-ptr-deref in crash log",
      "evidence: fs/fs_context.c:597 'struct dentry *root;'",
      "deref_exprs: se->type, curseg->segno, curseg->seg_type",
      "faulting address: 0xdffffc0000000000",
      "BUG: KASAN: slab-out-of-bounds in __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]; fs_context.c:597 -> struct dentry *root;; dereference expressions: se->type, curseg->segno, curseg->seg_type; faulting address: 0xdffffc0000000000; No clear evidence of arbitrary read/write (KASAN null-pointer derefs commonly indicate DoS)",
      "Allocation origin: __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>",
      "Syscall(s) detected in crash text: ioctl, mount, sendmsg",
      "Syzkaller repro indicates syscalls: ffff8881f7100000, disassembly, movzbl"
    ],
    "path_constraints": {
      "input_constraints": [
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1724,
          "code": "if (err && err != -ENODATA && err != -EAGAIN)",
          "condition": "err && err != -ENODATA && err != -EAGAIN",
          "variables": [
            "err",
            "err",
            "ENODATA",
            "err",
            "EAGAIN"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1856,
          "code": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "condition": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "variables": [
            "if",
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1874,
          "code": "if (offset >= inode->i_size)",
          "condition": "offset >= inode->i_size",
          "variables": [
            "offset",
            "inode",
            "i_size"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 316,
          "code": "if (offset < 0 || len <= 0)",
          "condition": "offset < 0 || len <= 0",
          "variables": [
            "offset",
            "len"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 354,
          "code": "if ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))",
          "condition": "(mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode)",
          "variables": [
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "IS_APPEND",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 384,
          "code": "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))",
          "condition": "((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0)",
          "variables": [
            "offset",
            "len",
            "inode",
            "i_sb",
            "s_maxbytes",
            "offset",
            "len"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 500,
          "code": "if (copy_from_user(&sr, argp, sizeof(sr)))",
          "condition": "copy_from_user(&sr, argp, sizeof(sr))",
          "variables": [
            "copy_from_user",
            "sr",
            "argp",
            "sizeof",
            "sr"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'sr' traced to user/syscall source: copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 503,
          "code": "switch (sr.l_whence) {",
          "condition": "sr.l_whence",
          "variables": [
            "sr",
            "l_whence"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sr' traced to user/syscall source: copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 516,
          "code": "return vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,",
          "condition": "return vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,",
          "variables": [
            "return",
            "vfs_fallocate",
            "filp",
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "sr",
            "l_start"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sr' traced to user/syscall source: copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 735,
          "code": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "condition": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "variables": [
            "return",
            "copy_to_user",
            "argp",
            "res",
            "sizeof",
            "res"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 742,
          "code": "return ioctl_fsfreeze(filp);",
          "condition": "return ioctl_fsfreeze(filp);",
          "variables": [
            "return",
            "ioctl_fsfreeze",
            "filp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 745,
          "code": "return ioctl_fsthaw(filp);",
          "condition": "return ioctl_fsthaw(filp);",
          "variables": [
            "return",
            "ioctl_fsthaw",
            "filp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 748,
          "code": "return ioctl_fiemap(filp, argp);",
          "condition": "return ioctl_fiemap(filp, argp);",
          "variables": [
            "return",
            "ioctl_fiemap",
            "filp",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 752,
          "code": "if (!inode->i_sb->s_blocksize)",
          "condition": "!inode->i_sb->s_blocksize",
          "variables": [
            "inode",
            "i_sb",
            "s_blocksize"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 755,
          "code": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "condition": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "variables": [
            "return",
            "put_user",
            "inode",
            "i_sb",
            "s_blocksize",
            "int",
            "__user",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'int' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "condition": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "variables": [
            "return",
            "ioctl_file_clone",
            "filp",
            "arg"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "return ioctl_file_clone_range(filp, argp);",
          "condition": "return ioctl_file_clone_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_clone_range",
            "filp",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 764,
          "code": "return ioctl_file_dedupe_range(filp, argp);",
          "condition": "return ioctl_file_dedupe_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_dedupe_range",
            "filp",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 768,
          "code": "return vfs_ioctl(filp, cmd, arg);",
          "condition": "return vfs_ioctl(filp, cmd, arg);",
          "variables": [
            "return",
            "vfs_ioctl",
            "filp",
            "cmd",
            "arg"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 770,
          "code": "return put_user(i_size_read(inode) - filp->f_pos,",
          "condition": "return put_user(i_size_read(inode) - filp->f_pos,",
          "variables": [
            "return",
            "put_user",
            "i_size_read",
            "inode",
            "filp",
            "f_pos"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 775,
          "code": "return file_ioctl(filp, cmd, argp);",
          "condition": "return file_ioctl(filp, cmd, argp);",
          "variables": [
            "return",
            "file_ioctl",
            "filp",
            "cmd",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "arch/x86/entry/common.c",
          "line": 52,
          "code": "if (likely(nr < NR_syscalls)) {",
          "condition": "likely(nr < NR_syscalls)",
          "variables": [
            "likely",
            "nr",
            "NR_syscalls"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'nr' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4039,
          "code": "if (unlikely(size > KMALLOC_MAX_CACHE_SIZE))",
          "condition": "unlikely(size > KMALLOC_MAX_CACHE_SIZE)",
          "variables": [
            "unlikely",
            "size",
            "KMALLOC_MAX_CACHE_SIZE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4040,
          "code": "return kmalloc_large(size, flags);",
          "condition": "return kmalloc_large(size, flags);",
          "variables": [
            "return",
            "kmalloc_large",
            "size",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 419,
          "code": "return __kmalloc(size, flags);",
          "condition": "return __kmalloc(size, flags);",
          "variables": [
            "return",
            "__kmalloc",
            "size",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 579,
          "code": "if (__builtin_constant_p(size) &&",
          "condition": "__builtin_constant_p(size",
          "variables": [
            "__builtin_constant_p",
            "size"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 584,
          "code": "return ZERO_SIZE_PTR;",
          "condition": "return ZERO_SIZE_PTR;",
          "variables": [
            "return",
            "ZERO_SIZE_PTR"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 591,
          "code": "return __kmalloc_node(size, flags, node);",
          "condition": "return __kmalloc_node(size, flags, node);",
          "variables": [
            "return",
            "__kmalloc_node",
            "size",
            "flags",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 622,
          "code": "if ((flags & GFP_KERNEL) != GFP_KERNEL)",
          "condition": "(flags & GFP_KERNEL) != GFP_KERNEL",
          "variables": [
            "flags",
            "GFP_KERNEL",
            "GFP_KERNEL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 623,
          "code": "return kmalloc_node(size, flags, node);",
          "condition": "return kmalloc_node(size, flags, node);",
          "variables": [
            "return",
            "kmalloc_node",
            "size",
            "flags",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 632,
          "code": "if (size > PAGE_SIZE) {",
          "condition": "size > PAGE_SIZE",
          "variables": [
            "size",
            "PAGE_SIZE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "include/linux/mm.h",
          "line": 834,
          "code": "return kvmalloc_node(size, flags, NUMA_NO_NODE);",
          "condition": "return kvmalloc_node(size, flags, NUMA_NO_NODE);",
          "variables": [
            "return",
            "kvmalloc_node",
            "size",
            "flags",
            "NUMA_NO_NODE"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/f2fs.h",
          "line": 3375,
          "code": "return kvmalloc(size, flags);",
          "condition": "return kvmalloc(size, flags);",
          "variables": [
            "return",
            "kvmalloc",
            "size",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/f2fs.h",
          "line": 3381,
          "code": "return f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);",
          "condition": "return f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);",
          "variables": [
            "return",
            "f2fs_kvmalloc",
            "sbi",
            "size",
            "flags",
            "__GFP_ZERO"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5298,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5299,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5303,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5304,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/super.c",
          "line": 4318,
          "code": "if (err) {",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1450,
          "code": "if (!(flags & SB_RDONLY))",
          "condition": "!(flags & SB_RDONLY)",
          "variables": [
            "flags",
            "SB_RDONLY"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1463,
          "code": "if (bdev->bd_fsfreeze_count > 0) {",
          "condition": "bdev->bd_fsfreeze_count > 0",
          "variables": [
            "bdev",
            "bd_fsfreeze_count"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1475,
          "code": "if ((flags ^ s->s_flags) & SB_RDONLY) {",
          "condition": "(flags ^ s->s_flags) & SB_RDONLY",
          "variables": [
            "flags",
            "s",
            "s_flags",
            "SB_RDONLY"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/super.c",
          "line": 4596,
          "code": "return mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);",
          "condition": "return mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);",
          "variables": [
            "return",
            "mount_bdev",
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "f2fs_fill_super"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3038,
          "code": "if (!err && name)",
          "condition": "!err && name",
          "variables": [
            "err",
            "name"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3040,
          "code": "if (!err)",
          "condition": "!err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3042,
          "code": "if (!err && !mount_capable(fc))",
          "condition": "!err && !mount_capable(fc)",
          "variables": [
            "err",
            "mount_capable",
            "fc"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3044,
          "code": "if (!err)",
          "condition": "!err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5385,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'NULL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5391,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'NULL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 1820,
          "code": "if (gfpflags_allow_blocking(flags))",
          "condition": "gfpflags_allow_blocking(flags)",
          "variables": [
            "gfpflags_allow_blocking",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2926,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'NULL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2956,
          "code": "return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr, orig_size);",
          "condition": "return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr, orig_size);",
          "variables": [
            "return",
            "slab_alloc_node",
            "s",
            "gfpflags",
            "NUMA_NO_NODE",
            "addr",
            "orig_size"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4542,
          "code": "if (unlikely(size > KMALLOC_MAX_CACHE_SIZE))",
          "condition": "unlikely(size > KMALLOC_MAX_CACHE_SIZE)",
          "variables": [
            "unlikely",
            "size",
            "KMALLOC_MAX_CACHE_SIZE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4543,
          "code": "return kmalloc_large(size, gfpflags);",
          "condition": "return kmalloc_large(size, gfpflags);",
          "variables": [
            "return",
            "kmalloc_large",
            "size",
            "gfpflags"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/core/skbuff.c",
          "line": 225,
          "code": "if (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))",
          "condition": "sk_memalloc_socks() && (flags & SKB_ALLOC_RX)",
          "variables": [
            "sk_memalloc_socks",
            "flags",
            "SKB_ALLOC_RX"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "include/linux/skbuff.h",
          "line": 1130,
          "code": "return __alloc_skb(size, priority, 0, NUMA_NO_NODE);",
          "condition": "return __alloc_skb(size, priority, 0, NUMA_NO_NODE);",
          "variables": [
            "return",
            "__alloc_skb",
            "size",
            "priority",
            "NUMA_NO_NODE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1185,
          "code": "if (size <= NLMSG_GOODSIZE || broadcast)",
          "condition": "size <= NLMSG_GOODSIZE || broadcast",
          "variables": [
            "size",
            "NLMSG_GOODSIZE",
            "broadcast"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1186,
          "code": "return alloc_skb(size, GFP_KERNEL);",
          "condition": "return alloc_skb(size, GFP_KERNEL);",
          "variables": [
            "return",
            "alloc_skb",
            "size",
            "GFP_KERNEL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'GFP_KERNEL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1902,
          "code": "if (msg->msg_flags & MSG_OOB)",
          "condition": "msg->msg_flags & MSG_OOB",
          "variables": [
            "msg",
            "msg_flags",
            "MSG_OOB"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1905,
          "code": "if (len == 0) {",
          "condition": "len == 0",
          "variables": [
            "len"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1911,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1912,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1914,
          "code": "if (msg->msg_namelen) {",
          "condition": "msg->msg_namelen",
          "variables": [
            "msg",
            "msg_namelen"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1916,
          "code": "if (msg->msg_namelen < sizeof(struct sockaddr_nl))",
          "condition": "msg->msg_namelen < sizeof(struct sockaddr_nl)",
          "variables": [
            "msg",
            "msg_namelen",
            "sizeof",
            "struct",
            "sockaddr_nl"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1918,
          "code": "if (addr->nl_family != AF_NETLINK)",
          "condition": "addr->nl_family != AF_NETLINK",
          "variables": [
            "addr",
            "nl_family",
            "AF_NETLINK"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1936,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1944,
          "code": "if (len > sk->sk_sndbuf - 32)",
          "condition": "len > sk->sk_sndbuf - 32",
          "variables": [
            "len",
            "sk",
            "sk_sndbuf"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sk' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 670,
          "code": "return err ?: sock_sendmsg_nosec(sock, msg);",
          "condition": "return err ?: sock_sendmsg_nosec(sock, msg);",
          "variables": [
            "return",
            "err",
            "sock_sendmsg_nosec",
            "sock",
            "msg"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2390,
          "code": "if (msg_sys->msg_controllen > INT_MAX)",
          "condition": "msg_sys->msg_controllen > INT_MAX",
          "variables": [
            "msg_sys",
            "msg_controllen",
            "INT_MAX"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg_sys' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2394,
          "code": "if ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
          "condition": "(MSG_CMSG_COMPAT & flags) && ctl_len",
          "variables": [
            "MSG_CMSG_COMPAT",
            "flags",
            "ctl_len"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'MSG_CMSG_COMPAT' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2398,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2402,
          "code": "} else if (ctl_len) {",
          "condition": "ctl_len",
          "variables": [
            "ctl_len"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'ctl_len' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2405,
          "code": "if (ctl_len > sizeof(ctl)) {",
          "condition": "ctl_len > sizeof(ctl)",
          "variables": [
            "ctl_len",
            "sizeof",
            "ctl"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'ctl_len' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2407,
          "code": "if (ctl_buf == NULL)",
          "condition": "ctl_buf == NULL",
          "variables": [
            "ctl_buf",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'ctl_buf' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2411,
          "code": "if (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))",
          "condition": "copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len)",
          "variables": [
            "copy_from_user",
            "ctl_buf",
            "msg_sys",
            "msg_control_user",
            "ctl_len"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'ctl_buf' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2418,
          "code": "if (sock->file->f_flags & O_NONBLOCK)",
          "condition": "sock->file->f_flags & O_NONBLOCK",
          "variables": [
            "sock",
            "file",
            "f_flags",
            "O_NONBLOCK"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sock' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2426,
          "code": "if (used_address && msg_sys->msg_name &&",
          "condition": "if (used_address && msg_sys->msg_name &&",
          "variables": [
            "if",
            "used_address",
            "msg_sys",
            "msg_name"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'used_address' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2443,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2444,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2467,
          "code": "if (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))",
          "condition": "forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT)",
          "variables": [
            "forbid_cmsg_compat",
            "flags",
            "MSG_CMSG_COMPAT"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'forbid_cmsg_compat' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2471,
          "code": "if (!sock)",
          "condition": "!sock",
          "variables": [
            "sock"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sock' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2471,
          "code": "return __sys_sendmsg(fd, msg, flags, true);",
          "condition": "return __sys_sendmsg(fd, msg, flags, true);",
          "variables": [
            "return",
            "__sys_sendmsg",
            "fd",
            "msg",
            "flags",
            "true"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'fd' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1421,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1422,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1428,
          "code": "if (unlikely((err = inc_valid_block_count(sbi, dn->inode, &count))))",
          "condition": "unlikely((err = inc_valid_block_count(sbi, dn->inode, &count)))",
          "variables": [
            "unlikely",
            "err",
            "inc_valid_block_count",
            "sbi",
            "dn",
            "inode",
            "count"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1429,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1600,
          "code": "if (__is_valid_data_blkaddr(blkaddr) &&",
          "condition": "__is_valid_data_blkaddr(blkaddr",
          "variables": [
            "__is_valid_data_blkaddr",
            "blkaddr"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1606,
          "code": "if (__is_valid_data_blkaddr(blkaddr)) {",
          "condition": "__is_valid_data_blkaddr(blkaddr)",
          "variables": [
            "__is_valid_data_blkaddr",
            "blkaddr"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1611,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1728,
          "code": "if (err && err != -ENODATA && err != -EAGAIN)",
          "condition": "err && err != -ENODATA && err != -EAGAIN",
          "variables": [
            "err",
            "err",
            "ENODATA",
            "err",
            "EAGAIN"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        }
      ],
      "kernel_state_constraints": [
        {
          "frame": null,
          "file": "fs/fs_context.c",
          "line": 597,
          "code": "struct dentry *root;",
          "condition": "dentry pointer may be NULL or invalid",
          "variables": [
            "dentry"
          ],
          "evidence": [
            {
              "file": "fs/fs_context.c",
              "line": 597,
              "code": "struct dentry *root;",
              "note": "dentry-related line near crash site"
            }
          ],
          "why_it_blocks": "null/invalid dentry pointer will cause dereference and crash"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 134,
          "code": "if (old == -1) {",
          "condition": "old == -1",
          "variables": [
            "old"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 136,
          "code": "} else if (old == cpu) {",
          "condition": "old == cpu",
          "variables": [
            "old",
            "cpu"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 145,
          "code": "do { cpu_relax(); } while (atomic_read(&dump_lock) != -1);",
          "condition": "atomic_read(&dump_lock) != -1",
          "variables": [
            "atomic_read",
            "dump_lock"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 146,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 2731,
          "code": "if (curseg->inited)",
          "condition": "curseg->inited",
          "variables": [
            "curseg",
            "inited"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 2734,
          "code": "if (seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA)",
          "condition": "seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA",
          "variables": [
            "seg_type",
            "CURSEG_WARM_DATA",
            "seg_type",
            "CURSEG_COLD_DATA"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 2737,
          "code": "if (test_opt(sbi, NOHEAP))",
          "condition": "test_opt(sbi, NOHEAP)",
          "variables": [
            "test_opt",
            "sbi",
            "NOHEAP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3046,
          "code": "if (!curseg->inited)",
          "condition": "!curseg->inited",
          "variables": [
            "curseg",
            "inited"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3047,
          "code": "goto alloc;",
          "condition": "goto alloc;",
          "variables": [
            "goto",
            "alloc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3049,
          "code": "if (force || curseg->next_blkoff ||",
          "condition": "if (force || curseg->next_blkoff ||",
          "variables": [
            "if",
            "force",
            "curseg",
            "next_blkoff"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3051,
          "code": "goto alloc;",
          "condition": "goto alloc;",
          "variables": [
            "goto",
            "alloc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3053,
          "code": "if (!get_ckpt_valid_blocks(sbi, curseg->segno, new_sec))",
          "condition": "!get_ckpt_valid_blocks(sbi, curseg->segno, new_sec)",
          "variables": [
            "get_ckpt_valid_blocks",
            "sbi",
            "curseg",
            "segno",
            "new_sec"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3054,
          "code": "return;",
          "condition": "return;",
          "variables": [
            "return"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1725,
          "code": "goto out_err;",
          "condition": "goto out_err;",
          "variables": [
            "goto",
            "out_err"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1832,
          "code": "if (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))",
          "condition": "unlikely(f2fs_cp_error(F2FS_I_SB(inode)))",
          "variables": [
            "unlikely",
            "f2fs_cp_error",
            "F2FS_I_SB",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1833,
          "code": "return -EIO;",
          "condition": "return -EIO;",
          "variables": [
            "return",
            "EIO"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1834,
          "code": "if (!f2fs_is_checkpoint_ready(F2FS_I_SB(inode)))",
          "condition": "!f2fs_is_checkpoint_ready(F2FS_I_SB(inode))",
          "variables": [
            "f2fs_is_checkpoint_ready",
            "F2FS_I_SB",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1835,
          "code": "return -ENOSPC;",
          "condition": "return -ENOSPC;",
          "variables": [
            "return",
            "ENOSPC"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1836,
          "code": "if (!f2fs_is_compress_backend_ready(inode))",
          "condition": "!f2fs_is_compress_backend_ready(inode)",
          "variables": [
            "f2fs_is_compress_backend_ready",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1837,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1840,
          "code": "if (!S_ISREG(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1841,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1843,
          "code": "if (IS_ENCRYPTED(inode) &&",
          "condition": "IS_ENCRYPTED(inode",
          "variables": [
            "IS_ENCRYPTED",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1845,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1851,
          "code": "if ((f2fs_compressed_file(inode) || f2fs_is_pinned_file(inode)) &&",
          "condition": "(f2fs_compressed_file(inode) || f2fs_is_pinned_file(inode)",
          "variables": [
            "f2fs_compressed_file",
            "inode",
            "f2fs_is_pinned_file",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1854,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1859,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1864,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1865,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1873,
          "code": "if (mode & FALLOC_FL_PUNCH_HOLE) {",
          "condition": "mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1875,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1878,
          "code": "} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {",
          "condition": "mode & FALLOC_FL_COLLAPSE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_COLLAPSE_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1880,
          "code": "} else if (mode & FALLOC_FL_ZERO_RANGE) {",
          "condition": "mode & FALLOC_FL_ZERO_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_ZERO_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1882,
          "code": "} else if (mode & FALLOC_FL_INSERT_RANGE) {",
          "condition": "mode & FALLOC_FL_INSERT_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_INSERT_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 317,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 320,
          "code": "if (mode & ~FALLOC_FL_SUPPORTED_MASK)",
          "condition": "mode & ~FALLOC_FL_SUPPORTED_MASK",
          "variables": [
            "mode",
            "FALLOC_FL_SUPPORTED_MASK"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 321,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 324,
          "code": "if ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==",
          "condition": "(mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE",
            "FALLOC_FL_ZERO_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 326,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 329,
          "code": "if ((mode & FALLOC_FL_PUNCH_HOLE) &&",
          "condition": "(mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 331,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 334,
          "code": "if ((mode & FALLOC_FL_COLLAPSE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_COLLAPSE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_COLLAPSE_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 336,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 339,
          "code": "if ((mode & FALLOC_FL_INSERT_RANGE) &&",
          "condition": "(mode & FALLOC_FL_INSERT_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_INSERT_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 341,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 344,
          "code": "if ((mode & FALLOC_FL_UNSHARE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_UNSHARE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_UNSHARE_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 346,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 348,
          "code": "if (!(file->f_mode & FMODE_WRITE))",
          "condition": "!(file->f_mode & FMODE_WRITE)",
          "variables": [
            "file",
            "f_mode",
            "FMODE_WRITE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 349,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 355,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 357,
          "code": "if (IS_IMMUTABLE(inode))",
          "condition": "IS_IMMUTABLE(inode)",
          "variables": [
            "IS_IMMUTABLE",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 358,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 363,
          "code": "if (IS_SWAPFILE(inode))",
          "condition": "IS_SWAPFILE(inode)",
          "variables": [
            "IS_SWAPFILE",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 364,
          "code": "return -ETXTBSY;",
          "condition": "return -ETXTBSY;",
          "variables": [
            "return",
            "ETXTBSY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 371,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 372,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 374,
          "code": "if (S_ISFIFO(inode->i_mode))",
          "condition": "S_ISFIFO(inode->i_mode)",
          "variables": [
            "S_ISFIFO",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 375,
          "code": "return -ESPIPE;",
          "condition": "return -ESPIPE;",
          "variables": [
            "return",
            "ESPIPE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 377,
          "code": "if (S_ISDIR(inode->i_mode))",
          "condition": "S_ISDIR(inode->i_mode)",
          "variables": [
            "S_ISDIR",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 378,
          "code": "return -EISDIR;",
          "condition": "return -EISDIR;",
          "variables": [
            "return",
            "EISDIR"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 380,
          "code": "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode",
            "S_ISBLK",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 381,
          "code": "return -ENODEV;",
          "condition": "return -ENODEV;",
          "variables": [
            "return",
            "ENODEV"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 385,
          "code": "return -EFBIG;",
          "condition": "return -EFBIG;",
          "variables": [
            "return",
            "EFBIG"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 387,
          "code": "if (!file->f_op->fallocate)",
          "condition": "!file->f_op->fallocate",
          "variables": [
            "file",
            "f_op",
            "fallocate"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 388,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 501,
          "code": "return -EFAULT;",
          "condition": "return -EFAULT;",
          "variables": [
            "return",
            "EFAULT"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 513,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 739,
          "code": "return -ENOTTY;",
          "condition": "return -ENOTTY;",
          "variables": [
            "return",
            "ENOTTY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 753,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 767,
          "code": "if (!S_ISREG(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 774,
          "code": "if (S_ISREG(inode->i_mode))",
          "condition": "S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 757,
          "code": "if (!f.file)",
          "condition": "!f.file",
          "variables": [
            "f",
            "file"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 762,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4044,
          "code": "if (unlikely(ZERO_OR_NULL_PTR(s)))",
          "condition": "unlikely(ZERO_OR_NULL_PTR(s))",
          "variables": [
            "unlikely",
            "ZERO_OR_NULL_PTR",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4045,
          "code": "return s;",
          "condition": "return s;",
          "variables": [
            "return",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 583,
          "code": "if (!i)",
          "condition": "!i",
          "variables": [
            "i"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 586,
          "code": "return kmem_cache_alloc_node_trace(",
          "condition": "return kmem_cache_alloc_node_trace(",
          "variables": [
            "return",
            "kmem_cache_alloc_node_trace"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 635,
          "code": "if (!(kmalloc_flags & __GFP_RETRY_MAYFAIL))",
          "condition": "!(kmalloc_flags & __GFP_RETRY_MAYFAIL)",
          "variables": [
            "kmalloc_flags",
            "__GFP_RETRY_MAYFAIL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 4407,
          "code": "if (!sit_i)",
          "condition": "!sit_i",
          "variables": [
            "sit_i"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 4408,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5267,
          "code": "if (!sm_info)",
          "condition": "!sm_info",
          "variables": [
            "sm_info"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5268,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5281,
          "code": "if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
          "condition": "sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS",
          "variables": [
            "sm_info",
            "rec_prefree_segments",
            "DEF_MAX_RECLAIM_PREFREE_SEGMENTS"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5284,
          "code": "if (!f2fs_lfs_mode(sbi))",
          "condition": "!f2fs_lfs_mode(sbi)",
          "variables": [
            "f2fs_lfs_mode",
            "sbi"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5296,
          "code": "if (!f2fs_readonly(sbi->sb)) {",
          "condition": "!f2fs_readonly(sbi->sb)",
          "variables": [
            "f2fs_readonly",
            "sbi",
            "sb"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/super.c",
          "line": 4322,
          "code": "goto stop_ckpt_thread;",
          "condition": "goto stop_ckpt_thread;",
          "variables": [
            "goto",
            "stop_ckpt_thread"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1454,
          "code": "if (IS_ERR(bdev))",
          "condition": "IS_ERR(bdev)",
          "variables": [
            "IS_ERR",
            "bdev"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1455,
          "code": "return ERR_CAST(bdev);",
          "condition": "return ERR_CAST(bdev);",
          "variables": [
            "return",
            "ERR_CAST",
            "bdev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1466,
          "code": "goto error_bdev;",
          "condition": "goto error_bdev;",
          "variables": [
            "goto",
            "error_bdev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1471,
          "code": "if (IS_ERR(s))",
          "condition": "IS_ERR(s)",
          "variables": [
            "IS_ERR",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1472,
          "code": "goto error_s;",
          "condition": "goto error_s;",
          "variables": [
            "goto",
            "error_s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1474,
          "code": "if (s->s_root) {",
          "condition": "s->s_root",
          "variables": [
            "s",
            "s_root"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1478,
          "code": "goto error_bdev;",
          "condition": "goto error_bdev;",
          "variables": [
            "goto",
            "error_bdev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1578,
          "code": "if (fc->root)",
          "condition": "fc->root",
          "variables": [
            "fc",
            "root"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1579,
          "code": "return -EBUSY;",
          "condition": "return -EBUSY;",
          "variables": [
            "return",
            "EBUSY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3006,
          "code": "if (!fstype)",
          "condition": "!fstype",
          "variables": [
            "fstype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3007,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3010,
          "code": "if (!type)",
          "condition": "!type",
          "variables": [
            "type"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3011,
          "code": "return -ENODEV;",
          "condition": "return -ENODEV;",
          "variables": [
            "return",
            "ENODEV"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3013,
          "code": "if (type->fs_flags & FS_HAS_SUBTYPE) {",
          "condition": "type->fs_flags & FS_HAS_SUBTYPE",
          "variables": [
            "type",
            "fs_flags",
            "FS_HAS_SUBTYPE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3015,
          "code": "if (subtype) {",
          "condition": "subtype",
          "variables": [
            "subtype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3017,
          "code": "if (!*subtype) {",
          "condition": "!*subtype",
          "variables": [
            "subtype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3019,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3026,
          "code": "if (IS_ERR(fc))",
          "condition": "IS_ERR(fc)",
          "variables": [
            "IS_ERR",
            "fc"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3027,
          "code": "return PTR_ERR(fc);",
          "condition": "return PTR_ERR(fc);",
          "variables": [
            "return",
            "PTR_ERR",
            "fc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3035,
          "code": "if (subtype)",
          "condition": "subtype",
          "variables": [
            "subtype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3328,
          "code": "return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
          "condition": "return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
          "variables": [
            "return",
            "do_new_mount",
            "path",
            "type_page",
            "sb_flags",
            "mnt_flags",
            "dev_name"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3348,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3349,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3559,
          "code": "if (IS_ERR(kernel_type))",
          "condition": "IS_ERR(kernel_type)",
          "variables": [
            "IS_ERR",
            "kernel_type"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3560,
          "code": "goto out_type;",
          "condition": "goto out_type;",
          "variables": [
            "goto",
            "out_type"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3564,
          "code": "if (IS_ERR(kernel_dev))",
          "condition": "IS_ERR(kernel_dev)",
          "variables": [
            "IS_ERR",
            "kernel_dev"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3565,
          "code": "goto out_dev;",
          "condition": "goto out_dev;",
          "variables": [
            "goto",
            "out_dev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3569,
          "code": "if (IS_ERR(options))",
          "condition": "IS_ERR(options)",
          "variables": [
            "IS_ERR",
            "options"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3570,
          "code": "goto out_data;",
          "condition": "goto out_data;",
          "variables": [
            "goto",
            "out_data"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4275,
          "code": "if (cpusets_enabled() &&",
          "condition": "cpusets_enabled(",
          "variables": [
            "cpusets_enabled"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4298,
          "code": "if (ac->spread_dirty_pages) {",
          "condition": "ac->spread_dirty_pages",
          "variables": [
            "ac",
            "spread_dirty_pages"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4299,
          "code": "if (last_pgdat_dirty_limit == zone->zone_pgdat)",
          "condition": "last_pgdat_dirty_limit == zone->zone_pgdat",
          "variables": [
            "last_pgdat_dirty_limit",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4302,
          "code": "if (!node_dirty_ok(zone->zone_pgdat)) {",
          "condition": "!node_dirty_ok(zone->zone_pgdat)",
          "variables": [
            "node_dirty_ok",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4308,
          "code": "if (no_fallback && nr_online_nodes > 1 &&",
          "condition": "if (no_fallback && nr_online_nodes > 1 &&",
          "variables": [
            "if",
            "no_fallback",
            "nr_online_nodes"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4318,
          "code": "if (zone_to_nid(zone) != local_nid) {",
          "condition": "zone_to_nid(zone) != local_nid",
          "variables": [
            "zone_to_nid",
            "zone",
            "local_nid"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4320,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4325,
          "code": "if (!zone_watermark_fast(zone, order, mark,",
          "condition": "if (!zone_watermark_fast(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_fast",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4335,
          "code": "if (static_branch_unlikely(&deferred_pages)) {",
          "condition": "static_branch_unlikely(&deferred_pages)",
          "variables": [
            "static_branch_unlikely",
            "deferred_pages"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4336,
          "code": "if (_deferred_grow_zone(zone, order))",
          "condition": "_deferred_grow_zone(zone, order)",
          "variables": [
            "_deferred_grow_zone",
            "zone",
            "order"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4337,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4342,
          "code": "if (alloc_flags & ALLOC_NO_WATERMARKS)",
          "condition": "alloc_flags & ALLOC_NO_WATERMARKS",
          "variables": [
            "alloc_flags",
            "ALLOC_NO_WATERMARKS"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4343,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4345,
          "code": "if (node_reclaim_mode == 0 ||",
          "condition": "if (node_reclaim_mode == 0 ||",
          "variables": [
            "if",
            "node_reclaim_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4350,
          "code": "switch (ret) {",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4359,
          "code": "if (zone_watermark_ok(zone, order, mark,",
          "condition": "if (zone_watermark_ok(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_ok",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4361,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4370,
          "code": "if (page) {",
          "condition": "page",
          "variables": [
            "page"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5383,
          "code": "if (unlikely(order >= MAX_ORDER)) {",
          "condition": "unlikely(order >= MAX_ORDER)",
          "variables": [
            "unlikely",
            "order",
            "MAX_ORDER"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5390,
          "code": "if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))",
          "condition": "!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags)",
          "variables": [
            "prepare_alloc_pages",
            "gfp_mask",
            "order",
            "preferred_nid",
            "nodemask",
            "ac",
            "alloc_mask",
            "alloc_flags"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 1830,
          "code": "if ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))",
          "condition": "(alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min)",
          "variables": [
            "alloc_gfp",
            "__GFP_DIRECT_RECLAIM",
            "oo_order",
            "oo",
            "oo_order",
            "s",
            "min"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 1870,
          "code": "return allocate_slab(s,",
          "condition": "return allocate_slab(s,",
          "variables": [
            "return",
            "allocate_slab",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2639,
          "code": "if (freelist)",
          "condition": "freelist",
          "variables": [
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2640,
          "code": "return freelist;",
          "condition": "return freelist;",
          "variables": [
            "return",
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2801,
          "code": "if (!page) {",
          "condition": "!page",
          "variables": [
            "page"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2806,
          "code": "if (unlikely(node != NUMA_NO_NODE &&",
          "condition": "if (unlikely(node != NUMA_NO_NODE &&",
          "variables": [
            "if",
            "unlikely",
            "node",
            "NUMA_NO_NODE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2809,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2813,
          "code": "if (unlikely(!node_match(page, node))) {",
          "condition": "unlikely(!node_match(page, node))",
          "variables": [
            "unlikely",
            "node_match",
            "page",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2818,
          "code": "if (!node_state(node, N_NORMAL_MEMORY)) {",
          "condition": "!node_state(node, N_NORMAL_MEMORY)",
          "variables": [
            "node_state",
            "node",
            "N_NORMAL_MEMORY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2820,
          "code": "goto redo;",
          "condition": "goto redo;",
          "variables": [
            "goto",
            "redo"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2824,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2833,
          "code": "if (unlikely(!pfmemalloc_match(page, gfpflags))) {",
          "condition": "unlikely(!pfmemalloc_match(page, gfpflags))",
          "variables": [
            "unlikely",
            "pfmemalloc_match",
            "page",
            "gfpflags"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2835,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2840,
          "code": "if (freelist)",
          "condition": "freelist",
          "variables": [
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2841,
          "code": "goto load_freelist;",
          "condition": "goto load_freelist;",
          "variables": [
            "goto",
            "load_freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2845,
          "code": "if (!freelist) {",
          "condition": "!freelist",
          "variables": [
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2849,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2863,
          "code": "return freelist;",
          "condition": "return freelist;",
          "variables": [
            "return",
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2867,
          "code": "if (slub_percpu_partial(c)) {",
          "condition": "slub_percpu_partial(c)",
          "variables": [
            "slub_percpu_partial",
            "c"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2871,
          "code": "goto redo;",
          "condition": "goto redo;",
          "variables": [
            "goto",
            "redo"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2925,
          "code": "if (!s)",
          "condition": "!s",
          "variables": [
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2929,
          "code": "if (unlikely(object))",
          "condition": "unlikely(object)",
          "variables": [
            "unlikely",
            "object"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2930,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2946,
          "code": "} while (IS_ENABLED(CONFIG_PREEMPTION) &&",
          "condition": "IS_ENABLED(CONFIG_PREEMPTION",
          "variables": [
            "IS_ENABLED",
            "CONFIG_PREEMPTION"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2968,
          "code": "if (unlikely(!object || !page || !node_match(page, node))) {",
          "condition": "unlikely(!object || !page || !node_match(page, node))",
          "variables": [
            "unlikely",
            "object",
            "page",
            "node_match",
            "page",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4547,
          "code": "if (unlikely(ZERO_OR_NULL_PTR(s)))",
          "condition": "unlikely(ZERO_OR_NULL_PTR(s))",
          "variables": [
            "unlikely",
            "ZERO_OR_NULL_PTR",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4548,
          "code": "return s;",
          "condition": "return s;",
          "variables": [
            "return",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/core/skbuff.c",
          "line": 230,
          "code": "if (!skb)",
          "condition": "!skb",
          "variables": [
            "skb"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/core/skbuff.c",
          "line": 231,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1903,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1907,
          "code": "return -ENODATA;",
          "condition": "return -ENODATA;",
          "variables": [
            "return",
            "ENODATA"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1917,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1919,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1923,
          "code": "if ((dst_group || dst_portid) &&",
          "condition": "(dst_group || dst_portid",
          "variables": [
            "dst_group",
            "dst_portid"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1925,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1934,
          "code": "if (!READ_ONCE(nlk->bound)) {",
          "condition": "!READ_ONCE(nlk->bound)",
          "variables": [
            "READ_ONCE",
            "nlk",
            "bound"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1937,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1945,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2391,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2399,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2408,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2412,
          "code": "goto out_freectl;",
          "condition": "goto out_freectl;",
          "variables": [
            "goto",
            "out_freectl"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2431,
          "code": "goto out_freectl;",
          "condition": "goto out_freectl;",
          "variables": [
            "goto",
            "out_freectl"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2468,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2472,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3498,
          "code": "if (from_gc) {",
          "condition": "from_gc",
          "variables": [
            "from_gc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3521,
          "code": "if (from_gc) {",
          "condition": "from_gc",
          "variables": [
            "from_gc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1417,
          "code": "if (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))",
          "condition": "unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC))",
          "variables": [
            "unlikely",
            "is_inode_flag_set",
            "dn",
            "inode",
            "FI_NO_ALLOC"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1418,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1425,
          "code": "if (dn->data_blkaddr != NULL_ADDR)",
          "condition": "dn->data_blkaddr != NULL_ADDR",
          "variables": [
            "dn",
            "data_blkaddr",
            "NULL_ADDR"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1426,
          "code": "goto alloc;",
          "condition": "goto alloc;",
          "variables": [
            "goto",
            "alloc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1578,
          "code": "goto unlock_out;",
          "condition": "goto unlock_out;",
          "variables": [
            "goto",
            "unlock_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1582,
          "code": "if (map->m_next_pgofs)",
          "condition": "map->m_next_pgofs",
          "variables": [
            "map",
            "m_next_pgofs"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1585,
          "code": "if (map->m_next_extent)",
          "condition": "map->m_next_extent",
          "variables": [
            "map",
            "m_next_extent"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1589,
          "code": "goto unlock_out;",
          "condition": "goto unlock_out;",
          "variables": [
            "goto",
            "unlock_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1603,
          "code": "goto sync_out;",
          "condition": "goto sync_out;",
          "variables": [
            "goto",
            "sync_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1608,
          "code": "if (f2fs_lfs_mode(sbi) && flag == F2FS_GET_BLOCK_DIO &&",
          "condition": "f2fs_lfs_mode(sbi",
          "variables": [
            "f2fs_lfs_mode",
            "sbi"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1612,
          "code": "goto sync_out;",
          "condition": "goto sync_out;",
          "variables": [
            "goto",
            "sync_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1617,
          "code": "if (create) {",
          "condition": "create",
          "variables": [
            "create"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1618,
          "code": "if (unlikely(f2fs_cp_error(sbi))) {",
          "condition": "unlikely(f2fs_cp_error(sbi))",
          "variables": [
            "unlikely",
            "f2fs_cp_error",
            "sbi"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1620,
          "code": "goto sync_out;",
          "condition": "goto sync_out;",
          "variables": [
            "goto",
            "sync_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1622,
          "code": "if (flag == F2FS_GET_BLOCK_PRE_AIO) {",
          "condition": "flag == F2FS_GET_BLOCK_PRE_AIO",
          "variables": [
            "flag",
            "F2FS_GET_BLOCK_PRE_AIO"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1623,
          "code": "if (blkaddr == NULL_ADDR) {",
          "condition": "blkaddr == NULL_ADDR",
          "variables": [
            "blkaddr",
            "NULL_ADDR"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1729,
          "code": "goto out_err;",
          "condition": "goto out_err;",
          "variables": [
            "goto",
            "out_err"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        }
      ]
    },
    "exploitability": "high",
    "non_canonical_addr": "0xdffffc0000000000",
    "overview": {
      "exploitability": "HIGH",
      "rationale": "attacker-controlled input reaches vulnerable path; pointer deref evidence (reads=149, writes=62); boundedness=bounded",
      "primitive_capabilities": "Unknown or limited primitive; further manual analysis required",
      "confidence_breakdown": {
        "attacker_control": 0.4,
        "evidence_strength": 0.4,
        "boundedness_score": 0.0,
        "kasan_indicator": 0.1,
        "aggregate_estimate": 0.9,
        "reported_confidence": 1.0
      }
    },
    "how_to_create": {
      "alloc_frame": "__kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>",
      "guidance": [
        "Allocation from slab/kmalloc: create objects via normal kernel paths (file ops, network ops, or module-specific APIs)"
      ]
    }
  },
  "exploitability": {
    "free_site": null,
    "trigger_site": {
      "file": "fs/f2fs/segment.c",
      "line": 2257,
      "url": "https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257",
      "func": "static void __set_sit_entry_type"
    },
    "allocation_site": {
      "raw": "Allocated by task 817:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#45'>mm/kasan/common.c:45</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#430'>mm/kasan/common.c:430</a> [inline]\n ____kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#509'>mm/kasan/common.c:509</a> [inline]\n __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>\n kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/kasan.h#254'>include/linux/kasan.h:254</a> [inline]\n __kmalloc+0x1a7/0x330 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033'>mm/slub.c:4033</a>\n __kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418'>include/linux/slab.h:418</a> [inline]\n kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575'>include/linux/slab.h:575</a> [inline]\n kvmalloc_node+0x88/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612'>mm/util.c:612</a>\n kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833'>include/linux/mm.h:833</a> [inline]\n f2fs_kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374'>fs/f2fs/f2fs.h:3374</a> [inline]\n f2fs_kvzalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380'>fs/f2fs/f2fs.h:3380</a> [inline]\n build_sit_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395'>fs/f2fs/segment.c:4395</a> [inline]\n f2fs_build_segment_manager+0xdba/0x48f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258'>fs/f2fs/segment.c:5258</a>\n f2fs_fill_super+0x42d1/0x6c70 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315'>fs/f2fs/super.c:4315</a>\n mount_bdev+0x28b/0x3a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442'>fs/super.c:1442</a>\n f2fs_mount+0x34/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595'>fs/f2fs/super.c:4595</a>\n legacy_get_tree+0xed/0x190 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593'>fs/fs_context.c:593</a>\n vfs_get_tree+0x89/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572'>fs/super.c:1572</a>\n do_new_mount+0x25a/0xa20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997'>fs/namespace.c:2997</a>\n path_mount+0x572/0xc80 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327'>fs/namespace.c:3327</a>\n do_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340'>fs/namespace.c:3340</a> [inline]\n __do_sys_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548'>fs/namespace.c:3548</a> [inline]\n __se_sys_mount+0x318/0x380 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n __x64_sys_mount+0xbf/0xd0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb",
      "file": "mm/kasan/common.c",
      "line": 38
    },
    "object": {
      "obj_addr": "ffff88811471c800",
      "cache": "kmalloc-1k",
      "obj_size": 1024,
      "offset": 960
    },
    "struct_info": {
      "struct_name": null,
      "fields_used": [
        "Drop",
        "If",
        "In",
        "It",
        "Locality",
        "Need",
        "Preemption",
        "So",
        "That",
        "The",
        "This",
        "Thus",
        "We",
        "allocflags",
        "ax",
        "bd_fsfreeze_count",
        "bd_fsfreeze_mutex",
        "blkdev_put",
        "blocks_per_seg",
        "bound",
        "c",
        "cpu_slab",
        "ctor",
        "curseg_lock",
        "curseg_mutex",
        "data_blkaddr",
        "dst_group",
        "dst_portid",
        "f_flags",
        "f_mode",
        "f_op",
        "f_pos",
        "fallocate",
        "file",
        "freelist",
        "frozen",
        "fs_flags",
        "fs_private",
        "fs_type",
        "g",
        "gc_lock",
        "get_tree",
        "head",
        "highest_zoneidx",
        "i_mode",
        "i_sb",
        "i_size",
        "inited",
        "inode",
        "ipu_policy",
        "l_start",
        "l_whence",
        "m_may_create",
        "m_next_extent",
        "m_next_pgofs",
        "m_seg_type",
        "main_blkaddr",
        "main_segments",
        "migratetype",
        "min",
        "min_fsync_blocks",
        "min_hot_blocks",
        "min_ipu_util",
        "min_seq_blocks",
        "min_ssr_sections",
        "mount",
        "msg_control",
        "msg_control_is_user",
        "msg_control_user",
        "msg_controllen",
        "msg_flags",
        "msg_name",
        "msg_namelen",
        "name",
        "name_len",
        "next_blkoff",
        "next_segno",
        "nid",
        "nl_family",
        "nl_groups",
        "nl_pid",
        "node_page",
        "nodemask",
        "ofs_in_node",
        "oldapi",
        "oo",
        "ops",
        "overprov_segment_count",
        "ovp_segments",
        "page",
        "pin_sem",
        "preferred_zoneref",
        "rec_prefree_segments",
        "reserved_segments",
        "root",
        "rsvd_segment_count",
        "s_blocksize",
        "s_flags",
        "s_id",
        "s_maxbytes",
        "s_mode",
        "s_root",
        "s_umount",
        "sb",
        "sb_flags",
        "seg0_blkaddr",
        "seg_type",
        "segment0_blkaddr",
        "segment_count",
        "segment_count_main",
        "segno",
        "sendmsg",
        "sentries",
        "sentry_lock",
        "sit_entry_set",
        "sit_info",
        "size",
        "sk",
        "sk_sndbuf",
        "sm_info",
        "spread_dirty_pages",
        "ssa_blkaddr",
        "sum_blk",
        "tid",
        "type",
        "version",
        "zone",
        "zone_pgdat"
      ],
      "struct_def_snippet": null
    },
    "usage_examples": [
      {
        "line_no": 1,
        "text": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,"
      },
      {
        "line_no": 4,
        "text": "struct seg_entry *se = get_seg_entry(sbi, segno);"
      },
      {
        "line_no": 6,
        "text": "se->type = type;"
      }
    ],
    "notes": [
      "Object allocated from cache 'kmalloc-1k', reallocation under attacker control increases exploitability",
      "Object size=1024, access offset=960"
    ],
    "concrete_preconditions": [
      {
        "file": "fs/f2fs/segment.c",
        "line": 2257,
        "code": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,",
        "variables": [
          "sbi"
        ],
        "indices": [],
        "constraint": "variable(s) sbi may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 1,
            "text": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,"
          },
          {
            "line_no": 4,
            "text": "struct seg_entry *se = get_seg_entry(sbi, segno);"
          },
          {
            "line_no": 6,
            "text": "se->type = type;"
          }
        ]
      },
      {
        "file": "fs/f2fs/segment.c",
        "line": 2257,
        "code": "struct seg_entry *se = get_seg_entry(sbi, segno);",
        "variables": [
          "se"
        ],
        "indices": [],
        "constraint": "variable(s) se may point to reclaimed/out-of-bounds memory or contain attacker-controlled indices",
        "evidence": [
          {
            "line_no": 1,
            "text": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,"
          },
          {
            "line_no": 2,
            "text": "unsigned int segno, int modified)"
          },
          {
            "line_no": 4,
            "text": "struct seg_entry *se = get_seg_entry(sbi, segno);"
          },
          {
            "line_no": 6,
            "text": "se->type = type;"
          }
        ]
      },
      {
        "file": "fs/f2fs/segment.c",
        "line": 2257,
        "code": "se->type = type;",
        "variables": [
          "se"
        ],
        "indices": [],
        "constraint": "field(s) type may contain malformed/large values leading to OOB access",
        "evidence": [
          {
            "line_no": 1,
            "text": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,"
          },
          {
            "line_no": 2,
            "text": "unsigned int segno, int modified)"
          },
          {
            "line_no": 4,
            "text": "struct seg_entry *se = get_seg_entry(sbi, segno);"
          },
          {
            "line_no": 6,
            "text": "se->type = type;"
          }
        ]
      }
    ]
  },
  "strong_report": {
    "primitive": "null-pointer-deref",
    "vulnerability": "denial-of-service (kernel crash)",
    "confidence": 1.0,
    "preconditions": [
      "Triggering syzkaller syscall(s): ffff8881f7100000, disassembly, movzbl",
      "Triggering syscall(s) from crash text: ioctl, mount, sendmsg",
      "How to create: allocate the object via code path that calls: __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>",
      "How to create hint: Allocation from slab/kmalloc: create objects via normal kernel paths (file ops, network ops, or module-specific APIs)",
      "Object details: type 'kmalloc-1k', address ffff88811471c800, size 1024",
      "Object: cache 'kmalloc-1k', address ffff88811471c800, size 1024, offset 960",
      "State: dentry pointer may be NULL or invalid leading to null-pointer deref in dcache/namei code paths",
      "An externally-controlled syscall input (fuzzer/syzkaller) reached the vulnerable syscall path",
      "Input state: attacker-controlled syscall parameters or user-supplied data must reach the vulnerable code path",
      "Code path: execution reaches function '__set_sit_entry_type' (from crash context)",
      "State: variable(s) like sbi, se, curseg may point into freed/reclaimed memory (observed in nearby source lines)",
      "path constraint (input): err && err != -ENODATA && err != -EAGAIN -- at fs/f2fs/file.c:1724",
      "path constraint (input): if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE | -- at fs/f2fs/file.c:1856",
      "path constraint (input): offset >= inode->i_size -- at fs/f2fs/file.c:1874",
      "path constraint (input): offset < 0 || len <= 0 -- at fs/open.c:316",
      "path constraint (input): (mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode) -- at fs/open.c:354",
      "path constraint (kernel state): old == -1 -- at lib/dump_stack.c:134",
      "path constraint (kernel state): old == cpu -- at lib/dump_stack.c:136",
      "path constraint (kernel state): atomic_read(&dump_lock) != -1 -- at lib/dump_stack.c:145",
      "path constraint (kernel state): goto retry; -- at lib/dump_stack.c:146",
      "path constraint (kernel state): curseg->inited -- at fs/f2fs/segment.c:2731",
      "path constraint (kernel state): seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA -- at fs/f2fs/segment.c:2734",
      "path constraint (kernel state): test_opt(sbi, NOHEAP) -- at fs/f2fs/segment.c:2737",
      "path constraint (kernel state): !curseg->inited -- at fs/f2fs/segment.c:3046"
    ],
    "postconditions": [
      "KASAN or BUG report emitted indicating invalid memory access"
    ],
    "support": [
      "KASAN reported slab-out-of-bounds (log contains 'slab-out-of-bounds')",
      "Access offset 960 inside object size 1024",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains alloc-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Control-flow path constraints extracted from stack snippets (if/for/while/switch, returns)",
      "KASAN reported null-ptr-deref in crash log",
      "evidence: fs/fs_context.c:597 'struct dentry *root;'",
      "deref_exprs: se->type, curseg->segno, curseg->seg_type",
      "faulting address: 0xdffffc0000000000",
      "BUG: KASAN: slab-out-of-bounds in __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]; fs_context.c:597 -> struct dentry *root;; dereference expressions: se->type, curseg->segno, curseg->seg_type; faulting address: 0xdffffc0000000000; No clear evidence of arbitrary read/write (KASAN null-pointer derefs commonly indicate DoS)",
      "Allocation origin: __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>",
      "Syscall(s) detected in crash text: ioctl, mount, sendmsg",
      "Syzkaller repro indicates syscalls: ffff8881f7100000, disassembly, movzbl"
    ],
    "path_constraints": {
      "input_constraints": [
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1724,
          "code": "if (err && err != -ENODATA && err != -EAGAIN)",
          "condition": "err && err != -ENODATA && err != -EAGAIN",
          "variables": [
            "err",
            "err",
            "ENODATA",
            "err",
            "EAGAIN"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1856,
          "code": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "condition": "if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |",
          "variables": [
            "if",
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1874,
          "code": "if (offset >= inode->i_size)",
          "condition": "offset >= inode->i_size",
          "variables": [
            "offset",
            "inode",
            "i_size"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 316,
          "code": "if (offset < 0 || len <= 0)",
          "condition": "offset < 0 || len <= 0",
          "variables": [
            "offset",
            "len"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 354,
          "code": "if ((mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode))",
          "condition": "(mode & ~FALLOC_FL_KEEP_SIZE) && IS_APPEND(inode)",
          "variables": [
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "IS_APPEND",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 384,
          "code": "if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))",
          "condition": "((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0)",
          "variables": [
            "offset",
            "len",
            "inode",
            "i_sb",
            "s_maxbytes",
            "offset",
            "len"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 500,
          "code": "if (copy_from_user(&sr, argp, sizeof(sr)))",
          "condition": "copy_from_user(&sr, argp, sizeof(sr))",
          "variables": [
            "copy_from_user",
            "sr",
            "argp",
            "sizeof",
            "sr"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'sr' traced to user/syscall source: copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 503,
          "code": "switch (sr.l_whence) {",
          "condition": "sr.l_whence",
          "variables": [
            "sr",
            "l_whence"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sr' traced to user/syscall source: copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 516,
          "code": "return vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,",
          "condition": "return vfs_fallocate(filp, mode | FALLOC_FL_KEEP_SIZE, sr.l_start,",
          "variables": [
            "return",
            "vfs_fallocate",
            "filp",
            "mode",
            "FALLOC_FL_KEEP_SIZE",
            "sr",
            "l_start"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sr' traced to user/syscall source: copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 735,
          "code": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "condition": "return copy_to_user(argp, &res, sizeof(res)) ?",
          "variables": [
            "return",
            "copy_to_user",
            "argp",
            "res",
            "sizeof",
            "res"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 742,
          "code": "return ioctl_fsfreeze(filp);",
          "condition": "return ioctl_fsfreeze(filp);",
          "variables": [
            "return",
            "ioctl_fsfreeze",
            "filp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 745,
          "code": "return ioctl_fsthaw(filp);",
          "condition": "return ioctl_fsthaw(filp);",
          "variables": [
            "return",
            "ioctl_fsthaw",
            "filp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 748,
          "code": "return ioctl_fiemap(filp, argp);",
          "condition": "return ioctl_fiemap(filp, argp);",
          "variables": [
            "return",
            "ioctl_fiemap",
            "filp",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 752,
          "code": "if (!inode->i_sb->s_blocksize)",
          "condition": "!inode->i_sb->s_blocksize",
          "variables": [
            "inode",
            "i_sb",
            "s_blocksize"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 755,
          "code": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "condition": "return put_user(inode->i_sb->s_blocksize, (int __user *)argp);",
          "variables": [
            "return",
            "put_user",
            "inode",
            "i_sb",
            "s_blocksize",
            "int",
            "__user",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'int' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "condition": "return ioctl_file_clone(filp, arg, 0, 0, 0);",
          "variables": [
            "return",
            "ioctl_file_clone",
            "filp",
            "arg"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "return ioctl_file_clone_range(filp, argp);",
          "condition": "return ioctl_file_clone_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_clone_range",
            "filp",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 764,
          "code": "return ioctl_file_dedupe_range(filp, argp);",
          "condition": "return ioctl_file_dedupe_range(filp, argp);",
          "variables": [
            "return",
            "ioctl_file_dedupe_range",
            "filp",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 768,
          "code": "return vfs_ioctl(filp, cmd, arg);",
          "condition": "return vfs_ioctl(filp, cmd, arg);",
          "variables": [
            "return",
            "vfs_ioctl",
            "filp",
            "cmd",
            "arg"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 770,
          "code": "return put_user(i_size_read(inode) - filp->f_pos,",
          "condition": "return put_user(i_size_read(inode) - filp->f_pos,",
          "variables": [
            "return",
            "put_user",
            "i_size_read",
            "inode",
            "filp",
            "f_pos"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 775,
          "code": "return file_ioctl(filp, cmd, argp);",
          "condition": "return file_ioctl(filp, cmd, argp);",
          "variables": [
            "return",
            "file_ioctl",
            "filp",
            "cmd",
            "argp"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'argp' traced to user/syscall source: copy_to_user, copy_from_user"
        },
        {
          "frame": null,
          "file": "arch/x86/entry/common.c",
          "line": 52,
          "code": "if (likely(nr < NR_syscalls)) {",
          "condition": "likely(nr < NR_syscalls)",
          "variables": [
            "likely",
            "nr",
            "NR_syscalls"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'nr' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4039,
          "code": "if (unlikely(size > KMALLOC_MAX_CACHE_SIZE))",
          "condition": "unlikely(size > KMALLOC_MAX_CACHE_SIZE)",
          "variables": [
            "unlikely",
            "size",
            "KMALLOC_MAX_CACHE_SIZE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4040,
          "code": "return kmalloc_large(size, flags);",
          "condition": "return kmalloc_large(size, flags);",
          "variables": [
            "return",
            "kmalloc_large",
            "size",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 419,
          "code": "return __kmalloc(size, flags);",
          "condition": "return __kmalloc(size, flags);",
          "variables": [
            "return",
            "__kmalloc",
            "size",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 579,
          "code": "if (__builtin_constant_p(size) &&",
          "condition": "__builtin_constant_p(size",
          "variables": [
            "__builtin_constant_p",
            "size"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 584,
          "code": "return ZERO_SIZE_PTR;",
          "condition": "return ZERO_SIZE_PTR;",
          "variables": [
            "return",
            "ZERO_SIZE_PTR"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 591,
          "code": "return __kmalloc_node(size, flags, node);",
          "condition": "return __kmalloc_node(size, flags, node);",
          "variables": [
            "return",
            "__kmalloc_node",
            "size",
            "flags",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 622,
          "code": "if ((flags & GFP_KERNEL) != GFP_KERNEL)",
          "condition": "(flags & GFP_KERNEL) != GFP_KERNEL",
          "variables": [
            "flags",
            "GFP_KERNEL",
            "GFP_KERNEL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 623,
          "code": "return kmalloc_node(size, flags, node);",
          "condition": "return kmalloc_node(size, flags, node);",
          "variables": [
            "return",
            "kmalloc_node",
            "size",
            "flags",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 632,
          "code": "if (size > PAGE_SIZE) {",
          "condition": "size > PAGE_SIZE",
          "variables": [
            "size",
            "PAGE_SIZE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "include/linux/mm.h",
          "line": 834,
          "code": "return kvmalloc_node(size, flags, NUMA_NO_NODE);",
          "condition": "return kvmalloc_node(size, flags, NUMA_NO_NODE);",
          "variables": [
            "return",
            "kvmalloc_node",
            "size",
            "flags",
            "NUMA_NO_NODE"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/f2fs.h",
          "line": 3375,
          "code": "return kvmalloc(size, flags);",
          "condition": "return kvmalloc(size, flags);",
          "variables": [
            "return",
            "kvmalloc",
            "size",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/f2fs.h",
          "line": 3381,
          "code": "return f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);",
          "condition": "return f2fs_kvmalloc(sbi, size, flags | __GFP_ZERO);",
          "variables": [
            "return",
            "f2fs_kvmalloc",
            "sbi",
            "size",
            "flags",
            "__GFP_ZERO"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5298,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5299,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5303,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5304,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/super.c",
          "line": 4318,
          "code": "if (err) {",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1450,
          "code": "if (!(flags & SB_RDONLY))",
          "condition": "!(flags & SB_RDONLY)",
          "variables": [
            "flags",
            "SB_RDONLY"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1463,
          "code": "if (bdev->bd_fsfreeze_count > 0) {",
          "condition": "bdev->bd_fsfreeze_count > 0",
          "variables": [
            "bdev",
            "bd_fsfreeze_count"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1475,
          "code": "if ((flags ^ s->s_flags) & SB_RDONLY) {",
          "condition": "(flags ^ s->s_flags) & SB_RDONLY",
          "variables": [
            "flags",
            "s",
            "s_flags",
            "SB_RDONLY"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/super.c",
          "line": 4596,
          "code": "return mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);",
          "condition": "return mount_bdev(fs_type, flags, dev_name, data, f2fs_fill_super);",
          "variables": [
            "return",
            "mount_bdev",
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "f2fs_fill_super"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3038,
          "code": "if (!err && name)",
          "condition": "!err && name",
          "variables": [
            "err",
            "name"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3040,
          "code": "if (!err)",
          "condition": "!err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3042,
          "code": "if (!err && !mount_capable(fc))",
          "condition": "!err && !mount_capable(fc)",
          "variables": [
            "err",
            "mount_capable",
            "fc"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3044,
          "code": "if (!err)",
          "condition": "!err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5385,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'NULL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5391,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'NULL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 1820,
          "code": "if (gfpflags_allow_blocking(flags))",
          "condition": "gfpflags_allow_blocking(flags)",
          "variables": [
            "gfpflags_allow_blocking",
            "flags"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2926,
          "code": "return NULL;",
          "condition": "return NULL;",
          "variables": [
            "return",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'NULL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2956,
          "code": "return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr, orig_size);",
          "condition": "return slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr, orig_size);",
          "variables": [
            "return",
            "slab_alloc_node",
            "s",
            "gfpflags",
            "NUMA_NO_NODE",
            "addr",
            "orig_size"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4542,
          "code": "if (unlikely(size > KMALLOC_MAX_CACHE_SIZE))",
          "condition": "unlikely(size > KMALLOC_MAX_CACHE_SIZE)",
          "variables": [
            "unlikely",
            "size",
            "KMALLOC_MAX_CACHE_SIZE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4543,
          "code": "return kmalloc_large(size, gfpflags);",
          "condition": "return kmalloc_large(size, gfpflags);",
          "variables": [
            "return",
            "kmalloc_large",
            "size",
            "gfpflags"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/core/skbuff.c",
          "line": 225,
          "code": "if (sk_memalloc_socks() && (flags & SKB_ALLOC_RX))",
          "condition": "sk_memalloc_socks() && (flags & SKB_ALLOC_RX)",
          "variables": [
            "sk_memalloc_socks",
            "flags",
            "SKB_ALLOC_RX"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'flags' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "include/linux/skbuff.h",
          "line": 1130,
          "code": "return __alloc_skb(size, priority, 0, NUMA_NO_NODE);",
          "condition": "return __alloc_skb(size, priority, 0, NUMA_NO_NODE);",
          "variables": [
            "return",
            "__alloc_skb",
            "size",
            "priority",
            "NUMA_NO_NODE"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1185,
          "code": "if (size <= NLMSG_GOODSIZE || broadcast)",
          "condition": "size <= NLMSG_GOODSIZE || broadcast",
          "variables": [
            "size",
            "NLMSG_GOODSIZE",
            "broadcast"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1186,
          "code": "return alloc_skb(size, GFP_KERNEL);",
          "condition": "return alloc_skb(size, GFP_KERNEL);",
          "variables": [
            "return",
            "alloc_skb",
            "size",
            "GFP_KERNEL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'GFP_KERNEL' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1902,
          "code": "if (msg->msg_flags & MSG_OOB)",
          "condition": "msg->msg_flags & MSG_OOB",
          "variables": [
            "msg",
            "msg_flags",
            "MSG_OOB"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1905,
          "code": "if (len == 0) {",
          "condition": "len == 0",
          "variables": [
            "len"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1911,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1912,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1914,
          "code": "if (msg->msg_namelen) {",
          "condition": "msg->msg_namelen",
          "variables": [
            "msg",
            "msg_namelen"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1916,
          "code": "if (msg->msg_namelen < sizeof(struct sockaddr_nl))",
          "condition": "msg->msg_namelen < sizeof(struct sockaddr_nl)",
          "variables": [
            "msg",
            "msg_namelen",
            "sizeof",
            "struct",
            "sockaddr_nl"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1918,
          "code": "if (addr->nl_family != AF_NETLINK)",
          "condition": "addr->nl_family != AF_NETLINK",
          "variables": [
            "addr",
            "nl_family",
            "AF_NETLINK"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1936,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1944,
          "code": "if (len > sk->sk_sndbuf - 32)",
          "condition": "len > sk->sk_sndbuf - 32",
          "variables": [
            "len",
            "sk",
            "sk_sndbuf"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sk' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 670,
          "code": "return err ?: sock_sendmsg_nosec(sock, msg);",
          "condition": "return err ?: sock_sendmsg_nosec(sock, msg);",
          "variables": [
            "return",
            "err",
            "sock_sendmsg_nosec",
            "sock",
            "msg"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2390,
          "code": "if (msg_sys->msg_controllen > INT_MAX)",
          "condition": "msg_sys->msg_controllen > INT_MAX",
          "variables": [
            "msg_sys",
            "msg_controllen",
            "INT_MAX"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'msg_sys' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2394,
          "code": "if ((MSG_CMSG_COMPAT & flags) && ctl_len) {",
          "condition": "(MSG_CMSG_COMPAT & flags) && ctl_len",
          "variables": [
            "MSG_CMSG_COMPAT",
            "flags",
            "ctl_len"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'MSG_CMSG_COMPAT' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2398,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2402,
          "code": "} else if (ctl_len) {",
          "condition": "ctl_len",
          "variables": [
            "ctl_len"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'ctl_len' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2405,
          "code": "if (ctl_len > sizeof(ctl)) {",
          "condition": "ctl_len > sizeof(ctl)",
          "variables": [
            "ctl_len",
            "sizeof",
            "ctl"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'ctl_len' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2407,
          "code": "if (ctl_buf == NULL)",
          "condition": "ctl_buf == NULL",
          "variables": [
            "ctl_buf",
            "NULL"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'ctl_buf' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2411,
          "code": "if (copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len))",
          "condition": "copy_from_user(ctl_buf, msg_sys->msg_control_user, ctl_len)",
          "variables": [
            "copy_from_user",
            "ctl_buf",
            "msg_sys",
            "msg_control_user",
            "ctl_len"
          ],
          "evidence": [],
          "why_it_blocks": "contains explicit user-copy/syscall keywords; variable 'ctl_buf' traced to user/syscall source: syscall_param, copy_from_user"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2418,
          "code": "if (sock->file->f_flags & O_NONBLOCK)",
          "condition": "sock->file->f_flags & O_NONBLOCK",
          "variables": [
            "sock",
            "file",
            "f_flags",
            "O_NONBLOCK"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sock' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2426,
          "code": "if (used_address && msg_sys->msg_name &&",
          "condition": "if (used_address && msg_sys->msg_name &&",
          "variables": [
            "if",
            "used_address",
            "msg_sys",
            "msg_name"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'used_address' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2443,
          "code": "if (err < 0)",
          "condition": "err < 0",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2444,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2467,
          "code": "if (forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT))",
          "condition": "forbid_cmsg_compat && (flags & MSG_CMSG_COMPAT)",
          "variables": [
            "forbid_cmsg_compat",
            "flags",
            "MSG_CMSG_COMPAT"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'forbid_cmsg_compat' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2471,
          "code": "if (!sock)",
          "condition": "!sock",
          "variables": [
            "sock"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'sock' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2471,
          "code": "return __sys_sendmsg(fd, msg, flags, true);",
          "condition": "return __sys_sendmsg(fd, msg, flags, true);",
          "variables": [
            "return",
            "__sys_sendmsg",
            "fd",
            "msg",
            "flags",
            "true"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'fd' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1421,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1422,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1428,
          "code": "if (unlikely((err = inc_valid_block_count(sbi, dn->inode, &count))))",
          "condition": "unlikely((err = inc_valid_block_count(sbi, dn->inode, &count)))",
          "variables": [
            "unlikely",
            "err",
            "inc_valid_block_count",
            "sbi",
            "dn",
            "inode",
            "count"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1429,
          "code": "return err;",
          "condition": "return err;",
          "variables": [
            "return",
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1600,
          "code": "if (__is_valid_data_blkaddr(blkaddr) &&",
          "condition": "__is_valid_data_blkaddr(blkaddr",
          "variables": [
            "__is_valid_data_blkaddr",
            "blkaddr"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1606,
          "code": "if (__is_valid_data_blkaddr(blkaddr)) {",
          "condition": "__is_valid_data_blkaddr(blkaddr)",
          "variables": [
            "__is_valid_data_blkaddr",
            "blkaddr"
          ],
          "evidence": [],
          "why_it_blocks": "size/len/offset token present in condition"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1611,
          "code": "if (err)",
          "condition": "err",
          "variables": [
            "err"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1728,
          "code": "if (err && err != -ENODATA && err != -EAGAIN)",
          "condition": "err && err != -ENODATA && err != -EAGAIN",
          "variables": [
            "err",
            "err",
            "ENODATA",
            "err",
            "EAGAIN"
          ],
          "evidence": [],
          "why_it_blocks": "variable 'err' traced to user/syscall source: syscall_param"
        }
      ],
      "kernel_state_constraints": [
        {
          "frame": null,
          "file": "fs/fs_context.c",
          "line": 597,
          "code": "struct dentry *root;",
          "condition": "dentry pointer may be NULL or invalid",
          "variables": [
            "dentry"
          ],
          "evidence": [
            {
              "file": "fs/fs_context.c",
              "line": 597,
              "code": "struct dentry *root;",
              "note": "dentry-related line near crash site"
            }
          ],
          "why_it_blocks": "null/invalid dentry pointer will cause dereference and crash"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 134,
          "code": "if (old == -1) {",
          "condition": "old == -1",
          "variables": [
            "old"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 136,
          "code": "} else if (old == cpu) {",
          "condition": "old == cpu",
          "variables": [
            "old",
            "cpu"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 145,
          "code": "do { cpu_relax(); } while (atomic_read(&dump_lock) != -1);",
          "condition": "atomic_read(&dump_lock) != -1",
          "variables": [
            "atomic_read",
            "dump_lock"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "lib/dump_stack.c",
          "line": 146,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 2731,
          "code": "if (curseg->inited)",
          "condition": "curseg->inited",
          "variables": [
            "curseg",
            "inited"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 2734,
          "code": "if (seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA)",
          "condition": "seg_type == CURSEG_WARM_DATA || seg_type == CURSEG_COLD_DATA",
          "variables": [
            "seg_type",
            "CURSEG_WARM_DATA",
            "seg_type",
            "CURSEG_COLD_DATA"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 2737,
          "code": "if (test_opt(sbi, NOHEAP))",
          "condition": "test_opt(sbi, NOHEAP)",
          "variables": [
            "test_opt",
            "sbi",
            "NOHEAP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3046,
          "code": "if (!curseg->inited)",
          "condition": "!curseg->inited",
          "variables": [
            "curseg",
            "inited"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3047,
          "code": "goto alloc;",
          "condition": "goto alloc;",
          "variables": [
            "goto",
            "alloc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3049,
          "code": "if (force || curseg->next_blkoff ||",
          "condition": "if (force || curseg->next_blkoff ||",
          "variables": [
            "if",
            "force",
            "curseg",
            "next_blkoff"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3051,
          "code": "goto alloc;",
          "condition": "goto alloc;",
          "variables": [
            "goto",
            "alloc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3053,
          "code": "if (!get_ckpt_valid_blocks(sbi, curseg->segno, new_sec))",
          "condition": "!get_ckpt_valid_blocks(sbi, curseg->segno, new_sec)",
          "variables": [
            "get_ckpt_valid_blocks",
            "sbi",
            "curseg",
            "segno",
            "new_sec"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3054,
          "code": "return;",
          "condition": "return;",
          "variables": [
            "return"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1725,
          "code": "goto out_err;",
          "condition": "goto out_err;",
          "variables": [
            "goto",
            "out_err"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1832,
          "code": "if (unlikely(f2fs_cp_error(F2FS_I_SB(inode))))",
          "condition": "unlikely(f2fs_cp_error(F2FS_I_SB(inode)))",
          "variables": [
            "unlikely",
            "f2fs_cp_error",
            "F2FS_I_SB",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1833,
          "code": "return -EIO;",
          "condition": "return -EIO;",
          "variables": [
            "return",
            "EIO"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1834,
          "code": "if (!f2fs_is_checkpoint_ready(F2FS_I_SB(inode)))",
          "condition": "!f2fs_is_checkpoint_ready(F2FS_I_SB(inode))",
          "variables": [
            "f2fs_is_checkpoint_ready",
            "F2FS_I_SB",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1835,
          "code": "return -ENOSPC;",
          "condition": "return -ENOSPC;",
          "variables": [
            "return",
            "ENOSPC"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1836,
          "code": "if (!f2fs_is_compress_backend_ready(inode))",
          "condition": "!f2fs_is_compress_backend_ready(inode)",
          "variables": [
            "f2fs_is_compress_backend_ready",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1837,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1840,
          "code": "if (!S_ISREG(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1841,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1843,
          "code": "if (IS_ENCRYPTED(inode) &&",
          "condition": "IS_ENCRYPTED(inode",
          "variables": [
            "IS_ENCRYPTED",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1845,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1851,
          "code": "if ((f2fs_compressed_file(inode) || f2fs_is_pinned_file(inode)) &&",
          "condition": "(f2fs_compressed_file(inode) || f2fs_is_pinned_file(inode)",
          "variables": [
            "f2fs_compressed_file",
            "inode",
            "f2fs_is_pinned_file",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1854,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1859,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1864,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1865,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1873,
          "code": "if (mode & FALLOC_FL_PUNCH_HOLE) {",
          "condition": "mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1875,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1878,
          "code": "} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {",
          "condition": "mode & FALLOC_FL_COLLAPSE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_COLLAPSE_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1880,
          "code": "} else if (mode & FALLOC_FL_ZERO_RANGE) {",
          "condition": "mode & FALLOC_FL_ZERO_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_ZERO_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1882,
          "code": "} else if (mode & FALLOC_FL_INSERT_RANGE) {",
          "condition": "mode & FALLOC_FL_INSERT_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_INSERT_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 317,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 320,
          "code": "if (mode & ~FALLOC_FL_SUPPORTED_MASK)",
          "condition": "mode & ~FALLOC_FL_SUPPORTED_MASK",
          "variables": [
            "mode",
            "FALLOC_FL_SUPPORTED_MASK"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 321,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 324,
          "code": "if ((mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)) ==",
          "condition": "(mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_ZERO_RANGE)",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE",
            "FALLOC_FL_ZERO_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 326,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 329,
          "code": "if ((mode & FALLOC_FL_PUNCH_HOLE) &&",
          "condition": "(mode & FALLOC_FL_PUNCH_HOLE",
          "variables": [
            "mode",
            "FALLOC_FL_PUNCH_HOLE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 331,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 334,
          "code": "if ((mode & FALLOC_FL_COLLAPSE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_COLLAPSE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_COLLAPSE_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 336,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 339,
          "code": "if ((mode & FALLOC_FL_INSERT_RANGE) &&",
          "condition": "(mode & FALLOC_FL_INSERT_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_INSERT_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 341,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 344,
          "code": "if ((mode & FALLOC_FL_UNSHARE_RANGE) &&",
          "condition": "(mode & FALLOC_FL_UNSHARE_RANGE",
          "variables": [
            "mode",
            "FALLOC_FL_UNSHARE_RANGE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 346,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 348,
          "code": "if (!(file->f_mode & FMODE_WRITE))",
          "condition": "!(file->f_mode & FMODE_WRITE)",
          "variables": [
            "file",
            "f_mode",
            "FMODE_WRITE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 349,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 355,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 357,
          "code": "if (IS_IMMUTABLE(inode))",
          "condition": "IS_IMMUTABLE(inode)",
          "variables": [
            "IS_IMMUTABLE",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 358,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 363,
          "code": "if (IS_SWAPFILE(inode))",
          "condition": "IS_SWAPFILE(inode)",
          "variables": [
            "IS_SWAPFILE",
            "inode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 364,
          "code": "return -ETXTBSY;",
          "condition": "return -ETXTBSY;",
          "variables": [
            "return",
            "ETXTBSY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 371,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 372,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 374,
          "code": "if (S_ISFIFO(inode->i_mode))",
          "condition": "S_ISFIFO(inode->i_mode)",
          "variables": [
            "S_ISFIFO",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 375,
          "code": "return -ESPIPE;",
          "condition": "return -ESPIPE;",
          "variables": [
            "return",
            "ESPIPE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 377,
          "code": "if (S_ISDIR(inode->i_mode))",
          "condition": "S_ISDIR(inode->i_mode)",
          "variables": [
            "S_ISDIR",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 378,
          "code": "return -EISDIR;",
          "condition": "return -EISDIR;",
          "variables": [
            "return",
            "EISDIR"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 380,
          "code": "if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode",
            "S_ISBLK",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 381,
          "code": "return -ENODEV;",
          "condition": "return -ENODEV;",
          "variables": [
            "return",
            "ENODEV"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 385,
          "code": "return -EFBIG;",
          "condition": "return -EFBIG;",
          "variables": [
            "return",
            "EFBIG"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 387,
          "code": "if (!file->f_op->fallocate)",
          "condition": "!file->f_op->fallocate",
          "variables": [
            "file",
            "f_op",
            "fallocate"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/open.c",
          "line": 388,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 501,
          "code": "return -EFAULT;",
          "condition": "return -EFAULT;",
          "variables": [
            "return",
            "EFAULT"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 513,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 739,
          "code": "return -ENOTTY;",
          "condition": "return -ENOTTY;",
          "variables": [
            "return",
            "ENOTTY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 753,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 767,
          "code": "if (!S_ISREG(inode->i_mode))",
          "condition": "!S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 774,
          "code": "if (S_ISREG(inode->i_mode))",
          "condition": "S_ISREG(inode->i_mode)",
          "variables": [
            "S_ISREG",
            "inode",
            "i_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 757,
          "code": "if (!f.file)",
          "condition": "!f.file",
          "variables": [
            "f",
            "file"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 758,
          "code": "return -EBADF;",
          "condition": "return -EBADF;",
          "variables": [
            "return",
            "EBADF"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 761,
          "code": "if (error)",
          "condition": "error",
          "variables": [
            "error"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/ioctl.c",
          "line": 762,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4044,
          "code": "if (unlikely(ZERO_OR_NULL_PTR(s)))",
          "condition": "unlikely(ZERO_OR_NULL_PTR(s))",
          "variables": [
            "unlikely",
            "ZERO_OR_NULL_PTR",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4045,
          "code": "return s;",
          "condition": "return s;",
          "variables": [
            "return",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 583,
          "code": "if (!i)",
          "condition": "!i",
          "variables": [
            "i"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "include/linux/slab.h",
          "line": 586,
          "code": "return kmem_cache_alloc_node_trace(",
          "condition": "return kmem_cache_alloc_node_trace(",
          "variables": [
            "return",
            "kmem_cache_alloc_node_trace"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/util.c",
          "line": 635,
          "code": "if (!(kmalloc_flags & __GFP_RETRY_MAYFAIL))",
          "condition": "!(kmalloc_flags & __GFP_RETRY_MAYFAIL)",
          "variables": [
            "kmalloc_flags",
            "__GFP_RETRY_MAYFAIL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 4407,
          "code": "if (!sit_i)",
          "condition": "!sit_i",
          "variables": [
            "sit_i"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 4408,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5267,
          "code": "if (!sm_info)",
          "condition": "!sm_info",
          "variables": [
            "sm_info"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5268,
          "code": "return -ENOMEM;",
          "condition": "return -ENOMEM;",
          "variables": [
            "return",
            "ENOMEM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5281,
          "code": "if (sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS)",
          "condition": "sm_info->rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS",
          "variables": [
            "sm_info",
            "rec_prefree_segments",
            "DEF_MAX_RECLAIM_PREFREE_SEGMENTS"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5284,
          "code": "if (!f2fs_lfs_mode(sbi))",
          "condition": "!f2fs_lfs_mode(sbi)",
          "variables": [
            "f2fs_lfs_mode",
            "sbi"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 5296,
          "code": "if (!f2fs_readonly(sbi->sb)) {",
          "condition": "!f2fs_readonly(sbi->sb)",
          "variables": [
            "f2fs_readonly",
            "sbi",
            "sb"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/super.c",
          "line": 4322,
          "code": "goto stop_ckpt_thread;",
          "condition": "goto stop_ckpt_thread;",
          "variables": [
            "goto",
            "stop_ckpt_thread"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1454,
          "code": "if (IS_ERR(bdev))",
          "condition": "IS_ERR(bdev)",
          "variables": [
            "IS_ERR",
            "bdev"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1455,
          "code": "return ERR_CAST(bdev);",
          "condition": "return ERR_CAST(bdev);",
          "variables": [
            "return",
            "ERR_CAST",
            "bdev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1466,
          "code": "goto error_bdev;",
          "condition": "goto error_bdev;",
          "variables": [
            "goto",
            "error_bdev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1471,
          "code": "if (IS_ERR(s))",
          "condition": "IS_ERR(s)",
          "variables": [
            "IS_ERR",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1472,
          "code": "goto error_s;",
          "condition": "goto error_s;",
          "variables": [
            "goto",
            "error_s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1474,
          "code": "if (s->s_root) {",
          "condition": "s->s_root",
          "variables": [
            "s",
            "s_root"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1478,
          "code": "goto error_bdev;",
          "condition": "goto error_bdev;",
          "variables": [
            "goto",
            "error_bdev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1578,
          "code": "if (fc->root)",
          "condition": "fc->root",
          "variables": [
            "fc",
            "root"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/super.c",
          "line": 1579,
          "code": "return -EBUSY;",
          "condition": "return -EBUSY;",
          "variables": [
            "return",
            "EBUSY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3006,
          "code": "if (!fstype)",
          "condition": "!fstype",
          "variables": [
            "fstype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3007,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3010,
          "code": "if (!type)",
          "condition": "!type",
          "variables": [
            "type"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3011,
          "code": "return -ENODEV;",
          "condition": "return -ENODEV;",
          "variables": [
            "return",
            "ENODEV"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3013,
          "code": "if (type->fs_flags & FS_HAS_SUBTYPE) {",
          "condition": "type->fs_flags & FS_HAS_SUBTYPE",
          "variables": [
            "type",
            "fs_flags",
            "FS_HAS_SUBTYPE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3015,
          "code": "if (subtype) {",
          "condition": "subtype",
          "variables": [
            "subtype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3017,
          "code": "if (!*subtype) {",
          "condition": "!*subtype",
          "variables": [
            "subtype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3019,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3026,
          "code": "if (IS_ERR(fc))",
          "condition": "IS_ERR(fc)",
          "variables": [
            "IS_ERR",
            "fc"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3027,
          "code": "return PTR_ERR(fc);",
          "condition": "return PTR_ERR(fc);",
          "variables": [
            "return",
            "PTR_ERR",
            "fc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3035,
          "code": "if (subtype)",
          "condition": "subtype",
          "variables": [
            "subtype"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3328,
          "code": "return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
          "condition": "return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,",
          "variables": [
            "return",
            "do_new_mount",
            "path",
            "type_page",
            "sb_flags",
            "mnt_flags",
            "dev_name"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3348,
          "code": "if (ret)",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3349,
          "code": "return ret;",
          "condition": "return ret;",
          "variables": [
            "return",
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3559,
          "code": "if (IS_ERR(kernel_type))",
          "condition": "IS_ERR(kernel_type)",
          "variables": [
            "IS_ERR",
            "kernel_type"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3560,
          "code": "goto out_type;",
          "condition": "goto out_type;",
          "variables": [
            "goto",
            "out_type"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3564,
          "code": "if (IS_ERR(kernel_dev))",
          "condition": "IS_ERR(kernel_dev)",
          "variables": [
            "IS_ERR",
            "kernel_dev"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3565,
          "code": "goto out_dev;",
          "condition": "goto out_dev;",
          "variables": [
            "goto",
            "out_dev"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3569,
          "code": "if (IS_ERR(options))",
          "condition": "IS_ERR(options)",
          "variables": [
            "IS_ERR",
            "options"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/namespace.c",
          "line": 3570,
          "code": "goto out_data;",
          "condition": "goto out_data;",
          "variables": [
            "goto",
            "out_data"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4275,
          "code": "if (cpusets_enabled() &&",
          "condition": "cpusets_enabled(",
          "variables": [
            "cpusets_enabled"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4298,
          "code": "if (ac->spread_dirty_pages) {",
          "condition": "ac->spread_dirty_pages",
          "variables": [
            "ac",
            "spread_dirty_pages"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4299,
          "code": "if (last_pgdat_dirty_limit == zone->zone_pgdat)",
          "condition": "last_pgdat_dirty_limit == zone->zone_pgdat",
          "variables": [
            "last_pgdat_dirty_limit",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4302,
          "code": "if (!node_dirty_ok(zone->zone_pgdat)) {",
          "condition": "!node_dirty_ok(zone->zone_pgdat)",
          "variables": [
            "node_dirty_ok",
            "zone",
            "zone_pgdat"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4308,
          "code": "if (no_fallback && nr_online_nodes > 1 &&",
          "condition": "if (no_fallback && nr_online_nodes > 1 &&",
          "variables": [
            "if",
            "no_fallback",
            "nr_online_nodes"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4318,
          "code": "if (zone_to_nid(zone) != local_nid) {",
          "condition": "zone_to_nid(zone) != local_nid",
          "variables": [
            "zone_to_nid",
            "zone",
            "local_nid"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4320,
          "code": "goto retry;",
          "condition": "goto retry;",
          "variables": [
            "goto",
            "retry"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4325,
          "code": "if (!zone_watermark_fast(zone, order, mark,",
          "condition": "if (!zone_watermark_fast(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_fast",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4335,
          "code": "if (static_branch_unlikely(&deferred_pages)) {",
          "condition": "static_branch_unlikely(&deferred_pages)",
          "variables": [
            "static_branch_unlikely",
            "deferred_pages"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4336,
          "code": "if (_deferred_grow_zone(zone, order))",
          "condition": "_deferred_grow_zone(zone, order)",
          "variables": [
            "_deferred_grow_zone",
            "zone",
            "order"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4337,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4342,
          "code": "if (alloc_flags & ALLOC_NO_WATERMARKS)",
          "condition": "alloc_flags & ALLOC_NO_WATERMARKS",
          "variables": [
            "alloc_flags",
            "ALLOC_NO_WATERMARKS"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4343,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4345,
          "code": "if (node_reclaim_mode == 0 ||",
          "condition": "if (node_reclaim_mode == 0 ||",
          "variables": [
            "if",
            "node_reclaim_mode"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4350,
          "code": "switch (ret) {",
          "condition": "ret",
          "variables": [
            "ret"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4359,
          "code": "if (zone_watermark_ok(zone, order, mark,",
          "condition": "if (zone_watermark_ok(zone, order, mark,",
          "variables": [
            "if",
            "zone_watermark_ok",
            "zone",
            "order",
            "mark"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4361,
          "code": "goto try_this_zone;",
          "condition": "goto try_this_zone;",
          "variables": [
            "goto",
            "try_this_zone"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 4370,
          "code": "if (page) {",
          "condition": "page",
          "variables": [
            "page"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5383,
          "code": "if (unlikely(order >= MAX_ORDER)) {",
          "condition": "unlikely(order >= MAX_ORDER)",
          "variables": [
            "unlikely",
            "order",
            "MAX_ORDER"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/page_alloc.c",
          "line": 5390,
          "code": "if (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))",
          "condition": "!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags)",
          "variables": [
            "prepare_alloc_pages",
            "gfp_mask",
            "order",
            "preferred_nid",
            "nodemask",
            "ac",
            "alloc_mask",
            "alloc_flags"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 1830,
          "code": "if ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))",
          "condition": "(alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min)",
          "variables": [
            "alloc_gfp",
            "__GFP_DIRECT_RECLAIM",
            "oo_order",
            "oo",
            "oo_order",
            "s",
            "min"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 1870,
          "code": "return allocate_slab(s,",
          "condition": "return allocate_slab(s,",
          "variables": [
            "return",
            "allocate_slab",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2639,
          "code": "if (freelist)",
          "condition": "freelist",
          "variables": [
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2640,
          "code": "return freelist;",
          "condition": "return freelist;",
          "variables": [
            "return",
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2801,
          "code": "if (!page) {",
          "condition": "!page",
          "variables": [
            "page"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2806,
          "code": "if (unlikely(node != NUMA_NO_NODE &&",
          "condition": "if (unlikely(node != NUMA_NO_NODE &&",
          "variables": [
            "if",
            "unlikely",
            "node",
            "NUMA_NO_NODE"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2809,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2813,
          "code": "if (unlikely(!node_match(page, node))) {",
          "condition": "unlikely(!node_match(page, node))",
          "variables": [
            "unlikely",
            "node_match",
            "page",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2818,
          "code": "if (!node_state(node, N_NORMAL_MEMORY)) {",
          "condition": "!node_state(node, N_NORMAL_MEMORY)",
          "variables": [
            "node_state",
            "node",
            "N_NORMAL_MEMORY"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2820,
          "code": "goto redo;",
          "condition": "goto redo;",
          "variables": [
            "goto",
            "redo"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2824,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2833,
          "code": "if (unlikely(!pfmemalloc_match(page, gfpflags))) {",
          "condition": "unlikely(!pfmemalloc_match(page, gfpflags))",
          "variables": [
            "unlikely",
            "pfmemalloc_match",
            "page",
            "gfpflags"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2835,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2840,
          "code": "if (freelist)",
          "condition": "freelist",
          "variables": [
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2841,
          "code": "goto load_freelist;",
          "condition": "goto load_freelist;",
          "variables": [
            "goto",
            "load_freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2845,
          "code": "if (!freelist) {",
          "condition": "!freelist",
          "variables": [
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2849,
          "code": "goto new_slab;",
          "condition": "goto new_slab;",
          "variables": [
            "goto",
            "new_slab"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2863,
          "code": "return freelist;",
          "condition": "return freelist;",
          "variables": [
            "return",
            "freelist"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2867,
          "code": "if (slub_percpu_partial(c)) {",
          "condition": "slub_percpu_partial(c)",
          "variables": [
            "slub_percpu_partial",
            "c"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2871,
          "code": "goto redo;",
          "condition": "goto redo;",
          "variables": [
            "goto",
            "redo"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2925,
          "code": "if (!s)",
          "condition": "!s",
          "variables": [
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2929,
          "code": "if (unlikely(object))",
          "condition": "unlikely(object)",
          "variables": [
            "unlikely",
            "object"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2930,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2946,
          "code": "} while (IS_ENABLED(CONFIG_PREEMPTION) &&",
          "condition": "IS_ENABLED(CONFIG_PREEMPTION",
          "variables": [
            "IS_ENABLED",
            "CONFIG_PREEMPTION"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 2968,
          "code": "if (unlikely(!object || !page || !node_match(page, node))) {",
          "condition": "unlikely(!object || !page || !node_match(page, node))",
          "variables": [
            "unlikely",
            "object",
            "page",
            "node_match",
            "page",
            "node"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4547,
          "code": "if (unlikely(ZERO_OR_NULL_PTR(s)))",
          "condition": "unlikely(ZERO_OR_NULL_PTR(s))",
          "variables": [
            "unlikely",
            "ZERO_OR_NULL_PTR",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "mm/slub.c",
          "line": 4548,
          "code": "return s;",
          "condition": "return s;",
          "variables": [
            "return",
            "s"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/core/skbuff.c",
          "line": 230,
          "code": "if (!skb)",
          "condition": "!skb",
          "variables": [
            "skb"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/core/skbuff.c",
          "line": 231,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1903,
          "code": "return -EOPNOTSUPP;",
          "condition": "return -EOPNOTSUPP;",
          "variables": [
            "return",
            "EOPNOTSUPP"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1907,
          "code": "return -ENODATA;",
          "condition": "return -ENODATA;",
          "variables": [
            "return",
            "ENODATA"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1917,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1919,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1923,
          "code": "if ((dst_group || dst_portid) &&",
          "condition": "(dst_group || dst_portid",
          "variables": [
            "dst_group",
            "dst_portid"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1925,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1934,
          "code": "if (!READ_ONCE(nlk->bound)) {",
          "condition": "!READ_ONCE(nlk->bound)",
          "variables": [
            "READ_ONCE",
            "nlk",
            "bound"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1937,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/netlink/af_netlink.c",
          "line": 1945,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2391,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2399,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2408,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2412,
          "code": "goto out_freectl;",
          "condition": "goto out_freectl;",
          "variables": [
            "goto",
            "out_freectl"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2431,
          "code": "goto out_freectl;",
          "condition": "goto out_freectl;",
          "variables": [
            "goto",
            "out_freectl"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2468,
          "code": "return -EINVAL;",
          "condition": "return -EINVAL;",
          "variables": [
            "return",
            "EINVAL"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "net/socket.c",
          "line": 2472,
          "code": "goto out;",
          "condition": "goto out;",
          "variables": [
            "goto",
            "out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3498,
          "code": "if (from_gc) {",
          "condition": "from_gc",
          "variables": [
            "from_gc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/segment.c",
          "line": 3521,
          "code": "if (from_gc) {",
          "condition": "from_gc",
          "variables": [
            "from_gc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1417,
          "code": "if (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))",
          "condition": "unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC))",
          "variables": [
            "unlikely",
            "is_inode_flag_set",
            "dn",
            "inode",
            "FI_NO_ALLOC"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1418,
          "code": "return -EPERM;",
          "condition": "return -EPERM;",
          "variables": [
            "return",
            "EPERM"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1425,
          "code": "if (dn->data_blkaddr != NULL_ADDR)",
          "condition": "dn->data_blkaddr != NULL_ADDR",
          "variables": [
            "dn",
            "data_blkaddr",
            "NULL_ADDR"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1426,
          "code": "goto alloc;",
          "condition": "goto alloc;",
          "variables": [
            "goto",
            "alloc"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1578,
          "code": "goto unlock_out;",
          "condition": "goto unlock_out;",
          "variables": [
            "goto",
            "unlock_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1582,
          "code": "if (map->m_next_pgofs)",
          "condition": "map->m_next_pgofs",
          "variables": [
            "map",
            "m_next_pgofs"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1585,
          "code": "if (map->m_next_extent)",
          "condition": "map->m_next_extent",
          "variables": [
            "map",
            "m_next_extent"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1589,
          "code": "goto unlock_out;",
          "condition": "goto unlock_out;",
          "variables": [
            "goto",
            "unlock_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1603,
          "code": "goto sync_out;",
          "condition": "goto sync_out;",
          "variables": [
            "goto",
            "sync_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1608,
          "code": "if (f2fs_lfs_mode(sbi) && flag == F2FS_GET_BLOCK_DIO &&",
          "condition": "f2fs_lfs_mode(sbi",
          "variables": [
            "f2fs_lfs_mode",
            "sbi"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1612,
          "code": "goto sync_out;",
          "condition": "goto sync_out;",
          "variables": [
            "goto",
            "sync_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1617,
          "code": "if (create) {",
          "condition": "create",
          "variables": [
            "create"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1618,
          "code": "if (unlikely(f2fs_cp_error(sbi))) {",
          "condition": "unlikely(f2fs_cp_error(sbi))",
          "variables": [
            "unlikely",
            "f2fs_cp_error",
            "sbi"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1620,
          "code": "goto sync_out;",
          "condition": "goto sync_out;",
          "variables": [
            "goto",
            "sync_out"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1622,
          "code": "if (flag == F2FS_GET_BLOCK_PRE_AIO) {",
          "condition": "flag == F2FS_GET_BLOCK_PRE_AIO",
          "variables": [
            "flag",
            "F2FS_GET_BLOCK_PRE_AIO"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        },
        {
          "frame": null,
          "file": "fs/f2fs/data.c",
          "line": 1623,
          "code": "if (blkaddr == NULL_ADDR) {",
          "condition": "blkaddr == NULL_ADDR",
          "variables": [
            "blkaddr",
            "NULL_ADDR"
          ],
          "evidence": [],
          "why_it_blocks": "null/is_err/warn guard"
        },
        {
          "frame": null,
          "file": "fs/f2fs/file.c",
          "line": 1729,
          "code": "goto out_err;",
          "condition": "goto out_err;",
          "variables": [
            "goto",
            "out_err"
          ],
          "evidence": [],
          "why_it_blocks": "guard or conditional that may prevent reaching crash site"
        }
      ]
    },
    "exploitability": "high",
    "non_canonical_addr": "0xdffffc0000000000",
    "overview": {
      "exploitability": "HIGH",
      "rationale": "attacker-controlled input reaches vulnerable path; pointer deref evidence (reads=149, writes=62); boundedness=bounded",
      "primitive_capabilities": "Unknown or limited primitive; further manual analysis required",
      "confidence_breakdown": {
        "attacker_control": 0.4,
        "evidence_strength": 0.4,
        "boundedness_score": 0.0,
        "kasan_indicator": 0.1,
        "aggregate_estimate": 0.9,
        "reported_confidence": 1.0
      }
    },
    "how_to_create": {
      "alloc_frame": "__kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>",
      "guidance": [
        "Allocation from slab/kmalloc: create objects via normal kernel paths (file ops, network ops, or module-specific APIs)"
      ]
    }
  },
  "llm_analysis": {
    "prompt": "Task: Given the crash log and the provided source snippets, produce a concise developer-friendly description of the PRECONDITION(s) required to reach the crash. Provide concrete input ranges and variable constraints. Analyze the full call chain from the crash point backwards and inspect all 'if/for/while/switch' conditions, early 'return' and 'goto' statements that restrict reaching the crash. For each such conditional, classify it as either an INPUT constraint (user-controlled) or KERNEL_STATE constraint. Also include short evidence lines from the provided snippets that justify each constraint.\n\nINPUTS I WILL PROVIDE:\n- \"crash_log\": the full kernel oops/trace.\n- \"snippets\": a list of {file, line_start, line_end, code} entries (text blocks) containing the relevant source around frames in the call stack.\nOUTPUT FORMAT (strict JSON):\n{\n  \"overview\": {\n    \"exploitability\": \"<HIGH|MEDIUM|LOW>\",\n    \"rationale\": \"<one-sentence justification with evidence>\"\n    \"primitive_capabilities\": \"<1-2 sentence description of the capabilities this exploit provides, if any.>\"\n  },\n  \"preconditions\": [\n    {\n      \"summary\": \"<one-sentence developer-friendly precondition>\",\n      \"concrete_constraints\": [\n         \"<variable> => <allowed range or constraint, be concrete>\"\n      ],\n      \"why_reaches_crash\": \"<short reasoning>\"\n    }\n  ],\n  \"path_constraints\": {\n    \"input\": [\n      {\n        \"file\": \"<file path>\",\n        \"line\": <line number>,\n        \"code\": \"<exact single-line snippet that is the condition>\",\n        \"condition\": \"<short human-readable condition>\",\n        \"why_it_blocks\": \"<why this prevents/restricts reaching crash (user-controlled?)>\"\n      }, ...\n    ],\n    \"kernel_state\": [\n      {\n        \"file\": \"<file path>\",\n        \"line\": <line number>,\n        \"code\": \"<exact single-line snippet>\",\n        \"condition\": \"<short kernel-state condition>\",\n        \"why_it_blocks\": \"<why this prevents/restricts reaching crash (internal invariant)>\"\n      }, ...\n    ]\n  },\n  \"evidence\": [\n    { \"file\": \"<file>\", \"line\": <line>, \"code\": \"<line text>\", \"note\":\"<one-line justification linking to precondition>\" }\n  ]\n}\n\nREQUIREMENTS:\n1. Keep JSON **compact** but include only necessary fields. Do not include extra commentary outside the JSON.\n2. For each constraint entry in path_constraints.* produce **the exact single-line code text** from snippet that implements the check (or part of it) and a one-line explanation (why_it_blocks).\n3. If the snippets are truncated or missing some callee lines, indicate that clearly with a short note in the JSON (e.g., \"note\": \"caller's guard not present in snippets\").\n4. If a condition is ambiguous about whether it\u2019s input vs kernel_state, mark as \"ambiguous\" and explain why in the same entry.\n5. If the crash appears to be caused by corrupted metadata (e.g., extent header), give plausible concrete ranges/values that would cause arithmetic overflow or out-of-range lengths (e.g., `ee_len > EXT4_BLOCKS_PER_GROUP(sb)` or `ee_block + ee_len` wraps).\n6. Do not propose exploit techniques. If asked about exploitability, respond with a short field \"exploitability\": \"<HIGH|MEDIUM|LOW>\" plus one-sentence rationale, but do not provide attack steps.\n\nNow analyze the following inputs. Be precise, inspect conditional checks and early returns, and output only JSON that follows the schema above.\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\n---[ end trace b21af47fc54341fe ]---\n==================================================================\nBUG: KASAN: slab-out-of-bounds in __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]\nBUG: KASAN: slab-out-of-bounds in reset_curseg+0x4dd/0x560 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663'>fs/f2fs/segment.c:2663</a>\nRead of size 4 at addr ffff88811471cbc0 by task syz.6.85/837\n\nCPU: 0 PID: 837 Comm: syz.6.85 Tainted: G        W         syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/14/2025\nCall Trace:\n __dump_stack+0x21/0x24 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77'>lib/dump_stack.c:77</a>\n dump_stack_lvl+0x169/0x1d8 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118'>lib/dump_stack.c:118</a>\n print_address_description+0x7f/0x2c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#248'>mm/kasan/report.c:248</a>\n __kasan_report <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#435'>mm/kasan/report.c:435</a> [inline]\n kasan_report+0xe2/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#452'>mm/kasan/report.c:452</a>\n __asan_report_load4_noabort+0x14/0x20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report_generic.c#308'>mm/kasan/report_generic.c:308</a>\n __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]\n reset_curseg+0x4dd/0x560 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663'>fs/f2fs/segment.c:2663</a>\n new_curseg+0x12f6/0x18a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723'>fs/f2fs/segment.c:2723</a>\n __allocate_new_segment+0x13d/0x810 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039'>fs/f2fs/segment.c:3039</a>\n __allocate_new_section <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047'>fs/f2fs/segment.c:3047</a> [inline]\n f2fs_allocate_new_section+0x1d5/0x280 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054'>fs/f2fs/segment.c:3054</a>\n expand_inode_data+0x5a8/0x930 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720'>fs/f2fs/file.c:1720</a>\n f2fs_fallocate+0x42b/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825'>fs/f2fs/file.c:1825</a>\n vfs_fallocate+0x4b4/0x590 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310'>fs/open.c:310</a>\n ioctl_preallocate <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494'>fs/ioctl.c:494</a> [inline]\n file_ioctl fs/ioctl.c:-1 [inline]\n do_vfs_ioctl+0x12e3/0x1510 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x9f/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\nRIP: 0033:0x7feae1e11be9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007feae1c40038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007feae2049180 RCX: 00007feae1e11be9\nRDX: 00002000000000c0 RSI: 0000000040305828 RDI: 0000000000000005\nRBP: 00007feae1e94e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\n\nAllocated by task 817:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#45'>mm/kasan/common.c:45</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#430'>mm/kasan/common.c:430</a> [inline]\n ____kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#509'>mm/kasan/common.c:509</a> [inline]\n __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>\n kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/kasan.h#254'>include/linux/kasan.h:254</a> [inline]\n __kmalloc+0x1a7/0x330 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033'>mm/slub.c:4033</a>\n __kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418'>include/linux/slab.h:418</a> [inline]\n kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575'>include/linux/slab.h:575</a> [inline]\n kvmalloc_node+0x88/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612'>mm/util.c:612</a>\n kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833'>include/linux/mm.h:833</a> [inline]\n f2fs_kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374'>fs/f2fs/f2fs.h:3374</a> [inline]\n f2fs_kvzalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380'>fs/f2fs/f2fs.h:3380</a> [inline]\n build_sit_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395'>fs/f2fs/segment.c:4395</a> [inline]\n f2fs_build_segment_manager+0xdba/0x48f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258'>fs/f2fs/segment.c:5258</a>\n f2fs_fill_super+0x42d1/0x6c70 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315'>fs/f2fs/super.c:4315</a>\n mount_bdev+0x28b/0x3a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442'>fs/super.c:1442</a>\n f2fs_mount+0x34/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595'>fs/f2fs/super.c:4595</a>\n legacy_get_tree+0xed/0x190 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593'>fs/fs_context.c:593</a>\n vfs_get_tree+0x89/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572'>fs/super.c:1572</a>\n do_new_mount+0x25a/0xa20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997'>fs/namespace.c:2997</a>\n path_mount+0x572/0xc80 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327'>fs/namespace.c:3327</a>\n do_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340'>fs/namespace.c:3340</a> [inline]\n __do_sys_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548'>fs/namespace.c:3548</a> [inline]\n __se_sys_mount+0x318/0x380 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n __x64_sys_mount+0xbf/0xd0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\n\nThe buggy address belongs to the object at ffff88811471c800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 960 bytes inside of\n 1024-byte region [ffff88811471c800, ffff88811471cc00)\nThe buggy address belongs to the page:\npage:ffffea000451c600 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x114718\nhead:ffffea000451c600 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x4000000000010200(slab|head)\nraw: 4000000000010200 ffffea0004522200 0000000300000003 ffff888100042f00\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0xd20c0(__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 95, ts 5090814031, free_ts 0\n set_page_owner <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35'>include/linux/page_owner.h:35</a> [inline]\n post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456'>mm/page_alloc.c:2456</a> [inline]\n prep_new_page+0x179/0x180 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462'>mm/page_alloc.c:2462</a>\n get_page_from_freelist+0x2235/0x23d0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254'>mm/page_alloc.c:4254</a>\n __alloc_pages_nodemask+0x268/0x5f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370'>mm/page_alloc.c:5370</a>\n alloc_slab_page mm/slub.c:-1 [inline]\n allocate_slab <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808'>mm/slub.c:1808</a> [inline]\n new_slab+0x84/0x3f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869'>mm/slub.c:1869</a>\n new_slab_objects <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627'>mm/slub.c:2627</a> [inline]\n ___slab_alloc+0x2a6/0x450 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791'>mm/slub.c:2791</a>\n __slab_alloc+0x63/0xa0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831'>mm/slub.c:2831</a>\n slab_alloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913'>mm/slub.c:2913</a> [inline]\n slab_alloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955'>mm/slub.c:2955</a> [inline]\n __kmalloc_track_caller+0x1ef/0x320 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536'>mm/slub.c:4536</a>\n __kmalloc_reserve <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144'>net/core/skbuff.c:144</a> [inline]\n __alloc_skb+0xdc/0x520 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212'>net/core/skbuff.c:212</a>\n alloc_skb <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126'>include/linux/skbuff.h:1126</a> [inline]\n netlink_alloc_large_skb <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178'>net/netlink/af_netlink.c:1178</a> [inline]\n netlink_sendmsg+0x5f6/0xb30 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889'>net/netlink/af_netlink.c:1889</a>\n sock_sendmsg_nosec <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652'>net/socket.c:652</a> [inline]\n __sock_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664'>net/socket.c:664</a> [inline]\n ____sys_sendmsg+0x5a2/0x8c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376'>net/socket.c:2376</a>\n ___sys_sendmsg+0x1f0/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430'>net/socket.c:2430</a>\n __sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459'>net/socket.c:2459</a> [inline]\n __do_sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468'>net/socket.c:2468</a> [inline]\n __se_sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466'>net/socket.c:2466</a> [inline]\n __x64_sys_sendmsg+0x1e2/0x2a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466'>net/socket.c:2466</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\npage_owner free stack trace missing\n\nMemory state around the buggy address:\n ffff88811471ca80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88811471cb00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88811471cb80: 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc fc\n                                           ^\n ffff88811471cc00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff88811471cc80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n==================================================================\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nCPU: 1 PID: 837 Comm: syz.6.85 Tainted: G    B   W         syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/14/2025\nRIP: 0010:update_sit_entry+0x3eb/0xf50 fs/f2fs/segment.c:-1\nCode: 89 45 a8 49 01 c5 41 f6 d7 41 80 e7 07 44 89 f9 41 bf 01 00 00 00 41 d3 e7 4d 89 ee 49 c1 ee 03 48 b8 00 00 00 00 00 fc ff df <41> 0f b6 04 06 84 c0 0f 85 a5 08 00 00 41 0f b6 5d 00 44 89 f8 41\nRSP: 0018:ffffc90001207350 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88811471cbc8 RCX: 0000000000000007\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88811471cbc8\nRBP: ffffc900012073d0 R08: ffff888115c193c0 R09: 0000000000000003\nR10: 00000000ffffffff R11: 0000000000000000 R12: 0000000000004000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000080\nFS:  00007feae1c406c0(0000) GS:ffff8881f7100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffd90c62f98 CR3: 0000000127a9b000 CR4: 00000000003506a0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n f2fs_allocate_data_block+0x156b/0x3a10 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481'>fs/f2fs/segment.c:3481</a>\n __allocate_data_block+0x52a/0x980 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407'>fs/f2fs/data.c:1407</a>\n f2fs_map_blocks+0xdc8/0x35c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575'>fs/f2fs/data.c:1575</a>\n expand_inode_data+0x5d7/0x930 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724'>fs/f2fs/file.c:1724</a>\n f2fs_fallocate+0x42b/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825'>fs/f2fs/file.c:1825</a>\n vfs_fallocate+0x4b4/0x590 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310'>fs/open.c:310</a>\n ioctl_preallocate <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494'>fs/ioctl.c:494</a> [inline]\n file_ioctl fs/ioctl.c:-1 [inline]\n do_vfs_ioctl+0x12e3/0x1510 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x9f/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\nRIP: 0033:0x7feae1e11be9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007feae1c40038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007feae2049180 RCX: 00007feae1e11be9\nRDX: 00002000000000c0 RSI: 0000000040305828 RDI: 0000000000000005\nRBP: 00007feae1e94e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\nModules linked in:\n---[ end trace b21af47fc54341ff ]---\nRIP: 0010:update_sit_entry+0x3eb/0xf50 fs/f2fs/segment.c:-1\nCode: 89 45 a8 49 01 c5 41 f6 d7 41 80 e7 07 44 89 f9 41 bf 01 00 00 00 41 d3 e7 4d 89 ee 49 c1 ee 03 48 b8 00 00 00 00 00 fc ff df <41> 0f b6 04 06 84 c0 0f 85 a5 08 00 00 41 0f b6 5d 00 44 89 f8 41\nRSP: 0018:ffffc90001207350 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88811471cbc8 RCX: 0000000000000007\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88811471cbc8\nRBP: ffffc900012073d0 R08: ffff888115c193c0 R09: 0000000000000003\nR10: 00000000ffffffff R11: 0000000000000000 R12: 0000000000004000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000080\nFS:  00007feae1c406c0(0000) GS:ffff8881f7100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f0f2e064000 CR3: 0000000127a9b000 CR4: 00000000003506a0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n----------------\nCode disassembly (best guess):\n   0:\t89 45 a8             \tmov    %eax,-0x58(%rbp)\n   3:\t49 01 c5             \tadd    %rax,%r13\n   6:\t41 f6 d7             \tnot    %r15b\n   9:\t41 80 e7 07          \tand    $0x7,%r15b\n   d:\t44 89 f9             \tmov    %r15d,%ecx\n  10:\t41 bf 01 00 00 00    \tmov    $0x1,%r15d\n  16:\t41 d3 e7             \tshl    %cl,%r15d\n  19:\t4d 89 ee             \tmov    %r13,%r14\n  1c:\t49 c1 ee 03          \tshr    $0x3,%r14\n  20:\t48 b8 00 00 00 00 00 \tmovabs $0xdffffc0000000000,%rax\n  27:\tfc ff df\n* 2a:\t41 0f b6 04 06       \tmovzbl (%r14,%rax,1),%eax <-- trapping instruction\n  2f:\t84 c0                \ttest   %al,%al\n  31:\t0f 85 a5 08 00 00    \tjne    0x8dc\n  37:\t41 0f b6 5d 00       \tmovzbl 0x0(%r13),%ebx\n  3c:\t44 89 f8             \tmov    %r15d,%eax\n  3f:\t41                   \trex.B\n\n-- fs/f2fs/segment.c:2257 -> static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\n\tse->type = type;\n---\n-- fs/f2fs/segment.c:2663 -> \t__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);\n---\n-- lib/dump_stack.c:77 -> static void __dump_stack(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\tshow_stack(NULL, NULL, log_lvl);\n---",
    "local_llm": {
      "ok": false,
      "error": "Local LLM calls disabled in this version",
      "prompt": "Task: Given the crash log and the provided source snippets, produce a concise developer-friendly description of the PRECONDITION(s) required to reach the crash. Provide concrete input ranges and variable constraints. Analyze the full call chain from the crash point backwards and inspect all 'if/for/while/switch' conditions, early 'return' and 'goto' statements that restrict reaching the crash. For each such conditional, classify it as either an INPUT constraint (user-controlled) or KERNEL_STATE constraint. Also include short evidence lines from the provided snippets that justify each constraint.\n\nINPUTS I WILL PROVIDE:\n- \"crash_log\": the full kernel oops/trace.\n- \"snippets\": a list of {file, line_start, line_end, code} entries (text blocks) containing the relevant source around frames in the call stack.\nOUTPUT FORMAT (strict JSON):\n{\n  \"overview\": {\n    \"exploitability\": \"<HIGH|MEDIUM|LOW>\",\n    \"rationale\": \"<one-sentence justification with evidence>\"\n    \"primitive_capabilities\": \"<1-2 sentence description of the capabilities this exploit provides, if any.>\"\n  },\n  \"preconditions\": [\n    {\n      \"summary\": \"<one-sentence developer-friendly precondition>\",\n      \"concrete_constraints\": [\n         \"<variable> => <allowed range or constraint, be concrete>\"\n      ],\n      \"why_reaches_crash\": \"<short reasoning>\"\n    }\n  ],\n  \"path_constraints\": {\n    \"input\": [\n      {\n        \"file\": \"<file path>\",\n        \"line\": <line number>,\n        \"code\": \"<exact single-line snippet that is the condition>\",\n        \"condition\": \"<short human-readable condition>\",\n        \"why_it_blocks\": \"<why this prevents/restricts reaching crash (user-controlled?)>\"\n      }, ...\n    ],\n    \"kernel_state\": [\n      {\n        \"file\": \"<file path>\",\n        \"line\": <line number>,\n        \"code\": \"<exact single-line snippet>\",\n        \"condition\": \"<short kernel-state condition>\",\n        \"why_it_blocks\": \"<why this prevents/restricts reaching crash (internal invariant)>\"\n      }, ...\n    ]\n  },\n  \"evidence\": [\n    { \"file\": \"<file>\", \"line\": <line>, \"code\": \"<line text>\", \"note\":\"<one-line justification linking to precondition>\" }\n  ]\n}\n\nREQUIREMENTS:\n1. Keep JSON **compact** but include only necessary fields. Do not include extra commentary outside the JSON.\n2. For each constraint entry in path_constraints.* produce **the exact single-line code text** from snippet that implements the check (or part of it) and a one-line explanation (why_it_blocks).\n3. If the snippets are truncated or missing some callee lines, indicate that clearly with a short note in the JSON (e.g., \"note\": \"caller's guard not present in snippets\").\n4. If a condition is ambiguous about whether it\u2019s input vs kernel_state, mark as \"ambiguous\" and explain why in the same entry.\n5. If the crash appears to be caused by corrupted metadata (e.g., extent header), give plausible concrete ranges/values that would cause arithmetic overflow or out-of-range lengths (e.g., `ee_len > EXT4_BLOCKS_PER_GROUP(sb)` or `ee_block + ee_len` wraps).\n6. Do not propose exploit techniques. If asked about exploitability, respond with a short field \"exploitability\": \"<HIGH|MEDIUM|LOW>\" plus one-sentence rationale, but do not provide attack steps.\n\nNow analyze the following inputs. Be precise, inspect conditional checks and early returns, and output only JSON that follows the schema above.\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\n---[ end trace b21af47fc54341fe ]---\n==================================================================\nBUG: KASAN: slab-out-of-bounds in __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]\nBUG: KASAN: slab-out-of-bounds in reset_curseg+0x4dd/0x560 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663'>fs/f2fs/segment.c:2663</a>\nRead of size 4 at addr ffff88811471cbc0 by task syz.6.85/837\n\nCPU: 0 PID: 837 Comm: syz.6.85 Tainted: G        W         syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/14/2025\nCall Trace:\n __dump_stack+0x21/0x24 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#77'>lib/dump_stack.c:77</a>\n dump_stack_lvl+0x169/0x1d8 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/lib/dump_stack.c#118'>lib/dump_stack.c:118</a>\n print_address_description+0x7f/0x2c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#248'>mm/kasan/report.c:248</a>\n __kasan_report <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#435'>mm/kasan/report.c:435</a> [inline]\n kasan_report+0xe2/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report.c#452'>mm/kasan/report.c:452</a>\n __asan_report_load4_noabort+0x14/0x20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/report_generic.c#308'>mm/kasan/report_generic.c:308</a>\n __set_sit_entry_type <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2257'>fs/f2fs/segment.c:2257</a> [inline]\n reset_curseg+0x4dd/0x560 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2663'>fs/f2fs/segment.c:2663</a>\n new_curseg+0x12f6/0x18a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#2723'>fs/f2fs/segment.c:2723</a>\n __allocate_new_segment+0x13d/0x810 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3039'>fs/f2fs/segment.c:3039</a>\n __allocate_new_section <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3047'>fs/f2fs/segment.c:3047</a> [inline]\n f2fs_allocate_new_section+0x1d5/0x280 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3054'>fs/f2fs/segment.c:3054</a>\n expand_inode_data+0x5a8/0x930 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1720'>fs/f2fs/file.c:1720</a>\n f2fs_fallocate+0x42b/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825'>fs/f2fs/file.c:1825</a>\n vfs_fallocate+0x4b4/0x590 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310'>fs/open.c:310</a>\n ioctl_preallocate <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494'>fs/ioctl.c:494</a> [inline]\n file_ioctl fs/ioctl.c:-1 [inline]\n do_vfs_ioctl+0x12e3/0x1510 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x9f/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\nRIP: 0033:0x7feae1e11be9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007feae1c40038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007feae2049180 RCX: 00007feae1e11be9\nRDX: 00002000000000c0 RSI: 0000000040305828 RDI: 0000000000000005\nRBP: 00007feae1e94e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\n\nAllocated by task 817:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#45'>mm/kasan/common.c:45</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#430'>mm/kasan/common.c:430</a> [inline]\n ____kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#509'>mm/kasan/common.c:509</a> [inline]\n __kasan_kmalloc+0xda/0x110 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/kasan/common.c#518'>mm/kasan/common.c:518</a>\n kasan_kmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/kasan.h#254'>include/linux/kasan.h:254</a> [inline]\n __kmalloc+0x1a7/0x330 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4033'>mm/slub.c:4033</a>\n __kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#418'>include/linux/slab.h:418</a> [inline]\n kmalloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/slab.h#575'>include/linux/slab.h:575</a> [inline]\n kvmalloc_node+0x88/0x130 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/util.c#612'>mm/util.c:612</a>\n kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/mm.h#833'>include/linux/mm.h:833</a> [inline]\n f2fs_kvmalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3374'>fs/f2fs/f2fs.h:3374</a> [inline]\n f2fs_kvzalloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/f2fs.h#3380'>fs/f2fs/f2fs.h:3380</a> [inline]\n build_sit_info <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#4395'>fs/f2fs/segment.c:4395</a> [inline]\n f2fs_build_segment_manager+0xdba/0x48f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#5258'>fs/f2fs/segment.c:5258</a>\n f2fs_fill_super+0x42d1/0x6c70 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4315'>fs/f2fs/super.c:4315</a>\n mount_bdev+0x28b/0x3a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1442'>fs/super.c:1442</a>\n f2fs_mount+0x34/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/super.c#4595'>fs/f2fs/super.c:4595</a>\n legacy_get_tree+0xed/0x190 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/fs_context.c#593'>fs/fs_context.c:593</a>\n vfs_get_tree+0x89/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/super.c#1572'>fs/super.c:1572</a>\n do_new_mount+0x25a/0xa20 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#2997'>fs/namespace.c:2997</a>\n path_mount+0x572/0xc80 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3327'>fs/namespace.c:3327</a>\n do_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3340'>fs/namespace.c:3340</a> [inline]\n __do_sys_mount <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3548'>fs/namespace.c:3548</a> [inline]\n __se_sys_mount+0x318/0x380 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n __x64_sys_mount+0xbf/0xd0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/namespace.c#3525'>fs/namespace.c:3525</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\n\nThe buggy address belongs to the object at ffff88811471c800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 960 bytes inside of\n 1024-byte region [ffff88811471c800, ffff88811471cc00)\nThe buggy address belongs to the page:\npage:ffffea000451c600 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x114718\nhead:ffffea000451c600 order:3 compound_mapcount:0 compound_pincount:0\nflags: 0x4000000000010200(slab|head)\nraw: 4000000000010200 ffffea0004522200 0000000300000003 ffff888100042f00\nraw: 0000000000000000 0000000000100010 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 3, migratetype Unmovable, gfp_mask 0xd20c0(__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 95, ts 5090814031, free_ts 0\n set_page_owner <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/page_owner.h#35'>include/linux/page_owner.h:35</a> [inline]\n post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2456'>mm/page_alloc.c:2456</a> [inline]\n prep_new_page+0x179/0x180 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#2462'>mm/page_alloc.c:2462</a>\n get_page_from_freelist+0x2235/0x23d0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#4254'>mm/page_alloc.c:4254</a>\n __alloc_pages_nodemask+0x268/0x5f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/page_alloc.c#5370'>mm/page_alloc.c:5370</a>\n alloc_slab_page mm/slub.c:-1 [inline]\n allocate_slab <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1808'>mm/slub.c:1808</a> [inline]\n new_slab+0x84/0x3f0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#1869'>mm/slub.c:1869</a>\n new_slab_objects <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2627'>mm/slub.c:2627</a> [inline]\n ___slab_alloc+0x2a6/0x450 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2791'>mm/slub.c:2791</a>\n __slab_alloc+0x63/0xa0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2831'>mm/slub.c:2831</a>\n slab_alloc_node <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2913'>mm/slub.c:2913</a> [inline]\n slab_alloc <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#2955'>mm/slub.c:2955</a> [inline]\n __kmalloc_track_caller+0x1ef/0x320 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/mm/slub.c#4536'>mm/slub.c:4536</a>\n __kmalloc_reserve <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#144'>net/core/skbuff.c:144</a> [inline]\n __alloc_skb+0xdc/0x520 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/core/skbuff.c#212'>net/core/skbuff.c:212</a>\n alloc_skb <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/include/linux/skbuff.h#1126'>include/linux/skbuff.h:1126</a> [inline]\n netlink_alloc_large_skb <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1178'>net/netlink/af_netlink.c:1178</a> [inline]\n netlink_sendmsg+0x5f6/0xb30 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/netlink/af_netlink.c#1889'>net/netlink/af_netlink.c:1889</a>\n sock_sendmsg_nosec <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#652'>net/socket.c:652</a> [inline]\n __sock_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#664'>net/socket.c:664</a> [inline]\n ____sys_sendmsg+0x5a2/0x8c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2376'>net/socket.c:2376</a>\n ___sys_sendmsg+0x1f0/0x260 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2430'>net/socket.c:2430</a>\n __sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2459'>net/socket.c:2459</a> [inline]\n __do_sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2468'>net/socket.c:2468</a> [inline]\n __se_sys_sendmsg <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466'>net/socket.c:2466</a> [inline]\n __x64_sys_sendmsg+0x1e2/0x2a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/net/socket.c#2466'>net/socket.c:2466</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\npage_owner free stack trace missing\n\nMemory state around the buggy address:\n ffff88811471ca80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff88811471cb00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff88811471cb80: 00 00 00 00 00 00 00 00 fc fc fc fc fc fc fc fc\n                                           ^\n ffff88811471cc00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff88811471cc80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n==================================================================\ngeneral protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN\nKASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\nCPU: 1 PID: 837 Comm: syz.6.85 Tainted: G    B   W         syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/14/2025\nRIP: 0010:update_sit_entry+0x3eb/0xf50 fs/f2fs/segment.c:-1\nCode: 89 45 a8 49 01 c5 41 f6 d7 41 80 e7 07 44 89 f9 41 bf 01 00 00 00 41 d3 e7 4d 89 ee 49 c1 ee 03 48 b8 00 00 00 00 00 fc ff df <41> 0f b6 04 06 84 c0 0f 85 a5 08 00 00 41 0f b6 5d 00 44 89 f8 41\nRSP: 0018:ffffc90001207350 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88811471cbc8 RCX: 0000000000000007\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88811471cbc8\nRBP: ffffc900012073d0 R08: ffff888115c193c0 R09: 0000000000000003\nR10: 00000000ffffffff R11: 0000000000000000 R12: 0000000000004000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000080\nFS:  00007feae1c406c0(0000) GS:ffff8881f7100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007ffd90c62f98 CR3: 0000000127a9b000 CR4: 00000000003506a0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\nCall Trace:\n f2fs_allocate_data_block+0x156b/0x3a10 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/segment.c#3481'>fs/f2fs/segment.c:3481</a>\n __allocate_data_block+0x52a/0x980 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1407'>fs/f2fs/data.c:1407</a>\n f2fs_map_blocks+0xdc8/0x35c0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/data.c#1575'>fs/f2fs/data.c:1575</a>\n expand_inode_data+0x5d7/0x930 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1724'>fs/f2fs/file.c:1724</a>\n f2fs_fallocate+0x42b/0x7e0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/f2fs/file.c#1825'>fs/f2fs/file.c:1825</a>\n vfs_fallocate+0x4b4/0x590 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/open.c#310'>fs/open.c:310</a>\n ioctl_preallocate <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#494'>fs/ioctl.c:494</a> [inline]\n file_ioctl fs/ioctl.c:-1 [inline]\n do_vfs_ioctl+0x12e3/0x1510 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#732'>fs/ioctl.c:732</a>\n __do_sys_ioctl <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#751'>fs/ioctl.c:751</a> [inline]\n __se_sys_ioctl+0x9f/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n __x64_sys_ioctl+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/fs/ioctl.c#739'>fs/ioctl.c:739</a>\n do_syscall_64+0x31/0x40 <a href='https://android.googlesource.com/kernel/common/+/48647f2c6800c3eaa375f44ec58f3da7867eb85b/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xcb\nRIP: 0033:0x7feae1e11be9\nCode: ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 a8 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007feae1c40038 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\nRAX: ffffffffffffffda RBX: 00007feae2049180 RCX: 00007feae1e11be9\nRDX: 00002000000000c0 RSI: 0000000040305828 RDI: 0000000000000005\nRBP: 00007feae1e94e19 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007feae2049218 R14: 00007feae2049180 R15: 00007ffeedd3cd88\nModules linked in:\n---[ end trace b21af47fc54341ff ]---\nRIP: 0010:update_sit_entry+0x3eb/0xf50 fs/f2fs/segment.c:-1\nCode: 89 45 a8 49 01 c5 41 f6 d7 41 80 e7 07 44 89 f9 41 bf 01 00 00 00 41 d3 e7 4d 89 ee 49 c1 ee 03 48 b8 00 00 00 00 00 fc ff df <41> 0f b6 04 06 84 c0 0f 85 a5 08 00 00 41 0f b6 5d 00 44 89 f8 41\nRSP: 0018:ffffc90001207350 EFLAGS: 00010246\nRAX: dffffc0000000000 RBX: ffff88811471cbc8 RCX: 0000000000000007\nRDX: 0000000000000000 RSI: 0000000000000008 RDI: ffff88811471cbc8\nRBP: ffffc900012073d0 R08: ffff888115c193c0 R09: 0000000000000003\nR10: 00000000ffffffff R11: 0000000000000000 R12: 0000000000004000\nR13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000080\nFS:  00007feae1c406c0(0000) GS:ffff8881f7100000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 00007f0f2e064000 CR3: 0000000127a9b000 CR4: 00000000003506a0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n----------------\nCode disassembly (best guess):\n   0:\t89 45 a8             \tmov    %eax,-0x58(%rbp)\n   3:\t49 01 c5             \tadd    %rax,%r13\n   6:\t41 f6 d7             \tnot    %r15b\n   9:\t41 80 e7 07          \tand    $0x7,%r15b\n   d:\t44 89 f9             \tmov    %r15d,%ecx\n  10:\t41 bf 01 00 00 00    \tmov    $0x1,%r15d\n  16:\t41 d3 e7             \tshl    %cl,%r15d\n  19:\t4d 89 ee             \tmov    %r13,%r14\n  1c:\t49 c1 ee 03          \tshr    $0x3,%r14\n  20:\t48 b8 00 00 00 00 00 \tmovabs $0xdffffc0000000000,%rax\n  27:\tfc ff df\n* 2a:\t41 0f b6 04 06       \tmovzbl (%r14,%rax,1),%eax <-- trapping instruction\n  2f:\t84 c0                \ttest   %al,%al\n  31:\t0f 85 a5 08 00 00    \tjne    0x8dc\n  37:\t41 0f b6 5d 00       \tmovzbl 0x0(%r13),%ebx\n  3c:\t44 89 f8             \tmov    %r15d,%eax\n  3f:\t41                   \trex.B\n\n-- fs/f2fs/segment.c:2257 -> static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type,\n\t\t\t\t\tunsigned int segno, int modified)\n{\n\tstruct seg_entry *se = get_seg_entry(sbi, segno);\n\n\tse->type = type;\n---\n-- fs/f2fs/segment.c:2663 -> \t__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);\n---\n-- lib/dump_stack.c:77 -> static void __dump_stack(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\tshow_stack(NULL, NULL, log_lvl);\n---"
    },
    "openai_llm": {
      "raw_output": "{\n  \"overview\": {\n    \"exploitability\": \"HIGH\",\n    \"rationale\": \"curseg->segno is used to index SIT entries without bounds checks, causing an out-of-bounds access/write in a kmalloc-1k object when handed a crafted F2FS image; evidence: __set_sit_entry_type(sbi, seg_type, curseg->segno, ...) and se->type assignment.\",\n    \"primitive_capabilities\": \"Out-of-bounds 4-byte write (and read via KASAN shadow) into adjacent kmalloc-1k memory when setting se->type. Under KASAN it faults; without it this is a kernel heap overwrite adjacent to the SIT entry array.\"\n  },\n  \"preconditions\": [\n    {\n      \"summary\": \"Issue FS_IOC_FALLOCATE on a regular file on a mounted, attacker-controlled F2FS image such that allocation forces a new section/segment selection and curseg->segno indexes beyond the allocated SIT entries.\",\n      \"concrete_constraints\": [\n        \"ioctl.cmd => FS_IOC_FALLOCATE\",\n        \"fd.file_type => regular file on F2FS\",\n        \"fallocate.len => > 0\",\n        \"allocation_requires_new_section => true (ambiguous: depends on current free space/state)\",\n        \"curseg->segno => >= number_of_SIT_entries_allocated (e.g., >= MAIN_SEGS(sbi))\",\n        \"mount_succeeds => true (F2FS superblock/SIT metadata accepted despite inconsistency)\"\n      ],\n      \"why_reaches_crash\": \"reset_curseg calls __set_sit_entry_type(..., curseg->segno, ...); with segno out of range, get_seg_entry returns a pointer into/after a small kmalloc-1k object, and writing se->type triggers KASAN slab OOB.\"\n    }\n  ],\n  \"path_constraints\": {\n    \"input\": [\n      {\n        \"file\": \"fs/ioctl.c\",\n        \"line\": 494,\n        \"code\": \"ioctl_preallocate\",\n        \"condition\": \"Userspace issues FS_IOC_FALLOCATE on an open fd\",\n        \"why_it_blocks\": \"Only ioctl FS_IOC_FALLOCATE reaches vfs_fallocate/f2fs_fallocate.\",\n        \"note\": \"caller's guard not present in snippets\"\n      },\n      {\n        \"file\": \"fs/open.c\",\n        \"line\": 310,\n        \"code\": \"vfs_fallocate+0x4b4/0x590\",\n        \"condition\": \"File must support fallocate and length > 0\",\n        \"why_it_blocks\": \"Invalid mode/len or unsupported op would return early.\",\n        \"note\": \"exact if/return code not present in snippets\"\n      }\n    ],\n    \"kernel_state\": [\n      {\n        \"file\": \"fs/f2fs/segment.c\",\n        \"line\": 2663,\n        \"code\": \"__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);\",\n        \"condition\": \"curseg->segno is used without bounds check\",\n        \"why_it_blocks\": \"If curseg->segno were validated to be < SIT_entries, the OOB could not occur.\"\n      },\n      {\n        \"file\": \"fs/f2fs/segment.c\",\n        \"line\": 2257,\n        \"code\": \"struct seg_entry *se = get_seg_entry(sbi, segno);\",\n        \"condition\": \"get_seg_entry expects 0 <= segno < allocated_SIT_entries\",\n        \"why_it_blocks\": \"Kernel must have inconsistent state (segno out of range) for this to return a pointer into/after a small slab.\",\n        \"note\": \"full get_seg_entry implementation not present in snippets\"\n      },\n      {\n        \"file\": \"fs/f2fs/segment.c\",\n        \"line\": 3039,\n        \"code\": \"__allocate_new_segment+0x13d/0x810\",\n        \"condition\": \"Allocator picks a new segment number (curseg->segno) from on-disk state\",\n        \"why_it_blocks\": \"If allocator never selects an out-of-range segno, crash is unreachable.\",\n        \"note\": \"exact selection/guard conditions not present in snippets\"\n      },\n      {\n        \"file\": \"fs/f2fs/segment.c\",\n        \"line\": 3054,\n        \"code\": \"f2fs_allocate_new_section+0x1d5/0x280\",\n        \"condition\": \"Path taken only when a new section must be allocated\",\n        \"why_it_blocks\": \"If no new section is needed, reset_curseg is not reached.\",\n        \"note\": \"exact if/return code not present in snippets\"\n      },\n      {\n        \"file\": \"fs/f2fs/segment.c\",\n        \"line\": 5258,\n        \"code\": \"f2fs_build_segment_manager+0xdba/0x48f0\",\n        \"condition\": \"SIT entry array allocated based on superblock parameters\",\n        \"why_it_blocks\": \"If allocation size matched the maximum segno later used, OOB cannot occur; mismatch (from crafted FS metadata) is required.\",\n        \"note\": \"allocation line in build_sit_info not present in snippets\"\n      }\n    ]\n  },\n  \"evidence\": [\n    {\n      \"file\": \"fs/f2fs/segment.c\",\n      \"line\": 2663,\n      \"code\": \"__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);\",\n      \"note\": \"segno comes directly from curseg and is not checked here\"\n    },\n    {\n      \"file\": \"fs/f2fs/segment.c\",\n      \"line\": 2257,\n      \"code\": \"static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type, unsigned int segno, int modified)\",\n      \"note\": \"takes segno and uses it to fetch a seg_entry\"\n    },\n    {\n      \"file\": \"fs/f2fs/segment.c\",\n      \"line\": 2257,\n      \"code\": \"struct seg_entry *se = get_seg_entry(sbi, segno);\",\n      \"note\": \"out-of-range segno yields pointer into wrong slab; KASAN OOB at se->type\"\n    },\n    {\n      \"file\": \"fs/f2fs/segment.c\",\n      \"line\": 4395,\n      \"code\": \"build_sit_info\",\n      \"note\": \"call trace shows SIT memory allocated here; mismatch with later segno leads to OOB\"\n    }\n  ]\n}",
      "parsed": {
        "overview": {
          "exploitability": "HIGH",
          "rationale": "curseg->segno is used to index SIT entries without bounds checks, causing an out-of-bounds access/write in a kmalloc-1k object when handed a crafted F2FS image; evidence: __set_sit_entry_type(sbi, seg_type, curseg->segno, ...) and se->type assignment.",
          "primitive_capabilities": "Out-of-bounds 4-byte write (and read via KASAN shadow) into adjacent kmalloc-1k memory when setting se->type. Under KASAN it faults; without it this is a kernel heap overwrite adjacent to the SIT entry array."
        },
        "preconditions": [
          {
            "summary": "Issue FS_IOC_FALLOCATE on a regular file on a mounted, attacker-controlled F2FS image such that allocation forces a new section/segment selection and curseg->segno indexes beyond the allocated SIT entries.",
            "concrete_constraints": [
              "ioctl.cmd => FS_IOC_FALLOCATE",
              "fd.file_type => regular file on F2FS",
              "fallocate.len => > 0",
              "allocation_requires_new_section => true (ambiguous: depends on current free space/state)",
              "curseg->segno => >= number_of_SIT_entries_allocated (e.g., >= MAIN_SEGS(sbi))",
              "mount_succeeds => true (F2FS superblock/SIT metadata accepted despite inconsistency)"
            ],
            "why_reaches_crash": "reset_curseg calls __set_sit_entry_type(..., curseg->segno, ...); with segno out of range, get_seg_entry returns a pointer into/after a small kmalloc-1k object, and writing se->type triggers KASAN slab OOB."
          }
        ],
        "path_constraints": {
          "input": [
            {
              "file": "fs/ioctl.c",
              "line": 494,
              "code": "ioctl_preallocate",
              "condition": "Userspace issues FS_IOC_FALLOCATE on an open fd",
              "why_it_blocks": "Only ioctl FS_IOC_FALLOCATE reaches vfs_fallocate/f2fs_fallocate.",
              "note": "caller's guard not present in snippets"
            },
            {
              "file": "fs/open.c",
              "line": 310,
              "code": "vfs_fallocate+0x4b4/0x590",
              "condition": "File must support fallocate and length > 0",
              "why_it_blocks": "Invalid mode/len or unsupported op would return early.",
              "note": "exact if/return code not present in snippets"
            }
          ],
          "kernel_state": [
            {
              "file": "fs/f2fs/segment.c",
              "line": 2663,
              "code": "__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);",
              "condition": "curseg->segno is used without bounds check",
              "why_it_blocks": "If curseg->segno were validated to be < SIT_entries, the OOB could not occur."
            },
            {
              "file": "fs/f2fs/segment.c",
              "line": 2257,
              "code": "struct seg_entry *se = get_seg_entry(sbi, segno);",
              "condition": "get_seg_entry expects 0 <= segno < allocated_SIT_entries",
              "why_it_blocks": "Kernel must have inconsistent state (segno out of range) for this to return a pointer into/after a small slab.",
              "note": "full get_seg_entry implementation not present in snippets"
            },
            {
              "file": "fs/f2fs/segment.c",
              "line": 3039,
              "code": "__allocate_new_segment+0x13d/0x810",
              "condition": "Allocator picks a new segment number (curseg->segno) from on-disk state",
              "why_it_blocks": "If allocator never selects an out-of-range segno, crash is unreachable.",
              "note": "exact selection/guard conditions not present in snippets"
            },
            {
              "file": "fs/f2fs/segment.c",
              "line": 3054,
              "code": "f2fs_allocate_new_section+0x1d5/0x280",
              "condition": "Path taken only when a new section must be allocated",
              "why_it_blocks": "If no new section is needed, reset_curseg is not reached.",
              "note": "exact if/return code not present in snippets"
            },
            {
              "file": "fs/f2fs/segment.c",
              "line": 5258,
              "code": "f2fs_build_segment_manager+0xdba/0x48f0",
              "condition": "SIT entry array allocated based on superblock parameters",
              "why_it_blocks": "If allocation size matched the maximum segno later used, OOB cannot occur; mismatch (from crafted FS metadata) is required.",
              "note": "allocation line in build_sit_info not present in snippets"
            }
          ]
        },
        "evidence": [
          {
            "file": "fs/f2fs/segment.c",
            "line": 2663,
            "code": "__set_sit_entry_type(sbi, seg_type, curseg->segno, modified);",
            "note": "segno comes directly from curseg and is not checked here"
          },
          {
            "file": "fs/f2fs/segment.c",
            "line": 2257,
            "code": "static void __set_sit_entry_type(struct f2fs_sb_info *sbi, int type, unsigned int segno, int modified)",
            "note": "takes segno and uses it to fetch a seg_entry"
          },
          {
            "file": "fs/f2fs/segment.c",
            "line": 2257,
            "code": "struct seg_entry *se = get_seg_entry(sbi, segno);",
            "note": "out-of-range segno yields pointer into wrong slab; KASAN OOB at se->type"
          },
          {
            "file": "fs/f2fs/segment.c",
            "line": 4395,
            "code": "build_sit_info",
            "note": "call trace shows SIT memory allocated here; mismatch with later segno leads to OOB"
          }
        ]
      }
    },
    "summary": null
  }
}