{
  "parsed": {
    "kind": "KASAN: use-after-free in ext4_rename_dir_prepare+0x42e/0x4a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704'>fs/ext4/namei.c:3704</a>",
    "access": {
      "op": "read",
      "size": 4,
      "addr": "ffff888119c14000"
    },
    "object_info": {
      "obj_addr": "ffff888119c14000",
      "cache": "mm_struct",
      "obj_size": 1104,
      "offset": 0,
      "region": {
        "start": "ffff888119c14000",
        "end": "ffff888119c14450"
      }
    },
    "allocated_by": [
      "Allocated by task 345:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46'>mm/kasan/common.c:46</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428'>mm/kasan/common.c:428</a> [inline]\n __kasan_slab_alloc+0xb2/0xe0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461'>mm/kasan/common.c:461</a>\n kasan_slab_alloc <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259'>include/linux/kasan.h:259</a> [inline]\n slab_post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583'>include/../mm/slab.h:583</a> [inline]\n slab_alloc_node <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956'>mm/slub.c:2956</a> [inline]\n slab_alloc <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964'>mm/slub.c:2964</a> [inline]\n kmem_cache_alloc+0x16c/0x300 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969'>mm/slub.c:2969</a>\n dup_mm+0x29/0x320 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403'>kernel/fork.c:1403</a>\n copy_mm+0x108/0x1b0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468'>kernel/fork.c:1468</a>\n copy_process+0x133a/0x33a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152'>kernel/fork.c:2152</a>\n kernel_clone+0x22d/0x900 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524'>kernel/fork.c:2524</a>\n __do_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643'>kernel/fork.c:2643</a> [inline]\n __se_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a> [inline]\n __x64_sys_clone+0x271/0x2e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6"
    ],
    "freed_by": [
      "Freed by task 345:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track+0x4c/0x80 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46'>mm/kasan/common.c:46</a>\n kasan_set_free_info+0x23/0x40 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357'>mm/kasan/generic.c:357</a>\n ____kasan_slab_free+0x121/0x160 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360'>mm/kasan/common.c:360</a>\n __kasan_slab_free+0x11/0x20 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368'>mm/kasan/common.c:368</a>\n kasan_slab_free <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235'>include/linux/kasan.h:235</a> [inline]\n slab_free_hook <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604'>mm/slub.c:1604</a> [inline]\n slab_free_freelist_hook+0xcc/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630'>mm/slub.c:1630</a>\n slab_free <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212'>mm/slub.c:3212</a> [inline]\n kmem_cache_free+0xa9/0x1f0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228'>mm/slub.c:3228</a>\n __mmdrop+0x295/0x390 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722'>kernel/fork.c:722</a>\n mmdrop <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49'>include/linux/sched/mm.h:49</a> [inline]\n finish_task_switch+0x1e4/0x580 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892'>kernel/sched/core.c:3892</a>\n context_switch <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038'>kernel/sched/core.c:4038</a> [inline]\n __schedule+0x86e/0xc00 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796'>kernel/sched/core.c:4796</a>\n schedule+0x14b/0x1e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874'>kernel/sched/core.c:4874</a>\n pipe_read+0x9c8/0x1070 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378'>fs/pipe.c:378</a>\n call_read_iter <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963'>include/linux/fs.h:1963</a> [inline]\n new_sync_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415'>fs/read_write.c:415</a> [inline]\n vfs_read+0x9e2/0xbf0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496'>fs/read_write.c:496</a>\n ksys_read+0x198/0x2c0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634'>fs/read_write.c:634</a>\n __do_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644'>fs/read_write.c:644</a> [inline]\n __se_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a> [inline]\n __x64_sys_read+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6"
    ],
    "link_frames": [
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704",
        "file": "fs/ext4/namei.c",
        "line": 3704
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#77",
        "file": "lib/dump_stack.c",
        "line": 77
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#118",
        "file": "lib/dump_stack.c",
        "line": 118
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#233",
        "file": "mm/kasan/report.c",
        "line": 233
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#419",
        "file": "mm/kasan/report.c",
        "line": 419
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#436",
        "file": "mm/kasan/report.c",
        "line": 436
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report_generic.c#308",
        "file": "mm/kasan/report_generic.c",
        "line": 308
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704",
        "file": "fs/ext4/namei.c",
        "line": 3704
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4212",
        "file": "fs/ext4/namei.c",
        "line": 4212
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4296",
        "file": "fs/ext4/namei.c",
        "line": 4296
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4389",
        "file": "fs/namei.c",
        "line": 4389
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4536",
        "file": "fs/namei.c",
        "line": 4536
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4571",
        "file": "fs/namei.c",
        "line": 4571
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568",
        "file": "fs/namei.c",
        "line": 4568
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568",
        "file": "fs/namei.c",
        "line": 4568
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38",
        "file": "mm/kasan/common.c",
        "line": 38
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46",
        "file": "mm/kasan/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428",
        "file": "mm/kasan/common.c",
        "line": 428
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461",
        "file": "mm/kasan/common.c",
        "line": 461
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259",
        "file": "include/linux/kasan.h",
        "line": 259
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583",
        "file": "include/../mm/slab.h",
        "line": 583
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956",
        "file": "mm/slub.c",
        "line": 2956
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964",
        "file": "mm/slub.c",
        "line": 2964
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969",
        "file": "mm/slub.c",
        "line": 2969
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403",
        "file": "kernel/fork.c",
        "line": 1403
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468",
        "file": "kernel/fork.c",
        "line": 1468
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152",
        "file": "kernel/fork.c",
        "line": 2152
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524",
        "file": "kernel/fork.c",
        "line": 2524
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643",
        "file": "kernel/fork.c",
        "line": 2643
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627",
        "file": "kernel/fork.c",
        "line": 2627
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627",
        "file": "kernel/fork.c",
        "line": 2627
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38",
        "file": "mm/kasan/common.c",
        "line": 38
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46",
        "file": "mm/kasan/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357",
        "file": "mm/kasan/generic.c",
        "line": 357
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360",
        "file": "mm/kasan/common.c",
        "line": 360
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368",
        "file": "mm/kasan/common.c",
        "line": 368
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235",
        "file": "include/linux/kasan.h",
        "line": 235
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604",
        "file": "mm/slub.c",
        "line": 1604
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630",
        "file": "mm/slub.c",
        "line": 1630
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212",
        "file": "mm/slub.c",
        "line": 3212
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228",
        "file": "mm/slub.c",
        "line": 3228
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722",
        "file": "kernel/fork.c",
        "line": 722
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49",
        "file": "include/linux/sched/mm.h",
        "line": 49
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892",
        "file": "kernel/sched/core.c",
        "line": 3892
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038",
        "file": "kernel/sched/core.c",
        "line": 4038
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796",
        "file": "kernel/sched/core.c",
        "line": 4796
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874",
        "file": "kernel/sched/core.c",
        "line": 4874
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378",
        "file": "fs/pipe.c",
        "line": 378
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963",
        "file": "include/linux/fs.h",
        "line": 1963
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415",
        "file": "fs/read_write.c",
        "line": 415
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496",
        "file": "fs/read_write.c",
        "line": 496
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634",
        "file": "fs/read_write.c",
        "line": 634
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644",
        "file": "fs/read_write.c",
        "line": 644
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642",
        "file": "fs/read_write.c",
        "line": 642
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642",
        "file": "fs/read_write.c",
        "line": 642
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#35",
        "file": "include/linux/page_owner.h",
        "line": 35
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2386",
        "file": "mm/page_alloc.c",
        "line": 2386
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2392",
        "file": "mm/page_alloc.c",
        "line": 2392
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#4073",
        "file": "mm/page_alloc.c",
        "line": 4073
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#5160",
        "file": "mm/page_alloc.c",
        "line": 5160
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1815",
        "file": "mm/slub.c",
        "line": 1815
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1817",
        "file": "mm/slub.c",
        "line": 1817
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1878",
        "file": "mm/slub.c",
        "line": 1878
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2636",
        "file": "mm/slub.c",
        "line": 2636
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2800",
        "file": "mm/slub.c",
        "line": 2800
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2840",
        "file": "mm/slub.c",
        "line": 2840
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2922",
        "file": "mm/slub.c",
        "line": 2922
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964",
        "file": "mm/slub.c",
        "line": 2964
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969",
        "file": "mm/slub.c",
        "line": 2969
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403",
        "file": "kernel/fork.c",
        "line": 1403
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468",
        "file": "kernel/fork.c",
        "line": 1468
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152",
        "file": "kernel/fork.c",
        "line": 2152
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524",
        "file": "kernel/fork.c",
        "line": 2524
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643",
        "file": "kernel/fork.c",
        "line": 2643
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627",
        "file": "kernel/fork.c",
        "line": 2627
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627",
        "file": "kernel/fork.c",
        "line": 2627
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#28",
        "file": "include/linux/page_owner.h",
        "line": 28
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1332",
        "file": "mm/page_alloc.c",
        "line": 1332
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1612",
        "file": "mm/page_alloc.c",
        "line": 1612
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#717",
        "file": "mm/page_alloc.c",
        "line": 717
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#959",
        "file": "include/linux/mm.h",
        "line": 959
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#115",
        "file": "mm/swap.c",
        "line": 115
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#131",
        "file": "mm/swap.c",
        "line": 131
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#1255",
        "file": "include/linux/mm.h",
        "line": 1255
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/skbuff.h#3065",
        "file": "include/linux/skbuff.h",
        "line": 3065
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#619",
        "file": "net/core/skbuff.c",
        "line": 619
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#680",
        "file": "net/core/skbuff.c",
        "line": 680
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#694",
        "file": "net/core/skbuff.c",
        "line": 694
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/net/sock.h#2599",
        "file": "include/net/sock.h",
        "line": 2599
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/tcp.c#2317",
        "file": "net/ipv4/tcp.c",
        "line": 2317
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/af_inet.c#852",
        "file": "net/ipv4/af_inet.c",
        "line": 852
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#886",
        "file": "net/socket.c",
        "line": 886
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#904",
        "file": "net/socket.c",
        "line": 904
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#977",
        "file": "net/socket.c",
        "line": 977
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963",
        "file": "include/linux/fs.h",
        "line": 1963
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415",
        "file": "fs/read_write.c",
        "line": 415
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496",
        "file": "fs/read_write.c",
        "line": 496
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634",
        "file": "fs/read_write.c",
        "line": 634
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644",
        "file": "fs/read_write.c",
        "line": 644
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642",
        "file": "fs/read_write.c",
        "line": 642
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642",
        "file": "fs/read_write.c",
        "line": 642
      },
      {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46
      }
    ],
    "frames": [],
    "raw": "ext4 filesystem being mounted at /root/syzkaller.uYsrAf/1/file0 supports timestamps until 2038 (0x7fffffff)\n==================================================================\nBUG: KASAN: use-after-free in ext4_rename_dir_prepare+0x42e/0x4a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704'>fs/ext4/namei.c:3704</a>\nRead of size 4 at addr ffff888119c14000 by task syz-executor122/376\n\nCPU: 1 PID: 376 Comm: syz-executor122 Not tainted 5.10.161-syzkaller-00019-g416c4356f372 #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 04/14/2023\nCall Trace:\n __dump_stack <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#77'>lib/dump_stack.c:77</a> [inline]\n dump_stack_lvl+0x1e2/0x24b <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#118'>lib/dump_stack.c:118</a>\n print_address_description+0x81/0x3c0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#233'>mm/kasan/report.c:233</a>\n __kasan_report <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#419'>mm/kasan/report.c:419</a> [inline]\n kasan_report+0x1a4/0x1f0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#436'>mm/kasan/report.c:436</a>\n __asan_report_load4_noabort+0x14/0x20 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report_generic.c#308'>mm/kasan/report_generic.c:308</a>\n ext4_rename_dir_prepare+0x42e/0x4a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704'>fs/ext4/namei.c:3704</a>\n ext4_cross_rename <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4212'>fs/ext4/namei.c:4212</a> [inline]\n ext4_rename2+0x1f37/0x45a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4296'>fs/ext4/namei.c:4296</a>\n vfs_rename+0x95e/0xde0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4389'>fs/namei.c:4389</a>\n do_renameat2+0x83e/0x1190 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4536'>fs/namei.c:4536</a>\n __do_sys_renameat2 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4571'>fs/namei.c:4571</a> [inline]\n __se_sys_renameat2 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568'>fs/namei.c:4568</a> [inline]\n __x64_sys_renameat2+0xbf/0xd0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568'>fs/namei.c:4568</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\nRIP: 0033:0x7f95898f4a29\nCode: 28 00 00 00 75 05 48 83 c4 28 c3 e8 11 15 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 c0 ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007ffcca6970d8 EFLAGS: 00000246 ORIG_RAX: 000000000000013c\nRAX: ffffffffffffffda RBX: 0000000000005426 RCX: 00007f95898f4a29\nRDX: 0000000000000004 RSI: 0000000020000080 RDI: 0000000000000005\nRBP: 0000000000000000 R08: 0000000000000002 R09: 00007ffcca697100\nR10: 00000000200000c0 R11: 0000000000000246 R12: 00007ffcca6970fc\nR13: 00007ffcca697130 R14: 00007ffcca697110 R15: 0000000000000001\n\nAllocated by task 345:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46'>mm/kasan/common.c:46</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428'>mm/kasan/common.c:428</a> [inline]\n __kasan_slab_alloc+0xb2/0xe0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461'>mm/kasan/common.c:461</a>\n kasan_slab_alloc <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259'>include/linux/kasan.h:259</a> [inline]\n slab_post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583'>include/../mm/slab.h:583</a> [inline]\n slab_alloc_node <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956'>mm/slub.c:2956</a> [inline]\n slab_alloc <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964'>mm/slub.c:2964</a> [inline]\n kmem_cache_alloc+0x16c/0x300 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969'>mm/slub.c:2969</a>\n dup_mm+0x29/0x320 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403'>kernel/fork.c:1403</a>\n copy_mm+0x108/0x1b0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468'>kernel/fork.c:1468</a>\n copy_process+0x133a/0x33a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152'>kernel/fork.c:2152</a>\n kernel_clone+0x22d/0x900 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524'>kernel/fork.c:2524</a>\n __do_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643'>kernel/fork.c:2643</a> [inline]\n __se_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a> [inline]\n __x64_sys_clone+0x271/0x2e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nFreed by task 345:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track+0x4c/0x80 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46'>mm/kasan/common.c:46</a>\n kasan_set_free_info+0x23/0x40 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357'>mm/kasan/generic.c:357</a>\n ____kasan_slab_free+0x121/0x160 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360'>mm/kasan/common.c:360</a>\n __kasan_slab_free+0x11/0x20 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368'>mm/kasan/common.c:368</a>\n kasan_slab_free <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235'>include/linux/kasan.h:235</a> [inline]\n slab_free_hook <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604'>mm/slub.c:1604</a> [inline]\n slab_free_freelist_hook+0xcc/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630'>mm/slub.c:1630</a>\n slab_free <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212'>mm/slub.c:3212</a> [inline]\n kmem_cache_free+0xa9/0x1f0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228'>mm/slub.c:3228</a>\n __mmdrop+0x295/0x390 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722'>kernel/fork.c:722</a>\n mmdrop <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49'>include/linux/sched/mm.h:49</a> [inline]\n finish_task_switch+0x1e4/0x580 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892'>kernel/sched/core.c:3892</a>\n context_switch <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038'>kernel/sched/core.c:4038</a> [inline]\n __schedule+0x86e/0xc00 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796'>kernel/sched/core.c:4796</a>\n schedule+0x14b/0x1e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874'>kernel/sched/core.c:4874</a>\n pipe_read+0x9c8/0x1070 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378'>fs/pipe.c:378</a>\n call_read_iter <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963'>include/linux/fs.h:1963</a> [inline]\n new_sync_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415'>fs/read_write.c:415</a> [inline]\n vfs_read+0x9e2/0xbf0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496'>fs/read_write.c:496</a>\n ksys_read+0x198/0x2c0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634'>fs/read_write.c:634</a>\n __do_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644'>fs/read_write.c:644</a> [inline]\n __se_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a> [inline]\n __x64_sys_read+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nThe buggy address belongs to the object at ffff888119c14000\n which belongs to the cache mm_struct of size 1104\nThe buggy address is located 0 bytes inside of\n 1104-byte region [ffff888119c14000, ffff888119c14450)\nThe buggy address belongs to the page:\npage:ffffea0004670500 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x119c14\nhead:ffffea0004670500 order:2 compound_mapcount:0 compound_pincount:0\nflags: 0x8000000000010200(slab|head)\nraw: 8000000000010200 dead000000000100 dead000000000122 ffff888100066300\nraw: 0000000000000000 00000000000c000c 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\npage_owner tracks the page as allocated\npage last allocated via order 2, migratetype Unmovable, gfp_mask 0xd20c0(__GFP_IO|__GFP_FS|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 345, ts 16125248987, free_ts 16122080680\n set_page_owner <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#35'>include/linux/page_owner.h:35</a> [inline]\n post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2386'>mm/page_alloc.c:2386</a> [inline]\n prep_new_page <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2392'>mm/page_alloc.c:2392</a> [inline]\n get_page_from_freelist+0x755/0x810 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#4073'>mm/page_alloc.c:4073</a>\n __alloc_pages_nodemask+0x3b6/0x890 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#5160'>mm/page_alloc.c:5160</a>\n alloc_slab_page <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1815'>mm/slub.c:1815</a> [inline]\n allocate_slab+0x78/0x540 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1817'>mm/slub.c:1817</a>\n new_slab <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1878'>mm/slub.c:1878</a> [inline]\n new_slab_objects <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2636'>mm/slub.c:2636</a> [inline]\n ___slab_alloc+0x131/0x2e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2800'>mm/slub.c:2800</a>\n __slab_alloc+0x63/0xa0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2840'>mm/slub.c:2840</a>\n slab_alloc_node <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2922'>mm/slub.c:2922</a> [inline]\n slab_alloc <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964'>mm/slub.c:2964</a> [inline]\n kmem_cache_alloc+0x1ef/0x300 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969'>mm/slub.c:2969</a>\n dup_mm+0x29/0x320 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403'>kernel/fork.c:1403</a>\n copy_mm+0x108/0x1b0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468'>kernel/fork.c:1468</a>\n copy_process+0x133a/0x33a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152'>kernel/fork.c:2152</a>\n kernel_clone+0x22d/0x900 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524'>kernel/fork.c:2524</a>\n __do_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643'>kernel/fork.c:2643</a> [inline]\n __se_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a> [inline]\n __x64_sys_clone+0x271/0x2e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\npage last free stack trace:\n reset_page_owner <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#28'>include/linux/page_owner.h:28</a> [inline]\n free_pages_prepare <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1332'>mm/page_alloc.c:1332</a> [inline]\n __free_pages_ok+0x7f8/0x830 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1612'>mm/page_alloc.c:1612</a>\n free_compound_page+0x72/0x90 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#717'>mm/page_alloc.c:717</a>\n destroy_compound_page <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#959'>include/linux/mm.h:959</a> [inline]\n __put_compound_page+0x72/0xb0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#115'>mm/swap.c:115</a>\n __put_page+0xc0/0xd0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#131'>mm/swap.c:131</a>\n put_page <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#1255'>include/linux/mm.h:1255</a> [inline]\n __skb_frag_unref <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/skbuff.h#3065'>include/linux/skbuff.h:3065</a> [inline]\n skb_release_data+0x22d/0x630 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#619'>net/core/skbuff.c:619</a>\n skb_release_all <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#680'>net/core/skbuff.c:680</a> [inline]\n __kfree_skb+0x59/0x1c0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#694'>net/core/skbuff.c:694</a>\n sk_eat_skb <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/net/sock.h#2599'>include/net/sock.h:2599</a> [inline]\n tcp_recvmsg+0x1637/0x35a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/tcp.c#2317'>net/ipv4/tcp.c:2317</a>\n inet_recvmsg+0x157/0x500 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/af_inet.c#852'>net/ipv4/af_inet.c:852</a>\n sock_recvmsg_nosec <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#886'>net/socket.c:886</a> [inline]\n sock_recvmsg <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#904'>net/socket.c:904</a> [inline]\n sock_read_iter+0x3a7/0x4d0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#977'>net/socket.c:977</a>\n call_read_iter <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963'>include/linux/fs.h:1963</a> [inline]\n new_sync_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415'>fs/read_write.c:415</a> [inline]\n vfs_read+0x9e2/0xbf0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496'>fs/read_write.c:496</a>\n ksys_read+0x198/0x2c0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634'>fs/read_write.c:634</a>\n __do_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644'>fs/read_write.c:644</a> [inline]\n __se_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a> [inline]\n __x64_sys_read+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6\n\nMemory state around the buggy address:\n ffff888119c13f00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n ffff888119c13f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n>ffff888119c14000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                   ^\n ffff888119c14080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888119c14100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n"
  },
  "snippets": {
    "urls": {
      "https://android.googlesource.com/kernel/common/": {
        "error": "URL not in expected +/commit/path format"
      }
    },
    "links": {
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704#3704": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704",
        "file": "fs/ext4/namei.c",
        "line": 3704,
        "function_snippet": "static int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)\n{\n\tint retval;\n\n\tent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,\n\t\t\t\t\t      &retval, &ent->parent_de,\n\t\t\t\t\t      &ent->dir_inlined);\n\tif (!ent->dir_bh)\n\t\treturn retval;\n\tif (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#77#77": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#77",
        "file": "lib/dump_stack.c",
        "line": 77,
        "function_snippet": "static void __dump_stack(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\tshow_stack(NULL, NULL, log_lvl);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#118#118": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#118",
        "file": "lib/dump_stack.c",
        "line": 118,
        "function_snippet": "asmlinkage __visible void dump_stack_lvl(const char *log_lvl)\n{\n\tunsigned long flags;\n\tint was_locked;\n\tint old;\n\tint cpu;\n\n\t/*\n\t * Permit this cpu to perform nested stack dumps while serialising\n\t * against other CPUs\n\t */\nretry:\n\tlocal_irq_save(flags);\n\tcpu = smp_processor_id();\n\told = atomic_cmpxchg(&dump_lock, -1, cpu);\n\tif (old == -1) {\n\t\twas_locked = 0;\n\t} else if (old == cpu) {\n\t\twas_locked = 1;\n\t} else {\n\t\tlocal_irq_restore(flags);\n\t\t/*\n\t\t * Wait for the lock to release before jumping to\n\t\t * atomic_cmpxchg() in order to mitigate the thundering herd\n\t\t * problem.\n\t\t */\n\t\tdo { cpu_relax(); } while (atomic_read(&dump_lock) != -1);\n\t\tgoto retry;\n\t}\n\n\t__dump_stack(log_lvl);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#233#233": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#233",
        "file": "mm/kasan/report.c",
        "line": 233,
        "function_snippet": "static void print_address_description(void *addr, u8 tag)\n{\n\tstruct page *page = kasan_addr_to_page(addr);\n\n\tdump_stack_lvl(KERN_ERR);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#419#419": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#419",
        "file": "mm/kasan/report.c",
        "line": 419,
        "function_snippet": "static void __kasan_report(unsigned long addr, size_t size, bool is_write,\n\t\t\t\tunsigned long ip)\n{\n\tstruct kasan_access_info info;\n\tvoid *tagged_addr;\n\tvoid *untagged_addr;\n\tunsigned long flags;\n\n#if IS_ENABLED(CONFIG_KUNIT)\n\tif (current->kunit_test)\n\t\tkasan_update_kunit_status(current->kunit_test);\n#endif /* IS_ENABLED(CONFIG_KUNIT) */\n\n\tdisable_trace_on_warning();\n\n\ttagged_addr = (void *)addr;\n\tuntagged_addr = kasan_reset_tag(tagged_addr);\n\n\tinfo.access_addr = tagged_addr;\n\tif (addr_has_metadata(untagged_addr))\n\t\tinfo.first_bad_addr =\n\t\t\tkasan_find_first_bad_addr(tagged_addr, size);\n\telse\n\t\tinfo.first_bad_addr = untagged_addr;\n\tinfo.access_size = size;\n\tinfo.is_write = is_write;\n\tinfo.ip = ip;\n\n\tstart_report(&flags);\n\n\tprint_error_description(&info);\n\tif (addr_has_metadata(untagged_addr))\n\t\tkasan_print_tags(get_tag(tagged_addr), info.first_bad_addr);\n\tpr_err(\"\\n\");\n\n\tif (addr_has_metadata(untagged_addr)) {\n\t\tprint_address_description(untagged_addr, get_tag(tagged_addr));"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#436#436": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#436",
        "file": "mm/kasan/report.c",
        "line": 436,
        "function_snippet": "bool kasan_report(unsigned long addr, size_t size, bool is_write,\n\t\t\tunsigned long ip)\n{\n\tunsigned long flags = user_access_save();\n\tbool ret = false;\n\n\tif (likely(report_enabled())) {\n\t\t__kasan_report(addr, size, is_write, ip);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report_generic.c#308#308": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report_generic.c#308",
        "file": "mm/kasan/report_generic.c",
        "line": 308,
        "function_snippet": "EXPORT_SYMBOL(__asan_report_load##size##_noabort)\n\n#define DEFINE_ASAN_REPORT_STORE(size)                     \\\nvoid __asan_report_store##size##_noabort(unsigned long addr) \\\n{                                                          \\\n\tkasan_report(addr, size, true, _RET_IP_);\t   \\\n}                                                          \\\nEXPORT_SYMBOL(__asan_report_store##size##_noabort)\n\nDEFINE_ASAN_REPORT_LOAD(1);\nDEFINE_ASAN_REPORT_LOAD(2);\nDEFINE_ASAN_REPORT_LOAD(4);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4212#4212": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4212",
        "file": "fs/ext4/namei.c",
        "line": 4212,
        "function_snippet": "static int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t     struct inode *new_dir, struct dentry *new_dentry)\n{\n\thandle_t *handle = NULL;\n\tstruct ext4_renament old = {\n\t\t.dir = old_dir,\n\t\t.dentry = old_dentry,\n\t\t.inode = d_inode(old_dentry),\n\t};\n\tstruct ext4_renament new = {\n\t\t.dir = new_dir,\n\t\t.dentry = new_dentry,\n\t\t.inode = d_inode(new_dentry),\n\t};\n\tu8 new_file_type;\n\tint retval;\n\tstruct timespec64 ctime;\n\n\tif ((ext4_test_inode_flag(new_dir, EXT4_INODE_PROJINHERIT) &&\n\t     !projid_eq(EXT4_I(new_dir)->i_projid,\n\t\t\tEXT4_I(old_dentry->d_inode)->i_projid)) ||\n\t    (ext4_test_inode_flag(old_dir, EXT4_INODE_PROJINHERIT) &&\n\t     !projid_eq(EXT4_I(old_dir)->i_projid,\n\t\t\tEXT4_I(new_dentry->d_inode)->i_projid)))\n\t\treturn -EXDEV;\n\n\tretval = dquot_initialize(old.dir);\n\tif (retval)\n\t\treturn retval;\n\tretval = dquot_initialize(new.dir);\n\tif (retval)\n\t\treturn retval;\n\n\told.bh = ext4_find_entry(old.dir, &old.dentry->d_name,\n\t\t\t\t &old.de, &old.inlined, NULL);\n\tif (IS_ERR(old.bh))\n\t\treturn PTR_ERR(old.bh);\n\t/*\n\t *  Check for inode number is _not_ due to possible IO errors.\n\t *  We might rmdir the source, keep it as pwd of some process\n\t *  and merrily kill the link to whatever was created under the\n\t *  same name. Goodbye sticky bit ;-<\n\t */\n\tretval = -ENOENT;\n\tif (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)\n\t\tgoto end_rename;\n\n\tnew.bh = ext4_find_entry(new.dir, &new.dentry->d_name,\n\t\t\t\t &new.de, &new.inlined, NULL);\n\tif (IS_ERR(new.bh)) {\n\t\tretval = PTR_ERR(new.bh);\n\t\tnew.bh = NULL;\n\t\tgoto end_rename;\n\t}\n\n\t/* RENAME_EXCHANGE case: old *and* new must both exist */\n\tif (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)\n\t\tgoto end_rename;\n\n\thandle = ext4_journal_start(old.dir, EXT4_HT_DIR,\n\t\t(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +\n\t\t 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));\n\tif (IS_ERR(handle)) {\n\t\tretval = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tgoto end_rename;\n\t}\n\n\tif (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))\n\t\text4_handle_sync(handle);\n\n\tif (S_ISDIR(old.inode->i_mode)) {\n\t\told.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &old);\n\t\tif (retval)\n\t\t\tgoto end_rename;\n\t}\n\tif (S_ISDIR(new.inode->i_mode)) {\n\t\tnew.is_dir = true;\n\t\tretval = ext4_rename_dir_prepare(handle, &new);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4296#4296": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4296",
        "file": "fs/ext4/namei.c",
        "line": 4296,
        "function_snippet": "static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tint err;\n\n\tif (unlikely(ext4_forced_shutdown(EXT4_SB(old_dir->i_sb))))\n\t\treturn -EIO;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\terr = fscrypt_prepare_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t     flags);\n\tif (err)\n\t\treturn err;\n\n\tif (flags & RENAME_EXCHANGE) {\n\t\treturn ext4_cross_rename(old_dir, old_dentry,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4389#4389": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4389",
        "file": "fs/namei.c",
        "line": 4389,
        "function_snippet": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\tstruct name_snapshot old_name;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\terror = old_dir->i_op->rename(old_dir, old_dentry,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4536#4536": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4536",
        "file": "fs/namei.c",
        "line": 4536,
        "function_snippet": "static int do_renameat2(int olddfd, const char __user *oldname, int newdfd,\n\t\t\tconst char __user *newname, unsigned int flags)\n{\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct path old_path, new_path;\n\tstruct qstr old_last, new_last;\n\tint old_type, new_type;\n\tstruct inode *delegated_inode = NULL;\n\tstruct filename *from;\n\tstruct filename *to;\n\tunsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;\n\tbool should_retry = false;\n\tint error;\n\n\tif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\n\t\treturn -EINVAL;\n\n\tif ((flags & (RENAME_NOREPLACE | RENAME_WHITEOUT)) &&\n\t    (flags & RENAME_EXCHANGE))\n\t\treturn -EINVAL;\n\n\tif (flags & RENAME_EXCHANGE)\n\t\ttarget_flags = 0;\n\nretry:\n\tfrom = filename_parentat(olddfd, getname(oldname), lookup_flags,\n\t\t\t\t&old_path, &old_last, &old_type);\n\tif (IS_ERR(from)) {\n\t\terror = PTR_ERR(from);\n\t\tgoto exit;\n\t}\n\n\tto = filename_parentat(newdfd, getname(newname), lookup_flags,\n\t\t\t\t&new_path, &new_last, &new_type);\n\tif (IS_ERR(to)) {\n\t\terror = PTR_ERR(to);\n\t\tgoto exit1;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt)\n\t\tgoto exit2;\n\n\terror = -EBUSY;\n\tif (old_type != LAST_NORM)\n\t\tgoto exit2;\n\n\tif (flags & RENAME_NOREPLACE)\n\t\terror = -EEXIST;\n\tif (new_type != LAST_NORM)\n\t\tgoto exit2;\n\n\terror = mnt_want_write(old_path.mnt);\n\tif (error)\n\t\tgoto exit2;\n\nretry_deleg:\n\ttrap = lock_rename(new_path.dentry, old_path.dentry);\n\n\told_dentry = __lookup_hash(&old_last, old_path.dentry, lookup_flags);\n\terror = PTR_ERR(old_dentry);\n\tif (IS_ERR(old_dentry))\n\t\tgoto exit3;\n\t/* source must exist */\n\terror = -ENOENT;\n\tif (d_is_negative(old_dentry))\n\t\tgoto exit4;\n\tnew_dentry = __lookup_hash(&new_last, new_path.dentry, lookup_flags | target_flags);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry))\n\t\tgoto exit4;\n\terror = -EEXIST;\n\tif ((flags & RENAME_NOREPLACE) && d_is_positive(new_dentry))\n\t\tgoto exit5;\n\tif (flags & RENAME_EXCHANGE) {\n\t\terror = -ENOENT;\n\t\tif (d_is_negative(new_dentry))\n\t\t\tgoto exit5;\n\n\t\tif (!d_is_dir(new_dentry)) {\n\t\t\terror = -ENOTDIR;\n\t\t\tif (new_last.name[new_last.len])\n\t\t\t\tgoto exit5;\n\t\t}\n\t}\n\t/* unless the source is a directory trailing slashes give -ENOTDIR */\n\tif (!d_is_dir(old_dentry)) {\n\t\terror = -ENOTDIR;\n\t\tif (old_last.name[old_last.len])\n\t\t\tgoto exit5;\n\t\tif (!(flags & RENAME_EXCHANGE) && new_last.name[new_last.len])\n\t\t\tgoto exit5;\n\t}\n\t/* source should not be ancestor of target */\n\terror = -EINVAL;\n\tif (old_dentry == trap)\n\t\tgoto exit5;\n\t/* target should not be an ancestor of source */\n\tif (!(flags & RENAME_EXCHANGE))\n\t\terror = -ENOTEMPTY;\n\tif (new_dentry == trap)\n\t\tgoto exit5;\n\n\terror = security_path_rename(&old_path, old_dentry,\n\t\t\t\t     &new_path, new_dentry, flags);\n\tif (error)\n\t\tgoto exit5;\n\terror = vfs_rename(old_path.dentry->d_inode, old_dentry,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4571#4571": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4571",
        "file": "fs/namei.c",
        "line": 4571,
        "function_snippet": "\treturn do_renameat2(olddfd, oldname, newdfd, newname, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568#4568": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568",
        "file": "fs/namei.c",
        "line": 4568,
        "function_snippet": "SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46#46": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46",
        "file": "arch/x86/entry/common.c",
        "line": 46,
        "function_snippet": "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)\n{\n\tnr = syscall_enter_from_user_mode(regs, nr);\n\n\tinstrumentation_begin();\n\tif (likely(nr < NR_syscalls)) {\n\t\tnr = array_index_nospec(nr, NR_syscalls);\n\t\tregs->ax = sys_call_table[nr](regs);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38#38": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38",
        "file": "mm/kasan/common.c",
        "line": 38,
        "function_snippet": "depot_stack_handle_t kasan_save_stack(gfp_t flags)\n{\n\tunsigned long entries[KASAN_STACK_DEPTH];\n\tunsigned int nr_entries;\n\n\tnr_entries = stack_trace_save(entries, ARRAY_SIZE(entries), 0);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46#46": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46",
        "file": "mm/kasan/common.c",
        "line": 46,
        "function_snippet": "void kasan_set_track(struct kasan_track *track, gfp_t flags)\n{\n\ttrack->pid = current->pid;\n\ttrack->stack = kasan_save_stack(flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428#428": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428",
        "file": "mm/kasan/common.c",
        "line": 428,
        "function_snippet": "\t\tkasan_set_track(&alloc_meta->alloc_track, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461#461": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461",
        "file": "mm/kasan/common.c",
        "line": 461,
        "function_snippet": "void * __must_check __kasan_slab_alloc(struct kmem_cache *cache,\n\t\t\t\t\tvoid *object, gfp_t flags, bool init)\n{\n\tu8 tag;\n\tvoid *tagged_object;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tkasan_quarantine_reduce();\n\n\tif (unlikely(object == NULL))\n\t\treturn NULL;\n\n\tif (is_kfence_address(object))\n\t\treturn (void *)object;\n\n\t/*\n\t * Generate and assign random tag for tag-based modes.\n\t * Tag is ignored in set_tag() for the generic mode.\n\t */\n\ttag = assign_tag(cache, object, false);\n\ttagged_object = set_tag(object, tag);\n\n\t/*\n\t * Unpoison the whole object.\n\t * For kmalloc() allocations, kasan_kmalloc() will do precise poisoning.\n\t */\n\tkasan_unpoison(tagged_object, cache->object_size, init);\n\n\t/* Save alloc info (if possible) for non-kmalloc() allocations. */\n\tif (kasan_stack_collection_enabled())\n\t\tset_alloc_info(cache, (void *)object, flags, false);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259#259": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259",
        "file": "include/linux/kasan.h",
        "line": 259,
        "function_snippet": "static __always_inline void * __must_check kasan_slab_alloc(\n\t\tstruct kmem_cache *s, void *object, gfp_t flags, bool init)\n{\n\tif (kasan_enabled())\n\t\treturn __kasan_slab_alloc(s, object, flags, init);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583#583": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583",
        "file": "include/../mm/slab.h",
        "line": 583,
        "function_snippet": "static inline void slab_post_alloc_hook(struct kmem_cache *s,\n\t\t\t\t\tstruct obj_cgroup *objcg, gfp_t flags,\n\t\t\t\t\tsize_t size, void **p, bool init)\n{\n\tsize_t i;\n\n\tflags &= gfp_allowed_mask;\n\n\t/*\n\t * As memory initialization might be integrated into KASAN,\n\t * kasan_slab_alloc and initialization memset must be\n\t * kept together to avoid discrepancies in behavior.\n\t *\n\t * As p[i] might get tagged, memset and kmemleak hook come after KASAN.\n\t */\n\tfor (i = 0; i < size; i++) {\n\t\tp[i] = kasan_slab_alloc(s, p[i], flags, init);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956#2956": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956",
        "file": "mm/slub.c",
        "line": 2956,
        "function_snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr, size_t orig_size)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\tstruct obj_cgroup *objcg = NULL;\n\tbool init = false;\n\n\ts = slab_pre_alloc_hook(s, &objcg, 1, gfpflags);\n\tif (!s)\n\t\treturn NULL;\n\n\tobject = kfence_alloc(s, orig_size, gfpflags);\n\tif (unlikely(object))\n\t\tgoto out;\n\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPTION so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPTION) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !page || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);\n\t} else {\n\t\tvoid *next_object = get_freepointer_safe(s, object);\n\n\t\t/*\n\t\t * The cmpxchg will only match if there was no additional\n\t\t * operation and if we are on the right processor.\n\t\t *\n\t\t * The cmpxchg does the following atomically (without lock\n\t\t * semantics!)\n\t\t * 1. Relocate first pointer to the current per cpu area.\n\t\t * 2. Verify that tid and freelist have not been changed\n\t\t * 3. If they were not changed replace tid and freelist\n\t\t *\n\t\t * Since this is without lock semantics the protection is only\n\t\t * against code executing on this cpu *not* from access by\n\t\t * other cpus.\n\t\t */\n\t\tif (unlikely(!this_cpu_cmpxchg_double(\n\t\t\t\ts->cpu_slab->freelist, s->cpu_slab->tid,\n\t\t\t\tobject, tid,\n\t\t\t\tnext_object, next_tid(tid)))) {\n\n\t\t\tnote_cmpxchg_failure(\"slab_alloc\", s, tid);\n\t\t\tgoto redo;\n\t\t}\n\t\tprefetch_freepointer(s, next_object);\n\t\tstat(s, ALLOC_FASTPATH);\n\t}\n\n\tmaybe_wipe_obj_freeptr(s, object);\n\tinit = slab_want_init_on_alloc(gfpflags, s);\n\nout:\n\tslab_post_alloc_hook(s, objcg, gfpflags, 1, &object, init);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964#2964": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964",
        "file": "mm/slub.c",
        "line": 2964,
        "function_snippet": "\treturn slab_alloc_node(s, gfpflags, NUMA_NO_NODE, addr, orig_size);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969#2969": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969",
        "file": "mm/slub.c",
        "line": 2969,
        "function_snippet": "void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_, s->object_size);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403#1403": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403",
        "file": "kernel/fork.c",
        "line": 1403,
        "function_snippet": "static struct mm_struct *dup_mm(struct task_struct *tsk,\n\t\t\t\tstruct mm_struct *oldmm)\n{\n\tstruct mm_struct *mm;\n\tint err;\n\n\tmm = allocate_mm();"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468#1468": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468",
        "file": "kernel/fork.c",
        "line": 1468,
        "function_snippet": "static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)\n{\n\tstruct mm_struct *mm, *oldmm;\n\tint retval;\n\n\ttsk->min_flt = tsk->maj_flt = 0;\n\ttsk->nvcsw = tsk->nivcsw = 0;\n#ifdef CONFIG_DETECT_HUNG_TASK\n\ttsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;\n\ttsk->last_switch_time = 0;\n#endif\n\n\ttsk->mm = NULL;\n\ttsk->active_mm = NULL;\n\n\t/*\n\t * Are we cloning a kernel thread?\n\t *\n\t * We need to steal a active VM for that..\n\t */\n\toldmm = current->mm;\n\tif (!oldmm)\n\t\treturn 0;\n\n\t/* initialize the new vmacache entries */\n\tvmacache_flush(tsk);\n\n\tif (clone_flags & CLONE_VM) {\n\t\tmmget(oldmm);\n\t\tmm = oldmm;\n\t\tgoto good_mm;\n\t}\n\n\tretval = -ENOMEM;\n\tmm = dup_mm(tsk, current->mm);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152#2152": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152",
        "file": "kernel/fork.c",
        "line": 2152,
        "function_snippet": "\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524#2524": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524",
        "file": "kernel/fork.c",
        "line": 2524,
        "function_snippet": "pid_t kernel_clone(struct kernel_clone_args *args)\n{\n\tu64 clone_flags = args->flags;\n\tstruct completion vfork;\n\tstruct pid *pid;\n\tstruct task_struct *p;\n\tint trace = 0;\n\tpid_t nr;\n\n\t/*\n\t * For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument\n\t * to return the pidfd. Hence, CLONE_PIDFD and CLONE_PARENT_SETTID are\n\t * mutually exclusive. With clone3() CLONE_PIDFD has grown a separate\n\t * field in struct clone_args and it still doesn't make sense to have\n\t * them both point at the same memory location. Performing this check\n\t * here has the advantage that we don't need to have a separate helper\n\t * to check for legacy clone().\n\t */\n\tif ((args->flags & CLONE_PIDFD) &&\n\t    (args->flags & CLONE_PARENT_SETTID) &&\n\t    (args->pidfd == args->parent_tid))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Determine whether and which event to report to ptracer.  When\n\t * called from kernel_thread or CLONE_UNTRACED is explicitly\n\t * requested, no event is reported; otherwise, report if the event\n\t * for the type of forking is enabled.\n\t */\n\tif (!(clone_flags & CLONE_UNTRACED)) {\n\t\tif (clone_flags & CLONE_VFORK)\n\t\t\ttrace = PTRACE_EVENT_VFORK;\n\t\telse if (args->exit_signal != SIGCHLD)\n\t\t\ttrace = PTRACE_EVENT_CLONE;\n\t\telse\n\t\t\ttrace = PTRACE_EVENT_FORK;\n\n\t\tif (likely(!ptrace_event_enabled(current, trace)))\n\t\t\ttrace = 0;\n\t}\n\n\tp = copy_process(NULL, trace, NUMA_NO_NODE, args);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643#2643": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643",
        "file": "kernel/fork.c",
        "line": 2643,
        "function_snippet": "SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n\t\t int __user *, parent_tidptr,\n\t\t int __user *, child_tidptr,\n\t\t unsigned long, tls)\n#endif\n{\n\tstruct kernel_clone_args args = {\n\t\t.flags\t\t= (lower_32_bits(clone_flags) & ~CSIGNAL),\n\t\t.pidfd\t\t= parent_tidptr,\n\t\t.child_tid\t= child_tidptr,\n\t\t.parent_tid\t= parent_tidptr,\n\t\t.exit_signal\t= (lower_32_bits(clone_flags) & CSIGNAL),\n\t\t.stack\t\t= newsp,\n\t\t.tls\t\t= tls,\n\t};\n\n\treturn kernel_clone(&args);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627#2627": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627",
        "file": "kernel/fork.c",
        "line": 2627,
        "function_snippet": "SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357#357": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357",
        "file": "mm/kasan/generic.c",
        "line": 357,
        "function_snippet": "void kasan_set_free_info(struct kmem_cache *cache,\n\t\t\t\tvoid *object, u8 tag)\n{\n\tstruct kasan_free_meta *free_meta;\n\n\tfree_meta = kasan_get_free_meta(cache, object);\n\tif (!free_meta)\n\t\treturn;\n\n\tkasan_set_track(&free_meta->free_track, GFP_NOWAIT);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360#360": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360",
        "file": "mm/kasan/common.c",
        "line": 360,
        "function_snippet": "static inline bool ____kasan_slab_free(struct kmem_cache *cache, void *object,\n\t\t\t\tunsigned long ip, bool quarantine, bool init)\n{\n\tu8 tag;\n\tvoid *tagged_object;\n\n\ttag = get_tag(object);\n\ttagged_object = object;\n\tobject = kasan_reset_tag(object);\n\n\tif (is_kfence_address(object))\n\t\treturn false;\n\n\tif (unlikely(nearest_obj(cache, virt_to_head_page(object), object) !=\n\t    object)) {\n\t\tkasan_report_invalid_free(tagged_object, ip);\n\t\treturn true;\n\t}\n\n\t/* RCU slabs could be legally used after free within the RCU period */\n\tif (unlikely(cache->flags & SLAB_TYPESAFE_BY_RCU))\n\t\treturn false;\n\n\tif (!kasan_byte_accessible(tagged_object)) {\n\t\tkasan_report_invalid_free(tagged_object, ip);\n\t\treturn true;\n\t}\n\n\tkasan_poison(object, round_up(cache->object_size, KASAN_GRANULE_SIZE),\n\t\t\tKASAN_KMALLOC_FREE, init);\n\n\tif ((IS_ENABLED(CONFIG_KASAN_GENERIC) && !quarantine))\n\t\treturn false;\n\n\tif (kasan_stack_collection_enabled())\n\t\tkasan_set_free_info(cache, object, tag);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368#368": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368",
        "file": "mm/kasan/common.c",
        "line": 368,
        "function_snippet": "\treturn ____kasan_slab_free(cache, object, ip, true, init);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235#235": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235",
        "file": "include/linux/kasan.h",
        "line": 235,
        "function_snippet": "\t\treturn __kasan_slab_free(s, object, _RET_IP_, init);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604#1604": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604",
        "file": "mm/slub.c",
        "line": 1604,
        "function_snippet": "\treturn kasan_slab_free(s, x, init);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630#1630": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630",
        "file": "mm/slub.c",
        "line": 1630,
        "function_snippet": "static inline bool slab_free_freelist_hook(struct kmem_cache *s,\n\t\t\t\t\t   void **head, void **tail,\n\t\t\t\t\t   int *cnt)\n{\n\n\tvoid *object;\n\tvoid *next = *head;\n\tvoid *old_tail = *tail ? *tail : *head;\n\n\tif (is_kfence_address(next)) {\n\t\tslab_free_hook(s, next, false);\n\t\treturn true;\n\t}\n\n\t/* Head and tail of the reconstructed freelist */\n\t*head = NULL;\n\t*tail = NULL;\n\n\tdo {\n\t\tobject = next;\n\t\tnext = get_freepointer(s, object);\n\n\t\t/* If object's reuse doesn't have to be delayed */\n\t\tif (!slab_free_hook(s, object, slab_want_init_on_free(s))) {"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212#3212": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212",
        "file": "mm/slub.c",
        "line": 3212,
        "function_snippet": "static __always_inline void slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\t      void *head, void *tail, int cnt,\n\t\t\t\t      unsigned long addr)\n{\n\t/*\n\t * With KASAN enabled slab_free_freelist_hook modifies the freelist\n\t * to remove objects, whose reuse must be delayed.\n\t */\n\tif (slab_free_freelist_hook(s, &head, &tail, &cnt))"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228#3228": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228",
        "file": "mm/slub.c",
        "line": 3228,
        "function_snippet": "void kmem_cache_free(struct kmem_cache *s, void *x)\n{\n\ts = cache_from_obj(s, x);\n\tif (!s)\n\t\treturn;\n\tslab_free(s, virt_to_head_page(x), x, NULL, 1, _RET_IP_);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722#722": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722",
        "file": "kernel/fork.c",
        "line": 722,
        "function_snippet": "\tfree_mm(mm);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49#49": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49",
        "file": "include/linux/sched/mm.h",
        "line": 49,
        "function_snippet": "static inline void mmdrop(struct mm_struct *mm)\n{\n\t/*\n\t * The implicit full barrier implied by atomic_dec_and_test() is\n\t * required by the membarrier system call before returning to\n\t * user-space, after storing to rq->curr.\n\t */\n\tif (unlikely(atomic_dec_and_test(&mm->mm_count)))\n\t\t__mmdrop(mm);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892#3892": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892",
        "file": "kernel/sched/core.c",
        "line": 3892,
        "function_snippet": "\t__releases(rq->lock)\n{\n\tstruct rq *rq = this_rq();\n\tstruct mm_struct *mm = rq->prev_mm;\n\tlong prev_state;\n\n\t/*\n\t * The previous task will have left us with a preempt_count of 2\n\t * because it left us after:\n\t *\n\t *\tschedule()\n\t *\t  preempt_disable();\t\t\t// 1\n\t *\t  __schedule()\n\t *\t    raw_spin_lock_irq(&rq->lock)\t// 2\n\t *\n\t * Also, see FORK_PREEMPT_COUNT.\n\t */\n\tif (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,\n\t\t      \"corrupted preempt_count: %s/%d/0x%x\\n\",\n\t\t      current->comm, current->pid, preempt_count()))\n\t\tpreempt_count_set(FORK_PREEMPT_COUNT);\n\n\trq->prev_mm = NULL;\n\n\t/*\n\t * A task struct has one reference for the use as \"current\".\n\t * If a task dies, then it sets TASK_DEAD in tsk->state and calls\n\t * schedule one last time. The schedule call will never return, and\n\t * the scheduled task must drop that reference.\n\t *\n\t * We must observe prev->state before clearing prev->on_cpu (in\n\t * finish_task), otherwise a concurrent wakeup can get prev\n\t * running on another CPU and we could rave with its RUNNING -> DEAD\n\t * transition, resulting in a double drop.\n\t */\n\tprev_state = prev->state;\n\tvtime_task_switch(prev);\n\tperf_event_task_sched_in(prev, current);\n\tfinish_task(prev);\n\tfinish_lock_switch(rq);\n\tfinish_arch_post_lock_switch();\n\tkcov_finish_switch(current);\n\n\tfire_sched_in_preempt_notifiers(current);\n\t/*\n\t * When switching through a kernel thread, the loop in\n\t * membarrier_{private,global}_expedited() may have observed that\n\t * kernel thread and not issued an IPI. It is therefore possible to\n\t * schedule between user->kernel->user threads without passing though\n\t * switch_mm(). Membarrier requires a barrier after storing to\n\t * rq->curr, before returning to userspace, so provide them here:\n\t *\n\t * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly\n\t *   provided by mmdrop(),\n\t * - a sync_core for SYNC_CORE.\n\t */\n\tif (mm) {\n\t\tmembarrier_mm_sync_core_before_usermode(mm);\n\t\tmmdrop(mm);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038#4038": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038",
        "file": "kernel/sched/core.c",
        "line": 4038,
        "function_snippet": "context_switch(struct rq *rq, struct task_struct *prev,\n\t       struct task_struct *next, struct rq_flags *rf)\n{\n\tprepare_task_switch(rq, prev, next);\n\n\t/*\n\t * For paravirt, this is coupled with an exit in switch_to to\n\t * combine the page table reload and the switch backend into\n\t * one hypercall.\n\t */\n\tarch_start_context_switch(prev);\n\n\t/*\n\t * kernel -> kernel   lazy + transfer active\n\t *   user -> kernel   lazy + mmgrab() active\n\t *\n\t * kernel ->   user   switch + mmdrop() active\n\t *   user ->   user   switch\n\t */\n\tif (!next->mm) {                                // to kernel\n\t\tenter_lazy_tlb(prev->active_mm, next);\n\n\t\tnext->active_mm = prev->active_mm;\n\t\tif (prev->mm)                           // from user\n\t\t\tmmgrab(prev->active_mm);\n\t\telse\n\t\t\tprev->active_mm = NULL;\n\t} else {                                        // to user\n\t\tmembarrier_switch_mm(rq, prev->active_mm, next->mm);\n\t\t/*\n\t\t * sys_membarrier() requires an smp_mb() between setting\n\t\t * rq->curr / membarrier_switch_mm() and returning to userspace.\n\t\t *\n\t\t * The below provides this either through switch_mm(), or in\n\t\t * case 'prev->active_mm == next->mm' through\n\t\t * finish_task_switch()'s mmdrop().\n\t\t */\n\t\tswitch_mm_irqs_off(prev->active_mm, next->mm, next);\n\n\t\tif (!prev->mm) {                        // from kernel\n\t\t\t/* will mmdrop() in finish_task_switch(). */\n\t\t\trq->prev_mm = prev->active_mm;\n\t\t\tprev->active_mm = NULL;\n\t\t}\n\t}\n\n\trq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);\n\n\tprepare_lock_switch(rq, next, rf);\n\n\t/* Here we just switch the register state and the stack. */\n\tswitch_to(prev, next, prev);\n\tbarrier();\n\n\treturn finish_task_switch(prev);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796#4796": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796",
        "file": "kernel/sched/core.c",
        "line": 4796,
        "function_snippet": "static void __sched notrace __schedule(bool preempt)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tunsigned long prev_state;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\tprev = rq->curr;\n\n\tschedule_debug(prev, preempt);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\tlocal_irq_disable();\n\trcu_note_context_switch(preempt);\n\n\t/*\n\t * Make sure that signal_pending_state()->signal_pending() below\n\t * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)\n\t * done by the caller to avoid the race with signal_wake_up():\n\t *\n\t * __set_current_state(@state)\t\tsignal_wake_up()\n\t * schedule()\t\t\t\t  set_tsk_thread_flag(p, TIF_SIGPENDING)\n\t *\t\t\t\t\t  wake_up_state(p, state)\n\t *   LOCK rq->lock\t\t\t    LOCK p->pi_state\n\t *   smp_mb__after_spinlock()\t\t    smp_mb__after_spinlock()\n\t *     if (signal_pending_state())\t    if (p->state & @state)\n\t *\n\t * Also, the membarrier system call requires a full memory barrier\n\t * after coming from user-space, before storing to rq->curr.\n\t */\n\trq_lock(rq, &rf);\n\tsmp_mb__after_spinlock();\n\n\t/* Promote REQ to ACT */\n\trq->clock_update_flags <<= 1;\n\tupdate_rq_clock(rq);\n\n\tswitch_count = &prev->nivcsw;\n\n\t/*\n\t * We must load prev->state once (task_struct::state is volatile), such\n\t * that:\n\t *\n\t *  - we form a control dependency vs deactivate_task() below.\n\t *  - ptrace_{,un}freeze_traced() can change ->state underneath us.\n\t */\n\tprev_state = prev->state;\n\tif (!preempt && prev_state) {\n\t\tif (signal_pending_state(prev_state, prev)) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tprev->sched_contributes_to_load =\n\t\t\t\t(prev_state & TASK_UNINTERRUPTIBLE) &&\n\t\t\t\t!(prev_state & TASK_NOLOAD) &&\n\t\t\t\t!(prev->flags & PF_FROZEN);\n\n\t\t\tif (prev->sched_contributes_to_load)\n\t\t\t\trq->nr_uninterruptible++;\n\n\t\t\t/*\n\t\t\t * __schedule()\t\t\tttwu()\n\t\t\t *   prev_state = prev->state;    if (p->on_rq && ...)\n\t\t\t *   if (prev_state)\t\t    goto out;\n\t\t\t *     p->on_rq = 0;\t\t  smp_acquire__after_ctrl_dep();\n\t\t\t *\t\t\t\t  p->state = TASK_WAKING\n\t\t\t *\n\t\t\t * Where __schedule() and ttwu() have matching control dependencies.\n\t\t\t *\n\t\t\t * After this, schedule() must not care about p->state any more.\n\t\t\t */\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);\n\n\t\t\tif (prev->in_iowait) {\n\t\t\t\tatomic_inc(&rq->nr_iowait);\n\t\t\t\tdelayacct_blkio_start();\n\t\t\t}\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tnext = pick_next_task(rq, prev, &rf);\n\tclear_tsk_need_resched(prev);\n\tclear_preempt_need_resched();\n\n\ttrace_android_rvh_schedule(prev, next, rq);\n\tif (likely(prev != next)) {\n\t\trq->nr_switches++;\n\t\t/*\n\t\t * RCU users of rcu_dereference(rq->curr) may not see\n\t\t * changes to task_struct made by pick_next_task().\n\t\t */\n\t\tRCU_INIT_POINTER(rq->curr, next);\n\t\t/*\n\t\t * The membarrier system call requires each architecture\n\t\t * to have a full memory barrier after updating\n\t\t * rq->curr, before returning to user-space.\n\t\t *\n\t\t * Here are the schemes providing that barrier on the\n\t\t * various architectures:\n\t\t * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.\n\t\t *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.\n\t\t * - finish_lock_switch() for weakly-ordered\n\t\t *   architectures where spin_unlock is a full barrier,\n\t\t * - switch_to() for arm64 (weakly-ordered, spin_unlock\n\t\t *   is a RELEASE barrier),\n\t\t */\n\t\t++*switch_count;\n\n\t\tpsi_sched_switch(prev, next, !task_on_rq_queued(prev));\n\n\t\ttrace_sched_switch(preempt, prev, next);\n\n\t\t/* Also unlocks the rq: */\n\t\trq = context_switch(rq, prev, next, &rf);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874#4874": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874",
        "file": "kernel/sched/core.c",
        "line": 4874,
        "function_snippet": "asmlinkage __visible void __sched schedule(void)\n{\n\tstruct task_struct *tsk = current;\n\n\tsched_submit_work(tsk);\n\tdo {\n\t\tpreempt_disable();\n\t\t__schedule(false);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378#378": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378",
        "file": "fs/pipe.c",
        "line": 378,
        "function_snippet": "pipe_read(struct kiocb *iocb, struct iov_iter *to)\n{\n\tsize_t total_len = iov_iter_count(to);\n\tstruct file *filp = iocb->ki_filp;\n\tstruct pipe_inode_info *pipe = filp->private_data;\n\tbool was_full, wake_next_reader = false;\n\tssize_t ret;\n\n\t/* Null read succeeds. */\n\tif (unlikely(total_len == 0))\n\t\treturn 0;\n\n\tret = 0;\n\t__pipe_lock(pipe);\n\n\t/*\n\t * We only wake up writers if the pipe was full when we started\n\t * reading in order to avoid unnecessary wakeups.\n\t *\n\t * But when we do wake up writers, we do so using a sync wakeup\n\t * (WF_SYNC), because we want them to get going and generate more\n\t * data for us.\n\t */\n\twas_full = pipe_full(pipe->head, pipe->tail, pipe->max_usage);\n\tfor (;;) {\n\t\t/* Read ->head with a barrier vs post_one_notification() */\n\t\tunsigned int head = smp_load_acquire(&pipe->head);\n\t\tunsigned int tail = pipe->tail;\n\t\tunsigned int mask = pipe->ring_size - 1;\n\n#ifdef CONFIG_WATCH_QUEUE\n\t\tif (pipe->note_loss) {\n\t\t\tstruct watch_notification n;\n\n\t\t\tif (total_len < 8) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -ENOBUFS;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tn.type = WATCH_TYPE_META;\n\t\t\tn.subtype = WATCH_META_LOSS_NOTIFICATION;\n\t\t\tn.info = watch_sizeof(n);\n\t\t\tif (copy_to_iter(&n, sizeof(n), to) != sizeof(n)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += sizeof(n);\n\t\t\ttotal_len -= sizeof(n);\n\t\t\tpipe->note_loss = false;\n\t\t}\n#endif\n\n\t\tif (!pipe_empty(head, tail)) {\n\t\t\tstruct pipe_buffer *buf = &pipe->bufs[tail & mask];\n\t\t\tsize_t chars = buf->len;\n\t\t\tsize_t written;\n\t\t\tint error;\n\n\t\t\tif (chars > total_len) {\n\t\t\t\tif (buf->flags & PIPE_BUF_FLAG_WHOLE) {\n\t\t\t\t\tif (ret == 0)\n\t\t\t\t\t\tret = -ENOBUFS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchars = total_len;\n\t\t\t}\n\n\t\t\terror = pipe_buf_confirm(pipe, buf);\n\t\t\tif (error) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = error;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twritten = copy_page_to_iter(buf->page, buf->offset, chars, to);\n\t\t\tif (unlikely(written < chars)) {\n\t\t\t\tif (!ret)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tret += chars;\n\t\t\tbuf->offset += chars;\n\t\t\tbuf->len -= chars;\n\n\t\t\t/* Was it a packet buffer? Clean up and exit */\n\t\t\tif (buf->flags & PIPE_BUF_FLAG_PACKET) {\n\t\t\t\ttotal_len = chars;\n\t\t\t\tbuf->len = 0;\n\t\t\t}\n\n\t\t\tif (!buf->len) {\n\t\t\t\tpipe_buf_release(pipe, buf);\n\t\t\t\tspin_lock_irq(&pipe->rd_wait.lock);\n#ifdef CONFIG_WATCH_QUEUE\n\t\t\t\tif (buf->flags & PIPE_BUF_FLAG_LOSS)\n\t\t\t\t\tpipe->note_loss = true;\n#endif\n\t\t\t\ttail++;\n\t\t\t\tpipe->tail = tail;\n\t\t\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\t\t}\n\t\t\ttotal_len -= chars;\n\t\t\tif (!total_len)\n\t\t\t\tbreak;\t/* common path: read succeeded */\n\t\t\tif (!pipe_empty(head, tail))\t/* More to do? */\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (filp->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\t__pipe_unlock(pipe);\n\n\t\t/*\n\t\t * We only get here if we didn't actually read anything.\n\t\t *\n\t\t * However, we could have seen (and removed) a zero-sized\n\t\t * pipe buffer, and might have made space in the buffers\n\t\t * that way.\n\t\t *\n\t\t * You can't make zero-sized pipe buffers by doing an empty\n\t\t * write (not even in packet mode), but they can happen if\n\t\t * the writer gets an EFAULT when trying to fill a buffer\n\t\t * that already got allocated and inserted in the buffer\n\t\t * array.\n\t\t *\n\t\t * So we still need to wake up any pending writers in the\n\t\t * _very_ unlikely case that the pipe was full, but we got\n\t\t * no data.\n\t\t */\n\t\tif (unlikely(was_full)) {\n\t\t\twake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);\n\t\t\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n\t\t}\n\n\t\t/*\n\t\t * But because we didn't read anything, at this point we can\n\t\t * just return directly with -ERESTARTSYS if we're interrupted,\n\t\t * since we've done any required wakeups and there's no need\n\t\t * to mark anything accessed. And we've dropped the lock.\n\t\t */\n\t\tif (wait_event_interruptible_exclusive(pipe->rd_wait, pipe_readable(pipe)) < 0)"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963#1963": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963",
        "file": "include/linux/fs.h",
        "line": 1963,
        "function_snippet": "static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,\n\t\t\t\t     struct iov_iter *iter)\n{\n\treturn file->f_op->read_iter(kio, iter);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415#415": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415",
        "file": "fs/read_write.c",
        "line": 415,
        "function_snippet": "static ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = (ppos ? *ppos : 0);\n\tiov_iter_init(&iter, READ, &iov, 1, len);\n\n\tret = call_read_iter(filp, &kiocb, &iter);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496#496": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496",
        "file": "fs/read_write.c",
        "line": 496,
        "function_snippet": "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(buf, count)))\n\t\treturn -EFAULT;\n\n\tret = rw_verify_area(READ, file, pos, count);\n\tif (ret)\n\t\treturn ret;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\n\tif (file->f_op->read)\n\t\tret = file->f_op->read(file, buf, count, pos);\n\telse if (file->f_op->read_iter)\n\t\tret = new_sync_read(file, buf, count, pos);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634#634": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634",
        "file": "fs/read_write.c",
        "line": 634,
        "function_snippet": "ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)\n{\n\tstruct fd f = fdget_pos(fd);\n\tssize_t ret = -EBADF;\n\n\tif (f.file) {\n\t\tloff_t pos, *ppos = file_ppos(f.file);\n\t\tif (ppos) {\n\t\t\tpos = *ppos;\n\t\t\tppos = &pos;\n\t\t}\n\t\tret = vfs_read(f.file, buf, count, ppos);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644#644": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644",
        "file": "fs/read_write.c",
        "line": 644,
        "function_snippet": "\treturn ksys_read(fd, buf, count);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642#642": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642",
        "file": "fs/read_write.c",
        "line": 642,
        "function_snippet": "SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#35#35": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#35",
        "file": "include/linux/page_owner.h",
        "line": 35,
        "function_snippet": "\t\t__set_page_owner(page, order, gfp_mask);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2386#2386": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2386",
        "file": "mm/page_alloc.c",
        "line": 2386,
        "function_snippet": "\tset_page_owner(page, order, gfp_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2392#2392": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2392",
        "file": "mm/page_alloc.c",
        "line": 2392,
        "function_snippet": "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,\n\t\t\t\t\t\t\tunsigned int alloc_flags)\n{\n\tpost_alloc_hook(page, order, gfp_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#4073#4073": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#4073",
        "file": "mm/page_alloc.c",
        "line": 4073,
        "function_snippet": "get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,\n\t\t\t\t\t\tconst struct alloc_context *ac)\n{\n\tstruct zoneref *z;\n\tstruct zone *zone;\n\tstruct pglist_data *last_pgdat_dirty_limit = NULL;\n\tbool no_fallback;\n\nretry:\n\t/*\n\t * Scan zonelist, looking for a zone with enough free.\n\t * See also __cpuset_node_allowed() comment in kernel/cpuset.c.\n\t */\n\tno_fallback = alloc_flags & ALLOC_NOFRAGMENT;\n\tz = ac->preferred_zoneref;\n\tfor_next_zone_zonelist_nodemask(zone, z, ac->highest_zoneidx,\n\t\t\t\t\tac->nodemask) {\n\t\tstruct page *page;\n\t\tunsigned long mark;\n\n\t\tif (cpusets_enabled() &&\n\t\t\t(alloc_flags & ALLOC_CPUSET) &&\n\t\t\t!__cpuset_zone_allowed(zone, gfp_mask))\n\t\t\t\tcontinue;\n\t\t/*\n\t\t * When allocating a page cache page for writing, we\n\t\t * want to get it from a node that is within its dirty\n\t\t * limit, such that no single node holds more than its\n\t\t * proportional share of globally allowed dirty pages.\n\t\t * The dirty limits take into account the node's\n\t\t * lowmem reserves and high watermark so that kswapd\n\t\t * should be able to balance it without having to\n\t\t * write pages from its LRU list.\n\t\t *\n\t\t * XXX: For now, allow allocations to potentially\n\t\t * exceed the per-node dirty limit in the slowpath\n\t\t * (spread_dirty_pages unset) before going into reclaim,\n\t\t * which is important when on a NUMA setup the allowed\n\t\t * nodes are together not big enough to reach the\n\t\t * global limit.  The proper fix for these situations\n\t\t * will require awareness of nodes in the\n\t\t * dirty-throttling and the flusher threads.\n\t\t */\n\t\tif (ac->spread_dirty_pages) {\n\t\t\tif (last_pgdat_dirty_limit == zone->zone_pgdat)\n\t\t\t\tcontinue;\n\n\t\t\tif (!node_dirty_ok(zone->zone_pgdat)) {\n\t\t\t\tlast_pgdat_dirty_limit = zone->zone_pgdat;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (no_fallback && nr_online_nodes > 1 &&\n\t\t    zone != ac->preferred_zoneref->zone) {\n\t\t\tint local_nid;\n\n\t\t\t/*\n\t\t\t * If moving to a remote node, retry but allow\n\t\t\t * fragmenting fallbacks. Locality is more important\n\t\t\t * than fragmentation avoidance.\n\t\t\t */\n\t\t\tlocal_nid = zone_to_nid(ac->preferred_zoneref->zone);\n\t\t\tif (zone_to_nid(zone) != local_nid) {\n\t\t\t\talloc_flags &= ~ALLOC_NOFRAGMENT;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\tmark = wmark_pages(zone, alloc_flags & ALLOC_WMARK_MASK);\n\t\tif (!zone_watermark_fast(zone, order, mark,\n\t\t\t\t       ac->highest_zoneidx, alloc_flags,\n\t\t\t\t       gfp_mask)) {\n\t\t\tint ret;\n\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\n\t\t\t/*\n\t\t\t * Watermark failed for this zone, but see if we can\n\t\t\t * grow this zone if it contains deferred pages.\n\t\t\t */\n\t\t\tif (static_branch_unlikely(&deferred_pages)) {\n\t\t\t\tif (_deferred_grow_zone(zone, order))\n\t\t\t\t\tgoto try_this_zone;\n\t\t\t}\n#endif\n\t\t\t/* Checked here to keep the fast path fast */\n\t\t\tBUILD_BUG_ON(ALLOC_NO_WATERMARKS < NR_WMARK);\n\t\t\tif (alloc_flags & ALLOC_NO_WATERMARKS)\n\t\t\t\tgoto try_this_zone;\n\n\t\t\tif (node_reclaim_mode == 0 ||\n\t\t\t    !zone_allows_reclaim(ac->preferred_zoneref->zone, zone))\n\t\t\t\tcontinue;\n\n\t\t\tret = node_reclaim(zone->zone_pgdat, gfp_mask, order);\n\t\t\tswitch (ret) {\n\t\t\tcase NODE_RECLAIM_NOSCAN:\n\t\t\t\t/* did not scan */\n\t\t\t\tcontinue;\n\t\t\tcase NODE_RECLAIM_FULL:\n\t\t\t\t/* scanned but unreclaimable */\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\t/* did we reclaim enough */\n\t\t\t\tif (zone_watermark_ok(zone, order, mark,\n\t\t\t\t\tac->highest_zoneidx, alloc_flags))\n\t\t\t\t\tgoto try_this_zone;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\ntry_this_zone:\n\t\tpage = rmqueue(ac->preferred_zoneref->zone, zone, order,\n\t\t\t\tgfp_mask, alloc_flags, ac->migratetype);\n\t\tif (page) {\n\t\t\tprep_new_page(page, order, gfp_mask, alloc_flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#5160#5160": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#5160",
        "file": "mm/page_alloc.c",
        "line": 5160,
        "function_snippet": "__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; /* The gfp_t that was actually used for allocation */\n\tstruct alloc_context ac = { };\n\n\t/*\n\t * There are several places where we assume that the order value is sane\n\t * so bail out early if the request is out of bound.\n\t */\n\tif (unlikely(order >= MAX_ORDER)) {\n\t\tWARN_ON_ONCE(!(gfp_mask & __GFP_NOWARN));\n\t\treturn NULL;\n\t}\n\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\n\t/*\n\t * Forbid the first pass from falling back to types that fragment\n\t * memory until all local zones are considered.\n\t */\n\talloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref->zone, gfp_mask);\n\n\t/* First allocation attempt */\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1815#1815": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1815",
        "file": "mm/slub.c",
        "line": 1815,
        "function_snippet": "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p, *next;\n\tint idx;\n\tbool shuffle;\n\n\tflags &= gfp_allowed_mask;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_enable();\n\n\tflags |= s->allocflags;\n\n\t/*\n\t * Let the initial higher-order allocation fail under memory pressure\n\t * so we fall-back to the minimum order allocation.\n\t */\n\talloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) & ~__GFP_NOFAIL;\n\tif ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))\n\t\talloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1817#1817": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1817",
        "file": "mm/slub.c",
        "line": 1817,
        "function_snippet": "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_order_objects oo = s->oo;\n\tgfp_t alloc_gfp;\n\tvoid *start, *p, *next;\n\tint idx;\n\tbool shuffle;\n\n\tflags &= gfp_allowed_mask;\n\n\tif (gfpflags_allow_blocking(flags))\n\t\tlocal_irq_enable();\n\n\tflags |= s->allocflags;\n\n\t/*\n\t * Let the initial higher-order allocation fail under memory pressure\n\t * so we fall-back to the minimum order allocation.\n\t */\n\talloc_gfp = (flags | __GFP_NOWARN | __GFP_NORETRY) & ~__GFP_NOFAIL;\n\tif ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))\n\t\talloc_gfp = (alloc_gfp | __GFP_NOMEMALLOC) & ~(__GFP_RECLAIM|__GFP_NOFAIL);\n\n\tpage = alloc_slab_page(s, alloc_gfp, node, oo);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1878#1878": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1878",
        "file": "mm/slub.c",
        "line": 1878,
        "function_snippet": "\treturn allocate_slab(s,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2636#2636": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2636",
        "file": "mm/slub.c",
        "line": 2636,
        "function_snippet": "static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,\n\t\t\tint node, struct kmem_cache_cpu **pc)\n{\n\tvoid *freelist;\n\tstruct kmem_cache_cpu *c = *pc;\n\tstruct page *page;\n\n\tWARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));\n\n\tfreelist = get_partial(s, flags, node, c);\n\n\tif (freelist)\n\t\treturn freelist;\n\n\tpage = new_slab(s, flags, node);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2800#2800": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2800",
        "file": "mm/slub.c",
        "line": 2800,
        "function_snippet": "static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *freelist;\n\tstruct page *page;\n\n\tstat(s, ALLOC_SLOWPATH);\n\n\tpage = c->page;\n\tif (!page) {\n\t\t/*\n\t\t * if the node is not online or has no normal memory, just\n\t\t * ignore the node constraint\n\t\t */\n\t\tif (unlikely(node != NUMA_NO_NODE &&\n\t\t\t     !node_state(node, N_NORMAL_MEMORY)))\n\t\t\tnode = NUMA_NO_NODE;\n\t\tgoto new_slab;\n\t}\nredo:\n\n\tif (unlikely(!node_match(page, node))) {\n\t\t/*\n\t\t * same as above but node_match() being false already\n\t\t * implies node != NUMA_NO_NODE\n\t\t */\n\t\tif (!node_state(node, N_NORMAL_MEMORY)) {\n\t\t\tnode = NUMA_NO_NODE;\n\t\t\tgoto redo;\n\t\t} else {\n\t\t\tstat(s, ALLOC_NODE_MISMATCH);\n\t\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\t\tgoto new_slab;\n\t\t}\n\t}\n\n\t/*\n\t * By rights, we should be searching for a slab page that was\n\t * PFMEMALLOC but right now, we are losing the pfmemalloc\n\t * information when the page leaves the per-cpu allocator\n\t */\n\tif (unlikely(!pfmemalloc_match(page, gfpflags))) {\n\t\tdeactivate_slab(s, page, c->freelist, c);\n\t\tgoto new_slab;\n\t}\n\n\t/* must check again c->freelist in case of cpu migration or IRQ */\n\tfreelist = c->freelist;\n\tif (freelist)\n\t\tgoto load_freelist;\n\n\tfreelist = get_freelist(s, page);\n\n\tif (!freelist) {\n\t\tc->page = NULL;\n\t\tc->tid = next_tid(c->tid);\n\t\tstat(s, DEACTIVATE_BYPASS);\n\t\tgoto new_slab;\n\t}\n\n\tstat(s, ALLOC_REFILL);\n\nload_freelist:\n\t/*\n\t * freelist is pointing to the list of objects to be used.\n\t * page is pointing to the page from which the objects are obtained.\n\t * That page must be frozen for per cpu allocations to work.\n\t */\n\tVM_BUG_ON(!c->page->frozen);\n\tc->freelist = get_freepointer(s, freelist);\n\tc->tid = next_tid(c->tid);\n\treturn freelist;\n\nnew_slab:\n\n\tif (slub_percpu_partial(c)) {\n\t\tpage = c->page = slub_percpu_partial(c);\n\t\tslub_set_percpu_partial(c, page);\n\t\tstat(s, CPU_PARTIAL_ALLOC);\n\t\tgoto redo;\n\t}\n\n\tfreelist = new_slab_objects(s, gfpflags, node, &c);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2840#2840": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2840",
        "file": "mm/slub.c",
        "line": 2840,
        "function_snippet": "static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,\n\t\t\t  unsigned long addr, struct kmem_cache_cpu *c)\n{\n\tvoid *p;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n#ifdef CONFIG_PREEMPTION\n\t/*\n\t * We may have been preempted and rescheduled on a different\n\t * cpu before disabling interrupts. Need to reload cpu area\n\t * pointer.\n\t */\n\tc = this_cpu_ptr(s->cpu_slab);\n#endif\n\n\tp = ___slab_alloc(s, gfpflags, node, addr, c);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2922#2922": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2922",
        "file": "mm/slub.c",
        "line": 2922,
        "function_snippet": "static __always_inline void *slab_alloc_node(struct kmem_cache *s,\n\t\tgfp_t gfpflags, int node, unsigned long addr, size_t orig_size)\n{\n\tvoid *object;\n\tstruct kmem_cache_cpu *c;\n\tstruct page *page;\n\tunsigned long tid;\n\tstruct obj_cgroup *objcg = NULL;\n\tbool init = false;\n\n\ts = slab_pre_alloc_hook(s, &objcg, 1, gfpflags);\n\tif (!s)\n\t\treturn NULL;\n\n\tobject = kfence_alloc(s, orig_size, gfpflags);\n\tif (unlikely(object))\n\t\tgoto out;\n\nredo:\n\t/*\n\t * Must read kmem_cache cpu data via this cpu ptr. Preemption is\n\t * enabled. We may switch back and forth between cpus while\n\t * reading from one cpu area. That does not matter as long\n\t * as we end up on the original cpu again when doing the cmpxchg.\n\t *\n\t * We should guarantee that tid and kmem_cache are retrieved on\n\t * the same cpu. It could be different if CONFIG_PREEMPTION so we need\n\t * to check if it is matched or not.\n\t */\n\tdo {\n\t\ttid = this_cpu_read(s->cpu_slab->tid);\n\t\tc = raw_cpu_ptr(s->cpu_slab);\n\t} while (IS_ENABLED(CONFIG_PREEMPTION) &&\n\t\t unlikely(tid != READ_ONCE(c->tid)));\n\n\t/*\n\t * Irqless object alloc/free algorithm used here depends on sequence\n\t * of fetching cpu_slab's data. tid should be fetched before anything\n\t * on c to guarantee that object and page associated with previous tid\n\t * won't be used with current tid. If we fetch tid first, object and\n\t * page could be one associated with next tid and our alloc/free\n\t * request will be failed. In this case, we will retry. So, no problem.\n\t */\n\tbarrier();\n\n\t/*\n\t * The transaction ids are globally unique per cpu and per operation on\n\t * a per cpu queue. Thus they can be guarantee that the cmpxchg_double\n\t * occurs on the right processor and that there was no operation on the\n\t * linked list in between.\n\t */\n\n\tobject = c->freelist;\n\tpage = c->page;\n\tif (unlikely(!object || !page || !node_match(page, node))) {\n\t\tobject = __slab_alloc(s, gfpflags, node, addr, c);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#28#28": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#28",
        "file": "include/linux/page_owner.h",
        "line": 28,
        "function_snippet": "\t\t__reset_page_owner(page, order);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1332#1332": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1332",
        "file": "mm/page_alloc.c",
        "line": 1332,
        "function_snippet": "static __always_inline bool free_pages_prepare(struct page *page,\n\t\t\tunsigned int order, bool check_free, fpi_t fpi_flags)\n{\n\tint bad = 0;\n\tbool skip_kasan_poison = should_skip_kasan_poison(page, fpi_flags);\n\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\n\ttrace_mm_page_free(page, order);\n\n\tif (unlikely(PageHWPoison(page)) && !order) {\n\t\t/*\n\t\t * Do not let hwpoison pages hit pcplists/buddy\n\t\t * Untie memcg state and reset page's owner\n\t\t */\n\t\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\t\t__memcg_kmem_uncharge_page(page, order);\n\t\treset_page_owner(page, order);\n\t\tfree_page_pinner(page, order);\n\t\treturn false;\n\t}\n\n\t/*\n\t * Check tail pages before head page information is cleared to\n\t * avoid checking PageCompound for order-0 pages.\n\t */\n\tif (unlikely(order)) {\n\t\tbool compound = PageCompound(page);\n\t\tint i;\n\n\t\tVM_BUG_ON_PAGE(compound && compound_order(page) != order, page);\n\n\t\tif (compound)\n\t\t\tClearPageDoubleMap(page);\n\t\tfor (i = 1; i < (1 << order); i++) {\n\t\t\tif (compound)\n\t\t\t\tbad += free_tail_pages_check(page, page + i);\n\t\t\tif (unlikely(check_free_page(page + i))) {\n\t\t\t\tbad++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\t\t}\n\t}\n\tif (PageMappingFlags(page))\n\t\tpage->mapping = NULL;\n\tif (memcg_kmem_enabled() && PageKmemcg(page))\n\t\t__memcg_kmem_uncharge_page(page, order);\n\tif (check_free)\n\t\tbad += check_free_page(page);\n\tif (bad)\n\t\treturn false;\n\n\tpage_cpupid_reset_last(page);\n\tpage->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;\n\treset_page_owner(page, order);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1612#1612": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1612",
        "file": "mm/page_alloc.c",
        "line": 1612,
        "function_snippet": "static void __free_pages_ok(struct page *page, unsigned int order,\n\t\t\t    fpi_t fpi_flags)\n{\n\tunsigned long flags;\n\tint migratetype;\n\tunsigned long pfn = page_to_pfn(page);\n\n\tif (!free_pages_prepare(page, order, true, fpi_flags))"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#717#717": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#717",
        "file": "mm/page_alloc.c",
        "line": 717,
        "function_snippet": "\t__free_pages_ok(page, compound_order(page), FPI_NONE);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#959#959": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#959",
        "file": "include/linux/mm.h",
        "line": 959,
        "function_snippet": "\tVM_BUG_ON_PAGE(page[1].compound_dtor >= NR_COMPOUND_DTORS, page);\n\tcompound_page_dtors[page[1].compound_dtor](page);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#115#115": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#115",
        "file": "mm/swap.c",
        "line": 115,
        "function_snippet": "\tdestroy_compound_page(page);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#131#131": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#131",
        "file": "mm/swap.c",
        "line": 131,
        "function_snippet": "void __put_page(struct page *page)\n{\n\tif (is_zone_device_page(page)) {\n\t\tput_dev_pagemap(page->pgmap);\n\n\t\t/*\n\t\t * The page belongs to the device that created pgmap. Do\n\t\t * not return it to page allocator.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (unlikely(PageCompound(page)))\n\t\t__put_compound_page(page);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#1255#1255": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#1255",
        "file": "include/linux/mm.h",
        "line": 1255,
        "function_snippet": "static inline void put_page(struct page *page)\n{\n\tpage = compound_head(page);\n\n\t/*\n\t * For devmap managed pages we need to catch refcount transition from\n\t * 2 to 1, when refcount reach one it means the page is free and we\n\t * need to inform the device driver through callback. See\n\t * include/linux/memremap.h and HMM for details.\n\t */\n\tif (page_is_devmap_managed(page)) {\n\t\tput_devmap_managed_page(page);\n\t\treturn;\n\t}\n\n\tif (put_page_testzero(page))\n\t\t__put_page(page);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/skbuff.h#3065#3065": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/skbuff.h#3065",
        "file": "include/linux/skbuff.h",
        "line": 3065,
        "function_snippet": "static inline void __skb_frag_unref(skb_frag_t *frag)\n{\n\tput_page(skb_frag_page(frag));"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#619#619": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#619",
        "file": "net/core/skbuff.c",
        "line": 619,
        "function_snippet": "static void skb_release_data(struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint i;\n\n\tif (skb->cloned &&\n\t    atomic_sub_return(skb->nohdr ? (1 << SKB_DATAREF_SHIFT) + 1 : 1,\n\t\t\t      &shinfo->dataref))\n\t\treturn;\n\n\tfor (i = 0; i < shinfo->nr_frags; i++)\n\t\t__skb_frag_unref(&shinfo->frags[i]);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#680#680": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#680",
        "file": "net/core/skbuff.c",
        "line": 680,
        "function_snippet": "static void skb_release_all(struct sk_buff *skb)\n{\n\tskb_release_head_state(skb);\n\tif (likely(skb->head))\n\t\tskb_release_data(skb);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#694#694": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#694",
        "file": "net/core/skbuff.c",
        "line": 694,
        "function_snippet": "void __kfree_skb(struct sk_buff *skb)\n{\n\tskb_release_all(skb);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/net/sock.h#2599#2599": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/net/sock.h#2599",
        "file": "include/net/sock.h",
        "line": 2599,
        "function_snippet": "\t__kfree_skb(skb);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/tcp.c#2317#2317": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/tcp.c#2317",
        "file": "net/ipv4/tcp.c",
        "line": 2317,
        "function_snippet": "\t\tskb_queue_walk(&sk->sk_receive_queue, skb) {\n\t\t\tlast = skb;\n\t\t\t/* Now that we have two receive queues this\n\t\t\t * shouldn't happen.\n\t\t\t */\n\t\t\tif (WARN(before(*seq, TCP_SKB_CB(skb)->seq),\n\t\t\t\t \"TCP recvmsg seq # bug: copied %X, seq %X, rcvnxt %X, fl %X\\n\",\n\t\t\t\t *seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt,\n\t\t\t\t flags))\n\t\t\t\tbreak;\n\n\t\t\toffset = *seq - TCP_SKB_CB(skb)->seq;\n\t\t\tif (unlikely(TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)) {\n\t\t\t\tpr_err_once(\"%s: found a SYN, please report !\\n\", __func__);\n\t\t\t\toffset--;\n\t\t\t}\n\t\t\tif (offset < skb->len)\n\t\t\t\tgoto found_ok_skb;\n\t\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\t\tgoto found_fin_ok;\n\t\t\tWARN(!(flags & MSG_PEEK),\n\t\t\t     \"TCP recvmsg seq # bug 2: copied %X, seq %X, rcvnxt %X, fl %X\\n\",\n\t\t\t     *seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt, flags);\n\t\t}\n\n\t\t/* Well, if we have backlog, try to process it now yet. */\n\n\t\tif (copied >= target && !READ_ONCE(sk->sk_backlog.tail))\n\t\t\tbreak;\n\n\t\tif (copied) {\n\t\t\tif (sk->sk_err ||\n\t\t\t    sk->sk_state == TCP_CLOSE ||\n\t\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t\t    !timeo ||\n\t\t\t    signal_pending(current))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_err) {\n\t\t\t\tcopied = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\t/* This occurs when user tries to read\n\t\t\t\t * from never connected socket.\n\t\t\t\t */\n\t\t\t\tcopied = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!timeo) {\n\t\t\t\tcopied = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tcopied = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttcp_cleanup_rbuf(sk, copied);\n\n\t\tif (copied >= target) {\n\t\t\t/* Do not sleep, just process backlog. */\n\t\t\trelease_sock(sk);\n\t\t\tlock_sock(sk);\n\t\t} else {\n\t\t\tsk_wait_data(sk, &timeo, last);\n\t\t}\n\n\t\tif ((flags & MSG_PEEK) &&\n\t\t    (peek_seq - copied - urg_hole != tp->copied_seq)) {\n\t\t\tnet_dbg_ratelimited(\"TCP(%s:%d): Application bug, race in MSG_PEEK\\n\",\n\t\t\t\t\t    current->comm,\n\t\t\t\t\t    task_pid_nr(current));\n\t\t\tpeek_seq = tp->copied_seq;\n\t\t}\n\t\tcontinue;\n\nfound_ok_skb:\n\t\t/* Ok so how much can we use? */\n\t\tused = skb->len - offset;\n\t\tif (len < used)\n\t\t\tused = len;\n\n\t\t/* Do we have urgent data here? */\n\t\tif (tp->urg_data) {\n\t\t\tu32 urg_offset = tp->urg_seq - *seq;\n\t\t\tif (urg_offset < used) {\n\t\t\t\tif (!urg_offset) {\n\t\t\t\t\tif (!sock_flag(sk, SOCK_URGINLINE)) {\n\t\t\t\t\t\tWRITE_ONCE(*seq, *seq + 1);\n\t\t\t\t\t\turg_hole++;\n\t\t\t\t\t\toffset++;\n\t\t\t\t\t\tused--;\n\t\t\t\t\t\tif (!used)\n\t\t\t\t\t\t\tgoto skip_copy;\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t\tused = urg_offset;\n\t\t\t}\n\t\t}\n\n\t\tif (!(flags & MSG_TRUNC)) {\n\t\t\terr = skb_copy_datagram_msg(skb, offset, msg, used);\n\t\t\tif (err) {\n\t\t\t\t/* Exception. Bailout! */\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tWRITE_ONCE(*seq, *seq + used);\n\t\tcopied += used;\n\t\tlen -= used;\n\n\t\ttcp_rcv_space_adjust(sk);\n\nskip_copy:\n\t\tif (tp->urg_data && after(tp->copied_seq, tp->urg_seq)) {\n\t\t\ttp->urg_data = 0;\n\t\t\ttcp_fast_path_check(sk);\n\t\t}\n\n\t\tif (TCP_SKB_CB(skb)->has_rxtstamp) {\n\t\t\ttcp_update_recv_tstamps(skb, &tss);\n\t\t\tcmsg_flags |= 2;\n\t\t}\n\n\t\tif (used + offset < skb->len)\n\t\t\tcontinue;\n\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\t\tgoto found_fin_ok;\n\t\tif (!(flags & MSG_PEEK))\n\t\t\tsk_eat_skb(sk, skb);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/af_inet.c#852#852": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/af_inet.c#852",
        "file": "net/ipv4/af_inet.c",
        "line": 852,
        "function_snippet": "int inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,\n\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint addr_len = 0;\n\tint err;\n\n\tif (likely(!(flags & MSG_ERRQUEUE)))\n\t\tsock_rps_record_flow(sk);\n\n\terr = INDIRECT_CALL_2(sk->sk_prot->recvmsg, tcp_recvmsg, udp_recvmsg,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#886#886": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#886",
        "file": "net/socket.c",
        "line": 886,
        "function_snippet": "static inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int flags)\n{\n\treturn INDIRECT_CALL_INET(sock->ops->recvmsg, inet6_recvmsg,"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#904#904": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#904",
        "file": "net/socket.c",
        "line": 904,
        "function_snippet": "int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags)\n{\n\tint err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags);\n\n\treturn err ?: sock_recvmsg_nosec(sock, msg, flags);"
      },
      "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#977#977": {
        "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#977",
        "file": "net/socket.c",
        "line": 977,
        "function_snippet": "static ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct socket *sock = file->private_data;\n\tstruct msghdr msg = {.msg_iter = *to,\n\t\t\t     .msg_iocb = iocb};\n\tssize_t res;\n\n\tif (file->f_flags & O_NONBLOCK || (iocb->ki_flags & IOCB_NOWAIT))\n\t\tmsg.msg_flags = MSG_DONTWAIT;\n\n\tif (iocb->ki_pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (!iov_iter_count(to))\t/* Match SYS5 behaviour */\n\t\treturn 0;\n\n\tres = sock_recvmsg(sock, &msg, msg.msg_flags);"
      }
    }
  },
  "evidence": {
    "https://android.googlesource.com/kernel/common/": {
      "error": "URL not in expected +/commit/path format"
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704#3704": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)"
        ],
        [
          5,
          "ent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,"
        ],
        [
          6,
          "&retval, &ent->parent_de,"
        ],
        [
          7,
          "&ent->dir_inlined);"
        ],
        [
          8,
          "if (!ent->dir_bh)"
        ],
        [
          10,
          "if (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704",
      "source_file": "fs/ext4/namei.c",
      "source_line": 3704
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#77#77": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void __dump_stack(const char *log_lvl)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#77",
      "source_file": "lib/dump_stack.c",
      "source_line": 77
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#118#118": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "asmlinkage __visible void dump_stack_lvl(const char *log_lvl)"
        ],
        [
          8,
          "/*"
        ],
        [
          9,
          "* Permit this cpu to perform nested stack dumps while serialising"
        ],
        [
          10,
          "* against other CPUs"
        ],
        [
          11,
          "*/"
        ],
        [
          22,
          "/*"
        ],
        [
          23,
          "* Wait for the lock to release before jumping to"
        ],
        [
          24,
          "* atomic_cmpxchg() in order to mitigate the thundering herd"
        ],
        [
          26,
          "*/"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/lib/dump_stack.c#118",
      "source_file": "lib/dump_stack.c",
      "source_line": 118
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#233#233": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void print_address_description(void *addr, u8 tag)"
        ],
        [
          3,
          "struct page *page = kasan_addr_to_page(addr);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#233",
      "source_file": "mm/kasan/report.c",
      "source_line": 233
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#419#419": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          5,
          "void *tagged_addr;"
        ],
        [
          6,
          "void *untagged_addr;"
        ],
        [
          10,
          "if (current->kunit_test)"
        ],
        [
          11,
          "kasan_update_kunit_status(current->kunit_test);"
        ],
        [
          12,
          "#endif /* IS_ENABLED(CONFIG_KUNIT) */"
        ],
        [
          16,
          "tagged_addr = (void *)addr;"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#419",
      "source_file": "mm/kasan/report.c",
      "source_line": 419
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#436#436": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report.c#436",
      "source_file": "mm/kasan/report.c",
      "source_line": 436
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report_generic.c#308#308": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/report_generic.c#308",
      "source_file": "mm/kasan/report_generic.c",
      "source_line": 308
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4212#4212": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,"
        ],
        [
          2,
          "struct inode *new_dir, struct dentry *new_dentry)"
        ],
        [
          4,
          "handle_t *handle = NULL;"
        ],
        [
          20,
          "!projid_eq(EXT4_I(new_dir)->i_projid,"
        ],
        [
          21,
          "EXT4_I(old_dentry->d_inode)->i_projid)) ||"
        ],
        [
          23,
          "!projid_eq(EXT4_I(old_dir)->i_projid,"
        ],
        [
          24,
          "EXT4_I(new_dentry->d_inode)->i_projid)))"
        ],
        [
          34,
          "old.bh = ext4_find_entry(old.dir, &old.dentry->d_name,"
        ],
        [
          38,
          "/*"
        ],
        [
          40,
          "*  We might rmdir the source, keep it as pwd of some process"
        ],
        [
          41,
          "*  and merrily kill the link to whatever was created under the"
        ],
        [
          43,
          "*/"
        ],
        [
          45,
          "if (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)"
        ],
        [
          48,
          "new.bh = ext4_find_entry(new.dir, &new.dentry->d_name,"
        ],
        [
          56,
          "/* RENAME_EXCHANGE case: old *and* new must both exist */"
        ],
        [
          57,
          "if (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)"
        ],
        [
          61,
          "(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +"
        ],
        [
          62,
          "2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));"
        ],
        [
          72,
          "if (S_ISDIR(old.inode->i_mode)) {"
        ],
        [
          78,
          "if (S_ISDIR(new.inode->i_mode)) {"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4212",
      "source_file": "fs/ext4/namei.c",
      "source_line": 4212
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4296#4296": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,"
        ],
        [
          2,
          "struct inode *new_dir, struct dentry *new_dentry,"
        ],
        [
          7,
          "if (unlikely(ext4_forced_shutdown(EXT4_SB(old_dir->i_sb))))"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#4296",
      "source_file": "fs/ext4/namei.c",
      "source_line": 4296
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4389#4389": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,"
        ],
        [
          2,
          "struct inode *new_dir, struct dentry *new_dentry,"
        ],
        [
          3,
          "struct inode **delegated_inode, unsigned int flags)"
        ],
        [
          7,
          "struct inode *source = old_dentry->d_inode;"
        ],
        [
          8,
          "struct inode *target = new_dentry->d_inode;"
        ],
        [
          10,
          "unsigned max_links = new_dir->i_sb->s_max_links;"
        ],
        [
          33,
          "if (!old_dir->i_op->rename)"
        ],
        [
          36,
          "/*"
        ],
        [
          37,
          "* If we are going to change the parent - check write permissions,"
        ],
        [
          39,
          "*/"
        ],
        [
          71,
          "if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)"
        ],
        [
          74,
          "old_dir->i_nlink >= max_links)"
        ],
        [
          87,
          "error = old_dir->i_op->rename(old_dir, old_dentry,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4389",
      "source_file": "fs/namei.c",
      "source_line": 4389
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4536#4536": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int do_renameat2(int olddfd, const char __user *oldname, int newdfd,"
        ],
        [
          2,
          "const char __user *newname, unsigned int flags)"
        ],
        [
          4,
          "struct dentry *old_dentry, *new_dentry;"
        ],
        [
          5,
          "struct dentry *trap;"
        ],
        [
          9,
          "struct inode *delegated_inode = NULL;"
        ],
        [
          10,
          "struct filename *from;"
        ],
        [
          11,
          "struct filename *to;"
        ],
        [
          65,
          "/* source must exist */"
        ],
        [
          87,
          "/* unless the source is a directory trailing slashes give -ENOTDIR */"
        ],
        [
          95,
          "/* source should not be ancestor of target */"
        ],
        [
          99,
          "/* target should not be an ancestor of source */"
        ],
        [
          109,
          "error = vfs_rename(old_path.dentry->d_inode, old_dentry,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4536",
      "source_file": "fs/namei.c",
      "source_line": 4536
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4571#4571": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4571",
      "source_file": "fs/namei.c",
      "source_line": 4571
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568#4568": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/namei.c#4568",
      "source_file": "fs/namei.c",
      "source_line": 4568
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46#46": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "__visible noinstr void do_syscall_64(unsigned long nr, struct pt_regs *regs)"
        ],
        [
          8,
          "regs->ax = sys_call_table[nr](regs);"
        ],
        [
          8,
          "regs->ax = sys_call_table[nr](regs);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46",
      "source_file": "arch/x86/entry/common.c",
      "source_line": 46
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38#38": {
      "dereference": false,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          3,
          "unsigned long entries[KASAN_STACK_DEPTH];"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38",
      "source_file": "mm/kasan/common.c",
      "source_line": 38
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46#46": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void kasan_set_track(struct kasan_track *track, gfp_t flags)"
        ],
        [
          3,
          "track->pid = current->pid;"
        ],
        [
          4,
          "track->stack = kasan_save_stack(flags);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46",
      "source_file": "mm/kasan/common.c",
      "source_line": 46
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428#428": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "kasan_set_track(&alloc_meta->alloc_track, flags);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428",
      "source_file": "mm/kasan/common.c",
      "source_line": 428
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461#461": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [
        [
          25,
          "* For kmalloc() allocations, kasan_kmalloc() will do precise poisoning."
        ],
        [
          29,
          "/* Save alloc info (if possible) for non-kmalloc() allocations. */"
        ]
      ],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void * __must_check __kasan_slab_alloc(struct kmem_cache *cache,"
        ],
        [
          2,
          "void *object, gfp_t flags, bool init)"
        ],
        [
          5,
          "void *tagged_object;"
        ],
        [
          14,
          "return (void *)object;"
        ],
        [
          16,
          "/*"
        ],
        [
          19,
          "*/"
        ],
        [
          23,
          "/*"
        ],
        [
          26,
          "*/"
        ],
        [
          27,
          "kasan_unpoison(tagged_object, cache->object_size, init);"
        ],
        [
          31,
          "set_alloc_info(cache, (void *)object, flags, false);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461",
      "source_file": "mm/kasan/common.c",
      "source_line": 461
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259#259": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline void * __must_check kasan_slab_alloc("
        ],
        [
          2,
          "struct kmem_cache *s, void *object, gfp_t flags, bool init)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259",
      "source_file": "include/linux/kasan.h",
      "source_line": 259
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583#583": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline void slab_post_alloc_hook(struct kmem_cache *s,"
        ],
        [
          2,
          "struct obj_cgroup *objcg, gfp_t flags,"
        ],
        [
          3,
          "size_t size, void **p, bool init)"
        ],
        [
          9,
          "/*"
        ],
        [
          10,
          "* As memory initialization might be integrated into KASAN,"
        ],
        [
          11,
          "* kasan_slab_alloc and initialization memset must be"
        ],
        [
          13,
          "*"
        ],
        [
          14,
          "* As p[i] might get tagged, memset and kmemleak hook come after KASAN."
        ],
        [
          15,
          "*/"
        ],
        [
          17,
          "p[i] = kasan_slab_alloc(s, p[i], flags, init);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583",
      "source_file": "include/../mm/slab.h",
      "source_line": 583
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956#2956": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline void *slab_alloc_node(struct kmem_cache *s,"
        ],
        [
          4,
          "void *object;"
        ],
        [
          5,
          "struct kmem_cache_cpu *c;"
        ],
        [
          6,
          "struct page *page;"
        ],
        [
          8,
          "struct obj_cgroup *objcg = NULL;"
        ],
        [
          20,
          "/*"
        ],
        [
          25,
          "*"
        ],
        [
          26,
          "* We should guarantee that tid and kmem_cache are retrieved on"
        ],
        [
          29,
          "*/"
        ],
        [
          31,
          "tid = this_cpu_read(s->cpu_slab->tid);"
        ],
        [
          32,
          "c = raw_cpu_ptr(s->cpu_slab);"
        ],
        [
          34,
          "unlikely(tid != READ_ONCE(c->tid)));"
        ],
        [
          36,
          "/*"
        ],
        [
          37,
          "* Irqless object alloc/free algorithm used here depends on sequence"
        ],
        [
          39,
          "* on c to guarantee that object and page associated with previous tid"
        ],
        [
          41,
          "* page could be one associated with next tid and our alloc/free"
        ],
        [
          43,
          "*/"
        ],
        [
          46,
          "/*"
        ],
        [
          47,
          "* The transaction ids are globally unique per cpu and per operation on"
        ],
        [
          49,
          "* occurs on the right processor and that there was no operation on the"
        ],
        [
          51,
          "*/"
        ],
        [
          53,
          "object = c->freelist;"
        ],
        [
          54,
          "page = c->page;"
        ],
        [
          58,
          "void *next_object = get_freepointer_safe(s, object);"
        ],
        [
          60,
          "/*"
        ],
        [
          61,
          "* The cmpxchg will only match if there was no additional"
        ],
        [
          63,
          "*"
        ],
        [
          64,
          "* The cmpxchg does the following atomically (without lock"
        ],
        [
          65,
          "* semantics!)"
        ],
        [
          69,
          "*"
        ],
        [
          70,
          "* Since this is without lock semantics the protection is only"
        ],
        [
          71,
          "* against code executing on this cpu *not* from access by"
        ],
        [
          73,
          "*/"
        ],
        [
          75,
          "s->cpu_slab->freelist, s->cpu_slab->tid,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956",
      "source_file": "mm/slub.c",
      "source_line": 2956
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964#2964": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964",
      "source_file": "mm/slub.c",
      "source_line": 2964
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969#2969": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [
        [
          1,
          "void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)"
        ]
      ],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void *kmem_cache_alloc(struct kmem_cache *s, gfp_t gfpflags)"
        ],
        [
          3,
          "void *ret = slab_alloc(s, gfpflags, _RET_IP_, s->object_size);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969",
      "source_file": "mm/slub.c",
      "source_line": 2969
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403#1403": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static struct mm_struct *dup_mm(struct task_struct *tsk,"
        ],
        [
          2,
          "struct mm_struct *oldmm)"
        ],
        [
          4,
          "struct mm_struct *mm;"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403",
      "source_file": "kernel/fork.c",
      "source_line": 1403
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468#1468": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)"
        ],
        [
          3,
          "struct mm_struct *mm, *oldmm;"
        ],
        [
          6,
          "tsk->min_flt = tsk->maj_flt = 0;"
        ],
        [
          7,
          "tsk->nvcsw = tsk->nivcsw = 0;"
        ],
        [
          9,
          "tsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;"
        ],
        [
          10,
          "tsk->last_switch_time = 0;"
        ],
        [
          13,
          "tsk->mm = NULL;"
        ],
        [
          14,
          "tsk->active_mm = NULL;"
        ],
        [
          16,
          "/*"
        ],
        [
          17,
          "* Are we cloning a kernel thread?"
        ],
        [
          18,
          "*"
        ],
        [
          20,
          "*/"
        ],
        [
          21,
          "oldmm = current->mm;"
        ],
        [
          25,
          "/* initialize the new vmacache entries */"
        ],
        [
          35,
          "mm = dup_mm(tsk, current->mm);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468",
      "source_file": "kernel/fork.c",
      "source_line": 1468
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152#2152": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "if (p->real_cred->user != INIT_USER &&"
        ],
        [
          6,
          "current->flags &= ~PF_NPROC_EXCEEDED;"
        ],
        [
          12,
          "/*"
        ],
        [
          13,
          "* If multiple threads are within copy_process(), then this check"
        ],
        [
          16,
          "*/"
        ],
        [
          21,
          "delayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */"
        ],
        [
          22,
          "p->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);"
        ],
        [
          23,
          "p->flags |= PF_FORKNOEXEC;"
        ],
        [
          24,
          "INIT_LIST_HEAD(&p->children);"
        ],
        [
          25,
          "INIT_LIST_HEAD(&p->sibling);"
        ],
        [
          27,
          "p->vfork_done = NULL;"
        ],
        [
          28,
          "spin_lock_init(&p->alloc_lock);"
        ],
        [
          30,
          "init_sigpending(&p->pending);"
        ],
        [
          32,
          "p->utime = p->stime = p->gtime = 0;"
        ],
        [
          34,
          "p->utimescaled = p->stimescaled = 0;"
        ],
        [
          36,
          "prev_cputime_init(&p->prev_cputime);"
        ],
        [
          39,
          "seqcount_init(&p->vtime.seqcount);"
        ],
        [
          40,
          "p->vtime.starttime = 0;"
        ],
        [
          41,
          "p->vtime.state = VTIME_INACTIVE;"
        ],
        [
          45,
          "p->io_uring = NULL;"
        ],
        [
          49,
          "memset(&p->rss_stat, 0, sizeof(p->rss_stat));"
        ],
        [
          52,
          "p->default_timer_slack_ns = current->timer_slack_ns;"
        ],
        [
          55,
          "p->psi_flags = 0;"
        ],
        [
          58,
          "task_io_accounting_init(&p->ioac);"
        ],
        [
          61,
          "posix_cputimers_init(&p->posix_cputimers);"
        ],
        [
          63,
          "p->io_context = NULL;"
        ],
        [
          67,
          "p->mempolicy = mpol_dup(p->mempolicy);"
        ],
        [
          68,
          "if (IS_ERR(p->mempolicy)) {"
        ],
        [
          69,
          "retval = PTR_ERR(p->mempolicy);"
        ],
        [
          70,
          "p->mempolicy = NULL;"
        ],
        [
          75,
          "p->cpuset_mem_spread_rotor = NUMA_NO_NODE;"
        ],
        [
          76,
          "p->cpuset_slab_spread_rotor = NUMA_NO_NODE;"
        ],
        [
          77,
          "seqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);"
        ],
        [
          80,
          "memset(&p->irqtrace, 0, sizeof(p->irqtrace));"
        ],
        [
          81,
          "p->irqtrace.hardirq_disable_ip\t= _THIS_IP_;"
        ],
        [
          82,
          "p->irqtrace.softirq_enable_ip\t= _THIS_IP_;"
        ],
        [
          83,
          "p->softirqs_enabled\t\t= 1;"
        ],
        [
          84,
          "p->softirq_context\t\t= 0;"
        ],
        [
          87,
          "p->pagefault_disabled = 0;"
        ],
        [
          94,
          "p->blocked_on = NULL; /* not blocked yet */"
        ],
        [
          97,
          "p->sequential_io\t= 0;"
        ],
        [
          98,
          "p->sequential_io_avg\t= 0;"
        ],
        [
          112,
          "/* copy all the process information */"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152",
      "source_file": "kernel/fork.c",
      "source_line": 2152
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524#2524": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "pid_t kernel_clone(struct kernel_clone_args *args)"
        ],
        [
          3,
          "u64 clone_flags = args->flags;"
        ],
        [
          5,
          "struct pid *pid;"
        ],
        [
          6,
          "struct task_struct *p;"
        ],
        [
          10,
          "/*"
        ],
        [
          11,
          "* For legacy clone() calls, CLONE_PIDFD uses the parent_tid argument"
        ],
        [
          14,
          "* field in struct clone_args and it still doesn't make sense to have"
        ],
        [
          16,
          "* here has the advantage that we don't need to have a separate helper"
        ],
        [
          18,
          "*/"
        ],
        [
          19,
          "if ((args->flags & CLONE_PIDFD) &&"
        ],
        [
          20,
          "(args->flags & CLONE_PARENT_SETTID) &&"
        ],
        [
          21,
          "(args->pidfd == args->parent_tid))"
        ],
        [
          24,
          "/*"
        ],
        [
          26,
          "* called from kernel_thread or CLONE_UNTRACED is explicitly"
        ],
        [
          27,
          "* requested, no event is reported; otherwise, report if the event"
        ],
        [
          29,
          "*/"
        ],
        [
          33,
          "else if (args->exit_signal != SIGCHLD)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524",
      "source_file": "kernel/fork.c",
      "source_line": 2524
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643#2643": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "int __user *, parent_tidptr,"
        ],
        [
          3,
          "int __user *, child_tidptr,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643",
      "source_file": "kernel/fork.c",
      "source_line": 2643
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627#2627": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627",
      "source_file": "kernel/fork.c",
      "source_line": 2627
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357#357": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void kasan_set_free_info(struct kmem_cache *cache,"
        ],
        [
          2,
          "void *object, u8 tag)"
        ],
        [
          4,
          "struct kasan_free_meta *free_meta;"
        ],
        [
          10,
          "kasan_set_track(&free_meta->free_track, GFP_NOWAIT);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357",
      "source_file": "mm/kasan/generic.c",
      "source_line": 357
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360#360": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline bool ____kasan_slab_free(struct kmem_cache *cache, void *object,"
        ],
        [
          5,
          "void *tagged_object;"
        ],
        [
          20,
          "/* RCU slabs could be legally used after free within the RCU period */"
        ],
        [
          21,
          "if (unlikely(cache->flags & SLAB_TYPESAFE_BY_RCU))"
        ],
        [
          29,
          "kasan_poison(object, round_up(cache->object_size, KASAN_GRANULE_SIZE),"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360",
      "source_file": "mm/kasan/common.c",
      "source_line": 360
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368#368": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368",
      "source_file": "mm/kasan/common.c",
      "source_line": 368
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235#235": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [
        [
          1,
          "return __kasan_slab_free(s, object, _RET_IP_, init);"
        ]
      ],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235",
      "source_file": "include/linux/kasan.h",
      "source_line": 235
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604#1604": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604",
      "source_file": "mm/slub.c",
      "source_line": 1604
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630#1630": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline bool slab_free_freelist_hook(struct kmem_cache *s,"
        ],
        [
          2,
          "void **head, void **tail,"
        ],
        [
          3,
          "int *cnt)"
        ],
        [
          6,
          "void *object;"
        ],
        [
          7,
          "void *next = *head;"
        ],
        [
          8,
          "void *old_tail = *tail ? *tail : *head;"
        ],
        [
          15,
          "/* Head and tail of the reconstructed freelist */"
        ],
        [
          16,
          "*head = NULL;"
        ],
        [
          17,
          "*tail = NULL;"
        ],
        [
          23,
          "/* If object's reuse doesn't have to be delayed */"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630",
      "source_file": "mm/slub.c",
      "source_line": 1630
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212#3212": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline void slab_free(struct kmem_cache *s, struct page *page,"
        ],
        [
          2,
          "void *head, void *tail, int cnt,"
        ],
        [
          5,
          "/*"
        ],
        [
          6,
          "* With KASAN enabled slab_free_freelist_hook modifies the freelist"
        ],
        [
          8,
          "*/"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212",
      "source_file": "mm/slub.c",
      "source_line": 3212
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228#3228": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [
        [
          1,
          "void kmem_cache_free(struct kmem_cache *s, void *x)"
        ]
      ],
      "nearby_lines": [
        [
          1,
          "void kmem_cache_free(struct kmem_cache *s, void *x)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228",
      "source_file": "mm/slub.c",
      "source_line": 3228
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722#722": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722",
      "source_file": "kernel/fork.c",
      "source_line": 722
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49#49": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline void mmdrop(struct mm_struct *mm)"
        ],
        [
          3,
          "/*"
        ],
        [
          4,
          "* The implicit full barrier implied by atomic_dec_and_test() is"
        ],
        [
          5,
          "* required by the membarrier system call before returning to"
        ],
        [
          6,
          "* user-space, after storing to rq->curr."
        ],
        [
          7,
          "*/"
        ],
        [
          8,
          "if (unlikely(atomic_dec_and_test(&mm->mm_count)))"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49",
      "source_file": "include/linux/sched/mm.h",
      "source_line": 49
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892#3892": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "__releases(rq->lock)"
        ],
        [
          3,
          "struct rq *rq = this_rq();"
        ],
        [
          4,
          "struct mm_struct *mm = rq->prev_mm;"
        ],
        [
          7,
          "/*"
        ],
        [
          8,
          "* The previous task will have left us with a preempt_count of 2"
        ],
        [
          9,
          "* because it left us after:"
        ],
        [
          10,
          "*"
        ],
        [
          11,
          "*\tschedule()"
        ],
        [
          12,
          "*\t  preempt_disable();\t\t\t// 1"
        ],
        [
          13,
          "*\t  __schedule()"
        ],
        [
          14,
          "*\t    raw_spin_lock_irq(&rq->lock)\t// 2"
        ],
        [
          15,
          "*"
        ],
        [
          17,
          "*/"
        ],
        [
          18,
          "if (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,"
        ],
        [
          20,
          "current->comm, current->pid, preempt_count()))"
        ],
        [
          23,
          "rq->prev_mm = NULL;"
        ],
        [
          25,
          "/*"
        ],
        [
          27,
          "* If a task dies, then it sets TASK_DEAD in tsk->state and calls"
        ],
        [
          30,
          "*"
        ],
        [
          31,
          "* We must observe prev->state before clearing prev->on_cpu (in"
        ],
        [
          32,
          "* finish_task), otherwise a concurrent wakeup can get prev"
        ],
        [
          33,
          "* running on another CPU and we could rave with its RUNNING -> DEAD"
        ],
        [
          35,
          "*/"
        ],
        [
          36,
          "prev_state = prev->state;"
        ],
        [
          45,
          "/*"
        ],
        [
          46,
          "* When switching through a kernel thread, the loop in"
        ],
        [
          47,
          "* membarrier_{private,global}_expedited() may have observed that"
        ],
        [
          49,
          "* schedule between user->kernel->user threads without passing though"
        ],
        [
          51,
          "* rq->curr, before returning to userspace, so provide them here:"
        ],
        [
          52,
          "*"
        ],
        [
          53,
          "* - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly"
        ],
        [
          54,
          "*   provided by mmdrop(),"
        ],
        [
          56,
          "*/"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892",
      "source_file": "kernel/sched/core.c",
      "source_line": 3892
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038#4038": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "context_switch(struct rq *rq, struct task_struct *prev,"
        ],
        [
          2,
          "struct task_struct *next, struct rq_flags *rf)"
        ],
        [
          6,
          "/*"
        ],
        [
          7,
          "* For paravirt, this is coupled with an exit in switch_to to"
        ],
        [
          8,
          "* combine the page table reload and the switch backend into"
        ],
        [
          10,
          "*/"
        ],
        [
          13,
          "/*"
        ],
        [
          14,
          "* kernel -> kernel   lazy + transfer active"
        ],
        [
          15,
          "*   user -> kernel   lazy + mmgrab() active"
        ],
        [
          16,
          "*"
        ],
        [
          17,
          "* kernel ->   user   switch + mmdrop() active"
        ],
        [
          18,
          "*   user ->   user   switch"
        ],
        [
          19,
          "*/"
        ],
        [
          20,
          "if (!next->mm) {                                // to kernel"
        ],
        [
          21,
          "enter_lazy_tlb(prev->active_mm, next);"
        ],
        [
          23,
          "next->active_mm = prev->active_mm;"
        ],
        [
          24,
          "if (prev->mm)                           // from user"
        ],
        [
          25,
          "mmgrab(prev->active_mm);"
        ],
        [
          27,
          "prev->active_mm = NULL;"
        ],
        [
          29,
          "membarrier_switch_mm(rq, prev->active_mm, next->mm);"
        ],
        [
          30,
          "/*"
        ],
        [
          31,
          "* sys_membarrier() requires an smp_mb() between setting"
        ],
        [
          32,
          "* rq->curr / membarrier_switch_mm() and returning to userspace."
        ],
        [
          33,
          "*"
        ],
        [
          34,
          "* The below provides this either through switch_mm(), or in"
        ],
        [
          35,
          "* case 'prev->active_mm == next->mm' through"
        ],
        [
          37,
          "*/"
        ],
        [
          38,
          "switch_mm_irqs_off(prev->active_mm, next->mm, next);"
        ],
        [
          40,
          "if (!prev->mm) {                        // from kernel"
        ],
        [
          42,
          "rq->prev_mm = prev->active_mm;"
        ],
        [
          43,
          "prev->active_mm = NULL;"
        ],
        [
          47,
          "rq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038",
      "source_file": "kernel/sched/core.c",
      "source_line": 4038
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796#4796": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          3,
          "struct task_struct *prev, *next;"
        ],
        [
          4,
          "unsigned long *switch_count;"
        ],
        [
          7,
          "struct rq *rq;"
        ],
        [
          12,
          "prev = rq->curr;"
        ],
        [
          22,
          "/*"
        ],
        [
          23,
          "* Make sure that signal_pending_state()->signal_pending() below"
        ],
        [
          24,
          "* can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)"
        ],
        [
          25,
          "* done by the caller to avoid the race with signal_wake_up():"
        ],
        [
          26,
          "*"
        ],
        [
          27,
          "* __set_current_state(@state)\t\tsignal_wake_up()"
        ],
        [
          28,
          "* schedule()\t\t\t\t  set_tsk_thread_flag(p, TIF_SIGPENDING)"
        ],
        [
          29,
          "*\t\t\t\t\t  wake_up_state(p, state)"
        ],
        [
          30,
          "*   LOCK rq->lock\t\t\t    LOCK p->pi_state"
        ],
        [
          31,
          "*   smp_mb__after_spinlock()\t\t    smp_mb__after_spinlock()"
        ],
        [
          32,
          "*     if (signal_pending_state())\t    if (p->state & @state)"
        ],
        [
          33,
          "*"
        ],
        [
          34,
          "* Also, the membarrier system call requires a full memory barrier"
        ],
        [
          35,
          "* after coming from user-space, before storing to rq->curr."
        ],
        [
          36,
          "*/"
        ],
        [
          40,
          "/* Promote REQ to ACT */"
        ],
        [
          41,
          "rq->clock_update_flags <<= 1;"
        ],
        [
          44,
          "switch_count = &prev->nivcsw;"
        ],
        [
          46,
          "/*"
        ],
        [
          47,
          "* We must load prev->state once (task_struct::state is volatile), such"
        ],
        [
          48,
          "* that:"
        ],
        [
          49,
          "*"
        ],
        [
          51,
          "*  - ptrace_{,un}freeze_traced() can change ->state underneath us."
        ],
        [
          52,
          "*/"
        ],
        [
          53,
          "prev_state = prev->state;"
        ],
        [
          56,
          "prev->state = TASK_RUNNING;"
        ],
        [
          58,
          "prev->sched_contributes_to_load ="
        ],
        [
          61,
          "!(prev->flags & PF_FROZEN);"
        ],
        [
          63,
          "if (prev->sched_contributes_to_load)"
        ],
        [
          64,
          "rq->nr_uninterruptible++;"
        ],
        [
          66,
          "/*"
        ],
        [
          67,
          "* __schedule()\t\t\tttwu()"
        ],
        [
          68,
          "*   prev_state = prev->state;    if (p->on_rq && ...)"
        ],
        [
          69,
          "*   if (prev_state)\t\t    goto out;"
        ],
        [
          70,
          "*     p->on_rq = 0;\t\t  smp_acquire__after_ctrl_dep();"
        ],
        [
          71,
          "*\t\t\t\t  p->state = TASK_WAKING"
        ],
        [
          72,
          "*"
        ],
        [
          74,
          "*"
        ],
        [
          75,
          "* After this, schedule() must not care about p->state any more."
        ],
        [
          76,
          "*/"
        ],
        [
          79,
          "if (prev->in_iowait) {"
        ],
        [
          80,
          "atomic_inc(&rq->nr_iowait);"
        ],
        [
          84,
          "switch_count = &prev->nvcsw;"
        ],
        [
          93,
          "rq->nr_switches++;"
        ],
        [
          94,
          "/*"
        ],
        [
          95,
          "* RCU users of rcu_dereference(rq->curr) may not see"
        ],
        [
          97,
          "*/"
        ],
        [
          98,
          "RCU_INIT_POINTER(rq->curr, next);"
        ],
        [
          99,
          "/*"
        ],
        [
          100,
          "* The membarrier system call requires each architecture"
        ],
        [
          101,
          "* to have a full memory barrier after updating"
        ],
        [
          102,
          "* rq->curr, before returning to user-space."
        ],
        [
          103,
          "*"
        ],
        [
          104,
          "* Here are the schemes providing that barrier on the"
        ],
        [
          105,
          "* various architectures:"
        ],
        [
          108,
          "* - finish_lock_switch() for weakly-ordered"
        ],
        [
          109,
          "*   architectures where spin_unlock is a full barrier,"
        ],
        [
          110,
          "* - switch_to() for arm64 (weakly-ordered, spin_unlock"
        ],
        [
          111,
          "*   is a RELEASE barrier),"
        ],
        [
          112,
          "*/"
        ],
        [
          113,
          "++*switch_count;"
        ],
        [
          119,
          "/* Also unlocks the rq: */"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796",
      "source_file": "kernel/sched/core.c",
      "source_line": 4796
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874#4874": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          3,
          "struct task_struct *tsk = current;"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874",
      "source_file": "kernel/sched/core.c",
      "source_line": 4874
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378#378": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "pipe_read(struct kiocb *iocb, struct iov_iter *to)"
        ],
        [
          4,
          "struct file *filp = iocb->ki_filp;"
        ],
        [
          5,
          "struct pipe_inode_info *pipe = filp->private_data;"
        ],
        [
          16,
          "/*"
        ],
        [
          17,
          "* We only wake up writers if the pipe was full when we started"
        ],
        [
          19,
          "*"
        ],
        [
          20,
          "* But when we do wake up writers, we do so using a sync wakeup"
        ],
        [
          21,
          "* (WF_SYNC), because we want them to get going and generate more"
        ],
        [
          23,
          "*/"
        ],
        [
          24,
          "was_full = pipe_full(pipe->head, pipe->tail, pipe->max_usage);"
        ],
        [
          26,
          "/* Read ->head with a barrier vs post_one_notification() */"
        ],
        [
          27,
          "unsigned int head = smp_load_acquire(&pipe->head);"
        ],
        [
          28,
          "unsigned int tail = pipe->tail;"
        ],
        [
          29,
          "unsigned int mask = pipe->ring_size - 1;"
        ],
        [
          32,
          "if (pipe->note_loss) {"
        ],
        [
          51,
          "pipe->note_loss = false;"
        ],
        [
          56,
          "struct pipe_buffer *buf = &pipe->bufs[tail & mask];"
        ],
        [
          56,
          "struct pipe_buffer *buf = &pipe->bufs[tail & mask];"
        ],
        [
          57,
          "size_t chars = buf->len;"
        ],
        [
          62,
          "if (buf->flags & PIPE_BUF_FLAG_WHOLE) {"
        ],
        [
          77,
          "written = copy_page_to_iter(buf->page, buf->offset, chars, to);"
        ],
        [
          84,
          "buf->offset += chars;"
        ],
        [
          85,
          "buf->len -= chars;"
        ],
        [
          87,
          "/* Was it a packet buffer? Clean up and exit */"
        ],
        [
          88,
          "if (buf->flags & PIPE_BUF_FLAG_PACKET) {"
        ],
        [
          90,
          "buf->len = 0;"
        ],
        [
          93,
          "if (!buf->len) {"
        ],
        [
          95,
          "spin_lock_irq(&pipe->rd_wait.lock);"
        ],
        [
          97,
          "if (buf->flags & PIPE_BUF_FLAG_LOSS)"
        ],
        [
          98,
          "pipe->note_loss = true;"
        ],
        [
          101,
          "pipe->tail = tail;"
        ],
        [
          102,
          "spin_unlock_irq(&pipe->rd_wait.lock);"
        ],
        [
          106,
          "break;\t/* common path: read succeeded */"
        ],
        [
          107,
          "if (!pipe_empty(head, tail))\t/* More to do? */"
        ],
        [
          111,
          "if (!pipe->writers)"
        ],
        [
          115,
          "if (filp->f_flags & O_NONBLOCK) {"
        ],
        [
          121,
          "/*"
        ],
        [
          123,
          "*"
        ],
        [
          124,
          "* However, we could have seen (and removed) a zero-sized"
        ],
        [
          125,
          "* pipe buffer, and might have made space in the buffers"
        ],
        [
          127,
          "*"
        ],
        [
          128,
          "* You can't make zero-sized pipe buffers by doing an empty"
        ],
        [
          129,
          "* write (not even in packet mode), but they can happen if"
        ],
        [
          130,
          "* the writer gets an EFAULT when trying to fill a buffer"
        ],
        [
          131,
          "* that already got allocated and inserted in the buffer"
        ],
        [
          133,
          "*"
        ],
        [
          134,
          "* So we still need to wake up any pending writers in the"
        ],
        [
          135,
          "* _very_ unlikely case that the pipe was full, but we got"
        ],
        [
          137,
          "*/"
        ],
        [
          139,
          "wake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);"
        ],
        [
          140,
          "kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);"
        ],
        [
          143,
          "/*"
        ],
        [
          144,
          "* But because we didn't read anything, at this point we can"
        ],
        [
          145,
          "* just return directly with -ERESTARTSYS if we're interrupted,"
        ],
        [
          146,
          "* since we've done any required wakeups and there's no need"
        ],
        [
          148,
          "*/"
        ],
        [
          149,
          "if (wait_event_interruptible_exclusive(pipe->rd_wait, pipe_readable(pipe)) < 0)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378",
      "source_file": "fs/pipe.c",
      "source_line": 378
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963#1963": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio,"
        ],
        [
          2,
          "struct iov_iter *iter)"
        ],
        [
          4,
          "return file->f_op->read_iter(kio, iter);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963",
      "source_file": "include/linux/fs.h",
      "source_line": 1963
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415#415": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415",
      "source_file": "fs/read_write.c",
      "source_line": 415
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496#496": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)"
        ],
        [
          5,
          "if (!(file->f_mode & FMODE_READ))"
        ],
        [
          7,
          "if (!(file->f_mode & FMODE_CAN_READ))"
        ],
        [
          18,
          "if (file->f_op->read)"
        ],
        [
          19,
          "ret = file->f_op->read(file, buf, count, pos);"
        ],
        [
          20,
          "else if (file->f_op->read_iter)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496",
      "source_file": "fs/read_write.c",
      "source_line": 496
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634#634": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)"
        ],
        [
          9,
          "pos = *ppos;"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634",
      "source_file": "fs/read_write.c",
      "source_line": 634
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644#644": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644",
      "source_file": "fs/read_write.c",
      "source_line": 644
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642#642": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642",
      "source_file": "fs/read_write.c",
      "source_line": 642
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#35#35": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#35",
      "source_file": "include/linux/page_owner.h",
      "source_line": 35
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2386#2386": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2386",
      "source_file": "mm/page_alloc.c",
      "source_line": 2386
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2392#2392": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#2392",
      "source_file": "mm/page_alloc.c",
      "source_line": 2392
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#4073#4073": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "const struct alloc_context *ac)"
        ],
        [
          4,
          "struct zoneref *z;"
        ],
        [
          5,
          "struct zone *zone;"
        ],
        [
          6,
          "struct pglist_data *last_pgdat_dirty_limit = NULL;"
        ],
        [
          10,
          "/*"
        ],
        [
          13,
          "*/"
        ],
        [
          15,
          "z = ac->preferred_zoneref;"
        ],
        [
          16,
          "for_next_zone_zonelist_nodemask(zone, z, ac->highest_zoneidx,"
        ],
        [
          17,
          "ac->nodemask) {"
        ],
        [
          18,
          "struct page *page;"
        ],
        [
          25,
          "/*"
        ],
        [
          26,
          "* When allocating a page cache page for writing, we"
        ],
        [
          27,
          "* want to get it from a node that is within its dirty"
        ],
        [
          28,
          "* limit, such that no single node holds more than its"
        ],
        [
          30,
          "* The dirty limits take into account the node's"
        ],
        [
          31,
          "* lowmem reserves and high watermark so that kswapd"
        ],
        [
          32,
          "* should be able to balance it without having to"
        ],
        [
          34,
          "*"
        ],
        [
          35,
          "* XXX: For now, allow allocations to potentially"
        ],
        [
          36,
          "* exceed the per-node dirty limit in the slowpath"
        ],
        [
          37,
          "* (spread_dirty_pages unset) before going into reclaim,"
        ],
        [
          38,
          "* which is important when on a NUMA setup the allowed"
        ],
        [
          39,
          "* nodes are together not big enough to reach the"
        ],
        [
          41,
          "* will require awareness of nodes in the"
        ],
        [
          43,
          "*/"
        ],
        [
          44,
          "if (ac->spread_dirty_pages) {"
        ],
        [
          45,
          "if (last_pgdat_dirty_limit == zone->zone_pgdat)"
        ],
        [
          48,
          "if (!node_dirty_ok(zone->zone_pgdat)) {"
        ],
        [
          49,
          "last_pgdat_dirty_limit = zone->zone_pgdat;"
        ],
        [
          55,
          "zone != ac->preferred_zoneref->zone) {"
        ],
        [
          58,
          "/*"
        ],
        [
          59,
          "* If moving to a remote node, retry but allow"
        ],
        [
          62,
          "*/"
        ],
        [
          63,
          "local_nid = zone_to_nid(ac->preferred_zoneref->zone);"
        ],
        [
          72,
          "ac->highest_zoneidx, alloc_flags,"
        ],
        [
          77,
          "/*"
        ],
        [
          78,
          "* Watermark failed for this zone, but see if we can"
        ],
        [
          80,
          "*/"
        ],
        [
          86,
          "/* Checked here to keep the fast path fast */"
        ],
        [
          92,
          "!zone_allows_reclaim(ac->preferred_zoneref->zone, zone))"
        ],
        [
          95,
          "ret = node_reclaim(zone->zone_pgdat, gfp_mask, order);"
        ],
        [
          98,
          "/* did not scan */"
        ],
        [
          101,
          "/* scanned but unreclaimable */"
        ],
        [
          104,
          "/* did we reclaim enough */"
        ],
        [
          106,
          "ac->highest_zoneidx, alloc_flags))"
        ],
        [
          114,
          "page = rmqueue(ac->preferred_zoneref->zone, zone, order,"
        ],
        [
          115,
          "gfp_mask, alloc_flags, ac->migratetype);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#4073",
      "source_file": "mm/page_alloc.c",
      "source_line": 4073
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#5160#5160": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          2,
          "nodemask_t *nodemask)"
        ],
        [
          4,
          "struct page *page;"
        ],
        [
          6,
          "gfp_t alloc_mask; /* The gfp_t that was actually used for allocation */"
        ],
        [
          9,
          "/*"
        ],
        [
          10,
          "* There are several places where we assume that the order value is sane"
        ],
        [
          12,
          "*/"
        ],
        [
          23,
          "/*"
        ],
        [
          24,
          "* Forbid the first pass from falling back to types that fragment"
        ],
        [
          26,
          "*/"
        ],
        [
          27,
          "alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref->zone, gfp_mask);"
        ],
        [
          29,
          "/* First allocation attempt */"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#5160",
      "source_file": "mm/page_alloc.c",
      "source_line": 5160
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1815#1815": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)"
        ],
        [
          3,
          "struct page *page;"
        ],
        [
          4,
          "struct kmem_cache_order_objects oo = s->oo;"
        ],
        [
          6,
          "void *start, *p, *next;"
        ],
        [
          15,
          "flags |= s->allocflags;"
        ],
        [
          17,
          "/*"
        ],
        [
          18,
          "* Let the initial higher-order allocation fail under memory pressure"
        ],
        [
          20,
          "*/"
        ],
        [
          22,
          "if ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1815",
      "source_file": "mm/slub.c",
      "source_line": 1815
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1817#1817": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static struct page *allocate_slab(struct kmem_cache *s, gfp_t flags, int node)"
        ],
        [
          3,
          "struct page *page;"
        ],
        [
          4,
          "struct kmem_cache_order_objects oo = s->oo;"
        ],
        [
          6,
          "void *start, *p, *next;"
        ],
        [
          15,
          "flags |= s->allocflags;"
        ],
        [
          17,
          "/*"
        ],
        [
          18,
          "* Let the initial higher-order allocation fail under memory pressure"
        ],
        [
          20,
          "*/"
        ],
        [
          22,
          "if ((alloc_gfp & __GFP_DIRECT_RECLAIM) && oo_order(oo) > oo_order(s->min))"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1817",
      "source_file": "mm/slub.c",
      "source_line": 1817
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1878#1878": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1878",
      "source_file": "mm/slub.c",
      "source_line": 1878
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2636#2636": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,"
        ],
        [
          2,
          "int node, struct kmem_cache_cpu **pc)"
        ],
        [
          4,
          "void *freelist;"
        ],
        [
          5,
          "struct kmem_cache_cpu *c = *pc;"
        ],
        [
          6,
          "struct page *page;"
        ],
        [
          8,
          "WARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2636",
      "source_file": "mm/slub.c",
      "source_line": 2636
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2800#2800": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void *___slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,"
        ],
        [
          2,
          "unsigned long addr, struct kmem_cache_cpu *c)"
        ],
        [
          4,
          "void *freelist;"
        ],
        [
          5,
          "struct page *page;"
        ],
        [
          9,
          "page = c->page;"
        ],
        [
          11,
          "/*"
        ],
        [
          12,
          "* if the node is not online or has no normal memory, just"
        ],
        [
          13,
          "* ignore the node constraint"
        ],
        [
          14,
          "*/"
        ],
        [
          23,
          "/*"
        ],
        [
          24,
          "* same as above but node_match() being false already"
        ],
        [
          25,
          "* implies node != NUMA_NO_NODE"
        ],
        [
          26,
          "*/"
        ],
        [
          32,
          "deactivate_slab(s, page, c->freelist, c);"
        ],
        [
          37,
          "/*"
        ],
        [
          38,
          "* By rights, we should be searching for a slab page that was"
        ],
        [
          39,
          "* PFMEMALLOC but right now, we are losing the pfmemalloc"
        ],
        [
          40,
          "* information when the page leaves the per-cpu allocator"
        ],
        [
          41,
          "*/"
        ],
        [
          43,
          "deactivate_slab(s, page, c->freelist, c);"
        ],
        [
          47,
          "/* must check again c->freelist in case of cpu migration or IRQ */"
        ],
        [
          48,
          "freelist = c->freelist;"
        ],
        [
          55,
          "c->page = NULL;"
        ],
        [
          56,
          "c->tid = next_tid(c->tid);"
        ],
        [
          64,
          "/*"
        ],
        [
          68,
          "*/"
        ],
        [
          69,
          "VM_BUG_ON(!c->page->frozen);"
        ],
        [
          70,
          "c->freelist = get_freepointer(s, freelist);"
        ],
        [
          71,
          "c->tid = next_tid(c->tid);"
        ],
        [
          77,
          "page = c->page = slub_percpu_partial(c);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2800",
      "source_file": "mm/slub.c",
      "source_line": 2800
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2840#2840": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void *__slab_alloc(struct kmem_cache *s, gfp_t gfpflags, int node,"
        ],
        [
          2,
          "unsigned long addr, struct kmem_cache_cpu *c)"
        ],
        [
          4,
          "void *p;"
        ],
        [
          9,
          "/*"
        ],
        [
          10,
          "* We may have been preempted and rescheduled on a different"
        ],
        [
          13,
          "*/"
        ],
        [
          14,
          "c = this_cpu_ptr(s->cpu_slab);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2840",
      "source_file": "mm/slub.c",
      "source_line": 2840
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2922#2922": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline void *slab_alloc_node(struct kmem_cache *s,"
        ],
        [
          4,
          "void *object;"
        ],
        [
          5,
          "struct kmem_cache_cpu *c;"
        ],
        [
          6,
          "struct page *page;"
        ],
        [
          8,
          "struct obj_cgroup *objcg = NULL;"
        ],
        [
          20,
          "/*"
        ],
        [
          25,
          "*"
        ],
        [
          26,
          "* We should guarantee that tid and kmem_cache are retrieved on"
        ],
        [
          29,
          "*/"
        ],
        [
          31,
          "tid = this_cpu_read(s->cpu_slab->tid);"
        ],
        [
          32,
          "c = raw_cpu_ptr(s->cpu_slab);"
        ],
        [
          34,
          "unlikely(tid != READ_ONCE(c->tid)));"
        ],
        [
          36,
          "/*"
        ],
        [
          37,
          "* Irqless object alloc/free algorithm used here depends on sequence"
        ],
        [
          39,
          "* on c to guarantee that object and page associated with previous tid"
        ],
        [
          41,
          "* page could be one associated with next tid and our alloc/free"
        ],
        [
          43,
          "*/"
        ],
        [
          46,
          "/*"
        ],
        [
          47,
          "* The transaction ids are globally unique per cpu and per operation on"
        ],
        [
          49,
          "* occurs on the right processor and that there was no operation on the"
        ],
        [
          51,
          "*/"
        ],
        [
          53,
          "object = c->freelist;"
        ],
        [
          54,
          "page = c->page;"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2922",
      "source_file": "mm/slub.c",
      "source_line": 2922
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#28#28": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/page_owner.h#28",
      "source_file": "include/linux/page_owner.h",
      "source_line": 28
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1332#1332": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static __always_inline bool free_pages_prepare(struct page *page,"
        ],
        [
          12,
          "/*"
        ],
        [
          13,
          "* Do not let hwpoison pages hit pcplists/buddy"
        ],
        [
          14,
          "* Untie memcg state and reset page's owner"
        ],
        [
          15,
          "*/"
        ],
        [
          23,
          "/*"
        ],
        [
          24,
          "* Check tail pages before head page information is cleared to"
        ],
        [
          26,
          "*/"
        ],
        [
          42,
          "(page + i)->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;"
        ],
        [
          46,
          "page->mapping = NULL;"
        ],
        [
          55,
          "page->flags &= ~PAGE_FLAGS_CHECK_AT_PREP;"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1332",
      "source_file": "mm/page_alloc.c",
      "source_line": 1332
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1612#1612": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void __free_pages_ok(struct page *page, unsigned int order,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#1612",
      "source_file": "mm/page_alloc.c",
      "source_line": 1612
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#717#717": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/page_alloc.c#717",
      "source_file": "mm/page_alloc.c",
      "source_line": 717
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#959#959": {
      "dereference": false,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "VM_BUG_ON_PAGE(page[1].compound_dtor >= NR_COMPOUND_DTORS, page);"
        ],
        [
          2,
          "compound_page_dtors[page[1].compound_dtor](page);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#959",
      "source_file": "include/linux/mm.h",
      "source_line": 959
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#115#115": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#115",
      "source_file": "mm/swap.c",
      "source_line": 115
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#131#131": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void __put_page(struct page *page)"
        ],
        [
          4,
          "put_dev_pagemap(page->pgmap);"
        ],
        [
          6,
          "/*"
        ],
        [
          9,
          "*/"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/swap.c#131",
      "source_file": "mm/swap.c",
      "source_line": 131
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#1255#1255": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline void put_page(struct page *page)"
        ],
        [
          5,
          "/*"
        ],
        [
          6,
          "* For devmap managed pages we need to catch refcount transition from"
        ],
        [
          7,
          "* 2 to 1, when refcount reach one it means the page is free and we"
        ],
        [
          10,
          "*/"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/mm.h#1255",
      "source_file": "include/linux/mm.h",
      "source_line": 1255
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/skbuff.h#3065#3065": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline void __skb_frag_unref(skb_frag_t *frag)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/skbuff.h#3065",
      "source_file": "include/linux/skbuff.h",
      "source_line": 3065
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#619#619": {
      "dereference": true,
      "array_access": true,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void skb_release_data(struct sk_buff *skb)"
        ],
        [
          3,
          "struct skb_shared_info *shinfo = skb_shinfo(skb);"
        ],
        [
          6,
          "if (skb->cloned &&"
        ],
        [
          7,
          "atomic_sub_return(skb->nohdr ? (1 << SKB_DATAREF_SHIFT) + 1 : 1,"
        ],
        [
          8,
          "&shinfo->dataref))"
        ],
        [
          11,
          "for (i = 0; i < shinfo->nr_frags; i++)"
        ],
        [
          12,
          "__skb_frag_unref(&shinfo->frags[i]);"
        ],
        [
          12,
          "__skb_frag_unref(&shinfo->frags[i]);"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#619",
      "source_file": "net/core/skbuff.c",
      "source_line": 619
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#680#680": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static void skb_release_all(struct sk_buff *skb)"
        ],
        [
          4,
          "if (likely(skb->head))"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#680",
      "source_file": "net/core/skbuff.c",
      "source_line": 680
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#694#694": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "void __kfree_skb(struct sk_buff *skb)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/core/skbuff.c#694",
      "source_file": "net/core/skbuff.c",
      "source_line": 694
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/net/sock.h#2599#2599": {
      "dereference": false,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/net/sock.h#2599",
      "source_file": "include/net/sock.h",
      "source_line": 2599
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/tcp.c#2317#2317": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "skb_queue_walk(&sk->sk_receive_queue, skb) {"
        ],
        [
          3,
          "/* Now that we have two receive queues this"
        ],
        [
          5,
          "*/"
        ],
        [
          6,
          "if (WARN(before(*seq, TCP_SKB_CB(skb)->seq),"
        ],
        [
          8,
          "*seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt,"
        ],
        [
          12,
          "offset = *seq - TCP_SKB_CB(skb)->seq;"
        ],
        [
          13,
          "if (unlikely(TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)) {"
        ],
        [
          17,
          "if (offset < skb->len)"
        ],
        [
          19,
          "if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)"
        ],
        [
          23,
          "*seq, TCP_SKB_CB(skb)->seq, tp->rcv_nxt, flags);"
        ],
        [
          28,
          "if (copied >= target && !READ_ONCE(sk->sk_backlog.tail))"
        ],
        [
          32,
          "if (sk->sk_err ||"
        ],
        [
          33,
          "sk->sk_state == TCP_CLOSE ||"
        ],
        [
          34,
          "(sk->sk_shutdown & RCV_SHUTDOWN) ||"
        ],
        [
          42,
          "if (sk->sk_err) {"
        ],
        [
          47,
          "if (sk->sk_shutdown & RCV_SHUTDOWN)"
        ],
        [
          50,
          "if (sk->sk_state == TCP_CLOSE) {"
        ],
        [
          51,
          "/* This occurs when user tries to read"
        ],
        [
          53,
          "*/"
        ],
        [
          80,
          "(peek_seq - copied - urg_hole != tp->copied_seq)) {"
        ],
        [
          82,
          "current->comm,"
        ],
        [
          84,
          "peek_seq = tp->copied_seq;"
        ],
        [
          89,
          "/* Ok so how much can we use? */"
        ],
        [
          90,
          "used = skb->len - offset;"
        ],
        [
          94,
          "/* Do we have urgent data here? */"
        ],
        [
          95,
          "if (tp->urg_data) {"
        ],
        [
          96,
          "u32 urg_offset = tp->urg_seq - *seq;"
        ],
        [
          100,
          "WRITE_ONCE(*seq, *seq + 1);"
        ],
        [
          122,
          "WRITE_ONCE(*seq, *seq + used);"
        ],
        [
          129,
          "if (tp->urg_data && after(tp->copied_seq, tp->urg_seq)) {"
        ],
        [
          130,
          "tp->urg_data = 0;"
        ],
        [
          134,
          "if (TCP_SKB_CB(skb)->has_rxtstamp) {"
        ],
        [
          139,
          "if (used + offset < skb->len)"
        ],
        [
          142,
          "if (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/tcp.c#2317",
      "source_file": "net/ipv4/tcp.c",
      "source_line": 2317
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/af_inet.c#852#852": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int inet_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,"
        ],
        [
          4,
          "struct sock *sk = sock->sk;"
        ],
        [
          11,
          "err = INDIRECT_CALL_2(sk->sk_prot->recvmsg, tcp_recvmsg, udp_recvmsg,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/ipv4/af_inet.c#852",
      "source_file": "net/ipv4/af_inet.c",
      "source_line": 852
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#886#886": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static inline int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,"
        ],
        [
          4,
          "return INDIRECT_CALL_INET(sock->ops->recvmsg, inet6_recvmsg,"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#886",
      "source_file": "net/socket.c",
      "source_line": 886
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#904#904": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags)"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#904",
      "source_file": "net/socket.c",
      "source_line": 904
    },
    "link:https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#977#977": {
      "dereference": true,
      "array_access": false,
      "alloc_calls": [],
      "free_calls": [],
      "nearby_lines": [
        [
          1,
          "static ssize_t sock_read_iter(struct kiocb *iocb, struct iov_iter *to)"
        ],
        [
          3,
          "struct file *file = iocb->ki_filp;"
        ],
        [
          4,
          "struct socket *sock = file->private_data;"
        ],
        [
          9,
          "if (file->f_flags & O_NONBLOCK || (iocb->ki_flags & IOCB_NOWAIT))"
        ],
        [
          12,
          "if (iocb->ki_pos != 0)"
        ],
        [
          15,
          "if (!iov_iter_count(to))\t/* Match SYS5 behaviour */"
        ]
      ],
      "access_op": "read",
      "access_size": 4,
      "source_url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/net/socket.c#977",
      "source_file": "net/socket.c",
      "source_line": 977
    }
  },
  "classification": {
    "classification": "use-after-free",
    "preconditions": [
      "Object must have been freed earlier on a prior code path (see freed_by stack)",
      "An allocation for the object occurred earlier (see allocated_by stack)",
      "Path from syscall/fuzzer entry to crash site must be executed with attacker-controlled inputs",
      "A timing/reuse window must exist for the freed object to be reallocated and reused by the vulnerable code path"
    ],
    "postconditions": [
      "KASAN reported invalid memory access (see crash report)"
    ],
    "notes": [
      "Crash generated by syzkaller/fuzzer - likely attacker-controlled input"
    ],
    "vulnerability": "likely_arbitrary_read"
  },
  "exploitability": {
    "free_site": {
      "raw": "Freed by task 345:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track+0x4c/0x80 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46'>mm/kasan/common.c:46</a>\n kasan_set_free_info+0x23/0x40 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/generic.c#357'>mm/kasan/generic.c:357</a>\n ____kasan_slab_free+0x121/0x160 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#360'>mm/kasan/common.c:360</a>\n __kasan_slab_free+0x11/0x20 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#368'>mm/kasan/common.c:368</a>\n kasan_slab_free <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235'>include/linux/kasan.h:235</a> [inline]\n slab_free_hook <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1604'>mm/slub.c:1604</a> [inline]\n slab_free_freelist_hook+0xcc/0x1a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#1630'>mm/slub.c:1630</a>\n slab_free <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3212'>mm/slub.c:3212</a> [inline]\n kmem_cache_free+0xa9/0x1f0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#3228'>mm/slub.c:3228</a>\n __mmdrop+0x295/0x390 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#722'>kernel/fork.c:722</a>\n mmdrop <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/sched/mm.h#49'>include/linux/sched/mm.h:49</a> [inline]\n finish_task_switch+0x1e4/0x580 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#3892'>kernel/sched/core.c:3892</a>\n context_switch <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4038'>kernel/sched/core.c:4038</a> [inline]\n __schedule+0x86e/0xc00 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4796'>kernel/sched/core.c:4796</a>\n schedule+0x14b/0x1e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/sched/core.c#4874'>kernel/sched/core.c:4874</a>\n pipe_read+0x9c8/0x1070 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/pipe.c#378'>fs/pipe.c:378</a>\n call_read_iter <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/fs.h#1963'>include/linux/fs.h:1963</a> [inline]\n new_sync_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#415'>fs/read_write.c:415</a> [inline]\n vfs_read+0x9e2/0xbf0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#496'>fs/read_write.c:496</a>\n ksys_read+0x198/0x2c0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#634'>fs/read_write.c:634</a>\n __do_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#644'>fs/read_write.c:644</a> [inline]\n __se_sys_read <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a> [inline]\n __x64_sys_read+0x7b/0x90 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/read_write.c#642'>fs/read_write.c:642</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6",
      "file": "mm/kasan/common.c",
      "line": 38
    },
    "trigger_site": {
      "file": "fs/ext4/namei.c",
      "line": 3704,
      "url": "https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/fs/ext4/namei.c#3704",
      "func": "static int ext4_rename_dir_prepare"
    },
    "allocation_site": {
      "raw": "Allocated by task 345:\n kasan_save_stack <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#38'>mm/kasan/common.c:38</a> [inline]\n kasan_set_track <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#46'>mm/kasan/common.c:46</a> [inline]\n set_alloc_info <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#428'>mm/kasan/common.c:428</a> [inline]\n __kasan_slab_alloc+0xb2/0xe0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/kasan/common.c#461'>mm/kasan/common.c:461</a>\n kasan_slab_alloc <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#259'>include/linux/kasan.h:259</a> [inline]\n slab_post_alloc_hook <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/../mm/slab.h#583'>include/../mm/slab.h:583</a> [inline]\n slab_alloc_node <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2956'>mm/slub.c:2956</a> [inline]\n slab_alloc <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2964'>mm/slub.c:2964</a> [inline]\n kmem_cache_alloc+0x16c/0x300 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969'>mm/slub.c:2969</a>\n dup_mm+0x29/0x320 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1403'>kernel/fork.c:1403</a>\n copy_mm+0x108/0x1b0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#1468'>kernel/fork.c:1468</a>\n copy_process+0x133a/0x33a0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2152'>kernel/fork.c:2152</a>\n kernel_clone+0x22d/0x900 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2524'>kernel/fork.c:2524</a>\n __do_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2643'>kernel/fork.c:2643</a> [inline]\n __se_sys_clone <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a> [inline]\n __x64_sys_clone+0x271/0x2e0 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/kernel/fork.c#2627'>kernel/fork.c:2627</a>\n do_syscall_64+0x34/0x70 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/arch/x86/entry/common.c#46'>arch/x86/entry/common.c:46</a>\n entry_SYSCALL_64_after_hwframe+0x61/0xc6",
      "file": "mm/kasan/common.c",
      "line": 38
    },
    "object": {
      "obj_addr": "ffff888119c14000",
      "cache": "mm_struct",
      "obj_size": 1104,
      "offset": 0
    },
    "struct_info": {
      "struct_name": null,
      "fields_used": [
        "And",
        "Assign",
        "Bailout",
        "DEAD",
        "Do",
        "Goodbye",
        "Hence",
        "If",
        "In",
        "It",
        "Locality",
        "Membarrier",
        "Need",
        "Performing",
        "Preemption",
        "Relocate",
        "See",
        "So",
        "That",
        "The",
        "This",
        "Thus",
        "Verify",
        "We",
        "When",
        "With",
        "access_addr",
        "access_size",
        "active_mm",
        "alloc_lock",
        "alloc_track",
        "allocflags",
        "ax",
        "bh",
        "blocked_on",
        "bufs",
        "c",
        "child_tid",
        "children",
        "clock_update_flags",
        "cloned",
        "comm",
        "compound_dtor",
        "copied_seq",
        "cpu_slab",
        "cpuset_mem_spread_rotor",
        "cpuset_slab_spread_rotor",
        "ctor",
        "curr",
        "d_inode",
        "d_name",
        "dataref",
        "de",
        "default_timer_slack_ns",
        "dentry",
        "dir",
        "dir_bh",
        "dir_inlined",
        "exit_signal",
        "f_flags",
        "f_mode",
        "f_op",
        "fasync_writers",
        "file",
        "first_bad_addr",
        "flags",
        "frags",
        "free_track",
        "freelist",
        "frozen",
        "gtime",
        "h",
        "hardirq_disable_ip",
        "has_rxtstamp",
        "head",
        "highest_zoneidx",
        "i_ino",
        "i_mode",
        "i_nlink",
        "i_op",
        "i_projid",
        "i_sb",
        "in_iowait",
        "info",
        "inlined",
        "inode",
        "io_context",
        "io_uring",
        "ioac",
        "iov_base",
        "iov_len",
        "ip",
        "irqtrace",
        "is_dir",
        "is_write",
        "kernel",
        "ki_filp",
        "ki_flags",
        "ki_pos",
        "kunit_test",
        "last_switch_count",
        "last_switch_time",
        "len",
        "lock",
        "maj_flt",
        "mapping",
        "max_usage",
        "mempolicy",
        "mems_allowed_seq",
        "migratetype",
        "min",
        "min_flt",
        "mm",
        "mm_count",
        "mnt",
        "msg_flags",
        "msg_iocb",
        "msg_iter",
        "name",
        "nivcsw",
        "nodemask",
        "nohdr",
        "note_loss",
        "nr_frags",
        "nr_iowait",
        "nr_switches",
        "nr_uninterruptible",
        "nvcsw",
        "object_size",
        "offset",
        "on_cpu",
        "on_rq",
        "oo",
        "ops",
        "page",
        "pagefault_disabled",
        "parent_de",
        "parent_tid",
        "pending",
        "pgmap",
        "pi_state",
        "pid",
        "pidfd",
        "posix_cputimers",
        "preferred_zoneref",
        "prev_cputime",
        "prev_mm",
        "private_data",
        "psi_flags",
        "rcv_nxt",
        "rd_wait",
        "read",
        "read_iter",
        "real_cred",
        "recvmsg",
        "rename",
        "ring_size",
        "rss_stat",
        "s_max_links",
        "sched_contributes_to_load",
        "seq",
        "seqcount",
        "sequential_io",
        "sequential_io_avg",
        "sibling",
        "signal_pending",
        "sk",
        "sk_backlog",
        "sk_err",
        "sk_prot",
        "sk_receive_queue",
        "sk_shutdown",
        "sk_state",
        "softirq_context",
        "softirq_enable_ip",
        "softirqs_enabled",
        "spread_dirty_pages",
        "stack",
        "starttime",
        "state",
        "stime",
        "stimescaled",
        "subtype",
        "tail",
        "tcp_flags",
        "tid",
        "timer_slack_ns",
        "tls",
        "type",
        "urg_data",
        "urg_seq",
        "user",
        "utime",
        "utimescaled",
        "vfork_done",
        "vtime",
        "wr_wait",
        "writers",
        "zone",
        "zone_pgdat"
      ],
      "struct_def_snippet": null
    },
    "usage_examples": [
      {
        "line_no": 1,
        "text": "static int ext4_rename_dir_prepare(handle_t *handle, struct ext4_renament *ent)"
      },
      {
        "line_no": 5,
        "text": "ent->dir_bh = ext4_get_first_dir_block(handle, ent->inode,"
      },
      {
        "line_no": 6,
        "text": "&retval, &ent->parent_de,"
      },
      {
        "line_no": 7,
        "text": "&ent->dir_inlined);"
      },
      {
        "line_no": 8,
        "text": "if (!ent->dir_bh)"
      },
      {
        "line_no": 10,
        "text": "if (le32_to_cpu(ent->parent_de->inode) != ent->dir->i_ino)"
      }
    ],
    "notes": [
      "Object allocated from cache 'mm_struct', reallocation under attacker control increases exploitability",
      "Object size=1104, access offset=0"
    ]
  },
  "strong_report": {
    "primitive": "info-leak (use-after-free read of reclaimed memory)",
    "vulnerability": "use-after-free",
    "confidence": 1.0,
    "preconditions": [
      "Triggering syscall(s) from crash text: renameat2, clone, read",
      "How to create: allocate the object via code path that calls: kmem_cache_alloc+0x16c/0x300 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969'>mm/slub.c:2969</a>",
      "How to create hint: Allocation from slab/kmalloc: create objects via normal kernel paths (file ops, network ops, or module-specific APIs)",
      "Object details: type 'mm_struct', address ffff888119c14000, size 1104",
      "Free observed: return __kasan_slab_free(s, object, _RET_IP_, init); (near include/linux/kasan.h:235 url=https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/include/linux/kasan.h#235)",
      "Object: cache 'mm_struct', address ffff888119c14000, size 1104, offset 0",
      "Object freed prior to access (log indicates use-after-free)",
      "An externally-controlled syscall input (fuzzer/syzkaller) reached the vulnerable syscall path",
      "Input state: attacker-controlled syscall parameters or user-supplied data must reach the vulnerable code path",
      "Code path: execution reaches function 'ext4_rename_dir_prepare' (from crash context)",
      "State: variable(s) like handle, ent, parent_de may point into freed/reclaimed memory (observed in nearby source lines)"
    ],
    "postconditions": [
      "KASAN or BUG report emitted indicating invalid memory access"
    ],
    "support": [
      "Access offset 0 inside object size 1104",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains alloc-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains alloc-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains free-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source contains free-like calls near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows array/index access near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Source shows pointer dereference near crash site",
      "Allocation origin: kmem_cache_alloc+0x16c/0x300 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969'>mm/slub.c:2969</a>",
      "Syscall(s) detected in crash text: renameat2, clone, read"
    ],
    "how_to_create": {
      "alloc_frame": "kmem_cache_alloc+0x16c/0x300 <a href='https://android.googlesource.com/kernel/common/+/416c4356f37295d6da2d7b290069f9adb349dc9f/mm/slub.c#2969'>mm/slub.c:2969</a>",
      "guidance": [
        "Allocation from slab/kmalloc: create objects via normal kernel paths (file ops, network ops, or module-specific APIs)"
      ]
    },
    "exploitability": "high"
  },
  "llm_analysis": {
    "prompt": "You are given a kernel crash stack trace and surrounding source snippets. Your task is to produce a concise, developer-friendly description of the PRECONDITION(s) that must hold to reach the crash. Provide concrete input ranges, variable constraints, and reproduction hints.\n\nCall chain (top -> bottom):\n\nAvailable source snippets (filename:line -> snippet):\n\nPlease output JSON with fields: preconditions (list of short statements), input_constraints (list of variable name -> allowed ranges), reproduction (steps), evidence (lines in the snippets that support each precondition). Keep answers concise and concrete.",
    "ok": false,
    "error": "llama_cpp not available: No module named 'llama_cpp' | gpt4all invocation failed: Unable to instantiate model: Unsupported file format | openai not available: No module named 'openai'",
    "summary": {
      "preconditions": [],
      "input_constraints": [],
      "reproduction": [],
      "evidence": []
    }
  }
}