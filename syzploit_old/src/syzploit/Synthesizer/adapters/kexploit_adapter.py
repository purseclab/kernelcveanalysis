"""
kexploit_adapter.py

Adapter for ingots_tools/kexploit capabilities.

Integrates the following kexploit subsystems into the syzploit pipeline:

1. **Object Database (ObjectDb)**: Kernel heap object and BTF type database
   built from kernel BTF data + CodeQL queries.  Exposes slab-cache-level
   information (kmalloc cache name, struct size, allocation flags) that
   enriches the PDDL problem generation and the stitcher's struct-offset
   resolution.

2. **Kernel Adaptation (KernelAdapter)**: Translates kernel addresses/ROP
   gadgets between two kernel versions using symbol tables, Ghidra-based
   reference tracing, and BinDiff-style basic-block matching.  This lets
   syzploit re-target a generated exploit at a different kernel build
   without manual offset patching.

3. **Annotation System**: Annotates exploit source with machine-readable
   pseudo-calls (``__kexploit_kernel_address``, ``__kexploit_rop_address``,
   etc.) so future kernel-version bumps can be handled automatically.

4. **Exploit Synthesis Agents**: Docker-sandboxed LLM agents (from
   kexploit_agent) that can compile and test exploit code in isolation,
   with read-only access to a kernel source tree.

All integration is optional – missing kexploit packages are caught at
import time and the adapter silently degrades to no-op stubs.
"""

from __future__ import annotations

import json
import os
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from ..core import ExploitPlan, Primitive, PrimitiveRegistry
from ...utils.debug import debug_print


# ---------------------------------------------------------------------------
# Lazy imports: kexploit is an *optional* dependency.
# ---------------------------------------------------------------------------

_HAS_KEXPLOIT = False
_HAS_KEXPLOIT_AGENT = False
_HAS_KEXPLOIT_UTILS = False

try:
    from kexploit_utils import kexploit_data_dir, synthesis_data_dir, KexploitConfig
    _HAS_KEXPLOIT_UTILS = True
except ImportError:
    pass

try:
    from kexploit.kernel_image import Kernel, KernelImage, KernelAdapter
    from kexploit.annotations import (
        Annotation, KernelAddress, RopAddress, KernelData, SrcMetadata,
    )
    from kexploit.synthesis.object_db import ObjectDb, HeapObject, KmallocCall, OBJECT_DB_FILE_NAME
    from kexploit.synthesis.btf_types import BtfTypes, BtfStruct
    from kexploit.synthesis.synthesis_metadata import SynthesisMetadata
    _HAS_KEXPLOIT = True
except ImportError:
    pass

try:
    from kexploit_agent import (
        DockerSandbox,
        DockerSandboxProvider,
        MountInfo,
        create_kexploit_agent,
    )
    _HAS_KEXPLOIT_AGENT = True
except ImportError:
    pass


def _kx_debug(msg: str, enabled: bool = True):
    debug_print("KexploitAdapter", msg, enabled)


# ---------------------------------------------------------------------------
# Public helpers – availability checks
# ---------------------------------------------------------------------------

def kexploit_available() -> bool:
    """Return True when the core kexploit package is importable."""
    return _HAS_KEXPLOIT


def kexploit_agent_available() -> bool:
    """Return True when kexploit_agent (Docker sandbox) is importable."""
    return _HAS_KEXPLOIT_AGENT


# ---------------------------------------------------------------------------
# 1. Object DB adapter – heap-object / slab-cache enrichment
# ---------------------------------------------------------------------------

@dataclass
class HeapObjectInfo:
    """Lightweight view of a kernel heap object for the syzploit pipeline."""
    struct_name: str
    struct_size: int
    slab_cache: str
    allocation_flags: str
    btf_type_id: Optional[int] = None
    field_names: List[str] = field(default_factory=list)
    source_location: str = ""


def load_heap_objects_from_object_db(
    kernel_name: str,
    db_path: Optional[str] = None,
    debug: bool = False,
) -> List[HeapObjectInfo]:
    """
    Load heap object information from the kexploit ObjectDb.

    If *db_path* is not given, looks for the database under the standard
    kexploit synthesis data directory for *kernel_name*.

    Returns a (possibly empty) list of ``HeapObjectInfo``.
    """
    if not _HAS_KEXPLOIT:
        _kx_debug("kexploit not available – skipping object DB load", debug)
        return []

    if db_path is None:
        try:
            kernel = Kernel(kernel_name)
            db_path = str(kernel.synthesis_data_path() / OBJECT_DB_FILE_NAME)
        except Exception as e:
            _kx_debug(f"Cannot resolve synthesis data path: {e}", debug)
            return []

    if not Path(db_path).exists():
        _kx_debug(f"ObjectDb not found: {db_path}", debug)
        return []

    _kx_debug(f"Loading ObjectDb from {db_path}", debug)
    obj_db = ObjectDb(Path(db_path))

    results: List[HeapObjectInfo] = []

    # Load kmalloc calls – each links to a struct via heap_object → btf_type
    try:
        calls = obj_db.get_all_kmalloc_calls()
        _kx_debug(f"  loaded {len(calls)} kmalloc calls", debug)

        for call in calls:
            info = HeapObjectInfo(
                struct_name=call.struct_type,
                struct_size=call.struct_size,
                slab_cache=call.kmalloc_cache_name or f"kmalloc-{call.struct_size}",
                allocation_flags=call.flags,
                source_location=call.call_site,
            )
            if call.heap_object:
                info.btf_type_id = call.heap_object.type_id
            results.append(info)
    except Exception as e:
        _kx_debug(f"Error reading kmalloc calls: {e}", debug)

    return results


def enrich_primitives_from_object_db(
    registry: PrimitiveRegistry,
    kernel_name: str,
    target_struct: Optional[str] = None,
    db_path: Optional[str] = None,
    debug: bool = False,
) -> List[Primitive]:
    """
    Query the kexploit ObjectDb and inject heap-layout primitives into the
    registry that help the planner / stitcher pick correct slab caches, struct
    sizes, and cross-cache spray parameters.

    If *target_struct* is given, only objects matching that name are imported.
    """
    objects = load_heap_objects_from_object_db(kernel_name, db_path, debug)
    if not objects:
        return []

    prims: List[Primitive] = []
    for obj in objects:
        if target_struct and obj.struct_name != target_struct:
            continue

        prim = Primitive(
            name=f"heap_object_{obj.struct_name}",
            description=(
                f"Heap object '{obj.struct_name}' (size={obj.struct_size}, "
                f"cache={obj.slab_cache}, flags={obj.allocation_flags})"
            ),
            requirements={},
            provides={
                "caps": ["CAP_heap_object_info", "CAP_struct_info"],
                "source": "kexploit_object_db",
                "struct_name": obj.struct_name,
                "struct_size": obj.struct_size,
                "slab_cache": obj.slab_cache,
                "alloc_flags": obj.allocation_flags,
                "btf_type_id": obj.btf_type_id,
            },
        )
        registry.add(prim)
        prims.append(prim)

    _kx_debug(f"Enriched registry with {len(prims)} heap-object primitives", debug)
    return prims


# ---------------------------------------------------------------------------
# 2. Kernel adaptation adapter
# ---------------------------------------------------------------------------

@dataclass
class AdaptationResult:
    """Result of adapting an exploit to a new kernel."""
    success: bool
    adapted_files: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    old_kernel: str = ""
    new_kernel: str = ""


def adapt_exploit_to_kernel(
    exploit_source: str,
    old_kernel_name: str,
    new_kernel_name: str,
    debug: bool = False,
) -> AdaptationResult:
    """
    Use kexploit's ``KernelAdapter`` to translate kernel-specific constants
    (addresses, ROP gadgets, data values) in *exploit_source* from
    *old_kernel_name* to *new_kernel_name*.

    Returns an ``AdaptationResult`` with the rewritten source on success.
    """
    if not _HAS_KEXPLOIT:
        return AdaptationResult(
            success=False,
            errors=["kexploit package not installed"],
            old_kernel=old_kernel_name,
            new_kernel=new_kernel_name,
        )

    try:
        from kexploit.parse import LexedCode, ExploitFileGroup, DiffMode
        from kexploit.annotate import AnnotateContext

        old_kernel = Kernel(old_kernel_name)
        new_kernel = Kernel(new_kernel_name)

        old_image = KernelImage.load(old_kernel)
        new_image = KernelImage.load(new_kernel)
        adapter = KernelAdapter(old_image, new_image)

        # Lex the source and find annotations
        lexed = LexedCode.from_string(exploit_source, "exploit.c")
        annotations = lexed.find_annotations()

        if not annotations:
            _kx_debug("No kexploit annotations found in source", debug)
            return AdaptationResult(
                success=True,
                adapted_files=[exploit_source],  # unchanged
                old_kernel=old_kernel_name,
                new_kernel=new_kernel_name,
            )

        # Adapt each annotation
        errors: List[str] = []
        for ann_raw in annotations:
            try:
                ann = ann_raw.to_annotation()
                new_code = ann.adapt_to_code(adapter)
                lexed.replace_annotation(ann_raw, new_code)
            except Exception as e:
                errors.append(f"Annotation adapt error: {e}")
                try:
                    fallback = ann.adapt_fallback(adapter)
                    lexed.replace_annotation(ann_raw, fallback)
                except Exception:
                    pass

        adapted_source = lexed.to_string()
        return AdaptationResult(
            success=len(errors) == 0,
            adapted_files=[adapted_source],
            errors=errors,
            old_kernel=old_kernel_name,
            new_kernel=new_kernel_name,
        )

    except Exception as e:
        return AdaptationResult(
            success=False,
            errors=[str(e)],
            old_kernel=old_kernel_name,
            new_kernel=new_kernel_name,
        )


# ---------------------------------------------------------------------------
# 3. Annotation helpers – inject / strip kexploit annotations
# ---------------------------------------------------------------------------

def annotate_exploit_source(
    source: str,
    kernel_name: str,
    use_llm: bool = True,
    model: str = "gpt-4o",
    debug: bool = False,
) -> str:
    """
    Run kexploit's LLM-assisted (or heuristic) annotator on *source*,
    returning a new source string with ``__kexploit_kernel_address(...)``
    pseudo-calls injected at every detected kernel constant.

    This makes the exploit portable to other kernel versions via ``adapt_exploit_to_kernel``.
    """
    if not _HAS_KEXPLOIT:
        _kx_debug("kexploit not available – returning source unchanged", debug)
        return source

    try:
        from kexploit.annotate import AnnotateContext
        from kexploit.parse import LexedCode

        kernel = Kernel(kernel_name)
        image = KernelImage.load(kernel)

        ctx = AnnotateContext(image, use_llm=use_llm, model=model)
        lexed = LexedCode.from_string(source, "exploit.c")
        ctx.annotate(lexed)
        return lexed.to_string()
    except Exception as e:
        _kx_debug(f"Annotation failed: {e}", debug)
        return source


# ---------------------------------------------------------------------------
# 4. Docker-sandboxed synthesis agent integration
# ---------------------------------------------------------------------------

def run_kexploit_synthesis_agent(
    vulnerability_details: str,
    kernel_name: str,
    linux_src_path: Optional[str] = None,
    debug: bool = False,
) -> Optional[str]:
    """
    Launch a kexploit Docker-sandboxed LLM agent to synthesize an exploit.

    This uses the kexploit_agent's Docker sandbox with:
    - Read-only kernel source mount
    - Read-write exploit template workspace
    - GPT-5.2 agent with shell execution inside the container

    Returns the agent's final output (which should include the exploit code),
    or None if kexploit_agent is not available.
    """
    if not (_HAS_KEXPLOIT and _HAS_KEXPLOIT_AGENT):
        _kx_debug("kexploit or kexploit_agent not available", debug)
        return None

    try:
        metadata = SynthesisMetadata.load_for_kernel(Kernel(kernel_name))
        from kexploit.synthesis.agents import run_synthesis_agent
        run_synthesis_agent(metadata, vulnerability_details)
    except Exception as e:
        _kx_debug(f"Synthesis agent failed: {e}", debug)
        return None


# ---------------------------------------------------------------------------
# 5. BTF type resolver integration
# ---------------------------------------------------------------------------

def resolve_struct_offsets_from_kexploit(
    kernel_name: str,
    struct_name: str,
    field_names: Optional[List[str]] = None,
    debug: bool = False,
) -> Dict[str, int]:
    """
    Resolve struct field offsets using kexploit's BTF type database.

    Falls back gracefully to an empty dict if kexploit is unavailable or the
    struct is not found.
    """
    if not _HAS_KEXPLOIT:
        return {}

    try:
        kernel = Kernel(kernel_name)
        btf = BtfTypes.load(kernel)
        struct_type = btf.get_type_by_name(struct_name)
        if struct_type is None or not isinstance(struct_type, BtfStruct):
            return {}

        offsets: Dict[str, int] = {}
        for member in struct_type.members:
            if field_names is None or member.name in field_names:
                offsets[member.name] = member.bits_offset // 8
        return offsets
    except Exception as e:
        _kx_debug(f"BTF offset resolution failed: {e}", debug)
        return {}


# ---------------------------------------------------------------------------
# 6. Unified ``list_primitives`` entry-point (like other adapters)
# ---------------------------------------------------------------------------

def list_primitives(
    registry: PrimitiveRegistry,
    kernel_name: Optional[str] = None,
    db_path: Optional[str] = None,
    debug: bool = False,
) -> List[Primitive]:
    """
    Top-level entry-point for the syzploit adapter interface.

    kexploit is a kernel exploit *adaptation* tool, not a primitive source.
    It provides:
    - Heap object / slab cache info from the ObjectDb (useful for planning)
    - Kernel address translation between kernel versions
    - Exploit annotation for portability

    This function only loads ObjectDb data (if a kernel_name is given).
    Adaptation capabilities are accessed directly via the adapter functions
    (adapt_exploit_to_kernel, annotate_exploit_source, etc.).
    """
    prims: List[Primitive] = []

    # Heap objects from ObjectDb — these ARE useful for planning
    # as they tell the planner which slab caches and struct sizes exist
    if kernel_name:
        prims.extend(
            enrich_primitives_from_object_db(registry, kernel_name, db_path=db_path, debug=debug)
        )

    # Note: kexploit adaptation and agent capabilities are NOT registered
    # as primitives — they don't contribute to PDDL planning.  They are
    # accessed directly via adapt_exploit_to_kernel(), annotate_exploit_source(),
    # and run_kexploit_synthesis_agent().

    _kx_debug(f"Listed {len(prims)} total kexploit primitives", debug)
    return prims
