# Pulls buts from syzkaller syzbot and filters for interesting looking ones

from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeRemainingColumn, MofNCompleteColumn
import csv
import json
import shutil
import os
import re
import sys
import traceback
import time

from .bug_db import SyzkallBugDatabase
from .scrape import pull_bugs
from .run_bug import test_repro_crashes, wait_for_connection

def pull(kernel_name: str):
    db = SyzkallBugDatabase(kernel_name)

    try:
        pull_bugs(db, kernel_name)
    finally:
        db.close()

def query(kernel_name: str):
    db = SyzkallBugDatabase(kernel_name)
    bugs = db.get_all_bugs()

    for bug in bugs:
        # print(bug.description)
        # print(bug.kernel_name)
        # if 'android' not in bug.kernel_name:
        #     continue
        print(f'{bug.bug_id}: {bug.title} ({bug.crash_time})')


def test_all(kernel_name: str):
    db = SyzkallBugDatabase(kernel_name)
    console = Console()
    table = Table(title="Syzkaller Bug Test Results")
    table.add_column("Bug ID", style="cyan", no_wrap=True)
    table.add_column("Description", style="magenta")
    table.add_column("Compiled", justify="center")
    table.add_column("Crash Occurred", justify="center", style="red")

    bugs = db.get_all_bugs()
    if not bugs:
        console.print("[red]No bugs found in the database.[/red]")
        return

    results = []
    crashing_bugs = []
    crash_summary = {}
    crash_type_summary = {}
    syscall_summary = {}
    exceptions = []

    base_dir = os.getcwd()
    crashes_dir = os.path.join(base_dir, f"{kernel_name}_crashes")
    os.makedirs(crashes_dir, exist_ok=True)

    # summary_path = os.path.join(base_dir, f"{kernel_name}_summary.txt")
    crash_report_path = os.path.join(base_dir, f"{kernel_name}_crash_analysis.json")
    crash_summary_path = os.path.join(base_dir, f"{kernel_name}_crash_summary.json")

    compiled_count = 0
    crashed_count = 0
    last_run = "❌"

    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        MofNCompleteColumn(),
        TimeRemainingColumn(),
        transient=True
    ) as progress:
        task = progress.add_task("Testing bugs...", total=len(bugs))

        for idx, bug in enumerate(bugs, 1):
            metadata = db.get_bug_metadata(bug.bug_id)
            if metadata is None:
                row = [str(bug.bug_id), "Invalid ID", "❌", "N/A"]
                table.add_row(*row)
                results.append(row)
                progress.advance(task)
                continue

            description = metadata.description
            progress.update(
                task,
                description=f"[{idx}/{len(bugs)}] Testing Bug ID {bug.bug_id}: {description[:50]} {last_run}"
            )

            try:
                repro_path = metadata.compile_repro('arm64')
                compiled = "✅"
                compiled_count += 1
            except Exception:
                compiled = "❌"
                repro_path = None

            crashed = "❌"
            crash_log_path = None
            if repro_path:
                progress.update(
                    task,
                    description=f"[{idx}/{len(bugs)}] Running repro for Bug ID {bug.bug_id}: {description[:50]}"
                )
                for root in [False, True]:
                    try:
                        v, t = test_repro_crashes(repro_path, root)
                        if v and t==1:
                            crashed = "💥"+str(t)+(" root" if root else "")
                            crashed_count += 1
                            crash_subdir = os.path.join(crashes_dir, f"bug_{bug.bug_id}")
                            os.makedirs(crash_subdir, exist_ok=True)

                            os.system(f'cp {os.path.dirname(repro_path)}/* {crash_subdir}')
                            try:
                                crashing_file, crashing_line, crash_type = extract_crash_locations(metadata.crash_report)
                            except Exception as e:
                                crashing_file = "unknown"
                                crash_type = "unknown"
                                crashing_line = 0
                                exceptions.append(f"Error extracting crash locations for bug {bug.bug_id}: {e}")
                            try:
                                all_syscalls, last_syscall = extract_last_syscall(os.path.join(os.path.dirname(repro_path),"repro.syz"))
                            except:
                                last_syscall = "unknown"

                            crash_type_summary[crash_type] = crash_type_summary.get(crash_type, 0) + 1
                            syscall_summary[last_syscall] = syscall_summary.get(last_syscall, 0) + 1

                            print("ADDING CRASH",  bug.bug_id, crashed)
                            crashing_bugs.append({
                                "bug_id": bug.bug_id,
                                "description": description,
                                "repro_path": os.path.join(crash_subdir, os.path.basename(repro_path)),
                                "file": crashing_file,
                                "line" : crashing_line,
                                "crash_type": crash_type,
                                "syscall": last_syscall
                            })

                            print("crashed happened, waiting for connection...")
                            wait_for_connection()
                            print("crashed happened, done")
                            break

                    except Exception as e:
                        # Print full traceback (with filenames & line numbers) to stdout
                        print("❌ Exception caught, full details below:", file=sys.stdout)
                        traceback.print_exc(file=sys.stdout)
                        crashed = "❌"
            last_run = crashed
            row = [str(bug.bug_id), description, compiled, crashed]
            table.add_row(*row)
            results.append(row)
            progress.advance(task)

    console.print(table)

    # === WRITE CRASH ANALYSIS ===
    crash_summary = {
        "kernel_name": kernel_name,
        "total_bugs": len(results),
        "compiled_count": compiled_count,
        "crashed_count": crashed_count,
        "crash_type_summary": crash_type_summary,
        "syscall_summary": syscall_summary
    }
    with open(crash_summary_path, 'w', encoding='utf-8') as f:
        json.dump(crash_summary, f, indent=2)

    with open(crash_report_path, 'w', encoding='utf-8') as f:
        json.dump(crashing_bugs, f, indent=2)

    # === WRITE CSV RESULTS ===
    csv_path = os.path.join(base_dir, f"{kernel_name}_results.csv")
    with open(csv_path, mode="w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Bug ID", "Description", "Compiled", "Crash Occurred"])
        writer.writerows(results)

    # === WRITE JSON RESULTS ===
    json_path = os.path.join(base_dir, f"{kernel_name}_results.json")
    json_data = [
        {
            "bug_id": bug_id,
            "description": desc,
            "compiled": compiled,
            "crashed": crashed
        }
        for bug_id, desc, compiled, crashed in results
    ]
    with open(json_path, mode="w", encoding="utf-8") as f:
        json.dump(json_data, f, indent=2)


    console.print(f"[green]Results saved to:[/green]")
    console.print(f"  [bold]{csv_path}[/bold]")
    console.print(f"  [bold]{json_path}[/bold]")
    console.print(f"  [bold]{crash_summary_path}[/bold]")
    console.print(f"  [bold]{crash_report_path}[/bold]")
    print(exceptions)



def extract_last_syscall(syz_file_path: str):
    syscalls = []

    with open(syz_file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            match = re.match(r'^([a-zA-Z0-9_]+)(\$[a-zA-Z0-9_]+)?\s*\(', line)
            if match:
                base_syscall = match.group(1)
                syscalls.append(base_syscall)

    last_syscall = syscalls[-1] if syscalls else None
    return syscalls, last_syscall


def extract_crash_type(crash_line: str, idx: int = 0) -> str:
    crash_type = ""
    for j in range(idx + 1, len(crash_line)):
        if crash_line[j] == 'in':
            break
        if crash_type:
            crash_type += ' '
        crash_type += crash_line[j].strip()
    return crash_type.strip()

def extract_crash_locations(log_text: str):
    """
    Extract the first N crash entries after a line of ====.
    Looks for lines like:
    'BUG: KASAN: ... in <func> <file>:<line> [inline]'
    """
    log_lines = log_text.split("\n")
    start = -1
    end = -1
    for idx, line in enumerate(log_lines):
        line = line.strip()
        if line.startswith('====') and start == -1:
            start = idx
        if start != -1 and line == '':
            end = idx - 1
        if start != -1 and line.startswith("CPU") and end == -1:
            end = idx - 2
    if start == -1:
        return "", 0, "start index out of range"
    if end < start or end >= len(log_lines):
        return "", 0, "end index out of range"
    # entries = []
    crashing_file = ""
    crash_type = ""
    crashing_line = 0
    for i in range(start +1, end):
        line = log_lines[i].split(' ')
        if line[-1] == '[inline]':
            continue
        else:
            file_line1 = next((word for word in line if '.c:' in word), None)
            file1, line1_num = (file_line1.split(':') if file_line1 else (None, None))
            crashing_file = file1
            crashing_line = line1_num
            for idx, word in enumerate(line):
                # TODO: make this more robust
                # currently this just looks at memory bugs from KASAN, UBSAN, and KMSAN
                # it then determines the type of the crash from all words starting after the colon afer the bug type
                # all the way until the word 'in'
                if 'KASAN:' in word:
                    crash_type = extract_crash_type(line, idx)
                elif 'UBSAN:' in word:
                    crash_type = extract_crash_type(line, idx)
                elif 'KMSAN:' in word:
                    crash_type = extract_crash_type(line, idx)
            break

    return crashing_file, crashing_line, crash_type

def test(id: str, kernel_name: str):
    db = SyzkallBugDatabase(kernel_name)
    metadata = db.get_bug_metadata(id)
    if metadata is None:
        print('Invalid bug id supplied')
        return
    
    print(f'Compiling {metadata.description}...')
    repro_path = metadata.compile_repro('arm64')

    if test_repro_crashes(repro_path):
        print('Crash occured')
    else:
        print('No crash occured')