# syz_trace.py
# GDB helper to trace a syzkaller PoC and detect whether it reproduces the
# same memory-access violation described in a crash log.
#
# Usage (example):
#   (gdb) set $poc_entry = "syz_executor_thread_start"
#   (gdb) set $fault_addr = 0xffff888012345678
#   (gdb) set $access_type = "write"     # "read" / "write" / "any"
#   (gdb) set $access_size = 8
#   (gdb) set $fault_insn = 0xffffffff81234567   # optional: faulting RIP from oops
#   (gdb) source syz_trace.py
#
# You can omit some variables; script will attempt best-effort checks.
#
# Diagram / context (for reference): file:///mnt/data/syzploit_overview.pdf

import gdb
import re
import time

# ---------- configuration helpers ----------
def conv_u64(v):
    try:
        return int(v)
    except Exception:
        s = str(v)
        if s.startswith("0x"):
            return int(s, 16)
        return int(s)

# read convenience variables; if not set, default to None
def gvar(name):
    try:
        return gdb.parse_and_eval(name)
    except Exception:
        return None

# ---------- Parameters read from GDB session ----------
_poc_entry_v = gvar("$poc_entry")         # symbol name or address string
_fault_addr_v = gvar("$fault_addr")       # address (int or expr)
_access_type_v = gvar("$access_type")     # "read", "write", "any"
_access_size_v = gvar("$access_size")     # bytes
_fault_insn_v = gvar("$fault_insn")       # RIP from crash log (optional)
_enable_alloc_track = True                # track kmalloc/kfree by default
_enable_kasan_check = True                # optionally check kasan symbols

# convert to Python types
poc_entry = str(_poc_entry_v) if _poc_entry_v is not None else None
fault_addr = None
if _fault_addr_v is not None:
    try:
        fault_addr = conv_u64(_fault_addr_v)
    except Exception:
        fault_addr = None
access_type = str(_access_type_v) if _access_type_v is not None else "any"
access_size = int(_access_size_v) if _access_size_v is not None else 0
fault_insn = None
if _fault_insn_v is not None:
    try:
        fault_insn = conv_u64(_fault_insn_v)
    except Exception:
        fault_insn = None

# nice summary for the user
gdb.write("syz_trace: configuration\n", gdb.STDERR)
gdb.write("  poc_entry = %s\n" % (poc_entry,), gdb.STDERR)
gdb.write("  fault_addr = %s\n" % (hex(fault_addr) if fault_addr else "None"), gdb.STDERR)
gdb.write("  access_type = %s\n" % (access_type,), gdb.STDERR)
gdb.write("  access_size = %s\n" % (access_size if access_size else "any"), gdb.STDERR)
gdb.write("  fault_insn = %s\n" % (hex(fault_insn) if fault_insn else "None"), gdb.STDERR)
gdb.write("\n", gdb.STDERR)

# ---------- global runtime state ----------
alloc_map = {}   # addr -> (size, stacktrace when allocated)
free_set = set() # addresses freed (for UAF detection)
hit_events = []  # collected verification events


# ---------- utility functions ----------
def _bt(max_frames=10):
    """Return a short backtrace as a string array."""
    frames = []
    i = 0
    f = gdb.newest_frame()
    while f and i < max_frames:
        try:
            sym = f.name() or "<unknown>"
        except Exception:
            sym = "<unknown>"
        sal = f.find_sal()
        fileline = "%s:%s" % (sal.symtab.filename, sal.line) if sal and sal.symtab else ""
        frames.append("%s %s" % (sym, fileline))
        i += 1
        f = f.older()
    return frames

def dump_regs():
    regs = {}
    for r in ["rip","rsp","rbp","rax","rbx","rcx","rdx","rsi","rdi","r8","r9","r10","r11","r12","r13","r14","r15"]:
        try:
            regs[r] = gdb.parse_and_eval("$" + r)
        except Exception:
            regs[r] = "<na>"
    return regs

def mem_read(addr, size):
    try:
        inferior = gdb.selected_inferior()
        data = inferior.read_memory(addr, size)
        return bytes(data)
    except Exception as e:
        return None

# ---------- allocation tracking (optional) ----------
class AllocBp(gdb.Breakpoint):
    def __init__(self, spec, is_alloc=True):
        super().__init__(spec, gdb.BP_BREAKPOINT, internal=False)
        self.is_alloc = is_alloc
        self.silent = True
    def stop(self):
        # On entry to allocator/free, capture args and record
        try:
            if self.is_alloc:
                # common alloc API: kmalloc(size, flags) or __kmalloc(size, flags)
                size = None
                try:
                    size = int(gdb.parse_and_eval("((unsigned long)$rdi)"))
                except Exception:
                    try:
                        size = int(gdb.parse_and_eval("((unsigned long)$rsi)"))
                    except Exception:
                        size = None
                regs = dump_regs()
                frames = _bt(8)
                gdb.write("[syz_trace] alloc detected size=%s\n" % (size,), gdb.STDERR)
                # we only record the call site; actual returned pointer will be captured in return breakpoint
                # store current frames in some temp map keyed by return address
                return False
            else:
                # free: commonly takes pointer in rdi
                try:
                    p = int(gdb.parse_and_eval("((unsigned long)$rdi)"))
                except Exception:
                    p = None
                if p:
                    free_set.add(p)
                    gdb.write("[syz_trace] free detected %s\n" % (hex(p),), gdb.STDERR)
                return False
        except Exception as e:
            gdb.write("[syz_trace] allocbp error: %s\n" % e, gdb.STDERR)
        return False

# optional: breakpoint on alloc return to capture returned addr
class AllocRetBp(gdb.FinishBreakpoint):
    def __init__(self, frame, size, frames):
        super().__init__(frame, internal=True)
        self.size = size
        self.frames = frames
    def stop(self):
        try:
            # return value commonly in rax
            p = int(gdb.parse_and_eval("((unsigned long)$rax)"))
            alloc_map[p] = (self.size, self.frames)
            gdb.write("[syz_trace] recorded alloc %s size=%s\n" % (hex(p), self.size), gdb.STDERR)
        except Exception as e:
            gdb.write("[syz_trace] allocretbp error: %s\n" % e, gdb.STDERR)
        return False

# ---------- watchpoint and verification logic ----------
class AccessWatchpoint(gdb.Breakpoint):
    """Generic watchpoint wrapper - uses gdb watchpoints via 'awatch' command."""
    def __init__(self, expr, expected_type="any", expected_size=0):
        # create hardware watchpoint using gdb command to allow 'awatch'
        super().__init__(spec=None, type=gdb.BP_BREAKPOINT, internal=True)
        self.expr = expr
        self.expected_type = expected_type.lower()
        self.expected_size = expected_size
        self.silent = True
        # actually install a hardware watchpoint via CLI:
        try:
            gdb.execute("awatch %s" % expr, to_string=True)
            gdb.write("[syz_trace] installed awatch %s\n" % expr, gdb.STDERR)
        except Exception as e:
            gdb.write("[syz_trace] awatch failed for %s: %s\n" % (expr, e), gdb.STDERR)

    def stop(self):
        try:
            rip = int(gdb.parse_and_eval("$rip"))
        except Exception:
            rip = None
        regs = dump_regs()
        frames = _bt(16)
        ev = {
            "type": "watch",
            "expr": self.expr,
            "rip": rip,
            "regs": regs,
            "bt": frames,
            "time": time.time(),
        }
        hit_events.append(ev)
        gdb.write("[syz_trace] watchpoint hit at RIP=%s expr=%s\n" % (hex(rip) if rip else "?", self.expr), gdb.STDERR)

        # Quick check: did we hit the crash instruction?
        if fault_insn and rip == fault_insn:
            gdb.write("[syz_trace] RIP matches crash RIP; probable match\n", gdb.STDERR)

        # Optional deeper validation: check access width by inspecting instruction encoding
        # (not implemented here; can be extended by disassembling RIP and inspecting operands)

        return False  # continue execution

# ---------- instruction-tracing fallback ----------
class RipBreakpoint(gdb.Breakpoint):
    def __init__(self, addr):
        super().__init__(str(addr), gdb.BP_BREAKPOINT, internal=False)
        self.silent = True
    def stop(self):
        rip = int(gdb.parse_and_eval("$rip"))
        gdb.write("[syz_trace] breakpoint at fault RIP %s reached\n" % hex(rip), gdb.STDERR)
        regs = dump_regs()
        frames = _bt(24)
        ev = {"type": "rip", "rip": rip, "regs": regs, "bt": frames, "time": time.time()}
        hit_events.append(ev)
        return False

# ---------- KASAN-aware check ----------
def install_kasan_watch():
    # KASAN runtime prints or calls kasan_report; try break on kasan_report if present
    try:
        bp = gdb.Breakpoint("kasan_report", gdb.BP_BREAKPOINT)
        bp.silent = True
        gdb.write("[syz_trace] set breakpoint on kasan_report\n", gdb.STDERR)
    except Exception:
        gdb.write("[syz_trace] kasan_report symbol not found\n", gdb.STDERR)

# ---------- main orchestration ----------
def install_checks():
    # 1) If fault_addr provided, install an awatch for it
    if fault_addr:
        # install awatch for the exact address dereference
        expr = "*((char *)%d)" % fault_addr
        try:
            wp = AccessWatchpoint(expr, expected_type=access_type, expected_size=access_size)
        except Exception as e:
            gdb.write("[syz_trace] failed to install access watch: %s\n" % e, gdb.STDERR)

    # 2) If fault_insn provided, place a breakpoint at that RIP to observe when it's executed
    if fault_insn:
        try:
            RipBreakpoint(" *0x%x " % fault_insn)
            gdb.write("[syz_trace] breakpoint placed at fault_insn %s\n" % hex(fault_insn), gdb.STDERR)
        except Exception as e:
            gdb.write("[syz_trace] could not place breakpoint at fault_insn: %s\n" % e, gdb.STDERR)

    # 3) If poc_entry provided, place a breakpoint at poc entry to start tracing; else trace from exec start
    if poc_entry:
        try:
            gdb.Breakpoint(poc_entry)
            gdb.write("[syz_trace] breakpoint placed at poc_entry %s\n" % poc_entry, gdb.STDERR)
        except Exception:
            # try as address
            try:
                gdb.Breakpoint("*%s" % poc_entry)
                gdb.write("[syz_trace] breakpoint placed at poc_entry %s (addr)\n" % poc_entry, gdb.STDERR)
            except Exception as e:
                gdb.write("[syz_trace] could not place poc_entry BP: %s\n" % e, gdb.STDERR)

    # 4) allocation/free tracking
    if _enable_alloc_track:
        # try kmalloc, kzalloc, __kmalloc, kfree symbols
        for sym in ("__kmalloc", "kmalloc", "kfree", "vfree"):
            try:
                AllocBp(sym, is_alloc=(sym != "kfree" and sym != "vfree"))
                gdb.write("[syz_trace] installed alloc/free bp on %s\n" % sym, gdb.STDERR)
            except Exception:
                pass

    # 5) KASAN detection
    if _enable_kasan_check:
        install_kasan_watch()

# install on load
install_checks()

gdb.write("[syz_trace] instrumentation installed. Run/continue the inferior to begin tracing.\n", gdb.STDERR)

# ---------- helper command to summarize hits ----------
class SyzTraceSummaryCmd(gdb.Command):
    """syz_trace_summary -- print a summary of hits collected so far."""

    def __init__(self):
        super(SyzTraceSummaryCmd, self).__init__("syz_trace_summary", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        gdb.write("=== syz_trace summary ===\n", gdb.STDERR)
        if not hit_events:
            gdb.write("  No watchpoint or RIP events seen yet.\n", gdb.STDERR)
            return
        for i, ev in enumerate(hit_events):
            gdb.write("Event %d type=%s time=%s\n" % (i, ev.get("type"), time.ctime(ev.get("time"))), gdb.STDERR)
            gdb.write(" RIP: %s\n" % (hex(ev.get("rip")) if ev.get("rip") else "unknown"), gdb.STDERR)
            gdb.write(" Backtrace:\n", gdb.STDERR)
            for f in ev.get("bt", []):
                gdb.write("   %s\n" % f, gdb.STDERR)
            gdb.write("\n", gdb.STDERR)

SyzTraceSummaryCmd()
