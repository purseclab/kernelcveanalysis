from typing import Any
from pathlib import Path
import subprocess
import os
import time
import paramiko
import signal
import sys
import threading


VM_HOST = "127.0.0.1"
VM_PORT = 10021
VM_USER = "root"
VM_PASS = ""  # adjust if needed
BINARY_PATH = "./repro"
REMOTE_PATH = "/root/repro"
REMOTE_ROOT_CMD = "export RANDOM=1000000; ./repro"
REMOTE_CMD = "mkdir -p /tmp/nonroot_test && cp ./repro /tmp/nonroot_test/ && cd /tmp/nonroot_test && chown 1000:1000 ./repro && chmod +x ./repro && su -s /bin/sh dbus -c './repro'"
LOG_FILE = "vm_output.log"

CRASH_PATTERNS = [
    "BUG:",
    "kernel panic",
    "Oops:",
    "general protection fault",
    "KASAN:",
    "UBSAN:",
    "Segfault",
    "lockdep warning",
]

def detect_crash(logs: str) -> bool:
    for pat in CRASH_PATTERNS:
        if pat in logs:
            return True
    return False

def wait_for_vm(host, port, timeout=60):
    import socket
    start = time.time()
    while time.time() - start < timeout:
        try:
            with socket.create_connection((host, port), timeout=3):
                return True
        except (ConnectionRefusedError, OSError):
            time.sleep(2)
    return False

def upload_and_run(repro_path: Path, root):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh.connect(VM_HOST, port=VM_PORT, username=VM_USER, password=VM_PASS, timeout=10)

    sftp = ssh.open_sftp()
    sftp.put(repro_path, REMOTE_PATH)
    sftp.chmod(REMOTE_PATH, 0o755)
    sftp.close()

    if root:
        stdin, stdout, stderr = ssh.exec_command(REMOTE_ROOT_CMD)
    else:
        stdin, stdout, stderr = ssh.exec_command(REMOTE_CMD)
    start = time.time()
    exit_status = None

    try:
        while not stdout.channel.exit_status_ready():
            if time.time() - start > 30:  # 10s timeout
                stdout.channel.close()    # kill command
                stderr.channel.close()
                ssh.close()
            time.sleep(0.5)

        exit_status = stdout.channel.recv_exit_status()
        logs = stdout.read().decode() + stderr.read().decode()

    finally:
        ssh.close()

    return exit_status, logs


def test_repro_crashes_qemu(repro_path: Path, local: bool, bug_id, log_dir, root, source_image: Path, source_disk: Path) -> bool:
    print("[*] Starting QEMU VM...")
    QEMU_CMD = [
        "qemu-system-x86_64",
        "-m", "2G",
        "-smp", "2",
        "-kernel", str(source_image),
        "-append", "console=ttyS0 root=/dev/vda1 earlyprintk=serial net.ifnames=0",
        "-drive", f"file={str(source_disk)},format=raw,if=virtio",
        "-netdev", "user,id=net0,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22",
        "-device", "virtio-net-pci,netdev=net0",
        "-enable-kvm",
        "-nographic"
    ]

    print(' '.join(QEMU_CMD))

    qemu_proc = subprocess.Popen(
        QEMU_CMD,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1
    )

    vm_logs = []
    log_ready = threading.Event()
    log_file_name = os.path.join(log_dir, f"{bug_id}_vm_output.log")

    # Open log file once
    log_fh = open(log_file_name, "w", buffering=1)

    def log_reader(proc, storage):
        for line in proc.stdout:
            storage.append(line)
            log_fh.write(line)
            if "syzkaller login:" in line:
                log_ready.set()

    log_thread = threading.Thread(target=log_reader, args=(qemu_proc, vm_logs), daemon=True)
    log_thread.start()

    def cleanup(sig=None, frame=None):
        print("\n[*] Caught interrupt, shutting down VM...")
        qemu_proc.terminate()
        log_thread.join(timeout=2)
        log_fh.close()
        sys.exit(1)

    # Handle CTRL-C
    # signal.signal(signal.SIGINT, cleanup)
    crash_type = 0
    result = False
    try:
        print("[*] Waiting for VM to show login prompt...")
        log_ready.wait(timeout=20)
        

        print("[*] VM is up. Uploading and executing binary...")
        exit_status, logs = upload_and_run(repro_path, root)

        log_fh.write("\n[Program Execution Logs]\n")
        log_fh.write(logs)

        print("[*] Execution finished. Exit status:", exit_status)

        all_logs = "".join(vm_logs) + logs

        if detect_crash(all_logs):
            result = True
            crash_type = 1
            print("[!] Crash detected! See logs in", log_file_name)
        elif "reproducer may not work as expected" in all_logs.lower():
            result = False
            crash_type = 2
            print("[!] Warning: Reproducer may not work as expected. See logs in", log_file_name)
        else:
            print("[+] No crash detected. See logs in", log_file_name)

    finally:
        print("[*] Shutting down VM...")
        qemu_proc.terminate()
        log_thread.join(timeout=2)
        log_fh.close()

    return result, crash_type

# uses syz_prog2c tool to translate syzkaller DSL to C code
def syz_to_c(syz_path: Path, options: dict[str, Any]) -> str:
    # features which can be enabled / disabled
    feature_flags = set([
        'binfmt_misc',
        'cgroups',
        'close_fds',
        'devlink_pci',
        'ieee802154',
        'net_dev',
        'netdev',
        'net_reset',
        'nic_vf',
        'swap',
        'sysctl',
        'tun',
        'usb',
        'vhci',
        'wifi',
        'resetnet',
    ])

    # boolean flags which need to be converted to just cli flag
    prog2c_flags = set([
        'leak',
        'segv',
        'threaded',
        'tmpdir',
        'trace',
    ])

    features = []
    # FIXME: don't hard code
    args = ['syz-prog2c', '-prog', str(syz_path)]

    for key, value in options.items():
        # cli tool expects 0 for repate forever
        if key == 'repeat' and value is True:
            value = 0
    
        if key in prog2c_flags:
            if value is True:
                args.append(f'-{key}')
        elif key in feature_flags:
            if key == 'netdev':
                key = 'net_dev'
            elif key == 'resetnet':
                key = 'net_reset'
            if value is True:
                features.append(key)
        else:
            if key =="callcomments":
                continue
            args.append(f'-{key}')
            if key == "arch" and value == "x86_64":
                value = "amd64"
            args.append(str(value))
    
    if len(features) > 0:
        args.append('-enable')
        args.append(','.join(features))

    return subprocess.check_output(args, stderr=subprocess.DEVNULL).decode('utf-8')

# FIXME: don't hardcode this
# ADB assumes adb server is avaialable at localhost:5037
# To proxy cuttlefish server, us `ssh -L localhost:5037:localhost:5037 cuttlefish`
ADB_EXE_PATH = './adb'

def wait_for_connection():
    print('Waiting for adb device to be available...')
    slept_once = False
    while True:
        proc = subprocess.Popen([ADB_EXE_PATH, 'devices'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = proc.communicate()

        # Decode and split into lines
        lines = out.decode("utf-8", errors="ignore").splitlines()

        # The first line is usually "List of devices attached"
        # Any subsequent nonâ€‘blank lines are "<serial>\t<state>"
        for line in lines[1:]:
            line = line.strip()
            if not line:
                continue
            if "device" in line:
                if slept_once:
                    print("adb is now available, but we wait 45 seconds more for the system to finish booting")
                    time.sleep(45)
                    # TODO this should be done better, the proper way is to way for this: "VIRTUAL_DEVICE_BOOT_COMPLETED"
                return
        print('Waiting more for adb device to be available...')
        time.sleep(1)
        slept_once = True


def adb_upload_file(file: Path, upload_location: Path):
    subprocess.run([ADB_EXE_PATH, 'push', str(file), str(upload_location)], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def is_device_connected() -> bool:
    # Output looks like:
    # List of devices attached
    # 0.0.0.0:6520    offline

    result = subprocess.check_output([ADB_EXE_PATH, 'devices']).decode().strip().split('\n')
    # if no devices in device list, not connected
    if len(result) == 1:
        return False
    
    # more than 1 device not supported
    assert len(result) <= 2

    status = result[1].split()[1]
    # device is connected if in device state
    return status == 'device'

def get_uptime() -> float:
    try:
        output = subprocess.check_output([ADB_EXE_PATH, 'shell', 'cat /proc/uptime']).decode()
        return float(output.strip().split()[0])
    except subprocess.CalledProcessError:
        return 0.0

# Path of repro in android VM
REPRO_PATH = '/data/local/tmp/repro'

# assumes an instance of cuttlefish VM is already running
# tests the exploit at the given path to see if it crashes the kernel
# returns true if it does
def test_repro_crashes(repro_path: Path, local: bool, id, log_dir, root=True) -> bool:
    wait_for_connection()

    adb_upload_file(repro_path, Path(REPRO_PATH))

    crash_occured = False, 0
    t0 = get_uptime()

    if root:
        run_repro_cmd = f'cd {os.path.dirname(REPRO_PATH)} && su root {REPRO_PATH}'
    else:
        run_repro_cmd = f'cd {os.path.dirname(REPRO_PATH)} && {REPRO_PATH}'
    print(run_repro_cmd)
    with subprocess.Popen([ADB_EXE_PATH, 'shell', run_repro_cmd]) as exploit_process:
        # wait for exploit to run a bit
        time.sleep(5)

        exploit_process.poll()
        t1 = get_uptime()
        if t1 < t0 or not is_device_connected():
            print("crash_occured CONDITION 1", t1, t0)
            crash_occured = True, 1
        elif exploit_process.returncode is not None:
            print("crash_occured CONDITION 2")
            crash_occured = True, 2
        elif not is_device_connected():
            print("crash_occured CONDITION 3")
            crash_occured = True, 1
        
        exploit_process.terminate()
    
    subprocess.Popen([ADB_EXE_PATH, 'shell', 'su', 'root', 'killall', 'repro']).communicate()
    return crash_occured
