from typing import Any
from pathlib import Path
import subprocess
import os
import time

# uses syz_prog2c tool to translate syzkaller DSL to C code
def syz_to_c(syz_path: Path, options: dict[str, Any]) -> str:
    # features which can be enabled / disabled
    feature_flags = set([
        'binfmt_misc',
        'cgroups',
        'close_fds',
        'devlink_pci',
        'ieee802154',
        'net_dev',
        'net_reset',
        'nic_vf',
        'swap',
        'sysctl',
        'tun',
        'usb',
        'vhci',
        'wifi',
    ])

    # boolean flags which need to be converted to just cli flag
    prog2c_flags = set([
        'leak',
        'segv',
        'threaded',
        'tmpdir',
        'trace',
    ])

    features = []
    # FIXME: don't hard code
    args = ['syz-prog2c', '-prog', str(syz_path)]

    for key, value in options.items():
        # cli tool expects 0 for repate forever
        if key == 'repeat' and value is True:
            value = 0
    
        if key in prog2c_flags:
            if value is True:
                args.append(f'-{key}')
        elif key in feature_flags:
            if value is True:
                features.append(key)
        else:
            args.append(f'-{key}')
            args.append(str(value))
    
    if len(features) > 0:
        args.append('-enable')
        args.append(','.join(features))

    return subprocess.check_output(args, stderr=subprocess.DEVNULL).decode('utf-8')

# FIXME: don't hardcode this
# ADB assumes adb server is avaialable at localhost:5037
# To proxy cuttlefish server, us `ssh -L localhost:5037:localhost:5037 cuttlefish`
ADB_EXE_PATH = './adb'

def wait_for_connection():
    print('Waiting for adb device to be available...')
    slept_once = False
    while True:
        proc = subprocess.Popen([ADB_EXE_PATH, 'devices'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = proc.communicate()

        # Decode and split into lines
        lines = out.decode("utf-8", errors="ignore").splitlines()

        # The first line is usually "List of devices attached"
        # Any subsequent nonâ€‘blank lines are "<serial>\t<state>"
        for line in lines[1:]:
            line = line.strip()
            if not line:
                continue
            if "device" in line:
                if slept_once:
                    print("adb is now available, but we wait 45 seconds more for the system to finish booting")
                    time.sleep(45)
                    # TODO this should be done better, the proper way is to way for this: "VIRTUAL_DEVICE_BOOT_COMPLETED"
                return
        print('Waiting more for adb device to be available...')
        time.sleep(1)
        slept_once = True


def adb_upload_file(file: Path, upload_location: Path):
    subprocess.run([ADB_EXE_PATH, 'push', str(file), str(upload_location)], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def is_device_connected() -> bool:
    # Output looks like:
    # List of devices attached
    # 0.0.0.0:6520    offline

    result = subprocess.check_output([ADB_EXE_PATH, 'devices']).decode().strip().split('\n')
    # if no devices in device list, not connected
    if len(result) == 1:
        return False
    
    # more than 1 device not supported
    assert len(result) <= 2

    status = result[1].split()[1]
    # device is connected if in device state
    return status == 'device'

def get_uptime() -> float:
    try:
        output = subprocess.check_output([ADB_EXE_PATH, 'shell', 'cat /proc/uptime']).decode()
        return float(output.strip().split()[0])
    except subprocess.CalledProcessError:
        return 0.0

# Path of repro in android VM
REPRO_PATH = '/data/local/tmp/repro'

# assumes an instance of cuttlefish VM is already running
# tests the exploit at the given path to see if it crashes the kernel
# returns true if it does
def test_repro_crashes(repro_path: Path, root=True) -> bool:
    wait_for_connection()

    adb_upload_file(repro_path, Path(REPRO_PATH))

    crash_occured = False, 0
    t0 = get_uptime()

    if root:
        run_repro_cmd = f'cd {os.path.dirname(REPRO_PATH)} && su root {REPRO_PATH}'
    else:
        run_repro_cmd = f'cd {os.path.dirname(REPRO_PATH)} && {REPRO_PATH}'
    print(run_repro_cmd)
    with subprocess.Popen([ADB_EXE_PATH, 'shell', run_repro_cmd]) as exploit_process:
        # wait for exploit to run a bit
        time.sleep(5)

        exploit_process.poll()
        t1 = get_uptime()
        if t1 < t0:
            print("crash_occured CONDITION 1", t1, t0)
            crash_occured = True, 1
        elif exploit_process.returncode is not None:
            print("crash_occured CONDITION 2")
            crash_occured = True, 2
        elif not is_device_connected():
            print("crash_occured CONDITION 3")
            crash_occured = True, 3
        
        exploit_process.terminate()
    
    subprocess.Popen([ADB_EXE_PATH, 'shell', 'su', 'root', 'killall', 'repro']).communicate()
    return crash_occured
