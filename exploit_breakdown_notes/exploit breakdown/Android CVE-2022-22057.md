https://github.blog/security/vulnerability-research/the-android-kernel-mitigations-obstacle-race/
TODO: perhaps do more detailed breakdown here, but as there is no source code, and article already gives good overview, maybe not much point to that.

# Bug
In the qualcomm msm GPU driver `kgsl_timeline` objects contain a list of `dma_fence` which are stored in a list with a reference count, except the reference count is not including the list reference, so it can be in the list and have a refcount of 0. There is a race condition where destroying the `ksgl_timeline` using a certain ioctl moves all the fences it contains to another list and increments their reference count. However if the individual fence is destroyed at the same time using a different ioctl, kernel may check its reference count before deciding to free it, so it can be freed twice.

# Exploit

### Getting Race Condition
- Many `dma_fence` can be added to the `kgsl_timeline` with a timeout after which they will be freed using `IOCTL_KGSL_TIMELINE_FENCE_GET`
	- Using a large amount of fences makes copying to the list take longer, so the chances one of them has their reference count decreased and checked to be 0 while freeing is higher
- The code which frees the individual fence will then wait for list to be emptied end code freeing timeline to release the lock, so it can try to remove element from the list
	- There is no longer any fences in the list, so it immediately releases lock then uses `kfree_rcu` to free fence
		- `kfree_rcu` is a delayed free though, which makes freeing object and replacing it before other thread completes difficult

The solution to the `kfree_rcu` delay is to run the code which destroys the whole timeline pinnec to a certain cpu as a lower priority task, and have a higher priority task waiting on a pipe pinned to the same cpu. Another thread will write to the pipe to wake up higher priority task which will prempt the first task after it removes `dma_fences` from list, but before it frees them, allowing `kfree_rcu` to finish and another thread to reclaim the `dma_fences` memory while the other task is prempted.

### ION Buffer
ION Buffer is used for DMA and it allows allocating contigous physical memory. Since the buffers are preallocated early in boot process, virtual address is also relatively predictable.
The ION buffer can be mmaped to userspace.

### Leak Stack Address to Exit Infinite Loop
First reclaim UAF `dma_fence` with `msg_msg`.
Point its ops pointer to to ion buff with 0s, so function pointer for freeing fence does not crash (kernel will check if its NULL before calling)
There is now an issue where second thread is an infinite loop since we cannot reclaim object and keep prev and next pointers the same, so they have to point to ION buff. However to exit infinite loop pointers must point back to original list.
A trick is used where a second list of callback functions in fake object in ION buff can be pointed to themselves, creating an empty list.
While kernel in infinite loop, it moves the elements of this list to list on stack, and by setting op pointers in correct way this stack address can be leaked, allowing userspace code to fix up other linked list and cause kernel to exit before watchdog triggers kernel panic.

### Corrupt Heap Next Pointer
After double free, `msg_msg` is freed again and can be overlapped with `signalfd`, and mask of `signalfd` can be used to set freelist next pointer to point in ION buff, allowing any objects to be allocated in memory userspace can read and write.

### Map Arbitrary Physical Memory
By allocating another ION buffer in fake heap, its page pointers can be controlled, so when the other buffer is mapped, arbitrary physical page is mapped ins userspace.

### Leak Physical KASLR
Leak `ion_heap` pointer in aloocated ION buffer, and the physical page can be calculated from this pointer since it is in low memory area. Then map this page and read ops vtable field to leak KASLR.