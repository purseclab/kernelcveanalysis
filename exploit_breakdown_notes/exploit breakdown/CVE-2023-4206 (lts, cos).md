# Bug
Uaf on qdisc, in exploit `drr` qdisc is used.
This is done by attaching it to a scoket filter, and abusing bug to get refcount of drr qdisc to 0. Then delete the qdisc object while it is still attached to the filter, and it will be freed.

The bug involves attaching filter to a class, then changing the filter, and a child class of the filter will be freed I think?

This is a bug in the route filter.

Details about filter types:
Filter basically determines when to put a packet in a qdisc.
https://www.man7.org/linux/man-pages/man8/tc.8.html#FILTERS

# Exploit Chain (lts)

### Fork Dummy Process
This process just changes its arg0 to a well known value. It is simply used to recover stdin, stdout, and stderr file descriptors once exploit finishes.

### Fork Crashing Process
This process waits for `/proc/sys/kernel/corepattern` to be overwritten. Once it is overwritten to a malicious value, this process intentionally segfaults to trigger a coredump, running the attacker process as root.

### Create Namespace
Creates new user, mount, and network namespace.

### Place Payload at Known MMAP Address
Places the payload string `|/proc/%P/fd/666` at a known address for shellcode to copy into `/proc/sys/kernel/corepattern`.

### Spray EBPF Shellcode
Sprays shellcode which will be run when rip control is gained. This shllcode address is never leaked, authors just tested that it tends to land in a certain region.
The shellcode overwrites the crash handler program to be run, and this program always runs as root.

### Spawn Thread to Spray msg_msg
There is a vtable pointer in the freed qdisc, so spraying msg_msg in same cache, since there is no variable sized cache isolation, results in controlling vtable pointer.

### Trigger bug
Triggers bug to get a freed qdisc still in use.

### Put Fake Vtable at Fixed Kernel Address
Using another bug (CVE-2023-0597), where kernel signal handler saves cpu registers at a fixed address when entering kernel, the process forks and has another process set its registers to make a fake vtable, then perform a divide by 0.

### Trigger Exploit
Finally the main process sends a packet, triggering code execution. The crashing process will detect crash handler has changed and intentionally crash, spawning root attacker program. This program retrieves stdin, stdout, and stderr from the dummy process, then finally runs a shell.

# Exploit Chain (cos)

It is identical to lts exploit, just different offsets.