# Bug
There are 2 features with unix sockets in the kernel:
- Unix sockets can send file descriptor to other process
	- This includes other unix sockets, so kernel has unix socket garbage collector because otherwise there is some reference cycle possibilities
- There is a feature for sockets called out of band message
	- Out of band message sends a message with higher priority, to alert receiver to network conditions or something usually
	- Unix sockets support this if kernel is compiled with `CONFIG_AF_UNIX_OOB=y`

Note: skb means `struct sk_buff`, which is called socket buffer. It is common thing for holding linux kernel packet data.

Unix sockets has a field for the incoming oob message called `oob_skb`. They also have a list called `sk_receive_queue`, which is a queue of incomming skbs. All sockets have this queue.

The oob skb for message goes into both `oob_skb` and `sk_receive_queue` when oob message sent. Skbs are reference counted to allow for scenarios like this.

The issue occurs when the garbage collector tries to free a socket, while you send a oob message to it. Kernel does:
```
if (ousk->oob_skb)
	consume_skb(ousk->oob_skb);

WRITE_ONCE(ousk->oob_skb, skb);
```
To replace old skb, so it decramnts reference count and replaces pointer, so this is correct to dec refcount, since reference has been changed.

Ths issue is in garbage collection calls `unix_release_sock` to free receiving socket:
```
if (u->oob_skb) {
	kfree_skb(u->oob_skb);
	u->oob_skb = NULL;
}
```
It could happen that first refcount decrament happens on old, and this second refcount dec happens on old as well, before it is replaced in the `WRITE_ONCE` line. So now 1 extra refcount has been done, and object is freed.

Later on `sk_receive_queue` is traversed while socket is still being freed by gc to free skbs in side it, so this results in a uaf becaue old `oob_skb` pointer is still in this list.

### Required Configs
`CONFIG_AF_UNIX_OOB=y`

# Exploit Chain (lts, cos)
lts and cos exploits are exactly the same except for offsets.

### Fork Crashing Process
First this process puts `/proc/self/exe` in memfd 666.
This process waits for `/proc/sys/kernel/corepattern` to be overwritten. Once it is overwritten to a malicious value, this process intentionally segfaults to trigger a coredump, running the attacker process as root.

### Adjust File Limit
Adjusts the maximum file descriptor limit to 0xf000.

### Place Coredump String at Fixed Address
Places the string `\/proc/%P/fd/666 %p` at a known address using mmap.
This will later be written to `/proc/sys/kernel/core_pattern` to control program executed on coredump.

### Spray EBPF Shellcode
Sprays shellcode which will be run when rip control is gained. This shllcode address is never leaked, authors just tested that it tends to land in a certain region.
The shellcode overwrites the crash handler program to be run, and this program always runs as root.

### Timerfd Trick
This exploit uses a trick with timerfd to extend the race condition window.
TODO: understand this part better

### Create Unix Domain Sockets
Creates 2 unix domain sockets connected with eachother with send and receive buff sizes of `0x400000`.

### Create Message Queues
Creates a lot of message queues for spraying `msg_msg`.

### Spawn Unix GC Triggering Thread
This thread triggers unix socket gc half of race condition. It sets up something in the timerfd every iteration to make race window larger, then it just opens and closes a socket to trigger gc. It has a bit of a sleep delays, and does this in a loop.
This thread is pinned on CPU 1.

### Pin CPU
Pins the main thread to CPU 0.

### Trigger Bug
Creates 2 more unix domain sockets. Sprays some normal messages in socket, to fill up cache specifically for `sk_buff`. Then send 1 oob message, which will be the double free target. Spray more normal `sk_buff` after.

Next send one file decriptor to itself, using the other, and close it. This creates reference cycle which GC wil attempt to free.

Next trigger timerfd thing to extand window.

Then Send oob message from other socket to trigger double free.

### Cross Cache Attack
`sk_buff` is in its own kmalloc cache. This exploit uses a cross cache cache to put `msg_msg` in general cache on page used by old `sk_buff` cache. This is done by using `recv` to free all the sprayed `sk_buff`, resulting in cache free, then sparying `msg_msg`, so they hopefully make new cache in the same page.

### Malicious `sk_buff`
The sprayed `msg_msg` overlaps skb which will be freed again. We set its refcount to 1, so next refcount decrement will trigger a free. skb has a function pointer for destructor, so this is also set to redirect execution. Execution will redirect to guessed eBPF shellcode offset.

### Spawn Shell
The same executable is launched as root coredump handler, with 1 argument this time. It then knows to get other process stdin, stdout, stderr and spawn a shell.

# Mitigation Notes
This exploit technique is foiled by [[Mitigations#SLAB_VIRTUAL]], and perhaps others.