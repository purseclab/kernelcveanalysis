There are 46 separate exploit dirs in kernelctf expoit folder.

Some CVEs are the same just used in different instances. Pairing same CVEs against different instances together we get 37 CVEs:

- CVE-2023-0461 (mitigation)
- CVE-2023-31436 (mitigation)
- CVE-2023-32233 (mitigation)
- CVE-2023-3390 (lts, cos, mitigation)
- [[CVE-2023-3609 (cos, mitigation)]]
- CVE-2023-3611 (lts, mitigation)
- CVE-2023-3776 (lts, cos, mitigation)
- [[CVE-2023-3777 (lts)]]
- CVE-2023-4004 (lts, cos, mitigation)
- [[CVE-2023-4015 (lts)]]
- CVE-2023-4147 (lts, cos, mitigation)
- [[CVE-2023-4206 (lts, cos)]]
- [[CVE-2023-4207 (lts, cos)]]
- [[CVE-2023-4208 (lts, cos, mitigation)]]
- CVE-2023-4244 (lts)
- CVE-2023-4569 (lts)
- CVE-2023-4622 (lts, cos)
- [[CVE-2023-4623 (lts, cos)]]
- [[CVE-2023-5197 (lts, cos, mitigation)]]
- CVE-2023-52447 (cos)
- CVE-2023-52620 (lts, cos, mitigation)
- CVE-2023-5345 (lts, mitigation)
- CVE-2023-6111 (lts, cos)
- CVE-2023-6817 (lts, cos, mitigation)
- CVE-2023-6932 (cos)
- CVE-2024-0193 (lts, cos, mitigation)
- CVE-2024-1085 (lts, cos)
- CVE-2024-1086 (lts, mitigation)
- CVE-2024-26581 (lts, cos, mitigation)
- CVE-2024-26642 (lts)
- CVE-2024-26808 (cos)
- CVE-2024-26925 (lts, cos)
- CVE-2024-27397 (mitigation)
- CVE-2024-36972 (lts, cos)
- CVE-2024-39503 (lts, cos)
- [[CVE-2024-41009 (lts, cos)]]
- CVE-2024-41010 (lts)



# Bug Categorization

I broke down the bugs for the exploits themselves into the following categories and subcategories:

### Memory Corruption

##### Temporal Heap Bug (UAF / Double Free)

Uaf of `icsk_ulp_data` (some thing used in kernel supported TLS sockets)
- CVE-2023-0461 (mitigation)

nftables uaf of `struct nft_chain` (common exploits)
- [[CVE-2023-3777 (lts)]]
- [[CVE-2023-4015 (lts)]]
- CVE-2023-4147 (lts, cos, mitigation)
- [[CVE-2023-5197 (lts, cos, mitigation)]]
- CVE-2024-0193 (lts, cos, mitigation)
	- also double free on pipapo set element, specifically catchall element when set is freed and element gc'd at same time
	- this element double free used to get uaf on `struct nft_chain`
- CVE-2023-52620 (lts, cos, mitigation)
	- slightly different from the above exploits

nftables uaf on `nft_set`
- CVE-2023-32233 (mitigation)
- CVE-2023-3390 (lts, cos, mitigation)
	- Kind of know about this already, so do full breakdown, but it is a bit complicated have to do later

nftables double free on pipapo element in pipapo set (pipapo is a specific algorithm implementing set functionality, nftables supports multiple set types)
- CVE-2023-4004 (lts, cos, mitigation)
	- Probably do full decomposition on this one looks kinda simple
- CVE-2023-6111 (lts, cos)
	- similar to CVE-2023-4004 (lts, cos, mitigation)

nftables double free on set element
- [[CVE-2023-4244 (lts)]]
	- eventually acheives uaf on `nft_set`
- CVE-2023-4569 (lts)
	- specifically on the catchall element, which is element returned if no element found in set
- CVE-2023-6817 (lts, cos, mitigation)
	- similar to CVE-2023-4569 (lts), mitigation a bit different
- CVE-2023-26642 (lts)
	- similar to CVE-2023-4569 (lts)
- CVE-2024-27397 (mitigation)
	- similar to CVE-2023-6817 (lts, cos, mitigation), only the mitigation exploit
- CVE-2024-1085 (lts, cos)
	- double free on catchall element as well
- CVE-2024-26581 (lts, cos, mitigation)
	- similar to CVE-2024-1085(lts, cos), just different bug to get set element double free

nftables double free on `struct sk_buff` (buffer for holding network traffic data)
- CVE-2024-1086 (lts, mitigation)
	- this on has a very detailed blog post (https://pwning.tech/nftables/)
	- also quite complicated seeming exploit

uaf on a network device
- CVE-2024-26808 (cos)
	- deleting the network device while having an nftables chain of type `NF_INET_INGRESS` will lead to chain having dangling pointer to old device
	- this one could be good to do breakdown on

uaf on qdisc of various types (these 5 are all basically the same exploit except few byte differences)
- [[CVE-2023-4206 (lts, cos)]]
	- uaf in cls_route
- [[CVE-2023-4207 (lts, cos)]]
	- uaf in cls_fwd
- [[CVE-2023-4208 (lts, cos, mitigation)]]
	- uaf in cls_u32
- [[CVE-2023-3609 (cos, mitigation)]]
	- uaf in cls_u32, invalid parameters cause premature return while adjusting refcount of qdisc
- CVE-2023-3776 (lts, cos, mitigation)
	- uaf in cls_fw, if tcf_change_indev fails

uaf on `tcx_entry` (some thing in a qdisc)
- CVE-2024-41010 (lts)

uaf on hfsc qdisc, but with different methodology then above:
- [[CVE-2023-4623 (lts, cos)]]

double free in smbfs
- CVE-2023-5345 (lts, mitigation)
	- forget to set freed pointer to NULL

##### Buffer Overrun / Out of Bounds Access

out of bounds access in sch_qfq qdisc
- CVE-2023-31436 (mitigation)
- CVE-2023-3611 (lts, mitigation)

bpf ringbuffer buffer overlapping
- [[CVE-2024-41009 (lts, cos)]]

### Logic Bug

### Race Condition

##### Race Condition Causing UAF / Double Free

unix socket race condition which could result in double free
- CVE-2023-4622 (lts, cos)
- CVE-2024-36972 (lts, cos)

race condition between namespaces and garbage collection of ip set objects (set of ip addresses used in older iptables)
- CVE-2024-39503 (lts, cos)

BPF race condition when freeing arraymap
- CVE-2023-52447 (cos)

Race condition on timer being freed in IGMP code
- CVE-2023-6932 (cos)

race condition leading to nftables set element double free
- CVE-2024-26925 (lts, cos)

### Side Channel

Some exploits use CVE-2022-4543 side channel to leak kaslr.
This essentially uses a CPU prefetch instruction, to scan for kernel entry stub mapped in userspace page tables. It turns out this piece of code is a constant offset from kaslr base.