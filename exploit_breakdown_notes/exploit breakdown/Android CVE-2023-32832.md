https://googleprojectzero.blogspot.com/2024/06/driving-forward-in-android-drivers.html

# Bug
There is a bug in the mediatek JPEG decoding accelerator driver. Functions for initializing and deinitializing a decoding core hold a lock when they are called, but the function for starting and running the decoding process does not take the lock. It was perhaps assumed once a core is initalized and reserved, noone else would try to use it. However, if invalid data is provided while calling the `JPEG_DEC_IOCTL_HYBRID_START` ioctl, the device is momentarily in use, allowing another task to call `JPEG_DEC_IOCTL_HYBRID_WAIT`, to be called, which after a timeout will free data associated with the decode operation. The original task can then start a valid decoding operation, and both tasks end up freeing associated data. Among this data is a `dma_buf` file descriptor having its refcount decreased, so a file descriptor has its refcount decreased twice, and then it is freed, while still remaining in the file table, which leads to a dangling `struct file`.

# Exploit
No code is available from what I can tell, so this is just rough overview of article:
- Use above exploit to get a freed `dma_buf` file with its entry still being in file buffer table
	- File is freed, but its memory has not been wiped (except for freelist pointers), but it is still usable
	- Since file is in its own kmalloc cache, getting overlapping objects is easier in the generic cache, which file still points to a freed `dma_buf`
- Spray GE Buffer on heap to overlap with freed `dma_buf`
	- GE buffer is from the Mediatek GPU Extension driver
	- GE buffer is entirely user controlled, freeable on demand, and can have its entire contents read and updated without being freed
- Arbitrary read primitive
	- Overlap freed `dmabuf->file`
	- Use `/proc/pid/fdinfo/<fd>` to get file info from dangling file
		- It does `seq_printf(m, "count:\t%ld\n", file_count(dmabuf->file) - 1);`, which reads 8 byte value from controlled address
- Arbitrary free primitive
	- `mtk_dma_buf_set_name` frees old `dmabuf` name, and allocates a new one. Since we control old name, this can free old controlled pointer
		- This is part of mediatek driver, which is used instead of regular ioctl to set dma name
			- Regular dma set name ioctl has an SELinux check which panics kernel on dangling file descriptor
- Leak fdtable address
	- Rename dmabuffer, and record old pointer to now freed heap memory
	- Spray fdtable by forking and unsharing fd table, causing new fdtable to be allocated
		- One will end up at old address
- Arbitrary write primitive
	- Mediatek GPU Extension driver keeps GE buffer in an array of pointers to GE buffer
	- Leak a GE Buffer array form file descriptor in leaked fd table using arbitrary read
	- Use arbitrary free to free array this GE Buffer array
	- Reclaim with regular GE buffer, allows overwriting pointer
	- Write to one of the GE buffers in this reclaimed array
		- Since pointers are controlled, we can write anywhere
- Leak KASLR
	- Article didn't specify how, but I would read `struct file_operations` from a `struct file` in leaked fdtable
		- This should be a vtable in kernel binary
- Code execution
	- With arbitrary read and write, it is straightforward
	- Article just disables selinux and overwrites process uid to 0