# Bug
Nftables set elements can have something called extension data. There are various types of extension data:
```
/**
 *	enum nft_set_extensions - set extension type IDs
 *
 *	@NFT_SET_EXT_KEY: element key
 *	@NFT_SET_EXT_KEY_END: upper bound element key, for ranges
 *	@NFT_SET_EXT_DATA: mapping data
 *	@NFT_SET_EXT_FLAGS: element flags
 *	@NFT_SET_EXT_TIMEOUT: element timeout
 *	@NFT_SET_EXT_EXPIRATION: element expiration time
 *	@NFT_SET_EXT_USERDATA: user data associated with the element
 *	@NFT_SET_EXT_EXPRESSIONS: expressions assiciated with the element
 *	@NFT_SET_EXT_OBJREF: stateful object reference associated with element
 *	@NFT_SET_EXT_NUM: number of extension types
 */
enum nft_set_extensions {
	NFT_SET_EXT_KEY,
	NFT_SET_EXT_KEY_END,
	NFT_SET_EXT_DATA,
	NFT_SET_EXT_FLAGS,
	NFT_SET_EXT_TIMEOUT,
	NFT_SET_EXT_EXPIRATION,
	NFT_SET_EXT_USERDATA,
	NFT_SET_EXT_EXPRESSIONS,
	NFT_SET_EXT_OBJREF,
	NFT_SET_EXT_NUM
};
```

When an element in a set is freed or flushed in some scenarios, the function `nft_setelem_data_deactivate` below is called, which releases some resources associated with these set element extensions.
```
static void nft_setelem_data_deactivate(const struct net *net,
					const struct nft_set *set,
					struct nft_set_elem *elem)
{
	const struct nft_set_ext *ext = nft_set_elem_ext(set, elem->priv);

	if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
		nft_data_release(nft_set_ext_data(ext), set->dtype);
	if (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF))
		nft_use_dec(&(*nft_set_ext_obj(ext))->use);
}

```

It turns out that if you have a map set (set which stores key value pairs) with a catchall element, and you flush the set (delete all elements in the set), then delete the set itself in the same transaction, `nft_setelem_data_deactivate` will be called twice on the same set element. This is because in improper check in `nft_map_catchall_deactivate` which is called when deleting the set does not check if the busy flag for the element is set.

# Exploit Chain (lts)
TODO
Essentially, corrupt length of user data exension type in set element by decramenting reference counter to cause an underflow, and make it big, so out of bounds read write can be done

### Create Namespace
Creates a new user and network namespace, to get CAP_NET_ADMIN.

### Record Register State
Records the current values of rsp, cs, ss, and rflags in global variables. Used for returning back to userspace after gaining code execution.

### Create Netlink Socket
Creates and connects a netlink socket, which is used for issuing nftables commands.

### Spray `nft_object`
Creates `0x40` `nft_object`. These objects are used for leaking heap and KASLR.

### Create Set Elements Referencing Object
Creates `0x29` set elements in a `pipapo_set` referencing one of the objects, as well as 1 object in as hash map set referencing the same object. This means the object's reference count is `0x2a`. Since many objects were sprayed, we choose an object in between 2 other objects on the heap.

### Trigger Vuln
The exploit then triggers the vulnerability `0x2a` times. It uses the vulnerability on a set element referencing the target object in a new set each time. This results in the reference count being increased by 1 every time the set element is created, decreased by 1 then the hash map set is flushed, then decreased again when the hash map set is deleted, so ref count is decreased by 1 per iteration, resulting in target object having reference count of 0.

The object can then be deleted. Note that reference count being 0 doesn't immediately trigger deletion, it just allows for deletion, since no other objects reference it.

### Leak Heap
Lots of new set elements are sprayed on the heap. The set element can have user data inside of it, which allows size to be manipulated to fit in the same cache size (`kmalloc-256`) as the freed object.

`nft_object` layout:
```
/**
 *	struct nft_object - nf_tables stateful object
 *
 *	@list: table stateful object list node
 *	@key:  keys that identify this object
 *	@rhlhead: nft_objname_ht node
 *	@genmask: generation mask
 *	@use: number of references to this stateful object
 *	@handle: unique object handle
 *	@ops: object operations
 *	@data: object data, layout depends on type
 */
struct nft_object {
	struct list_head		list;
	struct rhlist_head		rhlhead;
	struct nft_object_hash_key	key;
	u32				genmask:2;
	u32				use;
	u64				handle;
	u16				udlen;
	u8				*udata;
	/* runtime data below here */
	const struct nft_object_ops	*ops ____cacheline_aligned;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```

Set element will have extension data stored as follows:
```
/**
 *	struct nft_set_ext - set extensions
 *
 *	@genmask: generation mask
 *	@offset: offsets of individual extension types
 *	@data: beginning of extension data
 */
struct nft_set_ext {
	u8	genmask;
	u8	offset[NFT_SET_EXT_NUM];
	char	data[];
};
```

The userdata extension is stored as follows:
```
/**
 *	struct nft_userdata - user defined data associated with an object
 *
 *	@len: length of the data
 *	@data: content
 *
 *	The presence of user data is indicated in an object specific fashion,
 *	so a length of zero can't occur and the value "len" indicates data
 *	of length len + 1.
 */
struct nft_userdata {
	u8			len;
	unsigned char		data[];
};
```

By creating some extensions before userdata, we can get userdata to overlap with freed object reference count at `0x30` offset. Userdata length is `0xa0` to make set element correct size.

Then free the `0x29` set elements from before, triggering `len` to be decramented by 4 each time (2 lower order bits of refcount are used for genmask). This will trigger underflow in `len`, to make it `0xf4`. Userdata can then be read out, leading to leak of heap pointer from linked list of next object.

### Leak KASLR
Delete the previous set elements used to leak heap. Then spray some `struct nft_table` with a specific user data. User data is stored in a separately allocated buffer, so we can make it have the same size as freed object space, and put a fake object which the 1 set element not yet deleted still references.

This fake object has a name pointing to vtable pointer of object at the leaked heap address. This means exploit can simply read out the name of object referenced by set element to leak KASLR.

### RIP Control
A similar technique is used to leaking heap. Create a set element with a prviously freed object, but this time `NFT_SET_EXT_EXPRESSIONS` with length `0x10` is overlapped with refcount. It is underflowed to be `0xfffffffa`.  `nft_expr` is shown below:
```
struct nft_expr {
	const struct nft_expr_ops	*ops;
	unsigned char			data[]
		__attribute__((aligned(__alignof__(u64))));
};
```

`NFT_SET_EXT_OBJREF` will be placed directly `NFT_SET_EXPRESSIONS`, pointing to another freed object, where we put a fake vtable. When dumping the set element, ops->dump will be called, leading to rip control.

### ROP
The rop chain first uses a stack pivot to pivot into the same region of memory with the fake vtable. Then it calls `commit_creds(&init_creds)` to make process root, and removes it from the namespace created earlier, and returns back to userspace, which spawns a shell.