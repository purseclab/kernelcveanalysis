### SLAB_VIRTUAL
When a kmalloc cache of a certain type is freed, the underlying virtual address will never be reused for a cache of a different type.

Prevents cross cache attacks.

### SLAB_FREELIST_RANDOM
Randomizes order of entries in the slab freelist when new page is allocated and used in the slab allocator.

### SLAB_FREELIST_HARDENED
Among other things, freelist pointer is obfuscated with technique similar to safe linking from glibc.
Pointer is xor with its byte swapped virtual address, and a per cache random 64 bit value.

# Android Mitigations
Just mitigations ive seen mentioned in relation to android, not necessarily android specific

### kCFI
kCFI is a forward edge control flow integrity mechanism, using llvm control flow integrity (done in software). Essentially for each virtual function call, kCFI should ensure that execution can only be directed to the start of a function which matches the type of the function pointer being called.

https://clang.llvm.org/docs/ControlFlowIntegrityDesign.html
https://source.android.com/docs/security/test/kcfi

For C functions, the way it works is essentially there is a big jump table, where each function has 1 jump to it. The jump table is in a layout such that jump table entries to functions of the same type are all next to each other. Then when taking the address of a function, compiler instead takes the address of the jump in this jump table. When calling a function pointer, compiler checks it is 8 byte aligned (size of jump instruction), and within the proper range.

### Backward Edge CFI (Shadow Stack)
There is support for software powered shadow stack, where address of shadow stack is stored in x18 register. However in the kernel it seems this is disabled by default, but device manufacture can enable it with `CONFIG_SHADOW_CALL_STACK=y`.

https://source.android.com/docs/security/test/shadow-call-stack

### Automatic Variable Zeroing
`CONFIG_INIT_STACK_ALL_ZERO=y` zeroes all stack variables
`CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y` zeroes heap memory when it is allocated
Supposedly these are often set in android 11 and on.

### `seccomp_bpf` Filter
Seccomp filters out certain syscalls, and is generated from files in android source code here: https://cs.android.com/android/platform/superproject/main/+/main:bionic/libc/SECCOMP_ALLOWLIST_COMMON.TXT;bpv=0;bpt=0. Seccomp policy is installed per app by the zygote process. There is a seperate policy for system services, which is less restrictive.

### SELinux
Android has SELinux for enhanced security, rules are configured here: https://cs.android.com/android/platform/superproject/main/+/main:system/sepolicy/README.md;bpv=0;bpt=0. Apps will use the `untrusted_app` policy by default.
Additional info: https://source.android.com/docs/security/features/selinux

From skimming the config, it looks like notable exploitation areas on the x86 exploits I looked at which are completely blocked by SELinux include nftables, and net filter (`netlink_netfilter` socket is blocked). Netfilter sockets are however only banned in apps, some system server profiles look like they allow netfilter, so an exploit in them could allow netfilter vuln to be exploited.

# Structure Layout Randomization
If `CONFIG_GCC_PLUGIN_RANDSTRUCT`, ad GCC compiler plugin will randomize the order of fields in certain structures. It will randomize the order of every struct which consists of only function pointer, and every struct which is annotated with `__randomize_layout` macro (this includes popular structs like `struct file` and many others).

This randomization is based on a fixed seed. If you want to build a module for a kernel with randomization, you will need to know this seed if your module accesses any struct which is randomized (very likely to happen).

### Other ARM Notes
Just comparison to x86 mitigations I am more familiar to.

PXN (privileged execute never) is similar to SMEP (but on a per page basis)
PAN (privileged access never) is basically same as SMAP (there are also specific instructions ldtr and sttr which allow access to unprivilaged region from kernel code)

### User Access Override
With PAN, ldtr and sttr behave as user access instrucitons. Apparently there can be an issue with `copy_from_user` and `copy_to_user` copying from kernel code when overwriting `addr_limit` (which supposadly controls maxiumum address these functions can read and write to, anything above they can't).
When the user access override bit is set, which it will be by kernel if `addr_limit = -1 (0xfff...ffff)`, ldtr and sdtr, act like normal ldr and str. Apparantly this prevents certain attacks when overwriting `addr_limit` (https://duasynt.com/blog/android-uao-kernel-expl-mitigation).
TODO: look into this more. I don't understand how it prevents attacks, it seems easily bypassable by for example sending one end of pipe to another task and doing similar attack.

### Samsung Realtime Kernel Protection
One article I saw mentions this feature on samsung devices, which prevents certain snesitive areas of kernel memory from being written to. This can make exploits harder, but usually there is some area you can write to get exploit working if you have arbitrary read and write. There are probably similar features on some other devices.
TODO: look into this more