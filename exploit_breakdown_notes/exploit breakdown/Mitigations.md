### SLAB_VIRTUAL
When a kmalloc cache of a certain type is freed, the underlying virtual address will never be reused for a cache of a different type.

Prevents cross cache attacks.

### SLAB_FREELIST_RANDOM
Randomizes order of entries in the slab freelist when new page is allocated and used in the slab allocator.

# Android Mitigations
Just mitigations ive seen mentioned in relation to android, not necessarily android specific

### kCFI
kCFI is a forward edge control flow integrity mechanism, using llvm control flow integrity (done in software). Essentially for each virtual function call, kCFI should ensure that execution can only be directed to the start of a function which matches the type of the function pointer being called.

https://clang.llvm.org/docs/ControlFlowIntegrityDesign.html
https://source.android.com/docs/security/test/kcfi

### Automatic Variable Zeroing
`CONFIG_INIT_STACK_ALL_ZERO=y` zeroes all stack variables
`CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y` zeroes heap memory when it is allocated
Supposedly these are often set in android 11 and on.

### Other ARM Notes
Just comparison to x86 mitigations I am more familiar to.

PXN (privileged execute never) is similar to SMEP (but on a per page basis)
PAN (privileged access never) is basically same as SMAP (there are also specific instructions ldtr and sttr which allow access to unprivilaged region from kernel code)

### User Access Override
With PAN, ldtr and sttr behave as user access instrucitons. Apparently there can be an issue with `copy_from_user` and `copy_to_user` copying from kernel code when overwriting `addr_limit` (which supposadly controls maxiumum address these functions can read and write to, anything above they can't).
When the user access override bit is set, which it will be by kernel if `addr_limit = -1 (0xfff...ffff)`, ldtr and sdtr, act like normal ldr and str. Apparantly this prevents certain attacks when overwriting `addr_limit` (https://duasynt.com/blog/android-uao-kernel-expl-mitigation).
TODO: look into this more. I don't understand how it prevents attacks, it seems easily bypassable by for example sending one end of pipe to another task and doing similar attack.

### Samsung Realtime Kernel Protection
One article I saw mentions this feature on samsung devices, which prevents certain snesitive areas of kernel memory from being written to. This can make exploits harder, but usually there is some area you can write to get exploit working if you have arbitrary read and write. There are probably similar features on some other devices.
TODO: look into this more