# Bug
Use after free of `struct nft_chain`.
`nf_tables_delrule` doesn't check if a chain is bound when `NFTA_RULE_CHAIN` is not given, it simply deletes all rules in the chain. Then if the chain is bound, rules are deleted again. The exploit uses a `nft_immediate` expression referencing another chain to decrease its recount twice, so the other chain then has a use after free, since a different recounted reference still exists.

TODO: find out what `NFTA_RULE_CHAIN` is

# Exploit Chain (lts)

### Create Namespace
Creates a net, mount, and user namespace, and maps root in the user namespace to the process's uid in the parent namespace. Same applies to gid.

### Create Network Device
Creates a loopback (lo) device using netlink sockets.

### Pin Exploit to CPU
Pins the process running the exploit to CPU 0.

NOTE: creating namespace and creating network device are then done again in a loop inside existing namespace

### Trigger UAF
Code is quite complicated, just uses bug listed above with a ton of netlink operations. The end result is there is a chain which we can still access, but the underlying memory has been freed.

### Leak KASLR
Uses `NFT_MSG_GETRULE`, to get the rules in a table. This output also includes the freed chain name, which overlaps with a sprayed counter expressions vtable, so the name pointer now points into a vtable. A function pointer from the vtable will be returned as the table name, allowing kaslr leak.

```
/**
 *	struct nft_chain - nf_tables chain
 *
 *	@rules: list of rules in the chain
 *	@list: used internally
 *	@rhlhead: used internally
 *	@table: table that this chain belongs to
 *	@handle: chain handle
 *	@use: number of jump references to this chain
 *	@flags: bitmask of enum nft_chain_flags
 *	@name: name of the chain
 */
struct nft_chain {
	struct nft_rule_blob		__rcu *blob_gen_0;
	struct nft_rule_blob		__rcu *blob_gen_1;
	struct list_head		rules;
	struct list_head		list;
	struct rhlist_head		rhlhead;
	struct nft_table		*table;
	u64				handle;
	u32				use;
	u8				flags:5,
					bound:1,
					genmask:2;
	char				*name;
	u16				udlen;
	u8				*udata;

	/* Only used during control plane commit phase: */
	struct nft_rule_blob		*blob_next;
};

```

### Trigger UAF Again
Another UAF is triggered, presumable new free chain needed for next part of exploit.

### Leak Heap
In a similar manner to leaking kaslr, a `nft_rules` object is sprayed, and a pointer in this overlaps with name, and points to another heap address, so we can read out heap address.

### Overwrite Vtable Pointer
The uaf bug results in memory blob_gen_0, which contains a vtable pointer, being freed, so user controlled data section in `nft_table` is sprayed to overwrite thie vtable pointer.

### ROP Chain
A rop chain is sprayed also in the user data section, and it is split in 2 parts since it doesn't all fit in one section. The ROP chain makes the attacker process root and moves it out of the namespace.
Finally the ROP chain returns back to userspace process, to code which spawns a root shell.

### Trigger ROP
The process than forks, with one of the forks creating a socket to listen on port 1337, and the other sending a dummy message to this socket. This triggers the nftables filtering code, which uses corrupted vtable pointer, triggering entire exploit.

# Other Notes
The chain names are varied in size, to allocate the inital name to a particular kmalloc cache size, so that chain name overlaps with the correct objects.