blog post: [github_blog](https://github.blog/security/application-security/real-world-exploit-chains-explained/)

Vulnerable phone: Google Pixel 4
Vulnerable kernel: version QQ3A.200705.002

Overview:

This one is short, only three exploits and two of them are chromium exploits. This Qualcomm KGSL vulnerability was powerful enough for an attacker with arbitrary userland code execution (via the chromium exploits) to achieve arbitrary kernel code execution. For this exploit at least, it is easy to see how they all fit together. However, the qualcomm exploit is increadibly complicated and requires a lot of steps to deal with android mitigations. 


| CVE                 | Exploit                                                                                                                                                                                                                                                                                                                    Method | Purpose                                           | POC/Writeup                                                                                                                                                                                                                                  | Writeup                                                                                                                                                                                                                                                                | NVD                                                                                                |
| --------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |
| CVE-2020-15972 |Race causes UAF in chrome WebAudio system. Create ScriptProcessorNode's that pause a sufficient amount of time during processing to control the race. Then, connect them to a GainNode. The make the processing script2 of the Processor nodes delete the GainNode and garbage collect so it's input and output are freed. Delete other nodes before replacing the GainNode so it's output are not at the head of the free list. Replace GainNode, which then calls Bus giving freed AudioBus. Reclaim with ChannelMergerNode (this can be done through spraying). Cause a pause with setInterval on the main thread, create a minimal length AduioBus (out of bounds read is caused by replacing freed bus with a smaller bus) and place a BiquadDSPKernel behind it. Trigger bug for out of bounds read leaking BiquadDSPKernel object and read with ScriptProcessorNode.| chrome renderer exploit for RCE on chrome sandbox |                                                                                                                                                                                                                                              |[https://github.blog/security/vulnerability-research/one-day-short-of-a-full-chain-part-3-chrome-renderer-rce/#the-vulnerability](https://github.blog/security/vulnerability-research/one-day-short-of-a-full-chain-part-3-chrome-renderer-rce/#the-vulnerability)| [https://nvd.nist.gov/vuln/detail/CVE-2020-15972](https://nvd.nist.gov/vuln/detail/CVE-2020-15972) |
| CVE-2020-16045 |Extend the life of a `InternalAuthenticatorAndroid` object to outlive a `render_frame_host` object and replace the frame host with a call to a virtual function. poc and [blog post](https://github.blog/security/vulnerability-research/one-day-short-of-a-full-chain-part-2-chrome-sandbox-escape/#the-vulnerability) seem to work quite differently.| chrome sandbox escape                             | [https://github.com/yytgravity/Daily-learning-record/tree/2361ddb3405ff9bf644255687326dd63c543f39f/cve/CVE-2020-16045](https://github.com/yytgravity/Daily-learning-record/tree/2361ddb3405ff9bf644255687326dd63c543f39f/cve/CVE-2020-16045) |[https://github.blog/security/vulnerability-research/one-day-short-of-a-full-chain-part-2-chrome-sandbox-escape/#the-vulnerability](https://github.blog/security/vulnerability-research/one-day-short-of-a-full-chain-part-2-chrome-sandbox-escape/#the-vulnerability)| [https://nvd.nist.gov/vuln/detail/CVE-2020-16045](https://nvd.nist.gov/vuln/detail/CVE-2020-16045) |
| CVE-2020-11239 | UAF in Qualcomm Kernel Graphics Support Layer. The cleanup logic for DMA mappings does not work properly if the mapping was not created by the ION allocator. To trigger the vulnerablility, create objects using kgsl_iommu_get_gpuaddr with an alignment of 2^32. Since there are only two memory adresses that fit this alignment (0 and 2^32), calling the function again with the same alignment will cause a memory out of bounds error and automatically free our allocated memory. The free'd table will then be placed in the DMA buffer. Then you can spray the heap with another similar sized object to recover your table object. Normally spraying the table will not work, so to deal with this, the exploit races the sg_table cleanup conditions with replacing a->table with another table (essentially, we are directly replacing the table with another table of the same object type). However, the cleanup conditions are too fast, so the race must be setup so that the cleanup conditions wait for I/O input in the middle of cleanup. Race flowchart to the right. To leak KASLR it seems that we can search for binder file structs after triggering the vuln using the memory overflow. Then just overwrite privliged processes with your recovered table. | kernel priviledge escalation                      | [https://github.com/github/securitylab/tree/main/SecurityExploits/Android/Qualcomm/CVE-2020-11239](https://github.com/github/securitylab/tree/main/SecurityExploits/Android/Qualcomm/CVE-2020-11239)                                         | [https://github.blog/security/vulnerability-research/one-day-short-of-a-full-chain-part-1-android-kernel-arbitrary-code-execution/](https://github.blog/security/vulnerability-research/one-day-short-of-a-full-chain-part-1-android-kernel-arbitrary-code-execution/) | [https://nvd.nist.gov/vuln/detail/CVE-2020-11239](https://nvd.nist.gov/vuln/detail/CVE-2020-11239) |