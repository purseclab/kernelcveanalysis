https://i.blackhat.com/BH-US-23/Presentations/US-23-Lin-bad_io_uring.pdf
Also very similar to: https://blog.kylebot.net/2022/10/16/CVE-2022-1786/

fixed in: https://source.android.com/docs/security/bulletin/2022-10-01

To trigger other bug, in this function (https://elixir.bootlin.com/linux/v5.10.107/source/fs/io_uring.c#L1157), req->flags must not yet be initialized.
If it is, bad io uring will trigger.

The other bug will trigger with some sort of linked request. This is the case if we set some linked flag? Not sure really it looks like link flag only links requests submitted in the same syscall.

In bad io uring, uaf happens in io_identity_cow called in io_prep_async_work

In other bug, uaf happens io_put_identiy called in io_req_clean_work

io_prep_async_work setup bug which allows other iouring is patched in 5.10.117, but it seems its patched earlier in android?

Possible ways to init request right away:
splice operation in some cases (__io_splice_prep)
close operation (io_close_prep)
- Not supported on iopoll mode
io_req_defer, (always called, some list has to be empty, or a drain request sometimes triggers it)
a possible path in io_init_req, with io_req_set_file, occurs when a request is operating on an iouring file descriptor itself, so some circular reference handling

and of course the async init itself sets flags
also some kiocb  has possible reachable path (trigger when polling finishes? and in read and write finish?)

# Triggering Original Bug
To trigger original bug, must init request before we poll it.

This can be done by submitting a request, then submitting the second request with the drain flag, the new request now has been initialized, but it is in the defered list.

In the cqring commit function, it checks if the deferred request can be submitted. This is true after the first request is polled and finishes. It is submitted through some work queue. `io_issue_sqe` runs as expected, but the issue is we never requeue it, or see it in io iopoll finish? Perhaps the first read finishing causes it to be cached?