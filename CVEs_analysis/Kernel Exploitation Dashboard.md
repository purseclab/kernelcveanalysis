# Structure

- util contains some general purpose codeql queries
	- get interesting fields (function pointers, vtable pointers, and linked list pointers)
	- one that just gets all functions, and which lines they start and end on
	- one that gets all syscalls
- heap-exploitation just contains 1 codeql query
	- interesting objects gets all heap allocated objects
		- also gets other info like if it can be resized and such, what flags passed to kmalloc, etc.
- dashboard contains a bulk of the code
	- data: a set of python scripts which extract some data and put it in sqlite databases
		- detailed below
	- frontend: code for website
		- detailsed below
	- queries: more codeql queries
		- detailed below

## Data Scripts
Gets data from the following sources:
#### Field Information
Extracted from BTF from kernel elf (requires it to be present in elf, so binary does not work)

```sql
CREATE TABLE types (
	struct_name TEXT NOT NULL,
	struct_size UNSIGNED BIG INT NOT NULL,
	parent_type TEXT NOT NULL,
	kind VARCHAR(15) NOT NULL,
	type TEXT NOT NULL,
	name TEXT NOT NULL,
	bits_offset UNSIGNED BIG INT,
	nr_bits UNSIGNED BIG INT,
	bits_end UNSIGNED BIG INT,
	is_flex BOOLEAN NOT NULL
);
```

#### Git Blame
Parses git blame output and gets which commit introduced every line

```sql
CREATE TABLE git_blame (
	file_path TEXT NOT NULL,
	`commit` VARCHAR(40) NOT NULL,
	line_no UNSIGNED BIG INT NOT NULL,
	data TEXT NOT NULL
);
```

#### Git Log
Just gets all commits and puts them in database
```sql
CREATE TABLE git_log (
	start_line UNSIGNED BIG INT NOT NULL,
	end_line UNSIGNED BIG INT NOT NULL,
	file_path TEXT NOT NULL,
	author_date UNSIGNED BIG INT NOT NULL,
	`commit` VARCHAR(40) NOT NULL
);
```

#### Syzkaller Coverage
Which lines of codes using which syscalls certain programs can reach, pulled from syzkaller

```sql
CREATE TABLE file_path (file_id UNSIGNED BIG INT PRIMARY KEY NOT NULL, file_path TEXT NOT NULL);

CREATE TABLE syzk_cov (file_id UNSIGNED BIG INT NOT NULL, code_line_no UNSIGNED BIG INT NOT NULL, prog_id UNSIGNED BIG INT NOT NULL, PRIMARY KEY (file_id, code_line_no, prog_id));

CREATE TABLE syzk_prog (prog_id UNSIGNED BIG INT PRIMARY KEY NOT NULL, prog_code TEXT NOT NULL);

CREATE TABLE syscalls (prog_id UNSIGNED BIG INT NOT NULL, syscall TEXT NOT NULL);
```

#### Test Field Information
This is also parsed from the BTF. It seems to be a more details representation of the BTF.

#### CodeQL
Imports the results of various codeql queries into a sqlite database.

Imports some stuff from csv output:
```sql
CREATE TABLE IF NOT EXISTS kmalloc_calls (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	call_site TEXT,
	call_expr TEXT,
	struct_type TEXT,
	struct_def TEXT,
	struct_size INTEGER,
	flags TEXT,
	alloc_size INTEGER,
	sizeof_expr TEXT,
	is_flexible TEXT
);

CREATE TABLE IF NOT EXISTS function_locations (
	function_name TEXT,
	file_path TEXT,
	start_line INTEGER,
	end_line INTEGER
);

-- refers to kernel config paramaters, and if a function is present if the given config is enabled
CREATE TABLE IF NOT EXISTS configs (
	function_name TEXT,
	config TEXT
);
```

Also does a lot of stuff from some sarif output which represents the results of some dataflow analysis.
TODO: look into this part more.

### Queries

Queries seem to be a folder of codeql queries. Their results are parsed into sqlite database.

### Frontend
Actual code of the webapp

It has a db folder, which has a shell script which combines and processes all the databases created from data portion.
There are also some sql files, which have sql code to process stuff related to codeql data, git data, btf data, and syzkaller coverage data. It then also has all the queries used by webapp each in a seperate file.


The webapp itself is model view controller, with the 4 models described above which call sql queries. The rest of the code just involves rendering it for the user.
Unfortunately it uses some weird in browser sqlite thing which didn't work on firefox or chrome for me so I couldn't really see the sample website, what it looks like.