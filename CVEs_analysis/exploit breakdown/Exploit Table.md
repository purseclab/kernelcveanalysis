This is a table overview of some properties of each exploit.

# Table Columns
### Exploit Families
Exploit family is noting which exploits are very similar in structure and likely copied the same format and code.

##### UAF on Qdisc into eBPF shellcode
Basically [[CVE-2023-4206 (lts, cos)]], initial bug might be slightly different.

##### UAF on `nft_chain`
Basically [[CVE-2023-3777 (lts)]], initial bug might be changed.

##### Many Free on nftable set element
TODO: detail this more
see CVE-2023-4004 (lts, cos, mitigation) for details

##### Set element double free to overlap table udata
Similar to [[Exploit Table#Many Free on nftable set element]], just different format of things.
TODO: detail this more

##### Multiple decrement on nft object refcount
This allows reference count of referenced object to be decremented, and a UAF on `nft_object`.
Most are similar in structure to [[CVE-2023-4569 (lts)]].

### Code Execution Method
Code execution method is for example, rop, jop with rop, the eBPF jit shellcode technique, etc

### Privilege Escalation Technique
Privilege Escalation Technique is what the final thing the exploit does to gain privileges is.
This is usually either `commit_creds(init_creds())` (set process to root) or overwrite `/proc/sys/kernel/core_pattern` to control crash dump program.
Can also be overwrite `modprobe_path`, which controls the program run when executing a program with an unknown magic signature.

### KASLR Leak Method
KASLR leak method is like, how it leaked a pointer, or did it use the sidechannel.

| Exploit                                                                                                                                    |  POCs | Exploit Family?                                                                                           | Subsystem Affected                | Bug Type                      | Bug Details                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Exploit Techniques                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Code Execution Method                              | Privilege Escalation Technique                                                                                                                                                                                    | KASLR Leak Method                                                                                                                                                                                   | Data Address Leaks                                                                                                                                                                                                                                                             | Required Config                                                       |
| ------------------------------------------------------------------------------------------------------------------------------------------ |  --- | --------------------------------------------------------------------------------------------------------- | --------------------------------- | ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------- |
| CVE-2023-4622 (lts, cos)                                                                                                                   | [CVE-2023-4622_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4622_cos), [CVE-2023-4622_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4622_lts) | Unique                                                                                                    | Unix Sockets                      | Race Condition -> UAF         | Race condition in `unix_stream_sendpage` with socket GC causes extra refcount decrament on skb.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Cross Cache Attack, Timer fd extend race window, msg_msg                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | ROP                                                | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | [[Entry Bleed (CVE-2022-4543)]]                                                                                                                                                                     | leak heap address with corrupted `msg_msg`                                                                                                                                                                                                                                     | `CONFIG_UNIX=y`                                                       |
| [[CVE-2024-36972 (lts, cos)]]                                                                                                              | [CVE-2024-36972_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-36972_lts_cos) | Unique                                                                                                    | Unix Sockets                      | Race Condition -> UAF         | Race condition in unix sockets involving socket GC and out of band messages                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | Cross Cache Attack, Timer fd extend race window                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | overwrite function pointer -> eBPF shellcode       | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | None, just guess eBPF offset                                                                                                                                                                        |                                                                                                                                                                                                                                                                                | `CONFIG_AF_UNIX_OOB=y` `CONFIG_BPF_SYSCALL=y`                         |
| CVE-2024-39503 (lts, cos)                                                                                                                  | [CVE-2024-39503_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-39503_lts_cos) | Unique                                                                                                    | netfilter (and network namespace) | Race Condition -> UAF         | There is a race condition between `list_set` garbage collector (which contains an ipset) and network namespace cleanup freeing an ipset leading to UAF on an `struct ip_set`.                                                                                                                                                                                                                                                                                                                                                                                                                                            | TODO                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | None, Arbitrary Write                              | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | Leak kernel pointer on heap                                                                                                                                                                         |                                                                                                                                                                                                                                                                                |                                                                       |
| CVE-2023-52447 (cos)                                                                                                                       | [CVE-2023-52447_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-52447_cos) | Unique                                                                                                    | eBPF                              | Race Condition -> UAF         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                    |                                                                                                                                                                                                                   |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                |                                                                       |
| CVE-2023-6932 (cos)                                                                                                                        | [CVE-2023-6932_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-6932_cos) | Unique                                                                                                    | igmp (networking)                 | Race Condition -> UAF         | Race condition where newly created timer object is added to an rcu list whose elements could have reference count decremented in another thread. This leads to timer being freed when original thread did not expect it                                                                                                                                                                                                                                                                                                                                                                                                  | Uses register binfmt handler as initial function pointer to defer running of rop chain until a non interrupt context, then recorrupts the object with new payload for rop chain                                                                                                                                                                                                                                                                                                                                                  | overwrite function pointer -> ROP                  | `commit_creds(perpare_kernel_creds(0))`                                                                                                                                                                           | [[Entry Bleed (CVE-2022-4543)]]                                                                                                                                                                     | stack pivot to register with correct address                                                                                                                                                                                                                                   | `CONFIG_IP_MULTICAST=y`                                               |
| CVE-2024-26925 (lts, cos)                                                                                                                  | [CVE-2024-26925_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-26925_lts_cos) | Unique?                                                                                                   | nftables                          | Race Condition -> UAF         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                    |                                                                                                                                                                                                                   |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                |                                                                       |
| [[CVE-2024-41009 (lts, cos)]]                                                                                                              | [CVE-2024-41009_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-41009_lts_cos) | Unique                                                                                                    | eBPF                              | Buffer Overlap                | Malicious `consumer_offset` in eBPF ringbuffer can cause overlapping objects in ringbuffer allowing header to be overwritten                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | ROP                                                | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | [[Entry Bleed (CVE-2022-4543)]]                                                                                                                                                                     | stack pivot to register with correct address                                                                                                                                                                                                                                   | `CONFIG_BPF_SYSCALL=y`                                                |
| CVE-2023-3611 (lts, mitigation)                                                                                                            | [CVE-2023-3611_lts_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3611_lts_mitigation) | Unique                                                                                                    | netfilter (traffic control)       | Out of bounds access          | Length of packet when being queued in a qfq qdisc is not checked to be within bounds. This means user can use a qdisc size table to change the size of a packet to any abritrary value, and this results in a pointer pointing out of bounds.                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | ROP                                                | `commit_creds(prepare_kernel_creds(0))`                                                                                                                                                                           |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                | `CONFIG_NET_SCH_QFQ=y`                                                |
| CVE-2023-31436 (mitigation)                                                                                                                | [CVE-2023-31436_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-31436_mitigation) |                                                                                                           | netfilter (traffic control)       | Out of bounds access          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                    |                                                                                                                                                                                                                   |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                |                                                                       |
| [[CVE-2023-4206 (lts, cos)]]                                                                                                               | [CVE-2023-4206_lts_cos_mitigation_2](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4206_lts_cos_mitigation_2), [CVE-2023-4206_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4206_lts_cos) | [[Exploit Table#UAF on Qdisc into eBPF shellcode]]                                                        | netfilter (traffic control)       | UAF                           | When calling `route4_change` on a routing filter bound to a class, some data in filter will be freed, but reference copied to new filter, causing UAF.                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Use CVE-2023-0597 to put payload at fixed kernel address                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | fake vtable -> eBPF shellcode                      | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | None, just guess eBPF offset                                                                                                                                                                        |                                                                                                                                                                                                                                                                                | `CONFIG_NET_SCHED=y` `CONFIG_NET_CLS_ROUTE4=y` `CONFIG_BPF_SYSCALL=y` |
| [[CVE-2023-4207 (lts, cos)]]                                                                                                               | [CVE-2023-4207_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4207_lts_cos), [CVE-2023-4207_lts_cos_mitigation_2](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4207_lts_cos_mitigation_2) | [[Exploit Table#UAF on Qdisc into eBPF shellcode]]                                                        | netfilter (traffic control)       | UAF                           | Calling `fw_change` on a fwmark filter bound to a class, some data in filter will be freed, but reference copied to new filter, causing UAF.                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Use CVE-2023-0597 to put payload at fixed kernel address                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | fake vtable -> eBPF shellcode                      | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | None, just guess eBPF offset                                                                                                                                                                        |                                                                                                                                                                                                                                                                                | `CONFIG_NET_SCHED=y` `CONFIG_NET_CLS_FW=y` `CONFIG_BPF_SYSCALL=y`     |
| [[CVE-2023-4208 (lts, cos, mitigation)]]                                                                                                   | [CVE-2023-4208_lts_cos_mitigation_2](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4208_lts_cos_mitigation_2), [CVE-2023-4208_lts_cos_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4208_lts_cos_mitigation) | [[Exploit Table#UAF on Qdisc into eBPF shellcode]]                                                        | netfilter (traffic control)       | UAF                           | Calling `u32_change` on a u32 filter bound to a class, some data in filter will be freed, but reference copied to new filter, causing UAF.                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Use CVE-2023-0597 to put payload at fixed kernel address                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | fake vtable -> eBPF shellcode                      | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | None, just guess eBPF offset                                                                                                                                                                        |                                                                                                                                                                                                                                                                                | `CONFIG_NET_SCHED=y` `CONFIG_NET_CLS_U32=y` `CONFIG_BPF_SYSCALL=y`    |
| [[CVE-2023-3609 (cos, mitigation)]]                                                                                                        | [CVE-2023-3609_cos_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3609_cos_mitigation) | [[Exploit Table#UAF on Qdisc into eBPF shellcode]]                                                        | netfilter (traffic control)       | UAF                           | Sending invalid parameters to u32 classifier can cause premature decrement on `tcf_entry` refcount, leading to UAF on qdisc.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Use CVE-2023-0597 to put payload at fixed kernel address                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | fake vtable -> eBPF shellcode                      | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | None, just guess eBPF offset                                                                                                                                                                        |                                                                                                                                                                                                                                                                                | `CONFIG_NET_SCHED=y` `CONFIG_NET_CLS_U32=y` `CONFIG_BPF_SYSCALL=y`    |
| CVE-2023-3776 (lts, cos, mitigation)                                                                                                       | [CVE-2023-3776_cos_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3776_cos_mitigation), [CVE-2023-3776_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3776_lts) | [[Exploit Table#UAF on Qdisc into eBPF shellcode]]                                                        | netfilter (traffic control)       | UAF                           | If `tcf_change_indev` fails, it will decrement reference count incorrectly, leading to UAF on qdisc.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Use CVE-2023-0597 to put payload at fixed kernel address                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | fake vtable -> eBPF shellcode                      | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | None, just guess eBPF offset                                                                                                                                                                        |                                                                                                                                                                                                                                                                                | `CONFIG_NET_SCHED=y` `CONFIG_NET_CLS_FW=y` `CONFIG_BPF_SYSCALL=y`     |
| [[CVE-2023-4623 (lts, cos)]]                                                                                                               | [CVE-2023-4623_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4623_lts_cos) |                                                                                                           | netfilter (traffic control)       | UAF                           | When packet enqueued in child class of HFSC qdisc, but later dequed and free child class, a dangling pointer to child is created.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Arbitrary write by craying xattr in freed HFSC qdisc                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | JOP -> ROP                                         | `commit_creds(prepare_kernel_creds(0))`                                                                                                                                                                           | [[Entry Bleed (CVE-2022-4543)]]                                                                                                                                                                     | stack pivot to register with correct address                                                                                                                                                                                                                                   | `CONFIG_NET_SCHED=y`  `CONFIG_NET_SCH_HFSC=y`                         |
| CVE-2024-41010 (lts)                                                                                                                       | [CVE-2024-41010_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-41010_lts) | Unique?                                                                                                   | netfilter (traffic control)       | UAF                           | Creating a second ingress qdisc on the same device while a first one already exists will reuse the `tcx_entry` from the first qdisc, but the `tcx_entry` will be freed, leading to a UAF on `tcx_entry`                                                                                                                                                                                                                                                                                                                                                                                                                  | Uses cross cache attack to get `msg_nmsgseg` overlapping with UAF `tcx_entry`, which will cause next pointer on `msg_msgseg` to be overwritten, which makes a fake list of `msg_msgseg`                                                                                                                                                                                                                                                                                                                                          | Arbitrary page write with overlapped `pipe_buffer` | overwrite `modprobe_path`                                                                                                                                                                                         |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                |                                                                       |
| CVE-2023-5345 (lts, mitigation)                                                                                                            | [CVE-2023-5345_lts_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-5345_lts_mitigation) | Unique                                                                                                    | smbfs (filesystem)                | Double Free                   | TODO: double free smbfs (complicated exploit)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                    |                                                                                                                                                                                                                   |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                | `CONFIG_SMBFS=y`                                                      |
| CVE-2024-26808 (cos)                                                                                                                       | [CVE-2024-26808_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-26808_cos) | Unique                                                                                                    | netfilter                         | UAF                           | When a netfilter chain is bound to a device, it holds a pointer to the device. However when the device is deleted, kernel only notifies `NF_NETDET_INGRESS` chains of deletion, not `NF_INET_INGRESS` chains                                                                                                                                                                                                                                                                                                                                                                                                             | Cross cache attack, uses pipe buffer for arbitrary write                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Arbitrary page write with overlapped `pipe_buffer` | Overwrite `/proc/sys/kernel/core_pattern`                                                                                                                                                                         | Use vmsplice system call to splice vDSO pages into pipe, then use overlapping `msg_msgseg` to get physical address of these pages, allowing calculation of kernel physical addresses                | Leak pointers from `msg_msg` using UAF leak with device name                                                                                                                                                                                                                   | `CONFIG_NF_TABLES=y`                                                  |
| CVE-2024-1086 (lts, mitigation)                                                                                                            | [CVE-2024-1086_lts_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-1086_lts_mitigation) |                                                                                                           | nftables                          | Double Free                   | TODO: double free on `sk_buff` (complicated exploit)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                    |                                                                                                                                                                                                                   |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                |                                                                       |
| CVE-2023-0461 (mitigation)                                                                                                                 | [CVE-2023-0461_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-0461_mitigation) | Unique?                                                                                                   | networking (in kernel tls)        | UAF                           | A tls context can be attached to a socket. If a regular socket with a tls context is disconnected, then reused as a listening socket, accepted connections on this socket will use the same tls context. Closing one of the sockets will result in tls context being freed while still in use by the other socket.                                                                                                                                                                                                                                                                                                       | Uses overlapping `fqdir` with UAF to transfer exploitation from `kmalloc-512` cache to `dyn-kmalloc-512` cache                                                                                                                                                                                                                                                                                                                                                                                                                   | overwrite function pointer -> ROP                  | `commit_creds(prepare_kernel_creds(0))`                                                                                                                                                                           | Leak `tbf_qdisc_ops` vtable pointer with UAF                                                                                                                                                        |                                                                                                                                                                                                                                                                                | `CONFIG_TLS=y` or `CONFIG_XFRM_ESPINTCP=y`                            |
| [[CVE-2023-3777 (lts)]]                                                                                                                    | [CVE-2023-3777_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3777_lts) | [[Exploit Table#UAF on `nft_chain`]]                                                                      | nftables                          | UAF                           | `nf_tables_delrule` doesn't check if a chain is bound when `NFTA_RULE_CHAIN` is not given, it simply deletes all rules in the chain. Then if the chain is bound, rules are deleted again.                                                                                                                                                                                                                                                                                                                                                                                                                                | spray various nft expressions overlapping with `nft_chain`                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer with UAF                                                                                                                                                                        | Leak heap pointer with UAF                                                                                                                                                                                                                                                     | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| [[CVE-2023-4015 (lts)]]                                                                                                                    | [CVE-2023-4015_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4015_lts) | [[Exploit Table#UAF on `nft_chain`]]                                                                      | nftables                          | UAF                           | If an error occurs while creating a rule with an immediate expression in a transaction, other rules are deactivated, but they are also deactivated later at the end of transaction, which can be used to underflow `nft_chain` reference count.                                                                                                                                                                                                                                                                                                                                                                          | spray various nft expressions overlapping with `nft_chain`                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer with UAF                                                                                                                                                                        | Leak heap pointer with UAF                                                                                                                                                                                                                                                     | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2023-4147 (lts, cos, mitigation)                                                                                                       | [CVE-2023-4147_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4147_mitigation), [CVE-2023-4147_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4147_lts_cos) | [[Exploit Table#UAF on `nft_chain`]]                                                                      | nftables                          | UAF                           | `nft_tables_newrule` incorrectly adds a rule to a bound chain if the chain is specified by ID instead of by name. This means we can insert a rule into a bound chain and have that rule reference its own whain. When the rule is destoryed, the bound chain we de initialize the rule again leading to double decrament on reference count of `nft_chain`.                                                                                                                                                                                                                                                              | spray various nft expressions overlapping with `nft_chain`                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer with UAF                                                                                                                                                                        | Leak heap pointer with UAF                                                                                                                                                                                                                                                     | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| [[CVE-2023-5197 (lts, cos, mitigation)]]                                                                                                   | [CVE-2023-5197_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-5197_lts_cos), [CVE-2023-5197_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-5197_mitigation) | [[Exploit Table#UAF on `nft_chain`]]                                                                      | nftables                          | UAF                           | In a transaction, it is possible to use an immediate expression referencing a bound chain to decrease its reference count twice. Evantually this can lead to UAF of nft_chain                                                                                                                                                                                                                                                                                                                                                                                                                                            | spray various nft expressions overlapping with `nft_chain`                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer with UAF                                                                                                                                                                        | Leak heap pointer with UAF                                                                                                                                                                                                                                                     | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2024-0193 (lts, cos, mitigation)                                                                                                       | [CVE-2024-0193_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-0193_cos), [CVE-2024-0193_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-0193_mitigation), [CVE-2024-0193_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-0193_lts) | [[Exploit Table#UAF on `nft_chain`]]                                                                      | nftables                          | UAF                           | There is a missing check for if the set is dead when commiting an update, so deleting a set releases set elements data, but GC can still be run later causing set element to be released again                                                                                                                                                                                                                                                                                                                                                                                                                           | spray various nft expressions overlapping with `nft_chain`, bind set element to `nft_chain` to cause UAF                                                                                                                                                                                                                                                                                                                                                                                                                         | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer with UAF                                                                                                                                                                        | Leak heap pointer with UAF                                                                                                                                                                                                                                                     | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2023-52620 (lts, cos, mitigation)                                                                                                      | [CVE-2023-52620_lts_cos_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-52620_lts_cos_mitigation) | [[Exploit Table#UAF on `nft_chain`]]                                                                      | nftables                          | UAF                           | Creating an anonamous set with a catchall element in the set and setting a timeout allows set element data to be deactivated twice, by deleting the set first then finishing the transaction                                                                                                                                                                                                                                                                                                                                                                                                                             | spray various nft expressions overlapping with `nft_chain`, bind set element to `nft_chain` to cause UAF                                                                                                                                                                                                                                                                                                                                                                                                                         | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer with UAF                                                                                                                                                                        | Leak heap pointer with UAF                                                                                                                                                                                                                                                     | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2023-32233 (mitigation)                                                                                                                | [CVE-2023-32233_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-32233_mitigation) |                                                                                                           | nftables                          | UAF                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                    |                                                                                                                                                                                                                   |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                |                                                                       |
| CVE-2023-3390 (lts, cos, mitigation)                                                                                                       | [CVE-2023-3390_lts_cos_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-3390_lts_cos_mitigation) | Unique?                                                                                                   | nftables                          | UAF                           | In a transaction, if an anonymous set is freed because it is associated with an invalid rule, it will still remain in the transaction list, and can be referenced by future transaction commands.                                                                                                                                                                                                                                                                                                                                                                                                                        | `msg_msg` heap pruning, by getting a double freed chunk with 2 `msg_msg`                                                                                                                                                                                                                                                                                                                                                                                                                                                         | ROP                                                | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak `pipe_ops` vtable pointer with `msg_msg`                                                                                                                                                       | Leak heap pointer by corrupting `msg_msg` header length with `msg_seg`                                                                                                                                                                                                         | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2023-4004 (lts, cos, mitigation)                                                                                                       | [CVE-2023-4004_lts_cos_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4004_lts_cos_mitigation) | [[Exploit Table#Many Free on nftable set element]]                                                        | nftables                          | Double Free                   | When removing an element from a pipapo set, `nft_pipapo_remove` looks for elements with `NFT_SET_EXT_KEY` and `NFT_SET_EXT_KEY_END`. However an element might not have `NFT_SET_EXT_KEY_END`, and if it doesn't, it is freed, but not removed from the set. This means an elment without `NFT_SET_EXT_KEY_END` can be freed many times.                                                                                                                                                                                                                                                                                  | Uses double free to free `nft_table->udata`, which can be read and controlled.                                                                                                                                                                                                                                                                                                                                                                                                                                                   | ROP                                                | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak `nft_object` vtable pointer from udata of nft_table                                                                                                                                            | Leak heap pointer from udata of nft_table                                                                                                                                                                                                                                      | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2023-6111 (lts, cos)                                                                                                                   | [CVE-2023-6111_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-6111_lts), [CVE-2023-6111_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-6111_cos) | [[Exploit Table#Many Free on nftable set element]]                                                        | nftables                          | Double Free                   | The catchall element in a pipapo set can be freed many times if it is set with a GC timeout, then the GC will free it many times.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | Uses double free to free `nft_table->udata`, which can be read and controlled.                                                                                                                                                                                                                                                                                                                                                                                                                                                   | ROP                                                | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak `nft_object` vtable pointer from udata of nft_table                                                                                                                                            | Leak heap pointer from udata of nft_table                                                                                                                                                                                                                                      | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| [[CVE-2023-4244 (lts)]]                                                                                                                    | [CVE-2023-4244_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4244_lts) | [[Exploit Table#UAF on `nft_chain`]]                                                                      | nftables                          | Double Free                   | In some cases deleting an element from an `nft_set` does not mark it as busy for the GC. If GC is configured to run at a set interval, it will delete element again.                                                                                                                                                                                                                                                                                                                                                                                                                                                     | Make set element reference an `nft_chain`, so same exploit for UAF on `nft_chain` is used                                                                                                                                                                                                                                                                                                                                                                                                                                        | ROP                                                | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer with UAF                                                                                                                                                                        | Leak heap pointer with UAF                                                                                                                                                                                                                                                     | `CONFIG_NETFILTER=y` `CONFIG_NF_TABLES=y`                             |
| [[CVE-2023-4569 (lts)]]                                                                                                                    | [CVE-2023-4569_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-4569_lts) | [[Exploit Table#Multiple decrement on nft object refcount]]                                               | nftables                          | UAF                           | When using a map with a catchall element in nftables, flushing the map (deleting all elements in the map) then deleting the map itself leads to objects referenced by the catchall element having their reference count decramented twice, which can lead to UAF.                                                                                                                                                                                                                                                                                                                                                        | Uses refcount of freed object overlapping with set element extension data length to create out of bounds reads for extension data.                                                                                                                                                                                                                                                                                                                                                                                               | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak `nft_object` vtable pointer by corrupting another `nft_object` name to point to the vtable pointer                                                                                             | Leak heap address by corrupting set element user data length                                                                                                                                                                                                                   | `CONFIG_NETFILTEY=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2023-6817 (lts, cos, mitigation)                                                                                                       | [CVE-2023-6817_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-6817_mitigation), [CVE-2023-6817_lts_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2023-6817_lts_cos) | [[Exploit Table#Multiple decrement on nft object refcount]], mitigation a bit different                   | nftables                          | UAF                           | `nft_pipapo_walk` uses an incorrect check to see if an element is active. This means it is possible to deactivate the element twice by deleting an element then deleting the set.                                                                                                                                                                                                                                                                                                                                                                                                                                        | Uses refcount of freed object overlapping with set element extension data length to create out of bounds reads for extension data.                                                                                                                                                                                                                                                                                                                                                                                               | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak `nft_object` vtable pointer by corrupting another `nft_object` name to point to the vtable pointer                                                                                             | Leak heap address by corrupting set element user data length                                                                                                                                                                                                                   | `CONFIG_NETFILTEY=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2023-26642 (lts)                                                                                                                       | [CVE-2024-26642_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-26642_cos), [CVE-2024-26642_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-26642_lts), [CVE-2024-26642_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-26642_mitigation) | [[Exploit Table#Multiple decrement on nft object refcount]]                                               | nftables                          | UAF                           | `nf_tables_deactivate_set` does not set the dead field, meaning deleting a chain containing an anonymous set with a GC timeout could lead to the set being deleted twice, and set element inside will be deactivated twice.                                                                                                                                                                                                                                                                                                                                                                                              | Uses refcount of freed object overlapping with set element extension data length to create out of bounds reads for extension data.                                                                                                                                                                                                                                                                                                                                                                                               | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak `nft_object` vtable pointer by corrupting another `nft_object` name to point to the vtable pointer                                                                                             | Leak heap address by corrupting set element user data length                                                                                                                                                                                                                   | `CONFIG_NETFILTEY=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2024-27397 (mitigation)                                                                                                                | [CVE-2024-27397_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-27397_mitigation) | similar to CVE-2023-6817 (lts, cos, mitigation), only the mitigation exploit                              | nftables                          | UAF                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                    |                                                                                                                                                                                                                   |                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                |                                                                       |
| CVE-2024-1085 (lts, cos)                                                                                                                   | [CVE-2024-1085_lts](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-1085_lts), [CVE-2024-1085_cos](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-1085_cos) | [[Exploit Table#Set element double free to overlap table udata]]                                          | nftables                          | Double Free                   | During a transaction, a set catchall element can be deleted twice, causing a double free.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Double free allows overlapping udata and set elements for leaks and overwrites.                                                                                                                                                                                                                                                                                                                                                                                                                                                  | fake vtable -> ROP                                 | `commit_creds(&init_creds)`                                                                                                                                                                                       | Leak vtable pointer in expression data with overlapped set element and table udata                                                                                                                  | Leak next pointer in linked list of set element                                                                                                                                                                                                                                | `CONFIG_NETFILTEY=y` `CONFIG_NF_TABLES=y`                             |
| CVE-2024-26581 (lts, cos, mitigation)                                                                                                      | [CVE-2024-26581_lts_cos_mitigation](https://github.com/google/security-research/tree/master/pocs/linux/kernelctf/CVE-2024-26581_lts_cos_mitigation) | [[Exploit Table#Set element double free to overlap table udata]] (TODO: cos and mitigation are different) | nftables                          | Double Free                   | When `nft_rbtree_gc_elem` is called for destroying timed out elements in red black tree set, it doesn't check if the set element is valid during the current transaction (ie. doesn't check if it was just added), This means triggering the GC during a transaction then aborting the transaction leads to a set element double free.                                                                                                                                                                                                                                                                                   | Double free allows overlapping udata and set elements for leaks and overwrites.                                                                                                                                                                                                                                                                                                                                                                                                                                                  | fake vtable -> ROP                                 | `commit_creads(&init_creds)`                                                                                                                                                                                      | Leak vtable pointer in expression data with overlapped set element and table udata                                                                                                                  | Leak next pointer in linked list of set element                                                                                                                                                                                                                                | `CONFIG_NETFILTEY=y` `CONFIG_NF_TABLES=y`                             |
| [[Android CVE-2023-0266 and CVE-2023-0266]] (https://googleprojectzero.blogspot.com/2023/09/analyzing-modern-in-wild-android-exploit.html) |  | Unique                                                                                                    | Mali GPU driver                   | Race Condition -> UAF         | Doing a 32 bit syscall ioctl for alsa with the `SNDRV CTL IOCTL ELEM WRITE` does not acquire a lock, so it can race against `snd_ctl_elem_add`, which frees the `struct snd_kcontrol` if replace field is specified. The memory was overlapped with mali jit free jobs (mali is gpu driver)                                                                                                                                                                                                                                                                                                                              | Mali tistream allows placing 16 bytes of user controlled data at a known address.                                                                                                                                                                                                                                                                                                                                                                                                                                                | Arbitrary read and write                           | After gaining arbitrary read and write it is unspecified in article, and I could not yet find POC source code. Any number of things could be done quite easily with arbitrary read, write, and KASLR leak though. | Mali tistream data contains kernel pointers as identifiers, enabling leaks of heap objects with 16 bytes of user controlled data                                                                    | Mali tistream data contains kernel pointers as identifiers, enabling KASLR leak                                                                                                                                                                                                |                                                                       |
| [[Android CVE-2022-22057]] (https://github.blog/security/vulnerability-research/the-android-kernel-mitigations-obstacle-race/)             |  | Unique                                                                                                    | Qualcomm msm GPU driver           | Race Condition -> Double Free | In the qualcomm msm GPU driver `kgsl_timeline` objects contain a list of `dma_fence` which are stored in a list with a reference count, except the reference count is not including the list reference, so it can be in the list and have a refcount of 0. There is a race condition where destroying the `ksgl_timeline` using a certain ioctl moves all the fences it contains to another list and increments their reference count. However if the individual fence is destroyed at the same time using a different ioctl, kernel may check its reference count before deciding to free it, so it can be freed twice. | Uses a trick to extend race windows and bypass delayed `kfree_rcu` involving a normal priority and low priority thread pinned on the same cpu. High priority blocks by reading empty pip, low priority executing race in kernel can be paused by writing to pipe and waking up high priority task. Another technique is using the ION allocator to allocate memory at a known contiguous address in kernel space, which is fully controllable and can even be mmap'd in userspace and is available to unprivileged applications. | Arbtirary read write to physical addresses         | Add a fake `struct work_struct` to the kworker queue configured to us `call_usermodehelper_exec_work`, which runs a shell command as root.                                                                        | Read `ion_heap->ops`, which is a vtable in kernel code. In samsung device even kernel physical address is randomized, so although arbitrary physical read write is available, leak is still needed. | Stack leak by using having an object in the ION buffer be in a linked list and have an elemenet removed from the list, which results in linked list on stack address being written into next fields. ION buffer is allocated at a fixed address                                |                                                                       |
| [[Android CVE-2023-32832]] (https://googleprojectzero.blogspot.com/2024/06/driving-forward-in-android-drivers.html)                        |  | Unique                                                                                                    | Mediatek JPEG Decoder Driver      | Race Condition -> UAF         | A race condition in the mediatek JPEG decoder accelerator driver allows a `dma_buf` file descriptor referance count to be incorrectly decramented twice, which leads to a `struct file` being freed while still potentially in the process' file table.                                                                                                                                                                                                                                                                                                                                                                  | Transitions UAF from `struct file` kmalloc cache to general cache by simply overwriting `dma_buf` that the file referenced which was also freed with a GE buffer (part of the mediatek GPU extension device driver)                                                                                                                                                                                                                                                                                                              | Arbitrary read and write                           | Overwrite process credentials to root                                                                                                                                                                             | Not explicitly mentioned, could be easily done with arbitrary read to leak `file_operations` vtable pointer from known fdtable address                                                              | Leak fdtable by renaming overlapped `dma_buf`, causing its old name value to be freed. The old address can be read out using GE buffer. Then spray `fdtable`, so one ends up overlapping old name. Use arbitrary read to travers files in fdtable to get other necessary leaks |                                                                       |
| [[Android CVE-2023-20938 and CVE-2023-21255]] (talk: https://www.youtube.com/watch?v=U-xSM159YLI)                                          |  [cve-2023-20938_reproduction](/cve-2023-20938_reproduction)  | Unique                                                                                                    | Binder                            | UAF                           | A bug in binder causes all objects in transaction message to be deinitialized if an error occurs before any objects are copied to receiving process. This can lead to reference count on a sent binder node being erroneously decremented, leading to UAF of binder node.                                                                                                                                                                                                                                                                                                                                                | Cross cache attack from general kmalloc cache to `epitem` cache.                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Arbitrary read and (somewhat) arbitrary write      | Overwrite process credentials to root                                                                                                                                                                             | Not explicitly mentioned, could be easily done with arbitrary read to leak `file_operations` vtable pointer from known file address                                                                 | Leak address of `struct file` and `struct epitem` by leaking prev and next pointer of linked list from the `struct epitem` overlapped with freed binder node (pointers will be read in when binder message is received)                                                        |                                                                       |
| [[Android CVE-2022-20421]] (https://github.com/0xkol/badspin)                                                                              | [badsping_reproduction](/badspin_reproduction) | Unique                                                                                                    | Binder                            | Race Condition -> UAF         | If a binder transaction is started to send a binder `HANDLE` or `WEAK_HANDLE` (exploit uses `WEAK_HANDLE`) to a process, but the other process closes its binder fd concurrently, and an error occurs while translating the weak handle, the weak handle will be left in an unfreed state. After the transaction finishes, the recepient process' `binder_proc` context is freed. However, if the other process which the unfreed `WEAK_HANDLE` references closes its binder context, it triggers a UAF of the original freed context, by locking a spinlock in the freed context.                                       | Use spinlock to corrupt 2nd byte of pointer in fd table, then close the file to transfer UAF to TTY write buffer.                                                                                                                                                                                                                                                                                                                                                                                                                | Arbitrary read and write                           | Overwrite process credentials to root and disable selinux.enfording                                                                                                                                               | Leak `pipe_buffer->ops` vtable pointer                                                                                                                                                              |                                                                                                                                                                                                                                                                                |                                                                       |

Exploits potentially applicable to Android (not in subsystem blocked by SELinux or seccmop):
- Unix sockets
	- CVE-2023-4622 (lts, cos)
		- Would require significant adjustments on android, if its even possible
			- As far as I can tell there is no equivalent to entrybleed to leak KASLR on arm
			- kCFI will make using ROP from overwritten function pointer more difficult
	- [[CVE-2024-36972 (lts, cos)]]
		- Would require significant adjustments on android, if its even possible
			- eBPF shellcode trick cannot be used
			- overwritten function pointer woule be affected by kCFI
- Maybe accesable (check)
	- CVE-2023-6932 (cos) (igmp)
		- requires CAP_NET_ADMIN
		- Might be possible for app to get?
		- Requires adjustments on android
			- `add_key` syscall used to spray heap and reclaim freed timer is blocked by seccomp
			- kCFI will not allow overwriting time list function pointer with `__register_binfmt` since the argument is a different pointer type
				- I'm pretty sure kCFI works based on function argument types even though under the hood they both just take 8 byte pointer, but I'm not 100% sure
	- CVE-2023-0461 (mitigation) (TLS)
		- Doesn't require permissions, available if config is on I think
		- Seems like by default it is configured to be a loadable module
		- Requires adjustments on android
			- `add_key` syscall used to spray heap with key objects is blocked by seccomp
			- Makes network devices and sprays qdisc, which Is blocked by SELinux
			- kCFI will not allow overwriting `qdisc->enque()` function pointer to do ROP
- Not Accessible (in `untrusted_app` context)
	- All netfilter stuff (blocked by SELinux)
	- Traffic control stuff (blocked by SELinux I think)
	- eBPF (blocked by seccomp and probably also SELinux)
	- CVE-2023-5345 (lts, mitigation) (smbfs)
		- requires CAP_SYS_ADMIN and fsopen syscall (I imagine CAP_SYS_ADMIN is blocked)
