https://github.com/0xkol/badspin
# Bug
If a binder transaction is started to send a binder `HANDLE` or `WEAK_HANDLE` (exploit uses `WEAK_HANDLE`) to a process, but the other process closes its binder fd concurrently, and an error occurs while translating the weak handle, the weak handle will be left in an unfreed state. After the transaction finishes, the recepient process' `binder_proc` context is freed. However, if the other process which the unfreed `WEAK_HANDLE` references closes its binder context, it triggers a UAF of the original freed context, by locking a spinlock in the freed context.

# Exploit
https://0xkol.github.io/assets/files/Racing_Against_the_Lock__Exploiting_Spinlock_UAF_in_the_Android_Kernel.pdf
Below is summarized from above paper

### Trigger Initial UAF
3 processes are needed communicating over binder to trigger the bug.
Say we have process A, B, C

First process C creates a `binder_node`, and sends a reference to process A, and process A accepts the reference, incrementing the strong count.
Then process C has the thread that send the reference call ioctl `BINDER_THREAD_EXIT`. This prevents a workqueue entry that would have set some more fields on the sent reference from running, resulting in a slightly invalid entry. (`binder_node->has_weak_ref` is still 0)
This means if A ever tries to send this reference to another binder process, it would cause an error and the transaction would fail.

The following transaction is then sent to B:
- A first sends a long list of file descriptors in transaction to widen window
- Then send the invalid reference as a weak reference

At the same time B closes its binder file descriptor, which will eventually cause its `binder_proc` instance to be deinitizlized and have its reference count decremented. (note other transaction still holds a reference count to `binder_proc` so its not yet freed).
This can happen before reference is translated due to file descriptors widening race condition.
When `binder_proc` is deinitialized, it decrament refcount and potentially destroy all references it has.

However in race condition this happens before invalid reference sent.
Invalid weak reference will be put in the `binder_proc`, but an error will occur, but there is a bug where it is not destroyed on error.
Transaction then decrament process B `binder_proc`, and it is last refcount, so `binder_proc` is freed, while the sent weak ref still have a reference to destroyed binder proc.

When process C ever closes its binder context, the weak reference still refers to process C's `binder_node`, so it would destroy the reference in process B, and in the process lock a spinlock on the UAF `binder_context`.

### Exploiting UAF
Exploit uses `/dev/ptmx` to spray `tty_write_buffers` in `kmalloc-1k`, to reclaim `binder_context` (also in `kmalloc-1k`). This buffer is mostly user controlled when writing to a tty.
- First forge a locked spinlock. Then process C close its binder context, causing thread to spin.
- On another cpu, spray things in a particular order
	- have an 8 page `kmalloc-1k` cache containing `tty_write_buffer` with a fake `struct file`
	- have 4 2 page `filp` cache (contains `struct file`) directly after `kmalloc-1k`
- Then free original `tty_write_buffer` and reclaim with an `fdtable`
	- If lower byte of file pointer in fdtable is 0, spinlock will think it has acquited lock, and it will set the second byte to 0, and the first byte to 1
		- It will soon unlock the spinlock though and first byte will be set back to 0
		- This means second byte of file pointer has been cleared to 0, so it will point in `kmalloc-1k` to fake file
	- If lower byte is not 0, dup2 to overwrite fd entry with new file, and eventually after a few tries it is very likely one will end up as 0
- Close the file with corrupted pointer, leading to free of `tty_write_buffer`
- Reclaim memory with pipe with array of `pipe_buffer`
	- Leak KASLR by reading from `tty_write_buffer` the `pipe_buffer->ops` field
	- Arbitrary read and write to physical pages can now be done by overwriting `pipe_buffer->page` and reading or writing to pipe
- Exploit uses `pipe_buffer` arbitrary write to set another tasks `addr_limit` to -1
	- This means that task can now have `copy_to_user` and `copy_from_user` read from kernel memory
	- By writing to and reading from pipe with another task, easier to use arbitrary read and write is achieved
- Now exploit sets process credentials to root, and disable SELinux