import uuid
import shutil
from typing import Optional
from pathlib import Path

from langchain_openai import ChatOpenAI
from kexploit_agent import DockerSandboxProvider, MountInfo, create_kexploit_agent

from .lsp import KernelLsp, create_lsp
from .synthesis_metadata import SynthesisMetadata

SYNTHESIS_AGENT_MODEL = 'gpt-5.1'

def default_model() -> ChatOpenAI:
    return ChatOpenAI(
        model=SYNTHESIS_AGENT_MODEL,
        max_tokens=128_000,
        reasoning_effort='high',
    )

SYNTHESIS_AGENT_PROMPT = """You are an expert Linux kernel security researcher.

Your objective is to analyze a kernel vulnerability and synthesize a working privilege escalation exploit (obtaining root privileges).

Process:
1. Review the provided bug summary and vulnerability details.
2. Formulate a detailed, step-by-step exploitation plan.
3. Utilize the provided LSP tools (Go to definition, Find references, etc.) to explore the kernel codebase. Identify necessary structures, global variables, function addresses, and gadgets.
4. Implement the exploit by filling in the '/data/exp/exploit.c' template file. This file starts as a placeholder. Your final output must be a compilable C file that executes the attack. Make sure to read the contents of this file before updating it to understand the template and where to write your exploit code.
5. Compile your exploit with '/data/exp/compile.sh' to produce a binary called 'exploit'. Make sure there are no compilation errors. Modify the '/data/exp/compile.sh' file as necessary to build the final exploit correctly.

System Information:
{system_specific_info}
"""

ANDROID_SYSTEM_INFO = """Target OS: Android
Architecture: ARM64
Key Mitigations:
- Forward-Edge KCFI (Kernel Control Flow Integrity) is active. Indirect branches are validated.
- ROP (Return-Oriented Programming) is generally not feasible due to KCFI.
- JOP (Jump-Oriented Programming) is heavily restricted.
Constraints:
- Focus on data-only attacks (corrupting credentials, capabilities, or critical data structures) rather than hijacking control flow directly.
"""

EXPLOIT_TEMPLATE = Path(__file__).parent.parent.parent / 'exploit_template'

def exploit_mount_info() -> MountInfo:
    out = MountInfo.new_llm_workdir(
        name='exp',
        description='folder containing the exploit template, you should implement the exploit in here',
        template=EXPLOIT_TEMPLATE
    )
    print(f'using {out.src_folder} as llm workdir')
    return out

def linux_mount_info(metadata: SynthesisMetadata) -> MountInfo:
    return MountInfo(
        src_folder=metadata.linux_src,
        name='linux',
        description='source code of the linux kernel',
        writable=False,
    )

def run_synthesis_agent(metadata: SynthesisMetadata, details: str):
    with DockerSandboxProvider.get().create_instance([exploit_mount_info(), linux_mount_info(metadata)]) as sandbox:
        agent = create_kexploit_agent(
            model=default_model(),
            system_prompt=SYNTHESIS_AGENT_PROMPT.format(system_specific_info=ANDROID_SYSTEM_INFO),
            name='kernel exploit synthesis agent',
            tools=[],
            sandbox=sandbox,
        )

        print('starting agent')
        result = agent.invoke({
            'messages': [{
                'role': 'user',
                'content': f'Please construct an exploit using the following information: {details}',
            }],
        })

        print('done')
        print(result)

    # lsp = create_lsp(metadata)
    # with lsp.start_server() as lsp:
    #     kernel_lsp = KernelLsp(lsp)