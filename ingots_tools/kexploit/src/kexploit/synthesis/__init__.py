from pathlib import Path
import subprocess
import shutil
import json
from sandbox_env import DockerSandboxProvider

from ..kernel_image import Kernel
from .codeql import CodeqlContext, CodeqlQuery
from .object_db import ObjectDb, OBJECT_DB_FILE_NAME, KmallocCall, HeapObject
from .btf_types import BtfTypes, BTF_JSON_NAME, BtfStruct
from .location import Location
from .synthesis_metadata import SynthesisMetadata
from .lsp import create_lsp, KernelLsp
from .agent import create_synthesis_agent, ANDROID_SYSTEM_INFO

def setup_kernel_for_synthesis(kernel: Kernel, vmlinux_path: Path, codeql_db_path: Path, compile_commands_path: Path, linux_src_path: Path):
    synthesis_data = kernel.synthesis_data_path()
    # TODO: remove exists ok
    synthesis_data.mkdir(exist_ok=True)

    metadata = SynthesisMetadata(
        kernel_name=kernel.name,
        vmlinux=vmlinux_path,
        codeql_db=codeql_db_path,
        linux_src=linux_src_path,
    )
    # put compile commands in syntehsis data so clangd puts the cache in there
    shutil.copy(compile_commands_path, metadata.compile_commands_path())
    # TODO: maybe copy data like kernel image, compile commands over to data folder as well
    metadata.save()

    codeql = CodeqlContext(codeql_db_path)
    object_db = ObjectDb(synthesis_data / OBJECT_DB_FILE_NAME)

    extract_type_info(codeql, object_db, vmlinux_path, metadata)
    extract_kmalloc_calls(object_db, codeql)

# FIXME: a bit scuffed to have objects in json but kmalloc calls in sqlite
# this is just the lazy approach for now
def extract_type_info(codeql: CodeqlContext, object_db: ObjectDb, vmlinux_path: Path, metadata: SynthesisMetadata):
    # https://www.kernel.org/doc/html/latest/bpf/btf.html

    # NOTE: kernel dashboard originally uses pahole to extract and reencode btf data to another file first
    # I don't think this is necessary
    raw_json_output = subprocess.check_output([
        'bpftool', 'btf', 'dump', '--json', 'file', str(vmlinux_path),
    ]).decode('utf-8')
    types = BtfTypes(json.loads(raw_json_output))

    codeql_structs = codeql.get_structs()

    # mapping from struct name and field names to struct
    # used to match codeql structs with btf structs
    mapping = {}

    ids = list(sorted(types.types.keys()))
    objects = [types.get_type(id) for id in ids]
    object_db.save_btf_types(objects)

    for btf_type in types.types.values():
        if type(btf_type) is not BtfStruct:
            continue

        members = tuple(member.name for member in btf_type.members)
        mapping[(btf_type.name, members)] = btf_type
    
    # FIXME: see if there are any no matches for btf to codeql
    # FIXME: figure out why some codeql don't have a match
    # FIXME: just use codeql
    for struct in codeql_structs:
        name = '(anon)' if struct.is_anon else struct.struct_name
        key = (name, tuple(struct.field_names))
        if key not in mapping:
            # print(f'warning: no matching btf struct signature for {struct}')
            continue
        
        btf_type = mapping[key]
        mapping[key] = None

        if btf_type is None:
            print(f'warning: duplicate btf struct signature for {struct}')
            continue

        object_db.save_btf_type(btf_type)
        object_db.save_heap_object(HeapObject(
            id=struct.location.to_db_id(),
            type_id=btf_type.id,
            location=str(struct.location),
            source_code=struct.location.read_source(metadata),
            is_anon=struct.is_anon,
        ))

    # with open(json_file, 'w') as f:
    #     f.write(raw_json_output.decode('utf-8'))

def extract_kmalloc_calls(object_db: ObjectDb, codeql: CodeqlContext):
    results = codeql.get_kmalloc_calls()
    for result in results:
        call = KmallocCall.from_codeql_result(result)
        
        # Link to HeapObject if possible
        heap_obj_id = result.struct_def.to_db_id()
        if object_db.get_heap_object(heap_obj_id):
            call.heap_object_id = heap_obj_id
            
        object_db.save_kmalloc_call(call)

def synthesis_test_temp():
    kernel = Kernel('ingots_5.10.107')
    metadata = SynthesisMetadata.load_for_kernel(kernel)
    codeql = CodeqlContext(metadata.codeql_db)

    calls = codeql.get_kmalloc_calls()
    for call in calls:
        if call.kmalloc_cache_name is not None:
            print(call)
    # caches = codeql.run_query_raw(CodeqlQuery.Caches)
    # print(caches)

    # bpf_types = BtfTypes.load(kernel)
    # print(bpf_types.types[1])
    # print(bpf_types.get_type_by_name('pipe_buffer').format_long())

    # for row in codeql.run_query(CodeqlQuery.Structs):
    #     print(row)

    # anon_count = 0
    # for bpf_type in bpf_types.types.values():
    #     if bpf_type.kind == 'STRUCT' and bpf_type.name == '(anon)':
    #         anon_count += 1
    # print(anon_count)

# template to load into docker
DOCKER_TEMPLATE = Path(__file__).parent.parent.parent / 'docker_template'

# run simple synthesis agent to test the system
def run_synthesis(kernel: Kernel, details: str, state_out_dir: Path):
    metadata = SynthesisMetadata.load_for_kernel(kernel)

    provider = DockerSandboxProvider()
    backend = provider.create_instance(name=f'exploit_{kernel.name}')
    backend.upload_workdir(DOCKER_TEMPLATE)

    try:
        lsp = create_lsp(metadata)
        with lsp.start_server() as lsp:
            kernel_lsp = KernelLsp(lsp)

            agent = create_synthesis_agent(
                ANDROID_SYSTEM_INFO,
                kernel_lsp,
                backend,
            )

            print('starting agent')
            result = agent.invoke({
                'messages': [{
                    'role': 'user',
                    'content': f'Please construct an exploit using the following information: {details}',
                }],
            })

            print('done')
            print(result)

            backend.download_workdir(state_out_dir)
    finally:
        provider.delete(backend.id)