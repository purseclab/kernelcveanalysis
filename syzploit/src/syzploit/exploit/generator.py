"""
exploit.generator — LLM-driven exploit C code generation.

Takes an ``ExploitPlan`` and generates a complete C exploit source file
with all steps implemented.
"""

from __future__ import annotations

from typing import Optional

from ..core.config import Config, load_config
from ..core.llm import LLMClient, RESEARCH_SYSTEM_PROMPT
from ..core.log import console
from ..core.models import ExploitPlan, RootCauseAnalysis
from ..reproducer.compiler import _is_truncated

# ── C code validation helpers ─────────────────────────────────────────

import re as _re


def _looks_like_c(text: str) -> bool:
    """Return *True* if *text* plausibly starts with C source code."""
    stripped = text.lstrip()
    # C code typically begins with #include, #define, /*, //, or a type name
    c_start = _re.compile(
        r'^(?:#\s*(?:include|define|pragma|if|ifndef)|'
        r'/\*|//|'
        r'(?:static\s+)?(?:int|void|unsigned|long|char|struct|typedef|enum|#))',
    )
    return bool(c_start.match(stripped))


def _extract_c_from_prose(text: str) -> str | None:
    """Try to extract a ```c ... ``` block from LLM prose output."""
    # Look for fenced code blocks
    m = _re.search(r'```(?:c|C)?\s*\n(.*?)```', text, _re.DOTALL)
    if m:
        candidate = m.group(1).strip()
        if _looks_like_c(candidate):
            return candidate
    return None


# ── Prompt ────────────────────────────────────────────────────────────

_EXPLOIT_CODE_PROMPT = """\
Generate a complete Linux kernel exploit in C based on the plan and
exploitation technique details below.

Exploit Plan:
- Technique: {technique}
- Target struct: {target_struct}
- Slab cache: {slab_cache}
- Vulnerability type: {vuln_type}
- Target kernel: {target_kernel}
- Target arch: {arch}
- Platform: {platform}

Steps:
{steps}

{exploitation_technique_context}

{root_cause_context}

{poc_context}

{previous_feedback}

{kernel_offsets_context}

{primitive_context}

{kernel_source_context}

{gdb_trace_context}

{reference_exploit_context}

Additional notes:
{notes}

Requirements:
1. Complete, compilable, self-contained C source file.
2. Implements ALL plan steps as functions.
3. Includes a main() that executes each step in order.
4. CRITICAL for verification: The exploit MUST check and print its UID
   from within the SAME process, using EXACTLY these tags:
     printf("SYZPLOIT_UID_BEFORE=%d\\n", getuid());
     // ... exploitation + cred overwrite code ...
     // After cred overwrite, VALIDATE with setresuid/setresgid:
     setresuid(0, 0, 0);
     setresgid(0, 0, 0);
     printf("SYZPLOIT_UID_AFTER=%d\\n", getuid());
   The setresuid(0,0,0) call is the validation gate — it normalises all
   UIDs to 0 if the cred overwrite zeroed at least one uid field.  Just
   calling getuid() alone may still show the old UID if only saved-uid
   or effective-uid was zeroed.  Real exploits (badnode, badspin) all
   use setresuid(0,0,0) after cred overwrite.  A parent shell's UID
   will NOT change — this must be in the exploit process itself.
5. Uses appropriate syscalls for the target architecture.
6. Handles errors and prints clear status messages per step.
7. No placeholders or TODOs — every function must have a real implementation.
8. On success, also print "[+] SUCCESS" and spawn a root shell or exit 0.

CRITICAL ANTI-PATTERNS — YOUR CODE WILL BE REJECTED IF IT CONTAINS:
  A. STUB FUNCTIONS: Every function MUST have a complete, working body.
     A function like `uint64_t read64(uint64_t addr) { return 0; }` is a
     STUB and will be rejected. R/W primitives must use the actual kernel
     mechanism (corrupted object fields, ioctl, pipe read, etc.).
  B. "THINKING OUT LOUD" COMMENTS: Do NOT write comments like
     "alternatively we could...", "let's try another approach...",
     "for simplicity we use...", "NOTE: in a real exploit...".
     Every comment must describe what the code DOES, not what it COULD do.
  C. MULTIPLE STRATEGIES: Commit to ONE exploitation approach and
     implement it completely. Do NOT include code for "approach 1",
     "approach 2", "fallback strategy", etc. Pick the best one.
  D. WRONG CVE: Implement ONLY the vulnerability described in the plan.
     Do NOT confuse it with similar CVEs or implement a different bug.
  E. MISSING VALIDATION: After EACH exploit phase, add a validation check:
     - After trigger: printf("[+] Trigger succeeded\\n") or exit on failure
     - After spray: printf("[+] Spray: reclaimed %d objects\\n", count)
     - After leak: printf("[+] Kernel base: 0x%lx\\n", base)
     - After R/W setup: test with a known-good read and print result
     - After cred overwrite: check with getuid() before setresuid
  F. PLACEHOLDER CODE: No `// TODO`, `// FIXME`, `// PLACEHOLDER`,
     `// NOT IMPLEMENTED` markers. Every path must be complete.

CRITICAL IMPLEMENTATION RULES:
9.  NO comments explaining alternative approaches. Write WORKING CODE ONLY.
    Every line must contribute to the exploit. Do not write "let's try" or
    "alternatively we could" — pick ONE approach and implement it fully.
10. COMPILATION CONSTRAINTS (Android NDK cross-compilation):
    - Do NOT #include any kernel-internal headers like <linux/binder.h>,
      <linux/io_uring.h>, or <linux/android/binder.h>.  They don't exist
      in the NDK sysroot.
    - Instead, DEFINE all kernel structs/ioctl numbers/constants inline
      in your source file (e.g. struct binder_write_read, BINDER_WRITE_READ,
      BC_TRANSACTION, etc.).
    - Standard POSIX headers are available: <sys/ioctl.h>, <sys/mman.h>,
      <sys/types.h>, <fcntl.h>, <unistd.h>, <pthread.h>, <string.h>,
      <stdio.h>, <stdlib.h>, <errno.h>, <signal.h>, <sys/epoll.h>,
      <sys/timerfd.h>, <sys/socket.h>.
    - The binary is statically linked with -static -pthread.
    - Use ioctl() numbers directly (e.g. #define BINDER_WRITE_READ _IOWR('b', 1, ...))
      or compute them with _IO/_IOR/_IOW/_IOWR macros from <sys/ioctl.h>.
11. For BINDER exploits on Android:
    - NEVER call BINDER_SET_CONTEXT_MGR directly — the service manager
      already holds context manager. It will return EBUSY.
    - Use /dev/hwbinder (Hardware Binder) for exploits on Android.
    - Use fork() to create child processes. The child becomes context
      manager on /dev/hwbinder (or use ITokenManager for process discovery).
    - Multi-process binder exploits need pipe-based coordination between
      processes (parent writes command, child reads and acts).
    - binder_node is in kmalloc-128 slab — use epitem (via epoll_ctl)
      or sendmsg cmsg for cross-cache reclaim, NOT msg_msg (ENOSYS on
      many Android kernels) and NOT pipe_buffer (kmalloc-1024, wrong slab).
12. Define ALL kernel structures inline — do not assume kernel headers exist.
    Copy struct definitions for binder_write_read, binder_transaction_data,
    flat_binder_object, and any other kernel structs you use.

Return ONLY the C source code.
"""


def generate_exploit_code(
    plan: ExploitPlan,
    *,
    root_cause: Optional[RootCauseAnalysis] = None,
    previous_feedback: str = "",
    previous_source: str = "",
    kernel_offsets_header: str = "",
    primitive_context: str = "",
    kernel_source_context: str = "",
    gdb_trace_context: str = "",
    exploitation_technique_context: str = "",
    reference_exploit_context: str = "",
    cfg: Optional[Config] = None,
) -> str:
    """
    Generate complete exploit C code from an ``ExploitPlan``.

    Parameters
    ----------
    previous_feedback:
        Feedback from the last failed verification attempt, including
        the exploit's stdout/stderr and dmesg.  Helps the LLM avoid
        repeating the same mistakes.
    previous_source:
        C source of the previous failed exploit.
    kernel_offsets_header:
        Generated kernel_offsets.h content — concrete addresses and
        struct offsets.  Injected as-is into the prompt.
    primitive_context:
        Formatted primitive library context showing available C
        building blocks.
    kernel_source_context:
        Extracted vulnerable function source code from the kernel tree.
    gdb_trace_context:
        Formatted GDB trace results showing which kernel functions were
        reached during previous verification attempts.  Gives the LLM
        concrete evidence about which exploit stages work.
    exploitation_technique_context:
        Detailed exploitation technique extracted from blog analysis
        including trigger method, R/W primitive, process architecture.
    reference_exploit_context:
        Excerpts from a known working exploit for the same CVE,
        showing key patterns for the LLM to follow.

    Returns the C source code string.
    """
    cfg = cfg or load_config()
    llm = LLMClient(cfg).for_task("codegen")

    steps_text = "\n".join(
        f"  {i+1}. {s.name}: {s.description}"
        + (f"\n     Code hint: {s.code_hint}" if s.code_hint else "")
        for i, s in enumerate(plan.steps)
    )

    rca_ctx = ""
    if root_cause:
        rca_ctx = (
            f"Root cause analysis:\n"
            f"  Vulnerable function: {root_cause.vulnerable_function}\n"
            f"  Root cause: {root_cause.root_cause_description[:2000]}\n"
            f"  Affected structs: {', '.join(root_cause.affected_structs)}\n"
            f"  Syscalls: {', '.join(root_cause.syscalls)}\n"
        )

    poc_ctx = ""
    if plan.poc_source:
        poc_ctx = f"Existing PoC/reproducer code (adapt as needed):\n```c\n{plan.poc_source[:6000]}\n```"

    # Build previous-failure context
    feedback_section = ""
    if previous_feedback or previous_source:
        feedback_section = "PREVIOUS EXPLOIT ATTEMPT FAILED — do NOT repeat the same mistakes:\n"
        if previous_feedback:
            feedback_section += (
                f"Failure feedback:\n{previous_feedback[:2000]}\n\n"
            )
        if previous_source:
            feedback_section += (
                f"Previous exploit code that FAILED:\n"
                f"```c\n{previous_source[:6000]}\n```\n"
            )
        feedback_section += (
            "\nYou MUST address the specific errors above. "
            "If EBUSY was returned, use fork(). If msg_msg returned ENOSYS, "
            "use pipe_buffer or seq_operations for heap spray. If kallsyms "
            "returned zeros, do not depend on kernel pointer leaks. "
            "Add debug printf() to show which code paths are reached.\n"
        )

    # Build kernel offsets context
    offsets_section = ""
    if kernel_offsets_header:
        offsets_section = (
            "=== Kernel Offsets Header (kernel_offsets.h) ===\n"
            "The following header contains REAL, resolved kernel addresses \n"
            "and struct offsets. #include \"kernel_offsets.h\" in the exploit \n"
            "and use these defines directly — do NOT hardcode your own values.\n\n"
            f"```c\n{kernel_offsets_header[:3000]}\n```"
        )

    # Build primitive library context
    prim_section = ""
    if primitive_context:
        prim_section = primitive_context[:2000]

    # Build kernel source context
    ksource_section = ""
    if kernel_source_context:
        ksource_section = kernel_source_context[:3000]

    # Build GDB trace context
    gdb_section = ""
    if gdb_trace_context:
        gdb_section = gdb_trace_context[:2000]

    # Build exploitation technique context
    exploit_tech_section = ""
    if exploitation_technique_context:
        exploit_tech_section = exploitation_technique_context[:4000]

    # Build reference exploit context
    ref_exploit_section = ""
    if reference_exploit_context:
        ref_exploit_section = reference_exploit_context[:6000]

    prompt = _EXPLOIT_CODE_PROMPT.format(
        technique=plan.technique,
        target_struct=plan.target_struct,
        slab_cache=plan.slab_cache,
        vuln_type=plan.vulnerability_type.value,
        target_kernel=plan.target_kernel or "latest",
        arch=plan.target_arch.value,
        platform=plan.platform.value,
        steps=steps_text,
        root_cause_context=rca_ctx,
        poc_context=poc_ctx,
        previous_feedback=feedback_section,
        kernel_offsets_context=offsets_section,
        primitive_context=prim_section,
        kernel_source_context=ksource_section,
        gdb_trace_context=gdb_section,
        exploitation_technique_context=exploit_tech_section,
        reference_exploit_context=ref_exploit_section,
        notes="\n".join(f"  - {n}" for n in plan.notes) if plan.notes else "(none)",
    )

    code = llm.research_chat(
        [{"role": "user", "content": prompt}],
        max_retries=3,
        max_tokens=32768,
    )

    # Strip markdown fences
    code = code.strip()
    if code.startswith("```"):
        lines = code.split("\n")
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].strip() == "```":
            lines = lines[:-1]
        code = "\n".join(lines)

    # Validate the LLM returned actual C code, not prose.
    # If the response starts with English prose (e.g. "Looking at",
    # "Here is", "The issue"), extract any embedded code block or retry.
    if code and not _looks_like_c(code):
        console.print("  [yellow]LLM returned prose instead of C code, extracting…[/]")
        extracted = _extract_c_from_prose(code)
        if extracted:
            code = extracted
        else:
            # Retry once with a stricter prompt
            console.print("  [yellow]Retrying code generation with strict prompt…[/]")
            retry_code = llm.research_chat(
                [{"role": "user", "content": (
                    "Your previous response was NOT C code — it was English prose. "
                    "I need ONLY raw C source code. No explanations, no markdown, "
                    "no commentary. Start the response directly with #include or "
                    "a C preprocessor directive.\n\n" + prompt
                )}],
                max_retries=2,
                max_tokens=32768,
            )
            retry_code = retry_code.strip()
            if retry_code.startswith("```"):
                rlines = retry_code.split("\n")
                if rlines[0].startswith("```"):
                    rlines = rlines[1:]
                if rlines and rlines[-1].strip() == "```":
                    rlines = rlines[:-1]
                retry_code = "\n".join(rlines)
            if _looks_like_c(retry_code):
                code = retry_code

    # Detect and recover from truncation
    if _is_truncated(code):
        console.print("  [yellow]Generated code appears truncated, requesting completion…[/]")
        continuation_prompt = (
            "The code you just generated was TRUNCATED and is incomplete. "
            "Here is what you generated so far:\n\n"
            f"```c\n{code[-3000:]}\n```\n\n"
            "Please complete the remaining code starting from where it was "
            "cut off. Include all remaining functions and a complete main(). "
            "Return ONLY the continuation C code (I will append it)."
        )
        continuation = llm.research_chat(
            [{"role": "user", "content": continuation_prompt}],
            max_retries=2,
            max_tokens=32768,
        )
        continuation = continuation.strip()
        if continuation.startswith("```"):
            clines = continuation.split("\n")
            if clines[0].startswith("```"):
                clines = clines[1:]
            if clines and clines[-1].strip() == "```":
                clines = clines[:-1]
            continuation = "\n".join(clines)

        if continuation and len(continuation) > 50:
            code = code + "\n" + continuation

    return code


# ── Pre-compilation LLM review ────────────────────────────────────────

_REVIEW_PROMPT = """\
You are a kernel exploit code reviewer. Review the following C exploit code
and identify CRITICAL issues that will prevent it from working.

Target: {target_cve} — {vuln_type} in {target_struct}
Target slab: {slab_cache}

Check for these specific problems:
1. STUB FUNCTIONS: Functions with empty bodies, `return 0`, or `(void)arg; return 0`.
   Every function (especially R/W primitives like read64/write64) MUST have real code.
2. WRONG VULNERABILITY: Code should exploit {target_cve}, not a different CVE.
3. SLAB MISMATCH: Spray objects must target {slab_cache}.
4. INCOMPLETE LOGIC: Missing trigger, missing spray, missing R/W primitive.
5. BROKEN CONTROL FLOW: Code paths that never execute, dead code.
6. KERNEL HEADER INCLUDES: `#include <linux/...>` won't compile with NDK.

Respond with a JSON object:
{{
  "ready": true/false,
  "critical_issues": ["issue 1", "issue 2", ...],
  "stub_functions": ["func1", "func2", ...],
  "suggestions": ["how to fix issue 1", ...]
}}

If the code is ready to compile and has a realistic chance of working,
set "ready": true. Otherwise set "ready": false.

Source code:
```c
{code}
```
"""


def review_exploit_code(
    code: str,
    *,
    target_cve: str = "",
    vuln_type: str = "",
    target_struct: str = "",
    slab_cache: str = "",
    cfg: Optional[Config] = None,
) -> dict:
    """
    Quick LLM review of generated exploit code before compilation.

    Returns a dict with:
      - ready: bool — whether code is ready for compilation
      - critical_issues: list of issue strings
      - stub_functions: list of function names that are stubs
      - suggestions: list of fix suggestions

    This is a cheap extra LLM call that catches issues the rule-based
    validator might miss (semantic problems, broken logic, etc.).
    """
    cfg = cfg or load_config()
    llm = LLMClient(cfg).for_task("codegen")

    # Truncate code if very long to fit in context window
    code_for_review = code
    if len(code_for_review) > 30000:
        # Send first 15K + last 15K with a marker
        code_for_review = (
            code[:15000] +
            "\n\n/* ... middle of file omitted for review ... */\n\n" +
            code[-15000:]
        )

    prompt = _REVIEW_PROMPT.format(
        target_cve=target_cve or "unknown",
        vuln_type=vuln_type or "unknown",
        target_struct=target_struct or "unknown",
        slab_cache=slab_cache or "unknown",
        code=code_for_review,
    )

    try:
        from ..core.llm import _extract_json
        raw = llm.research_chat(
            [{"role": "user", "content": prompt}],
            max_retries=2,
            max_tokens=2048,
        )
        result = _extract_json(raw)
        if result:
            return {
                "ready": result.get("ready", True),
                "critical_issues": result.get("critical_issues", []),
                "stub_functions": result.get("stub_functions", []),
                "suggestions": result.get("suggestions", []),
            }
    except Exception as exc:
        console.print(f"  [dim]LLM review failed: {exc}[/]")

    # Default: assume ready if review fails
    return {"ready": True, "critical_issues": [], "stub_functions": [], "suggestions": []}
