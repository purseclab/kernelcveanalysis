"""
exploit.kernel_resolver — Kernel symbol & struct-offset resolution.

Extracts *real* kernel addresses and struct field offsets from the target
kernel (kallsyms, vmlinux, BTF / pahole), replacing LLM-hallucinated
values with ground truth.

The main artefact is a generated C header (``kernel_offsets.h``) that can
be ``#include``d by the exploit, making every kernel-version-specific
constant concrete and verifiable.
"""

from __future__ import annotations

import os
import re
import subprocess
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from ..core.log import console
from ..core.models import TargetSystemInfo


# ── Architecture constants ────────────────────────────────────────────

_ARCH_CONSTANTS: Dict[str, Dict[str, int]] = {
    "aarch64": {
        "VMEMMAP_START": 0xFFFF_FFFE_FFE0_0000,
        "KERNEL_VA_BASE": 0xFFFF_FFC0_1000_0000,
        "LINEAR_MAP_BASE": 0xFFFF_FF80_0000_0000,
        "PAGE_SHIFT": 12,
        "STRUCT_PAGE_SIZE": 64,
    },
    "x86_64": {
        "VMEMMAP_START": 0xFFFF_EA00_0000_0000,
        "KERNEL_VA_BASE": 0xFFFF_FFFF_8100_0000,
        "LINEAR_MAP_BASE": 0xFFFF_8880_0000_0000,
        "PAGE_SHIFT": 12,
        "STRUCT_PAGE_SIZE": 64,
    },
}

# Important kernel symbols to resolve for exploit building blocks.
_IMPORTANT_SYMBOLS = [
    "init_task",
    "anon_pipe_buf_ops",
    "selinux_state",
    "modprobe_path",
    "core_pattern",
    "_stext",
    "_etext",
    "page_offset_base",          # x86 only
    "memstart_addr",             # arm64 only
    "init_cred",
    "init_nsproxy",
    "init_uts_ns",
    "kthread_task",
    "prepare_kernel_cred",
    "commit_creds",
]

# Key kernel structs whose layouts we want to resolve.
_IMPORTANT_STRUCTS = [
    "task_struct",
    "cred",
    "file",
    "pipe_buffer",
    "pipe_inode_info",
    "inode",
    "msg_msg",
    "seq_operations",
    "timerfd_ctx",
    "sk_buff",
]


class KernelResolver:
    """Resolve kernel symbols and struct offsets for exploit generation.

    Data sources (in priority order):
    1. Collected kallsyms (from ``TargetSystemInfo``)
    2. ``vmlinux`` ELF on the build host (``nm``, ``readelf``)
    3. BTF / pahole (for struct layouts)
    4. ``/proc/config.gz`` (feature detection)
    """

    def __init__(
        self,
        target_info: Optional[TargetSystemInfo] = None,
        *,
        vmlinux_path: str = "",
        system_map_path: str = "",
        kallsyms_path: str = "",
    ) -> None:
        self._target_info = target_info
        self._vmlinux = vmlinux_path or (
            getattr(target_info, "vmlinux_path", "") if target_info else ""
        )
        self._system_map = system_map_path
        self._kallsyms_path = kallsyms_path or (
            target_info.kallsyms_path if target_info and target_info.kallsyms_path else ""
        )
        self._arch = self._detect_arch()

        # Caches
        self._symbol_cache: Dict[str, int] = {}
        self._struct_cache: Dict[str, Dict[str, int]] = {}
        self._kallsyms_loaded = False

    # ── Public API ────────────────────────────────────────────────────

    def resolve_symbol(self, name: str) -> Optional[int]:
        """Get kernel virtual address of *name* from kallsyms / vmlinux."""
        self._ensure_symbols()
        return self._symbol_cache.get(name)

    def resolve_symbol_offset(self, name: str) -> Optional[int]:
        """Get offset of *name* relative to kernel base (``_stext``)."""
        addr = self.resolve_symbol(name)
        base = self.resolve_symbol("_stext") or self.resolve_symbol("_text")
        if addr is not None and base is not None:
            return addr - base
        return addr  # absolute if no base known

    def resolve_struct_offsets(self, struct_name: str) -> Dict[str, int]:
        """Get field→offset mapping for *struct_name* via pahole / BTF.

        Returns ``{}`` if pahole is unavailable or the struct is not found.
        """
        if struct_name in self._struct_cache:
            return self._struct_cache[struct_name]
        offsets = self._pahole_struct(struct_name)
        self._struct_cache[struct_name] = offsets
        return offsets

    def resolve_struct_size(self, struct_name: str) -> Optional[int]:
        """Return total size of *struct_name* in bytes."""
        size = self._pahole_struct_size(struct_name)
        return size

    def get_slab_cache_for_struct(self, struct_name: str) -> Optional[str]:
        """Infer slab cache from struct *size* (pahole) + slabinfo.

        Heuristic: if struct has a dedicated slab (e.g. ``filp``,
        ``inode_cache``), return that.  Otherwise return ``kmalloc-N``
        for the nearest power-of-two bucket.
        """
        _DEDICATED_CACHES: Dict[str, str] = {
            "file": "filp",
            "inode": "inode_cache",
            "dentry": "dentry",
            "sock": "sock_inode_cache",
            "signal_struct": "signal_cache",
            "sighand_struct": "sighand_cache",
            "mm_struct": "mm_struct",
            "vm_area_struct": "vm_area_struct",
            "task_struct": "task_struct",
        }
        if struct_name in _DEDICATED_CACHES:
            return _DEDICATED_CACHES[struct_name]

        size = self.resolve_struct_size(struct_name)
        if size is None:
            return None
        return _size_to_kmalloc_cache(size)

    def get_kernel_base_offset(self) -> Optional[int]:
        """Kernel base virtual address (``_stext`` or ``_text``)."""
        return self.resolve_symbol("_stext") or self.resolve_symbol("_text")

    def get_arch_constants(self) -> Dict[str, int]:
        """Architecture-dependent constants (vmemmap, linear map, etc.)."""
        return dict(_ARCH_CONSTANTS.get(self._arch, _ARCH_CONSTANTS["aarch64"]))

    def resolve_important_symbols(self) -> Dict[str, Optional[int]]:
        """Resolve all commonly-needed exploit symbols in one call."""
        self._ensure_symbols()
        result: Dict[str, Optional[int]] = {}
        for sym in _IMPORTANT_SYMBOLS:
            result[sym] = self._symbol_cache.get(sym)
        return result

    def resolve_important_structs(self) -> Dict[str, Dict[str, int]]:
        """Resolve all commonly-needed struct layouts in one call."""
        result: Dict[str, Dict[str, int]] = {}
        for s in _IMPORTANT_STRUCTS:
            offsets = self.resolve_struct_offsets(s)
            if offsets:
                result[s] = offsets
        return result

    def generate_exploit_header(self) -> str:
        """Generate a C header with ``#define``s for all resolved values.

        This is the primary artifact — the exploit ``#include``s it to
        get verified kernel constants instead of relying on LLM guesses.
        """
        lines = [
            "/* Auto-generated by syzploit KernelResolver — do not edit. */",
            "#ifndef SYZPLOIT_KERNEL_OFFSETS_H",
            "#define SYZPLOIT_KERNEL_OFFSETS_H",
            "",
        ]

        # Architecture constants
        arch_const = self.get_arch_constants()
        if arch_const:
            lines.append("/* Architecture constants */")
            for name, val in sorted(arch_const.items()):
                lines.append(f"#define {name} 0x{val:x}UL")
            lines.append("")

        # Symbol offsets (relative to kernel base)
        kernel_base = self.get_kernel_base_offset()
        symbols = self.resolve_important_symbols()
        resolved_syms = {k: v for k, v in symbols.items() if v is not None}

        if resolved_syms:
            lines.append("/* Kernel symbol addresses (absolute) */")
            for name, addr in sorted(resolved_syms.items()):
                cname = name.upper().replace(".", "_")
                lines.append(f"#define KSYM_{cname} 0x{addr:x}UL")

            if kernel_base is not None:
                lines.append("")
                lines.append("/* Kernel symbol offsets (relative to _stext) */")
                lines.append(f"#define KERNEL_BASE 0x{kernel_base:x}UL")
                for name, addr in sorted(resolved_syms.items()):
                    if name in ("_stext", "_text"):
                        continue
                    cname = name.upper().replace(".", "_")
                    off = addr - kernel_base
                    lines.append(f"#define KSYM_{cname}_OFFSET 0x{off:x}UL")
            lines.append("")

        # Struct field offsets
        structs = self.resolve_important_structs()
        if structs:
            lines.append("/* Struct field offsets (from pahole / BTF) */")
            for sname, fields in sorted(structs.items()):
                csname = sname.upper()
                size = self.resolve_struct_size(sname)
                if size is not None:
                    lines.append(f"#define SIZEOF_{csname} {size}")
                for fname, off in sorted(fields.items(), key=lambda x: x[1]):
                    cfname = fname.upper()
                    lines.append(f"#define {csname}__{cfname}_OFFSET {off}")
                lines.append("")

        # vmemmap helpers
        lines.append("/* vmemmap address translation helpers */")
        vmem = arch_const.get("VMEMMAP_START", 0)
        ps = arch_const.get("PAGE_SHIFT", 12)
        sps = arch_const.get("STRUCT_PAGE_SIZE", 64)
        page_shift_bits = 6 if sps == 64 else 5
        lines.append(
            f"#define virt_to_page(kaddr) "
            f"((struct page *)(VMEMMAP_START + "
            f"(((unsigned long)(kaddr) >> {ps}) << {page_shift_bits})))"
        )
        lines.append(
            f"#define page_to_virt(page) "
            f"((void *)(((((unsigned long)(page) - VMEMMAP_START) "
            f">> {page_shift_bits}) << {ps}) + LINEAR_MAP_BASE))"
        )
        lines.append("")

        lines.append("#endif /* SYZPLOIT_KERNEL_OFFSETS_H */")
        return "\n".join(lines)

    def summary(self) -> str:
        """Human-readable summary of resolved information."""
        self._ensure_symbols()
        resolved_count = sum(
            1 for s in _IMPORTANT_SYMBOLS if s in self._symbol_cache
        )
        struct_count = len(self.resolve_important_structs())
        return (
            f"KernelResolver: arch={self._arch}, "
            f"symbols={len(self._symbol_cache)} total / "
            f"{resolved_count}/{len(_IMPORTANT_SYMBOLS)} important, "
            f"structs={struct_count}/{len(_IMPORTANT_STRUCTS)} resolved"
        )

    # ── Private helpers ───────────────────────────────────────────────

    def _detect_arch(self) -> str:
        if self._target_info and self._target_info.arch:
            a = self._target_info.arch.lower()
            if "aarch64" in a or "arm64" in a:
                return "aarch64"
            if "x86_64" in a or "amd64" in a:
                return "x86_64"
        # Try vmlinux ELF header
        if self._vmlinux and os.path.exists(self._vmlinux):
            try:
                out = subprocess.check_output(
                    ["file", self._vmlinux], text=True, timeout=10,
                )
                if "aarch64" in out or "ARM aarch64" in out:
                    return "aarch64"
                if "x86-64" in out:
                    return "x86_64"
            except Exception:
                pass
        return "aarch64"  # default for Android

    def _ensure_symbols(self) -> None:
        """Lazy-load symbols from kallsyms / vmlinux / System.map."""
        if self._kallsyms_loaded:
            return
        self._kallsyms_loaded = True

        # 1) kallsyms file (collected from target)
        path = self._kallsyms_path
        if path and os.path.exists(path):
            count = self._load_symbol_file(path)
            if count:
                console.print(f"  [dim]Loaded {count} symbols from kallsyms[/]")
                return

        # 2) System.map
        if self._system_map and os.path.exists(self._system_map):
            count = self._load_symbol_file(self._system_map)
            if count:
                console.print(f"  [dim]Loaded {count} symbols from System.map[/]")
                return

        # 3) vmlinux via nm
        if self._vmlinux and os.path.exists(self._vmlinux):
            count = self._load_vmlinux_symbols()
            if count:
                console.print(f"  [dim]Loaded {count} symbols from vmlinux[/]")

    def _load_symbol_file(self, path: str) -> int:
        """Parse a kallsyms or System.map file: ``addr type name``."""
        count = 0
        try:
            with open(path, "r") as f:
                for line in f:
                    parts = line.strip().split()
                    if len(parts) >= 3:
                        try:
                            addr = int(parts[0], 16)
                            name = parts[2]
                            if addr != 0:
                                self._symbol_cache[name] = addr
                                count += 1
                        except ValueError:
                            continue
        except Exception:
            pass
        return count

    def _load_vmlinux_symbols(self) -> int:
        """Load symbols from vmlinux via ``nm``."""
        try:
            output = subprocess.check_output(
                ["nm", "-n", self._vmlinux],
                text=True,
                timeout=60,
            )
        except Exception:
            # Try cross-tool if nm fails
            for prefix in ("aarch64-linux-gnu-", "aarch64-linux-android-"):
                try:
                    output = subprocess.check_output(
                        [f"{prefix}nm", "-n", self._vmlinux],
                        text=True,
                        timeout=60,
                    )
                    break
                except Exception:
                    continue
            else:
                return 0

        count = 0
        for line in output.splitlines():
            parts = line.strip().split()
            if len(parts) >= 3:
                try:
                    addr = int(parts[0], 16)
                    name = parts[2]
                    if addr != 0:
                        self._symbol_cache[name] = addr
                        count += 1
                except ValueError:
                    continue
        return count

    def _pahole_struct(self, struct_name: str) -> Dict[str, int]:
        """Run ``pahole -C struct_name vmlinux`` to get field offsets."""
        if not self._vmlinux or not os.path.exists(self._vmlinux):
            return {}
        try:
            output = subprocess.check_output(
                ["pahole", "-C", struct_name, self._vmlinux],
                text=True,
                timeout=30,
                stderr=subprocess.DEVNULL,
            )
        except Exception:
            return {}
        return self._parse_pahole_output(output)

    def _pahole_struct_size(self, struct_name: str) -> Optional[int]:
        """Get total struct size from pahole output."""
        if not self._vmlinux or not os.path.exists(self._vmlinux):
            return None
        try:
            output = subprocess.check_output(
                ["pahole", "-C", struct_name, self._vmlinux],
                text=True,
                timeout=30,
                stderr=subprocess.DEVNULL,
            )
        except Exception:
            return None
        # Look for last line: "/* size: NNN, ..."
        m = re.search(r"/\*\s*size:\s*(\d+)", output)
        if m:
            return int(m.group(1))
        return None

    @staticmethod
    def _parse_pahole_output(output: str) -> Dict[str, int]:
        """Parse pahole output to field→offset mapping.

        Example input::

            struct cred {
                atomic_t           usage;               /*     0     4 */
                kuid_t             uid;                  /*     4     4 */
                ...
            };
        """
        offsets: Dict[str, int] = {}
        for line in output.splitlines():
            # Match: type  name;  /* offset  size */
            m = re.match(
                r"\s+\S+(?:\s+\S+)*\s+"          # type (may have multiple words)
                r"(\w+)"                           # field name
                r"(?:\[\d+\])?"                    # optional array
                r"\s*;"                            # semicolon
                r"\s*/\*\s*(\d+)\s+\d+\s*\*/",    # /* offset  size */
                line,
            )
            if m:
                offsets[m.group(1)] = int(m.group(2))
        return offsets


# ── Utility functions (module-level) ──────────────────────────────────

def _size_to_kmalloc_cache(size: int) -> str:
    """Map an allocation size to its ``kmalloc-N`` slab cache name."""
    buckets = [8, 16, 32, 64, 96, 128, 192, 256, 512, 1024, 2048, 4096, 8192]
    for b in buckets:
        if size <= b:
            return f"kmalloc-{b}"
    return f"kmalloc-{size}"


def resolve_kernel_offsets(
    target_info: Optional[TargetSystemInfo] = None,
    *,
    vmlinux_path: str = "",
    work_dir: Optional[Path] = None,
) -> Tuple[KernelResolver, str]:
    """Convenience: build a ``KernelResolver`` and generate the header.

    Returns ``(resolver, header_text)``.  The header is also written
    to ``work_dir/kernel_offsets.h`` if *work_dir* is given.
    """
    resolver = KernelResolver(
        target_info=target_info,
        vmlinux_path=vmlinux_path,
    )
    header = resolver.generate_exploit_header()

    if work_dir:
        hpath = Path(work_dir) / "kernel_offsets.h"
        hpath.write_text(header)
        console.print(f"  Written {hpath}")

    return resolver, header
