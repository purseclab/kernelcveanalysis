"""
exploit.completer — Analyse an existing exploit for completeness and fill gaps.

The LLM-driven ``exploit`` tool often produces skeleton code with only some
steps implemented.  ``complete_exploit`` takes the current exploit source,
cross-references it against the ``ExploitPlan``, and uses an LLM to
generate the missing pieces so the result is a full, compilable exploit.

Entry-point:
    complete_exploit(ctx, cfg) -> TaskContext
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import Any, Dict, List, Optional

from ..core.config import Config, load_config
from ..core.llm import LLMClient, RESEARCH_SYSTEM_PROMPT
from ..core.log import console
from ..core.models import (
    Arch,
    ExploitPlan,
    ExploitResult,
    ExploitStep,
    Platform,
    RootCauseAnalysis,
)
from ..orchestrator.context import TaskContext
from ..reproducer.compiler import compile_reproducer, _is_truncated

# ── Incompleteness detection ──────────────────────────────────────────

# Patterns that signal a stub, placeholder, or unfinished section
_INCOMPLETE_SIGNALS: list[str] = [
    r"\bTODO\b",
    r"\bFIXME\b",
    r"\bHACK\b",
    r"\bSTUB\b",
    r"\bPLACEHOLDER\b",
    r"\bNOT\s+IMPLEMENTED\b",
    r"\bIMPLEMENT\s+ME\b",
    r"\bFILL\s+IN\b",
    r"\bYOUR\s+CODE\s+HERE\b",
    r"\binsert\s+.*\s+here\b",
    r"0x1234|0xdead|0xcafe|0xbeef|0xAAAA",
    r"return\s*;\s*/\*\s*(?:TODO|placeholder)",
]

# Patterns for suspicious placeholder addresses/offsets
_PLACEHOLDER_VALUES = re.compile(
    r"0x[0-9a-fA-F]*(?:1234|dead|cafe|beef|AAAA|BBBB|0000000)[0-9a-fA-F]*"
)


def _detect_incompleteness(source: str) -> Dict[str, Any]:
    """
    Scan exploit source code for signs of incompleteness.

    Returns a dict with:
      - ``is_incomplete``: bool
      - ``stub_markers``: list of (line_number, matched_text) tuples
      - ``placeholder_offsets``: list of (line_number, value) tuples
      - ``empty_functions``: list of function names with empty/trivial bodies
      - ``unused_globals``: list of global names declared but never referenced
      - ``missing_uid_tags``: True if SYZPLOIT_UID markers are absent
      - ``summary``: human-readable description of what's wrong
    """
    lines = source.split("\n")
    stub_markers: list[tuple[int, str]] = []
    placeholder_offsets: list[tuple[int, str]] = []
    empty_functions: list[str] = []
    issues: list[str] = []

    # Scan each line for stub/placeholder markers
    for i, line in enumerate(lines, 1):
        for pattern in _INCOMPLETE_SIGNALS:
            m = re.search(pattern, line, re.IGNORECASE)
            if m:
                stub_markers.append((i, m.group()))
                break  # one match per line is enough
        for m in _PLACEHOLDER_VALUES.finditer(line):
            placeholder_offsets.append((i, m.group()))

    # Detect empty or trivially-bodied functions
    func_re = re.compile(
        r"^(?:static\s+)?(?:int|void|long|unsigned|char\s*\*|ssize_t|size_t)\s+"
        r"(\w+)\s*\([^)]*\)\s*\{",
        re.MULTILINE,
    )
    for match in func_re.finditer(source):
        fname = match.group(1)
        if fname in ("main",):
            continue
        # Extract the body up to the matching closing brace
        start = match.end()
        depth = 1
        pos = start
        while pos < len(source) and depth > 0:
            if source[pos] == "{":
                depth += 1
            elif source[pos] == "}":
                depth -= 1
            pos += 1
        body = source[start : pos - 1].strip()
        # Trivial body: empty, just "return ...", single printf, or just a comment
        body_lines = [
            l.strip()
            for l in body.split("\n")
            if l.strip() and not l.strip().startswith("//") and not l.strip().startswith("/*")
        ]
        if len(body_lines) <= 1:
            empty_functions.append(fname)

    # Check for SYZPLOIT_UID markers
    missing_uid = "SYZPLOIT_UID_BEFORE" not in source or "SYZPLOIT_UID_AFTER" not in source

    # Check for main() existence
    has_main = re.search(r"\bint\s+main\s*\(", source) is not None

    # Summarise
    if stub_markers:
        issues.append(f"{len(stub_markers)} stub/TODO markers found")
    if placeholder_offsets:
        issues.append(f"{len(placeholder_offsets)} placeholder offset values")
    if empty_functions:
        issues.append(f"Empty/trivial functions: {', '.join(empty_functions)}")
    if missing_uid:
        issues.append("Missing SYZPLOIT_UID_BEFORE/AFTER tags for verification")
    if not has_main:
        issues.append("No main() function found")

    is_incomplete = bool(stub_markers or placeholder_offsets or empty_functions or not has_main)

    return {
        "is_incomplete": is_incomplete,
        "stub_markers": stub_markers,
        "placeholder_offsets": placeholder_offsets,
        "empty_functions": empty_functions,
        "missing_uid_tags": missing_uid,
        "has_main": has_main,
        "summary": "; ".join(issues) if issues else "Exploit appears complete",
        "line_count": len(lines),
    }


def _identify_implemented_steps(
    source: str, plan: ExploitPlan
) -> Dict[str, bool]:
    """
    For each step in the exploit plan, heuristically determine whether
    that step is actually implemented in the source code.

    Returns a dict mapping step name → bool (implemented?).
    """
    result: Dict[str, bool] = {}
    low = source.lower()

    for step in plan.steps:
        # Heuristics: check if step name appears as a function, comment,
        # or if key verbs from the description are present
        name_slug = step.name.lower().replace(" ", "_").replace("-", "_")

        # Check for a function matching the step name
        has_func = bool(re.search(rf"\b{re.escape(name_slug)}\s*\(", low))

        # Check for a labelled comment like "// Step 3: ..."
        has_comment = bool(
            re.search(
                rf"(?:step\s*\d+\s*[:.]?\s*)?{re.escape(step.name.lower())}",
                low,
            )
        )

        # Check for key action words from the description
        desc_words = set(step.description.lower().split()) - {
            "the", "a", "an", "is", "to", "for", "of", "in", "and", "or",
            "with", "by", "on", "at", "from", "that", "this", "it",
        }
        key_words = [w for w in desc_words if len(w) > 5][:5]
        word_hits = sum(1 for w in key_words if w in low) if key_words else 0
        has_keywords = word_hits >= max(1, len(key_words) // 2)

        # Consider implemented if we find the function or (comment + keywords)
        result[step.name] = has_func or (has_comment and has_keywords)

    return result


# ── LLM completion prompt ─────────────────────────────────────────────

_COMPLETION_PROMPT = """\
You are given an INCOMPLETE Linux kernel exploit in C.  Your task is to
produce a COMPLETE, COMPILABLE, SELF-CONTAINED version that implements
every step of the exploitation plan.

═══ EXPLOIT PLAN ═══
Technique: {technique}
Target struct: {target_struct}
Slab cache: {slab_cache}
Vulnerability type: {vuln_type}
Target kernel: {target_kernel}
Architecture: {arch}
Platform: {platform}

Planned steps:
{steps}

═══ ROOT CAUSE ═══
{root_cause_context}

═══ CURRENT (INCOMPLETE) SOURCE ═══
```c
{existing_code}
```

═══ INCOMPLETENESS ANALYSIS ═══
{analysis_summary}

Steps that ARE implemented: {implemented}
Steps that are MISSING or incomplete: {missing}

═══ INSTRUCTIONS ═══
1. Keep all working code that is already implemented correctly.
2. Replace ALL stubs, TODOs, and placeholder offsets with real implementations.
3. Fill in every missing exploitation step listed above.
4. Use correct kernel structs and offsets for {target_kernel} on {arch}.
5. The exploit MUST print UID verification tags:
     printf("SYZPLOIT_UID_BEFORE=%d\\n", getuid());
     // ... privilege escalation ...
     printf("SYZPLOIT_UID_AFTER=%d\\n", getuid());
6. Handle errors and print informative status messages per step.
7. No remaining TODOs, placeholders, or stub functions.
8. The result must compile with: {compiler} -static -o exploit exploit.c
9. On success print "[+] SUCCESS" and spawn a root shell.
{extra_instructions}

Return ONLY the complete C source code.
"""

_FREEFORM_COMPLETION_PROMPT = """\
You are given an INCOMPLETE Linux kernel exploit in C.  Your task is to
produce a COMPLETE, COMPILABLE, SELF-CONTAINED version.

═══ CURRENT (INCOMPLETE) SOURCE ═══
```c
{existing_code}
```

═══ INCOMPLETENESS ANALYSIS ═══
{analysis_summary}

Empty/stub functions: {empty_functions}
Placeholder offsets: {placeholder_offsets}

═══ VULNERABILITY CONTEXT ═══
{vuln_context}

═══ INSTRUCTIONS ═══
1. Keep all working code that is already implemented correctly.
2. Replace ALL stubs, TODOs, and placeholder offsets with real implementations.
3. Fill in every empty or trivially-bodied function.
4. The exploit MUST print UID verification tags:
     printf("SYZPLOIT_UID_BEFORE=%d\\n", getuid());
     // ... privilege escalation ...
     printf("SYZPLOIT_UID_AFTER=%d\\n", getuid());
5. Handle errors and print informative status messages per step.
6. No remaining TODOs, placeholders, or stub functions.
7. On success print "[+] SUCCESS" and spawn a root shell.
{extra_instructions}

Return ONLY the complete C source code.
"""


def _build_completion_prompt(
    source: str,
    analysis: Dict[str, Any],
    plan: Optional[ExploitPlan],
    root_cause: Optional[RootCauseAnalysis],
    ctx: TaskContext,
    extra_instructions: str = "",
) -> str:
    """Construct the LLM prompt for exploit completion."""
    arch = ctx.target_arch or Arch.ARM64
    arch_str = arch.value if isinstance(arch, Arch) else str(arch)
    compiler = "aarch64-linux-gnu-gcc" if "arm64" in arch_str or "aarch64" in arch_str else "gcc"

    if plan:
        steps_text = "\n".join(
            f"  {i+1}. {s.name}: {s.description}"
            + (f"\n     Code hint: {s.code_hint}" if s.code_hint else "")
            for i, s in enumerate(plan.steps)
        )
        implemented = _identify_implemented_steps(source, plan)
        impl_names = [n for n, v in implemented.items() if v]
        miss_names = [n for n, v in implemented.items() if not v]

        rca_ctx = ""
        if root_cause:
            rca_ctx = (
                f"Vulnerable function: {root_cause.vulnerable_function}\n"
                f"Root cause: {root_cause.root_cause_description[:2000]}\n"
                f"Affected structs: {', '.join(root_cause.affected_structs)}\n"
                f"Syscalls: {', '.join(root_cause.syscalls)}\n"
            )

        return _COMPLETION_PROMPT.format(
            technique=plan.technique,
            target_struct=plan.target_struct,
            slab_cache=plan.slab_cache,
            vuln_type=plan.vulnerability_type.value,
            target_kernel=plan.target_kernel or ctx.target_kernel or "latest",
            arch=arch_str,
            platform=(plan.platform.value if plan.platform else "linux"),
            steps=steps_text,
            root_cause_context=rca_ctx or "(not available)",
            existing_code=source[:12000],
            analysis_summary=analysis["summary"],
            implemented=", ".join(impl_names) if impl_names else "(none)",
            missing=", ".join(miss_names) if miss_names else "(none detected)",
            compiler=compiler,
            extra_instructions=extra_instructions,
        )
    else:
        # No plan available — use freeform completion
        vuln_ctx = ""
        if root_cause:
            vuln_ctx = (
                f"Vulnerable function: {root_cause.vulnerable_function}\n"
                f"Root cause: {root_cause.root_cause_description[:2000]}\n"
                f"Affected structs: {', '.join(root_cause.affected_structs)}\n"
                f"Syscalls: {', '.join(root_cause.syscalls)}\n"
            )
        elif ctx.crash_report:
            vuln_ctx = (
                f"Crash type: {ctx.crash_report.crash_type}\n"
                f"Vulnerable function: {ctx.crash_report.stack_frames[0].function if ctx.crash_report.stack_frames else '?'}\n"
                f"CVE: {ctx.crash_report.cve_id or '(unknown)'}\n"
            )

        return _FREEFORM_COMPLETION_PROMPT.format(
            existing_code=source[:12000],
            analysis_summary=analysis["summary"],
            empty_functions=", ".join(analysis["empty_functions"]) or "(none)",
            placeholder_offsets=", ".join(v for _, v in analysis["placeholder_offsets"]) or "(none)",
            vuln_context=vuln_ctx or "(no vulnerability context available)",
            extra_instructions=extra_instructions,
        )


# ── Main entry-point ──────────────────────────────────────────────────


def complete_exploit(ctx: TaskContext, cfg: Optional[Config] = None) -> TaskContext:
    """
    Analyse the current exploit for incompleteness and use the LLM
    to fill in missing steps.

    Reads the exploit source from ``ctx.exploit_result.source_code``
    (or ``ctx.exploit_result.source_path``), analyses it, generates
    the completed code, writes + compiles it, and updates the context.

    This function is designed to be called by the agent when:
      - The initial ``exploit`` tool produces a skeleton
      - Verification feedback indicates the exploit is non-functional
        due to stubs/placeholders rather than logic errors
    """
    cfg = cfg or load_config()

    # ── 1. Get current exploit source ─────────────────────────────
    source: Optional[str] = None
    source_path: Optional[Path] = None

    if ctx.exploit_result and ctx.exploit_result.source_code:
        source = ctx.exploit_result.source_code
        if ctx.exploit_result.source_path:
            source_path = Path(ctx.exploit_result.source_path)
    elif ctx.exploit_result and ctx.exploit_result.source_path:
        source_path = Path(ctx.exploit_result.source_path)
        if source_path.exists():
            source = source_path.read_text()

    if not source:
        ctx.errors.append(
            "complete_exploit: no exploit source available — run 'exploit' first"
        )
        return ctx

    # ── 2. Analyse completeness ───────────────────────────────────
    console.print("  [bold]Analysing exploit completeness…[/]")
    analysis = _detect_incompleteness(source)
    console.print(f"  Incompleteness: {analysis['summary']}")

    if not analysis["is_incomplete"] and not analysis["missing_uid_tags"]:
        console.print("  [green]Exploit appears complete — no gaps detected.[/]")
        ctx.log("exploit", "complete_exploit", "already complete")
        return ctx

    # ── 3. Generate completed code via LLM ────────────────────────
    console.print("  [bold]Generating completed exploit via LLM…[/]")
    llm = LLMClient(cfg).for_task("codegen")

    extra = ""
    # Include verification feedback if available
    last_feedback = ctx.last_verification_feedback()
    if last_feedback:
        extra = f"\nPrevious verification feedback:\n{last_feedback[:1000]}\n"

    prompt = _build_completion_prompt(
        source, analysis, ctx.exploit_plan, ctx.root_cause, ctx, extra,
    )

    completed_code = llm.research_chat(
        [{"role": "user", "content": prompt}],
        max_retries=3,
        max_tokens=16384,
    )

    # Strip markdown fences
    completed_code = completed_code.strip()
    if completed_code.startswith("```"):
        code_lines = completed_code.split("\n")
        if code_lines[0].startswith("```"):
            code_lines = code_lines[1:]
        if code_lines and code_lines[-1].strip() == "```":
            code_lines = code_lines[:-1]
        completed_code = "\n".join(code_lines)

    # Detect and recover from truncation
    if _is_truncated(completed_code):
        console.print("  [yellow]Completed code appears truncated, requesting continuation…[/]")
        continuation_prompt = (
            "The code you returned was TRUNCATED. "
            "Here is the end of what you generated:\n\n"
            f"```c\n{completed_code[-3000:]}\n```\n\n"
            "Please complete the remaining code starting from where it was "
            "cut off. Include all remaining functions and a complete main(). "
            "Return ONLY the continuation C code."
        )
        continuation = llm.research_chat(
            [{"role": "user", "content": continuation_prompt}],
            max_retries=2,
            max_tokens=16384,
        )
        continuation = continuation.strip()
        if continuation.startswith("```"):
            clines = continuation.split("\n")
            if clines[0].startswith("```"):
                clines = clines[1:]
            if clines and clines[-1].strip() == "```":
                clines = clines[:-1]
            continuation = "\n".join(clines)
        if continuation and len(continuation) > 50:
            completed_code = completed_code + "\n" + continuation

    # ── 4. Verify the completion actually improved things ─────────
    new_analysis = _detect_incompleteness(completed_code)
    old_issues = len(analysis["stub_markers"]) + len(analysis["placeholder_offsets"]) + len(analysis["empty_functions"])
    new_issues = len(new_analysis["stub_markers"]) + len(new_analysis["placeholder_offsets"]) + len(new_analysis["empty_functions"])

    if new_issues > old_issues and old_issues > 0:
        console.print(
            f"  [yellow]Warning: completion introduced more issues "
            f"({old_issues} → {new_issues}). Keeping original code.[/]"
        )
        ctx.log(
            "exploit", "complete_exploit",
            f"rejected: old_issues={old_issues} new_issues={new_issues}",
        )
        return ctx

    improvement = max(0, old_issues - new_issues)
    console.print(
        f"  Issues: {old_issues} → {new_issues} "
        f"(fixed {improvement})"
    )

    # ── 5. Write and compile ──────────────────────────────────────
    work_dir = ctx.work_dir or Path.cwd() / "syzploit_output"
    work_dir.mkdir(parents=True, exist_ok=True)

    # Back up the old source
    if source_path and source_path.exists():
        backup = source_path.with_suffix(".c.bak")
        backup.write_text(source)
        console.print(f"  Old source backed up to {backup}")

    out_path = source_path or (work_dir / "exploit.c")
    out_path.write_text(completed_code)
    console.print(f"  Written completed exploit to {out_path}")

    arch = ctx.target_arch or Arch.ARM64
    arch_str = arch.value if isinstance(arch, Arch) else str(arch)
    binary_path = out_path.with_suffix("")
    console.print(f"  [bold]Compiling for {arch_str}…[/]")

    success, error = compile_reproducer(
        str(out_path),
        str(binary_path),
        arch=arch_str,
        cfg=cfg,
    )

    # ── 6. Update context ─────────────────────────────────────────
    if ctx.exploit_result is None:
        ctx.exploit_result = ExploitResult(
            target_kernel=ctx.target_kernel,
            arch=arch,
        )

    ctx.exploit_result.source_code = completed_code
    ctx.exploit_result.source_path = str(out_path)

    if success:
        ctx.exploit_result.success = True
        ctx.exploit_result.binary_path = str(binary_path)
        console.print(f"  [green]Completed exploit compiled: {binary_path}[/]")

        # ── 7. Auto-verify on device if SSH configured ────────────
        if ctx.ssh_host:
            console.print("  [bold]Verifying completed exploit on target…[/]")
            ctx = _verify_completed_exploit(ctx, cfg, str(binary_path))
    else:
        ctx.exploit_result.success = False
        ctx.exploit_result.binary_path = None
        ctx.exploit_result.notes.append(f"Completion compiled but failed: {error[:500]}")
        console.print(f"  [red]Compilation failed: {error[:200]}[/]")

    ctx.log(
        "exploit", "complete_exploit",
        f"old_issues={old_issues} new_issues={new_issues} compiled={success}",
    )

    return ctx


def _verify_completed_exploit(
    ctx: TaskContext, cfg: Config, binary_path: str,
) -> TaskContext:
    """Run exploit verification and record the attempt (mirrors pipeline.py)."""
    from ..core.models import VerificationAttempt
    from ..infra.verification import verify_exploit

    attempt_num = len(ctx.exploit_verification_attempts()) + 1
    if not ctx.can_retry_exploit_verification():
        console.print(
            f"  [dim]Max verification attempts ({ctx.max_verification_attempts}) reached, skipping.[/]"
        )
        return ctx

    use_adb = ctx.target_platform.value == "android" and ctx.instance is not None

    vresult = verify_exploit(
        binary_path,
        ssh_host=ctx.ssh_host,
        ssh_port=ctx.ssh_port,
        ssh_user=getattr(cfg, "ssh_user", "root"),
        ssh_key=getattr(cfg, "ssh_key", None),
        instance=ctx.instance,
        start_cmd=ctx.start_cmd,
        stop_cmd=ctx.stop_cmd,
        exploit_start_cmd=ctx.exploit_start_cmd,
        gdb_port=ctx.gdb_port,
        setup_tunnels=ctx.setup_tunnels,
        persistent=ctx.persistent,
        use_adb=use_adb,
    )

    attempt = VerificationAttempt(
        attempt_number=attempt_num,
        target="exploit",
        binary_path=binary_path,
        success=vresult["success"],
        uid_before=vresult.get("uid_before"),
        uid_after=vresult.get("uid_after"),
        privilege_escalated=vresult.get("privilege_escalated", False),
        crash_occurred=vresult.get("crash_occurred", False),
        crash_pattern=vresult.get("crash_pattern", ""),
        device_stable=vresult.get("device_stable", True),
        failure_reason=vresult.get("failure_reason", ""),
        feedback=vresult.get("feedback", ""),
        exploit_output=vresult.get("exploit_output", "")[:3000],
        dmesg_new=vresult.get("dmesg_new", "")[:3000],
    )
    ctx.verification_history.append(attempt)

    if vresult["success"] and ctx.exploit_result:
        ctx.exploit_result.privilege_escalation_confirmed = True
        ctx.exploit_result.uid_before = vresult.get("uid_before")
        ctx.exploit_result.uid_after = vresult.get("uid_after")
        ctx.exploit_result.verification_log = vresult.get("exploit_output", "")
        console.print("  [bold green]✓ Exploit verified — privilege escalation confirmed![/]")
    else:
        console.print(
            f"  [bold yellow]✗ Verification failed: "
            f"{vresult.get('failure_reason', 'unknown')}[/]"
        )

    return ctx
