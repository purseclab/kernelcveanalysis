"""
exploit.exploit_compiler — Enhanced multi-file exploit compilation.

Extends the base ``reproducer.compiler`` with support for:
- Multiple source files compiled together
- Header file injection (kernel_offsets.h, primitive headers)
- Separate compilation and linking stages
- Static linking for standalone exploit binaries
"""

from __future__ import annotations

import os
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from ..core.config import Config, load_config
from ..core.log import console
from ..reproducer.compiler import compile_reproducer, _find_compile_script


class ExploitCompiler:
    """Compile multi-file exploit projects.

    Handles the common case where an exploit consists of:
    - ``exploit.c``         — main exploit source
    - ``kernel_offsets.h``  — resolved addresses and struct offsets
    - Extra headers         — primitive templates, helpers
    - Extra sources         — optional additional .c files

    All files are staged into a temporary build directory, compiled
    with the appropriate cross-compiler, and the binary is placed
    at *output_path*.
    """

    def __init__(
        self,
        *,
        arch: str = "arm64",
        cfg: Optional[Config] = None,
    ) -> None:
        self._arch = arch
        self._cfg = cfg or load_config()

    def compile_exploit(
        self,
        main_source: str,
        output_path: str,
        *,
        header_files: Optional[Dict[str, str]] = None,
        extra_sources: Optional[List[str]] = None,
        extra_cflags: Optional[List[str]] = None,
        static: bool = True,
        use_llm_fix: bool = True,
        max_fix_attempts: int = 3,
        timeout: int = 120,
    ) -> Tuple[bool, str]:
        """Compile an exploit with optional extra files.

        Parameters
        ----------
        main_source:
            Content (str) or path to the main .c file.
        output_path:
            Where to place the compiled binary.
        header_files:
            Dict of ``{filename: content}`` for generated headers
            (e.g. ``{"kernel_offsets.h": "#define INIT_TASK ..."}``)
        extra_sources:
            List of paths to additional .c files to compile together.
        extra_cflags:
            Additional compiler flags (e.g. ``["-lpthread"]``).
        static:
            Link statically (``-static``). Default True for Android.
        use_llm_fix:
            Attempt LLM-driven auto-fix on compilation failure.
        max_fix_attempts:
            Max LLM fix iterations.
        timeout:
            Compilation timeout in seconds.

        Returns ``(success, error_message)``.
        """
        header_files = header_files or {}
        extra_sources = extra_sources or []
        extra_cflags = extra_cflags or []

        # If no extra files, use the simple single-file path
        if not header_files and not extra_sources and not extra_cflags:
            return self._compile_single(
                main_source, output_path,
                use_llm_fix=use_llm_fix,
                max_fix_attempts=max_fix_attempts,
                timeout=timeout,
            )

        # Stage all files into a build directory
        build_dir = Path(tempfile.mkdtemp(prefix="syzploit_build_"))
        try:
            return self._compile_multi(
                main_source=main_source,
                output_path=output_path,
                header_files=header_files,
                extra_sources=extra_sources,
                extra_cflags=extra_cflags,
                static=static,
                build_dir=build_dir,
                use_llm_fix=use_llm_fix,
                max_fix_attempts=max_fix_attempts,
                timeout=timeout,
            )
        finally:
            shutil.rmtree(build_dir, ignore_errors=True)

    # ── Private ───────────────────────────────────────────────────────

    def _compile_single(
        self,
        main_source: str,
        output_path: str,
        **kwargs,
    ) -> Tuple[bool, str]:
        """Delegate to the existing single-file compiler."""
        # main_source can be content or path
        if os.path.isfile(main_source):
            source_path = main_source
        else:
            # Write content to a temp file
            tmp = Path(output_path).parent / "exploit.c"
            tmp.parent.mkdir(parents=True, exist_ok=True)
            tmp.write_text(main_source)
            source_path = str(tmp)

        return compile_reproducer(
            source_path,
            output_path,
            arch=self._arch,
            cfg=self._cfg,
            **kwargs,
        )

    def _compile_multi(
        self,
        *,
        main_source: str,
        output_path: str,
        header_files: Dict[str, str],
        extra_sources: List[str],
        extra_cflags: List[str],
        static: bool,
        build_dir: Path,
        use_llm_fix: bool,
        max_fix_attempts: int,
        timeout: int,
    ) -> Tuple[bool, str]:
        """Multi-file compilation via build directory."""
        # Make output_path absolute so the linker can find it when
        # cwd is the temp build directory.
        output_path = str(Path(output_path).resolve())

        # Ensure the output directory exists
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)

        # Write main source
        if os.path.isfile(main_source):
            main_path = build_dir / "exploit.c"
            shutil.copy2(main_source, main_path)
        else:
            main_path = build_dir / "exploit.c"
            main_path.write_text(main_source)

        # Write header files
        for name, content in header_files.items():
            header_path = build_dir / name
            header_path.parent.mkdir(parents=True, exist_ok=True)
            header_path.write_text(content)

        # Copy extra sources
        source_files = [str(main_path)]
        for src in extra_sources:
            if os.path.isfile(src):
                dest = build_dir / Path(src).name
                shutil.copy2(src, dest)
                source_files.append(str(dest))

        # Build compiler command
        script = _find_compile_script(
            self._arch, str(self._cfg.workspace_dir)
        )

        if script is not None:
            # Use project compile script (handles NDK / cross-compiler)
            # For multi-file, we concatenate sources via -I and let
            # the script handle the main file
            console.print(
                f"  [dim]Multi-file build: {len(source_files)} sources, "
                f"{len(header_files)} headers[/]"
            )

            # Inject -I build_dir so headers are found
            env = os.environ.copy()
            existing_cflags = env.get("EXTRA_CFLAGS", "")
            parts = [existing_cflags] if existing_cflags else []
            parts.append(f"-I{build_dir}")
            if static:
                parts.append("-static")
            parts.extend(extra_cflags)
            env["EXTRA_CFLAGS"] = " ".join(parts)

            # If multiple .c files, concatenate extra into main
            if len(source_files) > 1:
                self._merge_sources(
                    main_path, [Path(s) for s in source_files[1:]]
                )

            try:
                result = subprocess.run(
                    [str(script), str(main_path), output_path],
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                    cwd=str(build_dir),
                    env=env,
                )
                if result.returncode == 0 and os.path.exists(output_path):
                    os.chmod(output_path, 0o755)
                    console.print(
                        f"  [green]Multi-file exploit compiled: {output_path}[/]"
                    )
                    return True, ""
                error = result.stderr or result.stdout or "Unknown error"
            except subprocess.TimeoutExpired:
                return False, "Compilation timed out"
            except Exception as e:
                error = str(e)

            # LLM auto-fix if enabled
            if use_llm_fix:
                return self._fix_and_retry(
                    main_path=main_path,
                    output_path=output_path,
                    script=script,
                    build_dir=build_dir,
                    env=env,
                    last_error=error,
                    max_attempts=max_fix_attempts,
                    timeout=timeout,
                )
            return False, error

        else:
            # No compile script — try direct cross-compiler invocation
            return self._compile_direct(
                source_files=source_files,
                output_path=output_path,
                include_dirs=[str(build_dir)],
                extra_cflags=extra_cflags,
                static=static,
                timeout=timeout,
            )

    def _merge_sources(
        self, main: Path, extras: List[Path]
    ) -> None:
        """Append extra .c files into the main source via #include."""
        with open(main, "a") as f:
            f.write("\n\n/* ═══ Merged extra sources ═══ */\n")
            for extra in extras:
                f.write(f'\n#include "{extra.name}"\n')

    def _compile_direct(
        self,
        *,
        source_files: List[str],
        output_path: str,
        include_dirs: List[str],
        extra_cflags: List[str],
        static: bool,
        timeout: int,
    ) -> Tuple[bool, str]:
        """Try direct cross-compiler invocation without compile script."""
        # Determine compiler
        compilers = {
            "arm64": "aarch64-linux-gnu-gcc",
            "aarch64": "aarch64-linux-gnu-gcc",
            "x86_64": "gcc",
            "x86": "gcc",
        }
        cc = compilers.get(self._arch, "gcc")

        cmd = [cc, "-o", output_path]
        for d in include_dirs:
            cmd.extend(["-I", d])
        if static:
            cmd.append("-static")
        cmd.extend(extra_cflags)
        cmd.extend(source_files)

        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
            )
            if result.returncode == 0 and os.path.exists(output_path):
                os.chmod(output_path, 0o755)
                return True, ""
            return False, result.stderr or result.stdout or "Unknown error"
        except FileNotFoundError:
            return False, f"Compiler not found: {cc}"
        except subprocess.TimeoutExpired:
            return False, "Compilation timed out"

    def _fix_and_retry(
        self,
        *,
        main_path: Path,
        output_path: str,
        script: Path,
        build_dir: Path,
        env: dict,
        last_error: str,
        max_attempts: int,
        timeout: int,
    ) -> Tuple[bool, str]:
        """LLM-driven compilation fix loop for multi-file builds."""
        from ..reproducer.compiler import _llm_fix_compilation

        for attempt in range(1, max_attempts + 1):
            console.print(
                f"  [dim]Multi-file compilation failed, "
                f"LLM fix attempt {attempt}/{max_attempts}…[/]"
            )
            try:
                code = main_path.read_text()
                fixed = _llm_fix_compilation(
                    code, last_error, attempt=attempt, cfg=self._cfg
                )
                if fixed:
                    main_path.write_text(fixed)
                    result = subprocess.run(
                        [str(script), str(main_path), output_path],
                        capture_output=True,
                        text=True,
                        timeout=timeout,
                        cwd=str(build_dir),
                        env=env,
                    )
                    if result.returncode == 0 and os.path.exists(output_path):
                        os.chmod(output_path, 0o755)
                        console.print(
                            f"  [green]Compiled after fix attempt {attempt}[/]"
                        )
                        return True, ""
                    last_error = (
                        result.stderr or result.stdout or "Unknown error"
                    )
            except Exception:
                pass

        return False, last_error
