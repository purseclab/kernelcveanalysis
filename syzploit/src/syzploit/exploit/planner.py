"""
exploit.planner — LLM-driven exploit plan generation.

Takes a ``RootCauseAnalysis`` and produces an ``ExploitPlan``
with ordered steps, technique selection, and target struct/slab info.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional

from ..core.config import Config, load_config
from ..core.llm import LLMClient
from ..core.models import (
    Arch,
    ExploitPlan,
    ExploitStep,
    Platform,
    Primitive,
    RootCauseAnalysis,
    VulnType,
)

# ── Exploitation patterns (knowledge base) ────────────────────────────

EXPLOITATION_PATTERNS: Dict[str, Dict[str, Any]] = {
    "cross_cache_uaf": {
        "vuln_types": [VulnType.UAF, VulnType.DOUBLE_FREE],
        "description": "Cross-cache attack using slab-level UAF",
        "steps": [
            "trigger_vulnerability",
            "spray_heap_objects",
            "reclaim_freed_object",
            "overwrite_function_pointer",
            "hijack_control_flow",
            "escalate_privileges",
        ],
        "requirements": ["known_slab_cache", "controllable_allocation"],
    },
    "msg_msg_spray": {
        "vuln_types": [VulnType.UAF, VulnType.OOB_WRITE],
        "description": "Use msg_msg for heap spray and cross-cache reclaim",
        "steps": [
            "trigger_vulnerability",
            "spray_msg_msg",
            "leak_kernel_pointer",
            "overwrite_target_object",
            "escalate_privileges",
        ],
        "requirements": ["slab_size_compatible"],
    },
    "pipe_buffer_rw": {
        "vuln_types": [VulnType.UAF, VulnType.OOB_WRITE, VulnType.OOB_READ],
        "description": "Use pipe_buffer for arbitrary kernel R/W",
        "steps": [
            "trigger_vulnerability",
            "spray_pipe_buffers",
            "corrupt_pipe_buffer",
            "achieve_arbitrary_read",
            "achieve_arbitrary_write",
            "overwrite_cred_or_modprobe",
            "escalate_privileges",
        ],
        "requirements": [],
    },
    "direct_cred_overwrite": {
        "vuln_types": [VulnType.UAF, VulnType.OOB_WRITE],
        "description": "Directly overwrite task_struct->cred fields",
        "steps": [
            "trigger_vulnerability",
            "locate_cred_struct",
            "overwrite_uid_gid",
            "verify_privilege_escalation",
        ],
        "requirements": ["known_cred_offset"],
    },
    "modprobe_path": {
        "vuln_types": [VulnType.UAF, VulnType.OOB_WRITE, VulnType.RACE_CONDITION],
        "description": "Overwrite modprobe_path for code execution",
        "steps": [
            "trigger_vulnerability",
            "achieve_arbitrary_write",
            "overwrite_modprobe_path",
            "trigger_modprobe_execution",
        ],
        "requirements": ["arbitrary_write_primitive"],
    },
    "cross_cache_page_reclaim": {
        "vuln_types": [VulnType.UAF, VulnType.DOUBLE_FREE],
        "description": (
            "Page-level cross-cache reclaim: free slab pages back to "
            "the buddy allocator, then reclaim with pipe data pages "
            "for controlled overlapping content (as used in bad_io_uring, badspin)"
        ),
        "steps": [
            "pin_cpu",
            "groom_slab_cache",
            "trigger_vulnerability",
            "free_spray_objects_to_release_pages",
            "spray_pipe_pages_for_reclaim",
            "detect_overlap_via_pipe_read",
            "build_fake_pipe_buffer",
            "achieve_arbitrary_rw_via_pipe",
            "walk_task_list",
            "overwrite_cred",
            "disable_selinux",
            "escalate_privileges",
        ],
        "requirements": ["known_slab_cache"],
    },
    "dirty_pipe": {
        "vuln_types": [VulnType.LOGIC_BUG, VulnType.RACE_CONDITION],
        "description": (
            "Exploit stale PIPE_BUF_FLAG_CAN_MERGE flag to overwrite "
            "arbitrary page-cache-backed files (CVE-2022-0847 pattern)"
        ),
        "steps": [
            "prepare_pipe_with_merge_flag",
            "splice_target_file_page_into_pipe",
            "write_to_pipe_overwrites_page_cache",
            "overwrite_suid_binary_or_passwd",
            "trigger_suid_execution",
            "escalate_privileges",
        ],
        "requirements": ["readable_suid_binary_or_sensitive_file"],
    },
    "io_uring_race": {
        "vuln_types": [VulnType.RACE_CONDITION, VulnType.UAF, VulnType.DOUBLE_FREE],
        "description": (
            "Exploit race conditions in io_uring async paths. "
            "Trigger UAF/double-free during concurrent io_uring operations "
            "and reclaim with controlled objects."
        ),
        "steps": [
            "pin_cpu",
            "setup_io_uring_context",
            "trigger_race_condition",
            "spray_heap_for_reclaim",
            "corrupt_reclaimed_object",
            "achieve_arbitrary_rw",
            "walk_task_list",
            "overwrite_cred",
            "escalate_privileges",
        ],
        "requirements": ["io_uring_available"],
    },
    "namespace_escape": {
        "vuln_types": [VulnType.UAF, VulnType.OOB_WRITE, VulnType.LOGIC_BUG],
        "description": (
            "Escape from a restricted namespace / container by "
            "overwriting task_struct->nsproxy with init_task's nsproxy "
            "after achieving arbitrary kernel R/W"
        ),
        "steps": [
            "trigger_vulnerability",
            "achieve_arbitrary_rw",
            "walk_task_list",
            "overwrite_cred",
            "swap_nsproxy_with_init",
            "disable_selinux",
            "escalate_privileges",
        ],
        "requirements": ["arbitrary_rw_primitive"],
    },
    "binder_uaf_cross_cache": {
        "vuln_types": [VulnType.UAF, VulnType.DOUBLE_FREE],
        "description": (
            "Binder UAF exploit using cross-cache reclaim with epitem. "
            "Trigger UAF on binder_node (kmalloc-128) via corrupted "
            "transaction offsets_size causing refcount double-decrement. "
            "Reclaim freed nodes with epitem (epoll_ctl, same slab), "
            "leak kernel addresses from dangling binder transactions, "
            "build arbitrary read via hlist_del unlink + epoll_ctl + "
            "ioctl(FIGETBSZ), then walk binder_proc→task_struct→cred "
            "to overwrite uid/gid. Requires multi-process architecture "
            "with pipe-based coordination. Uses /dev/hwbinder on Android."
        ),
        "steps": [
            "pin_cpu_and_setup_processes",
            "open_hwbinder_and_mmap",
            "fork_context_manager_child",
            "register_with_token_manager",
            "fragment_binder_allocator",
            "create_binder_nodes_via_transactions",
            "send_async_transactions_to_nodes",
            "send_malformed_transaction_with_corrupted_offsets_size",
            "destroy_binder_context_to_free_nodes",
            "reclaim_freed_nodes_with_epitem_epoll_ctl",
            "read_dangling_transactions_to_leak_addresses",
            "build_arbitrary_read_via_unlink_epoll_figetbsz",
            "leak_kernel_base_from_timerfd_fops",
            "find_task_struct_via_binder_proc",
            "zero_cred_uid_gid",
            "disable_selinux",
            "escalate_privileges_setresuid",
        ],
        "requirements": ["binder_device_available", "android_platform"],
    },
}


# ── Plan generation prompt ────────────────────────────────────────────

_PLAN_PROMPT = """\
You are a kernel exploit developer.  Given the vulnerability analysis below,
create a detailed exploitation plan.

Vulnerability:
- Type: {vuln_type}
- Function: {function}
- Subsystem: {subsystem}
- Root cause: {root_cause}
- Structs: {structs}
- Slab cache: {slab_cache}
- Exploitability score: {score}/100
- Control level: {control}

Target:
- Kernel: {target_kernel}
- Arch: {arch}
- Platform: {platform}

Known exploitation patterns for this vuln type:
{patterns}

{primitive_library_context}

{slab_oracle_context}

{exploitation_details_context}

Return JSON:
{{
    "technique": "<chosen exploitation technique>",
    "target_struct": "<primary struct to target>",
    "description": "<1-2 sentence plan summary>",
    "steps": [
        {{
            "name": "<step_action_name>",
            "description": "<what this step does>",
            "requires": ["<preconditions>"],
            "provides": ["<postconditions>"],
            "code_hint": "<key C code / syscall to use>"
        }}
    ],
    "offsets": {{"<field>": "<description or value>"}},
    "notes": ["<important considerations>"]
}}
"""


def _format_exploitation_details_for_plan(details: dict) -> str:
    """Format exploitation_details for the planner prompt."""
    if not details:
        return ""
    lines = ["Exploitation technique details (from blog/write-up analysis):"]
    for key in ["trigger_method", "reclaim_object_type", "rw_primitive_method",
                "process_architecture", "privilege_escalation_path",
                "device_or_interface", "uaf_object_type"]:
        val = details.get(key, "")
        if val:
            lines.append(f"  - {key}: {val}")
    binder = details.get("binder_specific", {})
    if binder:
        for k, v in binder.items():
            if v:
                lines.append(f"  - binder.{k}: {v}")
    return "\n".join(lines)


def plan_exploit(
    root_cause: RootCauseAnalysis,
    *,
    target_kernel: str = "",
    arch: Arch = Arch.ARM64,
    platform: Platform = Platform.ANDROID,
    cfg: Optional[Config] = None,
) -> ExploitPlan:
    """
    Generate an exploit plan from root cause analysis.

    Uses LLM reasoning augmented with known exploitation patterns.
    """
    cfg = cfg or load_config()
    llm = LLMClient(cfg).for_task("planning")

    # Find matching patterns
    matching = []
    for name, pattern in EXPLOITATION_PATTERNS.items():
        if root_cause.vulnerability_type in pattern["vuln_types"]:
            matching.append(f"- {name}: {pattern['description']}")
    patterns_text = "\n".join(matching) if matching else "(no known patterns match)"

    # Gather primitive library and slab oracle context
    primitive_ctx = ""
    slab_ctx = ""
    try:
        from .primitive_library import PrimitiveLibrary
        plib = PrimitiveLibrary()
        primitive_ctx = plib.format_for_prompt()
    except Exception:
        pass
    try:
        from ..analysis.slab_oracle import SlabOracle
        oracle = SlabOracle()
        slab_ctx = oracle.format_for_prompt()
    except Exception:
        pass

    prompt = _PLAN_PROMPT.format(
        vuln_type=root_cause.vulnerability_type.value,
        function=root_cause.vulnerable_function,
        subsystem=root_cause.affected_subsystem,
        root_cause=root_cause.root_cause_description[:2000],
        structs=", ".join(root_cause.affected_structs) or "unknown",
        slab_cache=", ".join(root_cause.slab_caches) or "unknown",
        score=root_cause.exploitability_score,
        control=root_cause.control_classification.value,
        target_kernel=target_kernel or "latest",
        arch=arch.value,
        platform=platform.value,
        patterns=patterns_text,
        primitive_library_context=primitive_ctx,
        slab_oracle_context=slab_ctx,
        exploitation_details_context=_format_exploitation_details_for_plan(
            root_cause.exploitation_details
        ),
    )

    result = llm.ask_json(
        prompt,
        system="You are a kernel exploit developer at a security research lab.",
    )

    # Build plan from LLM output
    steps = []
    for s in result.get("steps", []):
        steps.append(ExploitStep(
            name=s.get("name", "unknown"),
            action=s.get("name", "unknown"),
            description=s.get("description", ""),
            requires=s.get("requires", []),
            provides=s.get("provides", []),
            code_hint=s.get("code_hint", ""),
        ))

    offsets = {}
    for k, v in result.get("offsets", {}).items():
        if isinstance(v, int):
            offsets[k] = v

    return ExploitPlan(
        vulnerability_type=root_cause.vulnerability_type,
        target_struct=result.get("target_struct", ""),
        slab_cache=", ".join(root_cause.slab_caches) if root_cause.slab_caches else "",
        technique=result.get("technique", ""),
        steps=steps,
        goal="privilege_escalation",
        platform=platform,
        target_arch=arch,
        target_kernel=target_kernel,
        offsets=offsets,
        description=result.get("description", ""),
        notes=result.get("notes", []),
    )
