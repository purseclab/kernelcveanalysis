import json
import os
from typing import Optional, Dict, Any
from pathlib import Path
from .core import PrimitiveRegistry, ExploitPlan, Primitive
from .adapters.syzanalyze_adapter import load_from_analysis
from .adapters.kernelresearch_adapter import KernelResearchAdapter
from .chainreactor_integration import ChainReactor
from .pddl_generator import PDDLGenerator


def synthesize(bug_id: str, goal: str, kernel_research_path: Optional[str] = None,
               chainreactor_path: Optional[str] = None,
               analysis_dir: Optional[str] = None,
               vmlinux_path: Optional[str] = None) -> Dict[str, Any]:
    """Orchestrate exploit synthesis by combining syzanalyze primitives and kernelXDK primitives,
    then optionally invoking ChainReactor to stitch them into an exploit.
    """
    registry = PrimitiveRegistry()

    # Resolve default submodule paths if not provided
    try:
        src_root = Path(__file__).resolve().parents[3]  # .../src
        if kernel_research_path is None:
            kr_candidate = src_root / 'kernel-research'
            if kr_candidate.exists():
                kernel_research_path = str(kr_candidate)
        if chainreactor_path is None:
            cr_candidate = src_root / 'chainreactor'
            if cr_candidate.exists():
                chainreactor_path = str(cr_candidate)
    except Exception:
        pass

    # Locate analysis directory
    cwd = os.getcwd()
    if not analysis_dir:
        # Try analysis_<bug_id>
        candidates = [d for d in os.listdir(cwd) if d.startswith('analysis_') and bug_id in d]
        analysis_dir = os.path.join(cwd, candidates[0]) if candidates else cwd

    syz_prims = load_from_analysis(analysis_dir, registry)

    # Integrate kernel-research primitives
    kr = KernelResearchAdapter(kernel_research_path)
    xdk_prims = kr.list_primitives(registry) if kr.available() else []

    # Compose plan
    target_info: Dict[str, Any] = {
        "bug_id": bug_id,
        "analysis_dir": analysis_dir,
        "vmlinux": vmlinux_path,
    }
    plan = ExploitPlan(goal=goal, target_info=target_info, primitives=registry.list())

    # Simple heuristic: choose ROP + credential escalation if goal mentions root/shell
    steps = []
    if 'priv' in goal or 'root' in goal or 'shell' in goal:
        steps.append({"action": "generate_rop_chain", "provider": "kernelXDK"})
        steps.append({"action": "commit_creds_prepare_kernel_cred", "provider": "kernelXDK"})
    plan.steps = steps

    # Write spec for ChainReactor or custom stitcher
    spec_path = os.path.join(analysis_dir, 'synth_spec.json')
    with open(spec_path, 'w') as f:
        json.dump({
            "goal": goal,
            "target": target_info,
            "primitives": [p.__dict__ for p in plan.primitives],
            "steps": plan.steps,
        }, f, indent=2)

    # If ChainReactor is available, generate PDDL and invoke solver
    cr = ChainReactor(chainreactor_path)
    if cr.available() and chainreactor_path:
        # Emit PDDL into a dedicated folder for re-runs
        pddl_dir = os.path.join(analysis_dir, 'pddl')
        os.makedirs(pddl_dir, exist_ok=True)
        # Generate problem PDDL from primitives
        gen = PDDLGenerator(chainreactor_path, analysis_dir=analysis_dir)
        domain_src = gen.domain_path()
        problem_path = gen.generate_problem(f"{bug_id}-goal", plan.primitives, os.path.join(pddl_dir, 'problem.pddl'), goal)
        # Copy domain to analysis dir for convenience
        try:
            import shutil
            domain_path = os.path.join(pddl_dir, 'domain.pddl')
            shutil.copyfile(domain_src, domain_path)
        except Exception:
            domain_path = domain_src
        # Run solver and copy plans back into the PDDL dir
        result = cr.solve_with_pddl(domain_path, problem_path, pddl_dir)
        return {"plan": plan.__dict__, "chainreactor": result, "pddl": {"domain": domain_path, "problem": problem_path}}

    # Else, minimal custom stitching placeholder
    outdir = os.path.join(analysis_dir, 'synth_output')
    os.makedirs(outdir, exist_ok=True)
    with open(os.path.join(outdir, 'README.txt'), 'w') as rf:
        rf.write("This directory would contain exploit artifacts generated by ChainReactor or custom stitcher.\n")
        rf.write(f"Goal: {goal}\n")
        rf.write(f"Selected primitives: {[p.name for p in plan.primitives]}\n")
    return {"plan": plan.__dict__, "chainreactor": {"success": False, "error": "ChainReactor unavailable"}}
