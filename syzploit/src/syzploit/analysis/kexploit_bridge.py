"""
analysis.kexploit_bridge — Bridge to kexploit modules for offset/struct analysis.

Provides access to kexploit capabilities (BTF struct layouts, CodeQL
allocation queries, exploit offset adaptation) when the kexploit
package is installed.  Gracefully degrades when it's not available.

Key functionality:
    - ``query_struct_layout`` — Get struct field offsets from BTF data
    - ``query_codeql_allocations`` — Find kmalloc call sites and slab caches
    - ``adapt_exploit_offsets`` — Translate addresses/offsets between kernels
"""

from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from ..core.log import console

# ── Availability check ────────────────────────────────────────────────

_KEXPLOIT_AVAILABLE = False
_KEXPLOIT_IMPORT_ERROR = ""

try:
    from kexploit.synthesis.btf_types import BtfTypes, BtfStruct, BtfUnion
    from kexploit.synthesis.codeql import (
        CodeqlContext,
        CodeqlQuery,
        CodeQlKmallocCallResult,
        CodeQlStructResult,
    )
    from kexploit.kernel_image import Kernel, KernelAdapter, KernelImage, AdaptError
    _KEXPLOIT_AVAILABLE = True
except ImportError as exc:
    _KEXPLOIT_IMPORT_ERROR = str(exc)


def is_available() -> bool:
    """Return True if kexploit package is importable."""
    return _KEXPLOIT_AVAILABLE


def import_error() -> str:
    """Return the import error message if kexploit is not available."""
    return _KEXPLOIT_IMPORT_ERROR


# =====================================================================
# 1.  Struct layout / offset queries via BTF
# =====================================================================

def query_struct_layout(
    struct_name: str,
    kernel_name: Optional[str] = None,
    btf_json_path: Optional[str] = None,
) -> Dict[str, Any]:
    """Get field-level layout information for a kernel struct.

    Uses BTF (BPF Type Format) data to provide accurate field offsets,
    sizes, and types.  This is critical for exploit code that needs to
    access specific struct fields at precise offsets.

    Args:
        struct_name: Kernel struct name (e.g. ``binder_proc``).
        kernel_name: kexploit kernel identifier (if using kexploit data dir).
        btf_json_path: Direct path to a btf_types.json file.

    Returns:
        Dict with struct info: name, size, fields (offset, name, type).
    """
    if not _KEXPLOIT_AVAILABLE:
        return {
            "error": f"kexploit not available: {_KEXPLOIT_IMPORT_ERROR}",
            "struct_name": struct_name,
        }

    btf: Optional[BtfTypes] = None

    # Load BTF data
    if btf_json_path and os.path.isfile(btf_json_path):
        with open(btf_json_path, "r") as f:
            btf = BtfTypes(json.load(f))
    elif kernel_name:
        try:
            kernel = Kernel(kernel_name)
            btf = BtfTypes.load(kernel)
        except Exception as exc:
            return {
                "error": f"Failed to load BTF for kernel {kernel_name}: {exc}",
                "struct_name": struct_name,
            }

    if btf is None:
        return {
            "error": "No BTF data source provided (need kernel_name or btf_json_path)",
            "struct_name": struct_name,
        }

    # Look up the struct
    btf_type = btf.get_type_by_name(struct_name)
    if btf_type is None:
        return {
            "error": f"Struct '{struct_name}' not found in BTF data",
            "struct_name": struct_name,
            "available_hint": "Try common names like task_struct, cred, file, etc.",
        }

    if not isinstance(btf_type, (BtfStruct, BtfUnion)):
        return {
            "error": f"'{struct_name}' is a {btf_type.kind}, not a struct/union",
            "struct_name": struct_name,
        }

    # Extract field info
    fields_info = []
    for member in btf_type.members:
        field_type_name = ""
        if member.type_id and member.type_id.type:
            field_type_name = member.type_id.type.format_short()

        fields_info.append({
            "name": member.name,
            "byte_offset": member.bits_offset // 8,
            "bit_offset": member.bits_offset,
            "type": field_type_name,
            "bitfield_size": member.bitfield_size,
        })

    return {
        "struct_name": struct_name,
        "size": btf_type.size,
        "num_fields": len(fields_info),
        "fields": fields_info,
        "c_definition": btf_type.format_long(),
    }


def query_multiple_structs(
    struct_names: List[str],
    kernel_name: Optional[str] = None,
    btf_json_path: Optional[str] = None,
) -> Dict[str, Any]:
    """Query layouts for multiple structs at once.

    Returns a dict mapping struct_name → layout info.
    """
    results = {}
    for name in struct_names:
        results[name] = query_struct_layout(
            name,
            kernel_name=kernel_name,
            btf_json_path=btf_json_path,
        )
    return results


def generate_offsets_header_from_btf(
    struct_names: List[str],
    kernel_name: Optional[str] = None,
    btf_json_path: Optional[str] = None,
) -> str:
    """Generate a C header with #define macros for struct field offsets.

    Example output::

        #define TASK_STRUCT_SIZE 9792
        #define TASK_STRUCT_CRED_OFFSET 2784
        #define CRED_UID_OFFSET 4
        ...
    """
    lines = [
        "/* Auto-generated struct offsets from BTF data */",
        "/* Generated by syzploit kexploit_bridge */",
        "",
    ]

    for struct_name in struct_names:
        info = query_struct_layout(
            struct_name,
            kernel_name=kernel_name,
            btf_json_path=btf_json_path,
        )
        if "error" in info:
            lines.append(f"/* {struct_name}: {info['error']} */")
            continue

        prefix = struct_name.upper()
        lines.append(f"#define {prefix}_SIZE {info['size']}")
        for field in info.get("fields", []):
            field_name = field["name"].upper()
            lines.append(
                f"#define {prefix}_{field_name}_OFFSET {field['byte_offset']}"
            )
        lines.append("")

    return "\n".join(lines)


# =====================================================================
# 2.  CodeQL allocation site queries
# =====================================================================

def query_codeql_allocations(
    codeql_db_path: str,
    struct_filter: Optional[str] = None,
) -> Dict[str, Any]:
    """Query a CodeQL database for kmalloc call sites.

    This reveals which structs are allocated from which slab caches,
    their sizes, and whether they use flexible arrays.  Critical for
    planning heap spray strategies.

    Args:
        codeql_db_path: Path to the CodeQL database.
        struct_filter: Optional struct name to filter results.

    Returns:
        Dict with allocation info.
    """
    if not _KEXPLOIT_AVAILABLE:
        return {"error": f"kexploit not available: {_KEXPLOIT_IMPORT_ERROR}"}

    if not os.path.isdir(codeql_db_path):
        return {"error": f"CodeQL database not found: {codeql_db_path}"}

    try:
        ctx = CodeqlContext(Path(codeql_db_path))
        calls = ctx.get_kmalloc_calls()

        results = []
        for call in calls:
            if struct_filter and struct_filter not in call.struct_type:
                continue
            results.append({
                "call_site": str(call.call_site),
                "call_type": str(call.call_type),
                "struct_type": call.struct_type,
                "struct_size": call.struct_size,
                "alloc_size": call.alloc_size,
                "flags": call.flags,
                "is_flexible": call.is_flexible,
                "kmalloc_cache_name": call.kmalloc_cache_name,
            })

        return {
            "total_calls": len(results),
            "allocations": results,
        }
    except Exception as exc:
        return {"error": f"CodeQL query failed: {exc}"}


def query_codeql_structs(codeql_db_path: str) -> Dict[str, Any]:
    """Query a CodeQL database for struct definitions.

    Returns struct names, whether they're anonymous, and their field names.
    """
    if not _KEXPLOIT_AVAILABLE:
        return {"error": f"kexploit not available: {_KEXPLOIT_IMPORT_ERROR}"}

    if not os.path.isdir(codeql_db_path):
        return {"error": f"CodeQL database not found: {codeql_db_path}"}

    try:
        ctx = CodeqlContext(Path(codeql_db_path))
        structs = ctx.get_structs()

        results = []
        for s in structs:
            results.append({
                "name": s.struct_name,
                "is_anonymous": s.is_anon,
                "field_names": s.field_names,
                "location": str(s.location),
            })

        return {
            "total_structs": len(results),
            "structs": results,
        }
    except Exception as exc:
        return {"error": f"CodeQL struct query failed: {exc}"}


# =====================================================================
# 3.  Exploit offset adaptation between kernel versions
# =====================================================================

def adapt_exploit_offsets(
    source_kernel: str,
    target_kernel: str,
    addresses: Optional[Dict[str, int]] = None,
    rop_gadgets: Optional[Dict[str, Dict[str, Any]]] = None,
) -> Dict[str, Any]:
    """Translate exploit addresses/offsets from one kernel version to another.

    Uses kexploit's binary analysis (ELF symbol matching, instruction
    pattern search for ROP gadgets, Ghidra-based data reference tracing)
    to map concrete exploit values.

    Args:
        source_kernel: kexploit kernel name for the original exploit.
        target_kernel: kexploit kernel name for the target.
        addresses: Dict mapping label → source address to translate.
        rop_gadgets: Dict mapping label → {gadget: str, is_relative: bool}.

    Returns:
        Dict with translated addresses and any errors.
    """
    if not _KEXPLOIT_AVAILABLE:
        return {"error": f"kexploit not available: {_KEXPLOIT_IMPORT_ERROR}"}

    try:
        src = Kernel(source_kernel)
        dst = Kernel(target_kernel)

        if not src.exists():
            return {"error": f"Source kernel '{source_kernel}' ELF not found"}
        if not dst.exists():
            return {"error": f"Target kernel '{target_kernel}' ELF not found"}

        adapter = KernelAdapter(src, dst)

        translated: Dict[str, Any] = {}
        errors: List[str] = []

        # Translate plain addresses
        if addresses:
            for label, addr in addresses.items():
                try:
                    new_addr = adapter.translate_address(addr)
                    translated[label] = {
                        "original": hex(addr),
                        "translated": hex(new_addr),
                        "offset_from_base": hex(
                            new_addr - adapter.dst_image.kernel_base
                        ),
                    }
                except AdaptError as exc:
                    errors.append(f"{label}: {exc.message}")
                    translated[label] = {
                        "original": hex(addr),
                        "error": exc.message,
                    }

        # Translate ROP gadgets
        if rop_gadgets:
            for label, info in rop_gadgets.items():
                gadget = info.get("gadget", "")
                is_relative = info.get("is_relative", False)
                try:
                    if is_relative:
                        new_addr = adapter.translate_rop_gadget_offset(gadget)
                    else:
                        new_addr = adapter.translate_rop_gadget(gadget)

                    translated[label] = {
                        "gadget": gadget,
                        "translated": hex(new_addr),
                        "is_relative": is_relative,
                    }
                except AdaptError as exc:
                    errors.append(f"ROP {label}: {exc.message}")
                    translated[label] = {
                        "gadget": gadget,
                        "error": exc.message,
                    }

        return {
            "source_kernel": source_kernel,
            "target_kernel": target_kernel,
            "source_base": hex(adapter.src_image.kernel_base),
            "target_base": hex(adapter.dst_image.kernel_base),
            "translations": translated,
            "errors": errors,
        }
    except Exception as exc:
        return {"error": f"Adaptation failed: {exc}"}


def get_symbol_address(
    kernel_name: str,
    symbol_name: str,
) -> Dict[str, Any]:
    """Look up a symbol address from the kexploit kernel ELF.

    Returns the symbol's absolute address and offset from kernel base.
    """
    if not _KEXPLOIT_AVAILABLE:
        return {"error": f"kexploit not available: {_KEXPLOIT_IMPORT_ERROR}"}

    try:
        kernel = Kernel(kernel_name)
        if not kernel.exists():
            return {"error": f"Kernel '{kernel_name}' ELF not found"}

        image = KernelImage(kernel)
        sym = image.get_symbol(symbol_name)
        if sym is None:
            return {
                "error": f"Symbol '{symbol_name}' not found",
                "kernel": kernel_name,
            }

        return {
            "symbol": symbol_name,
            "address": hex(sym.address),
            "offset": hex(sym.offset),
            "kernel_base": hex(image.kernel_base),
        }
    except Exception as exc:
        return {"error": f"Symbol lookup failed: {exc}"}
