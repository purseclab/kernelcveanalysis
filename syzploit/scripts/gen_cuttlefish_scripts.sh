#!/usr/bin/env bash
#
# gen_cuttlefish_scripts.sh
#
# Generates the instance management scripts (gdb_run.sh, run.sh, stop.sh) that
# syzploit's --start-cmd / --stop-cmd expect on the remote Cuttlefish host.
#
# These scripts are parameterised by a config file (cuttlefish_instance.conf)
# that records the kernel Image, initramfs, Cuttlefish directory, and other
# options so they don't have to be repeated every time.
#
# Usage:
#   # Generate a config + scripts in the current directory:
#   ./gen_cuttlefish_scripts.sh \
#       --kernel /home/user/kernel/Image \
#       --initramfs /home/user/kernel/initramfs.img \
#       --cf-dir /home/user/cuttlefish \
#       --output-dir /home/user/cuttlefish_workspace
#
#   # Then on the remote host the pipeline uses:
#   --start-cmd "cd /home/user/cuttlefish_workspace && ./gdb_run.sh 20"
#   --stop-cmd  "cd /home/user/cuttlefish_workspace && ./stop.sh 20"
#
#   # Regenerate after changing kernel:
#   ./gen_cuttlefish_scripts.sh --config /home/user/cuttlefish_workspace/cuttlefish_instance.conf \
#       --kernel /home/user/new_kernel/Image \
#       --initramfs /home/user/new_kernel/initramfs.img

set -euo pipefail

# ============================================================================
# Defaults
# ============================================================================
KERNEL_PATH=""
INITRAMFS_PATH=""
CF_DIR=""
OUTPUT_DIR="."
GDB_PORT=1234
VM_MANAGER="qemu_cli"     # "qemu_cli" or "crosvm" — qemu_cli supports multi-CPU GDB
EXTRA_KERNEL_CMDLINE="androidboot.selinux=permissive"
NUM_CPUS=6
CONFIG_FILE=""             # Load/update existing config

# ============================================================================
# Argument parsing
# ============================================================================
usage() {
    cat <<'USAGE'
Usage: gen_cuttlefish_scripts.sh [OPTIONS]

Required (unless --config is used):
  --kernel PATH          Path to kernel Image on the target host
  --cf-dir DIR           Cuttlefish home directory (contains bin/launch_cvd)

Optional:
  --initramfs PATH       Path to initramfs.img (omit to use Cuttlefish default)

Options:
  --output-dir DIR       Directory to write scripts into (default: .)
  --gdb-port PORT        GDB port (default: 1234)
  --vm-manager MGR       VM manager: qemu_cli or crosvm (default: qemu_cli)
  --cpus N               Number of guest CPUs (default: 6)
  --extra-cmdline STR    Extra kernel cmdline (default: "androidboot.selinux=permissive")
  --config FILE          Load existing config file (overrides with any flags given)
  --help                 Show this help
USAGE
    exit 0
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        --kernel)           KERNEL_PATH="$2"; shift 2 ;;
        --initramfs)        INITRAMFS_PATH="$2"; shift 2 ;;
        --cf-dir)           CF_DIR="$2"; shift 2 ;;
        --output-dir)       OUTPUT_DIR="$2"; shift 2 ;;
        --gdb-port)         GDB_PORT="$2"; shift 2 ;;
        --vm-manager)       VM_MANAGER="$2"; shift 2 ;;
        --cpus)             NUM_CPUS="$2"; shift 2 ;;
        --extra-cmdline)    EXTRA_KERNEL_CMDLINE="$2"; shift 2 ;;
        --config)           CONFIG_FILE="$2"; shift 2 ;;
        --help|-h)          usage ;;
        *)                  echo "Unknown option: $1"; usage ;;
    esac
done

# ============================================================================
# Load existing config if specified (CLI flags override config values)
# ============================================================================
if [[ -n "$CONFIG_FILE" && -f "$CONFIG_FILE" ]]; then
    echo "[+] Loading config: $CONFIG_FILE"
    # Source the config, but save CLI-provided values first
    _cli_kernel="$KERNEL_PATH"
    _cli_initramfs="$INITRAMFS_PATH"
    _cli_cf_dir="$CF_DIR"
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
    # CLI flags take precedence over config
    [[ -n "$_cli_kernel" ]]    && KERNEL_PATH="$_cli_kernel"
    [[ -n "$_cli_initramfs" ]] && INITRAMFS_PATH="$_cli_initramfs"
    [[ -n "$_cli_cf_dir" ]]    && CF_DIR="$_cli_cf_dir"
fi

# ============================================================================
# Validate
# ============================================================================
if [[ -z "$KERNEL_PATH" ]]; then
    echo "ERROR: --kernel is required"; exit 1
fi
if [[ -z "$CF_DIR" ]]; then
    echo "ERROR: --cf-dir is required"; exit 1
fi

mkdir -p "$OUTPUT_DIR"

# ============================================================================
# Write config file
# ============================================================================
CONF_PATH="$OUTPUT_DIR/cuttlefish_instance.conf"
cat > "$CONF_PATH" <<EOF
# Cuttlefish instance configuration
# Generated by gen_cuttlefish_scripts.sh on $(date -Iseconds)
# Re-run gen_cuttlefish_scripts.sh --config $CONF_PATH to regenerate scripts.

KERNEL_PATH="$KERNEL_PATH"
INITRAMFS_PATH="$INITRAMFS_PATH"
CF_DIR="$CF_DIR"
GDB_PORT=$GDB_PORT
VM_MANAGER="$VM_MANAGER"
EXTRA_KERNEL_CMDLINE="$EXTRA_KERNEL_CMDLINE"
NUM_CPUS=$NUM_CPUS
EOF

echo "[+] Config written: $CONF_PATH"

# ============================================================================
# Generate gdb_run.sh  —  starts Cuttlefish with GDB enabled
# ============================================================================
GDB_RUN="$OUTPUT_DIR/gdb_run.sh"
cat > "$GDB_RUN" <<'SCRIPT_HEAD'
#!/bin/bash
# gdb_run.sh — Start a Cuttlefish instance with GDB enabled
# Generated by gen_cuttlefish_scripts.sh
# Usage: ./gdb_run.sh <instance_number>

if [ -z "$1" ]; then
  echo "Usage: $0 <instance_number>"
  exit 1
fi

INSTANCE_NUM=$1
ADB_PORT=$((6519 + INSTANCE_NUM))

echo "Using adb -s 0.0.0.0:$ADB_PORT"
SCRIPT_HEAD

# Inline the config values
cat >> "$GDB_RUN" <<EOF

# --- Instance configuration ---
KERNEL_PATH="$KERNEL_PATH"
INITRAMFS_PATH="$INITRAMFS_PATH"
CF_DIR="$CF_DIR"
GDB_PORT=$GDB_PORT
VM_MANAGER="$VM_MANAGER"
EXTRA_KERNEL_CMDLINE="$EXTRA_KERNEL_CMDLINE"
NUM_CPUS=$NUM_CPUS
# --- End configuration ---
EOF

cat >> "$GDB_RUN" <<'SCRIPT_BODY'

# Build the kernel cmdline: always include nokaslr for GDB, plus any extras
# Deduplicate nokaslr in case EXTRA_KERNEL_CMDLINE already contains it
GDB_CMDLINE="nokaslr"
if [[ -n "$EXTRA_KERNEL_CMDLINE" ]]; then
    # Strip any existing nokaslr from extra cmdline to avoid duplication
    CLEANED="${EXTRA_KERNEL_CMDLINE//nokaslr/}"
    CLEANED="$(echo "$CLEANED" | xargs)"  # trim whitespace
    if [[ -n "$CLEANED" ]]; then
        GDB_CMDLINE="nokaslr ${CLEANED}"
    fi
fi

# Remove old log file if it exists
rm -f "${CF_DIR}/cuttlefish_runtime.${INSTANCE_NUM}/launcher.log" 2>/dev/null

# NOTE: When using qemu_cli, you must install the QEMU wrapper first!
# Run: sudo ./install_qemu_wrapper.sh
# The wrapper injects GDB, disables MTE, fixes audio, and adds vsock.

# Build launch arguments — mirrors the working run.sh but with GDB
# NOTE: We do NOT pass --gdb_port to launch_cvd because it adds -S (pause)
# to QEMU, which requires an external GDB client to send 'continue' before
# the kernel will boot. Instead, we export GDB_PORT and let the QEMU wrapper
# inject -gdb tcp::<port> WITHOUT -S, so the kernel boots normally with
# the GDB server available for post-boot attachment.
LAUNCH_ARGS=(
    -kernel_path "$KERNEL_PATH"
    -extra_kernel_cmdline "$GDB_CMDLINE"
    -vm_manager "$VM_MANAGER"
    -cpus "$NUM_CPUS"
    -report_anonymous_usage_stats=n
    -noresume
    -daemon
    -start_webrtc=true
    -base_instance_num "${INSTANCE_NUM}"
)

if [[ -n "$INITRAMFS_PATH" ]]; then
    LAUNCH_ARGS+=( -initramfs_path "$INITRAMFS_PATH" )
fi

# Export GDB_PORT so the QEMU wrapper can inject -gdb tcp::<port>
export GDB_PORT

cd "$CF_DIR"
echo "[gdb_run] Launching: HOME=$PWD ./bin/launch_cvd ${LAUNCH_ARGS[*]}"
echo "[gdb_run] GDB_PORT=$GDB_PORT exported for QEMU wrapper"
HOME=$PWD ./bin/launch_cvd "${LAUNCH_ARGS[@]}"

sleep 3  # Ensure output is populated in log before checking

LAUNCHER_LOG="./cuttlefish_runtime/launcher.log"
if [[ ! -f "$LAUNCHER_LOG" ]]; then
    LAUNCHER_LOG="./cuttlefish_runtime.${INSTANCE_NUM}/launcher.log"
fi

if grep -q "VIRTUAL_DEVICE_BOOT_COMPLETED" "$LAUNCHER_LOG" 2>/dev/null; then
    echo "[gdb_run] Boot complete (instance $INSTANCE_NUM)"
    echo "[gdb_run] GDB server available on port $GDB_PORT"
    echo "[gdb_run] Connect with: gdb -ex 'target remote :<GDB_PORT>'"
else
    echo "[gdb_run] Potential boot failure, verify device is up"
    echo "[gdb_run] Check log: $LAUNCHER_LOG"
fi
SCRIPT_BODY

chmod +x "$GDB_RUN"
echo "[+] Generated: $GDB_RUN"

# ============================================================================
# Generate run.sh  —  starts Cuttlefish WITHOUT GDB (mirrors original run.sh)
# ============================================================================
RUN_SH="$OUTPUT_DIR/run.sh"
cat > "$RUN_SH" <<'SCRIPT_HEAD'
#!/bin/bash
# run.sh — Start a Cuttlefish instance WITHOUT GDB (for verification / normal use)
# Generated by gen_cuttlefish_scripts.sh
# Usage: ./run.sh <instance_number>

if [ -z "$1" ]; then
  echo "Usage: $0 <instance_number>"
  exit 1
fi

INSTANCE_NUM=$1
ADB_PORT=$((6519 + INSTANCE_NUM))

echo "Using adb -s 0.0.0.0:$ADB_PORT"
SCRIPT_HEAD

cat >> "$RUN_SH" <<EOF

# --- Instance configuration ---
KERNEL_PATH="$KERNEL_PATH"
INITRAMFS_PATH="$INITRAMFS_PATH"
CF_DIR="$CF_DIR"
VM_MANAGER="$VM_MANAGER"
EXTRA_KERNEL_CMDLINE="$EXTRA_KERNEL_CMDLINE"
NUM_CPUS=$NUM_CPUS
# --- End configuration ---
EOF

cat >> "$RUN_SH" <<'SCRIPT_BODY'

# Remove old log file if it exists
rm -f "${CF_DIR}/cuttlefish_runtime.${INSTANCE_NUM}/launcher.log" 2>/dev/null

# NOTE: When using qemu_cli, you must install the QEMU wrapper first!
# Run: sudo ./install_qemu_wrapper.sh
# Ensure GDB_PORT is NOT set so the wrapper doesn't inject a GDB server
unset GDB_PORT

# Build launch arguments
LAUNCH_ARGS=(
    -kernel_path "$KERNEL_PATH"
    -vm_manager "$VM_MANAGER"
    -cpus "$NUM_CPUS"
    -report_anonymous_usage_stats=n
    -noresume
    -daemon
    -start_webrtc=true
    -base_instance_num "${INSTANCE_NUM}"
)

if [[ -n "$INITRAMFS_PATH" ]]; then
    LAUNCH_ARGS+=( -initramfs_path "$INITRAMFS_PATH" )
fi

if [[ -n "$EXTRA_KERNEL_CMDLINE" ]]; then
    LAUNCH_ARGS+=( -extra_kernel_cmdline "$EXTRA_KERNEL_CMDLINE" )
fi

cd "$CF_DIR"
echo "[run] Launching: HOME=$PWD ./bin/launch_cvd ${LAUNCH_ARGS[*]}"
HOME=$PWD ./bin/launch_cvd "${LAUNCH_ARGS[@]}"

sleep 3  # Ensure output is populated in log before checking

LAUNCHER_LOG="./cuttlefish_runtime/launcher.log"
if [[ ! -f "$LAUNCHER_LOG" ]]; then
    LAUNCHER_LOG="./cuttlefish_runtime.${INSTANCE_NUM}/launcher.log"
fi

if grep -q "VIRTUAL_DEVICE_BOOT_COMPLETED" "$LAUNCHER_LOG" 2>/dev/null; then
    echo "[run] Boot complete (instance $INSTANCE_NUM)"
    # Run app install if apps/ directory exists
    if [[ -d "apps" && -f "apps/install.sh" ]]; then
        cd apps
        ./install.sh "$INSTANCE_NUM" .
    fi
else
    echo "[run] Potential boot failure, verify device is up"
    echo "[run] Check log: $LAUNCHER_LOG"
fi
SCRIPT_BODY

chmod +x "$RUN_SH"
echo "[+] Generated: $RUN_SH"

# ============================================================================
# Generate stop.sh  —  stops a Cuttlefish instance
# ============================================================================
STOP_SH="$OUTPUT_DIR/stop.sh"
cat > "$STOP_SH" <<'SCRIPT_HEAD'
#!/bin/bash
# stop.sh — Stop Cuttlefish instance(s)
# Generated by gen_cuttlefish_scripts.sh
# Usage: ./stop.sh [instance_number]
SCRIPT_HEAD

cat >> "$STOP_SH" <<EOF

# --- Instance configuration ---
CF_DIR="$CF_DIR"
# --- End configuration ---
EOF

cat >> "$STOP_SH" <<'SCRIPT_BODY'

cd "$CF_DIR"
HOME=$PWD ./bin/stop_cvd
SCRIPT_BODY

chmod +x "$STOP_SH"
echo "[+] Generated: $STOP_SH"

# ============================================================================
# Generate install_qemu_wrapper.sh — copy the QEMU wrapper installer for qemu_cli mode
# ============================================================================
if [[ "$VM_MANAGER" == "qemu_cli" ]]; then
    WRAPPER_SH="$OUTPUT_DIR/install_qemu_wrapper.sh"
    # The wrapper installer is a standalone script shipped alongside this one
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    WRAPPER_SRC="$SCRIPT_DIR/install_qemu_wrapper.sh"

    if [[ -f "$WRAPPER_SRC" ]]; then
        cp "$WRAPPER_SRC" "$WRAPPER_SH"
        chmod +x "$WRAPPER_SH"
        echo "[+] Copied: $WRAPPER_SH (from $WRAPPER_SRC)"
    else
        echo "[!] WARNING: install_qemu_wrapper.sh not found at $WRAPPER_SRC"
        echo "[!] You'll need to create/install the QEMU wrapper manually."
        echo "[!] See Cuttlefish_with_gdb.md for instructions."
    fi
fi

# ============================================================================
# Summary
# ============================================================================
echo ""
echo "============================================"
echo "  Cuttlefish instance scripts generated"
echo "============================================"
echo "  Config:    $CONF_PATH"
echo "  gdb_run:   $GDB_RUN   (start with GDB)"
echo "  run:       $RUN_SH    (start without GDB)"
echo "  stop:      $STOP_SH   (stop instance)"
if [[ "$VM_MANAGER" == "qemu_cli" ]]; then
    echo "  wrapper:   $OUTPUT_DIR/install_qemu_wrapper.sh  (QEMU wrapper installer)"
fi
echo ""
if [[ "$VM_MANAGER" == "qemu_cli" ]]; then
    echo "IMPORTANT: Before first use, install the QEMU wrapper on the target host:"
    echo "  sudo ./install_qemu_wrapper.sh"
    echo ""
    echo "This moves the real qemu-system-aarch64 binary and creates a wrapper"
    echo "that fixes MTE, audio, vsock, and injects GDB support."
    echo "See Cuttlefish_with_gdb.md for details."
    echo ""
fi
echo "Usage with syzploit:"
echo "  syzploit pipeline-cuttlefish <BUG_ID> \\"
echo "      --ssh-host <HOST> --instance <N> \\"
echo "      --start-cmd \"cd $OUTPUT_DIR && ./gdb_run.sh <N>\" \\"
echo "      --stop-cmd \"cd $OUTPUT_DIR && ./stop.sh <N>\" \\"
echo "      --exploit-start-cmd \"cd $OUTPUT_DIR && ./run.sh <N>\""
echo ""
echo "To update kernel/initramfs later:"
echo "  ./gen_cuttlefish_scripts.sh --config $CONF_PATH \\"
echo "      --kernel /path/to/new/Image \\"
echo "      --initramfs /path/to/new/initramfs.img"
echo ""
