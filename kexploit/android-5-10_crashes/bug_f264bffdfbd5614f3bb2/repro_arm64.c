// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/capability.h>

#ifndef __NR_bpf
#define __NR_bpf 280
#endif
#ifndef __NR_close_range
#define __NR_close_range 436
#endif
#ifndef __NR_mmap
#define __NR_mmap 222
#endif
#ifndef __NR_openat
#define __NR_openat 56
#endif

static unsigned long long procid;

static void sleep_ms(uint64_t ms)
{
	usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts))
	exit(1);
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void use_temporary_dir(void)
{
	char tmpdir_template[] = "./syzkaller.XXXXXX";
	char* tmpdir = mkdtemp(tmpdir_template);
	if (!tmpdir)
	exit(1);
	if (chmod(tmpdir, 0777))
	exit(1);
	if (chdir(tmpdir))
	exit(1);
}

static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}

#define MAX_FDS 30

static void mount_cgroups(const char* dir, const char** controllers, int count)
{
	if (mkdir(dir, 0777)) {
		return;
	}
	char enabled[128] = {0};
	int i = 0;
	for (; i < count; i++) {
		if (mount("none", dir, "cgroup", 0, controllers[i])) {
			continue;
		}
		umount(dir);
		strcat(enabled, ",");
		strcat(enabled, controllers[i]);
	}
	if (enabled[0] == 0) {
		if (rmdir(dir) && errno != EBUSY)
	exit(1);
		return;
	}
	if (mount("none", dir, "cgroup", 0, enabled + 1)) {
		if (rmdir(dir) && errno != EBUSY)
	exit(1);
	}
	if (chmod(dir, 0777)) {
	}
}

static void mount_cgroups2(const char** controllers, int count)
{
	if (mkdir("/syzcgroup/unified", 0777)) {
		return;
	}
	if (mount("none", "/syzcgroup/unified", "cgroup2", 0, NULL)) {
		if (rmdir("/syzcgroup/unified") && errno != EBUSY)
	exit(1);
		return;
	}
	if (chmod("/syzcgroup/unified", 0777)) {
	}
	int control = open("/syzcgroup/unified/cgroup.subtree_control", O_WRONLY);
	if (control == -1)
		return;
	int i;
	for (i = 0; i < count; i++)
		if (write(control, controllers[i], strlen(controllers[i])) < 0) {
		}
	close(control);
}

static void setup_cgroups()
{
	const char* unified_controllers[] = {"+cpu", "+io", "+pids"};
	const char* net_controllers[] = {"net", "net_prio", "devices", "blkio", "freezer"};
	const char* cpu_controllers[] = {"cpuset", "cpuacct", "hugetlb", "rlimit", "memory"};
	if (mkdir("/syzcgroup", 0777)) {
		return;
	}
	mount_cgroups2(unified_controllers, sizeof(unified_controllers) / sizeof(unified_controllers[0]));
	mount_cgroups("/syzcgroup/net", net_controllers, sizeof(net_controllers) / sizeof(net_controllers[0]));
	mount_cgroups("/syzcgroup/cpu", cpu_controllers, sizeof(cpu_controllers) / sizeof(cpu_controllers[0]));
	write_file("/syzcgroup/cpu/cgroup.clone_children", "1");
	write_file("/syzcgroup/cpu/cpuset.memory_pressure_enabled", "1");
}

static void setup_cgroups_loop()
{
	int pid = getpid();
	char file[128];
	char cgroupdir[64];
	snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
	if (mkdir(cgroupdir, 0777)) {
	}
	snprintf(file, sizeof(file), "%s/pids.max", cgroupdir);
	write_file(file, "32");
	snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
	write_file(file, "%d", pid);
	snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
	if (mkdir(cgroupdir, 0777)) {
	}
	snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
	write_file(file, "%d", pid);
	snprintf(file, sizeof(file), "%s/memory.soft_limit_in_bytes", cgroupdir);
	write_file(file, "%d", 299 << 20);
	snprintf(file, sizeof(file), "%s/memory.limit_in_bytes", cgroupdir);
	write_file(file, "%d", 300 << 20);
	snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
	if (mkdir(cgroupdir, 0777)) {
	}
	snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
	write_file(file, "%d", pid);
}

static void setup_cgroups_test()
{
	char cgroupdir[64];
	snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
	if (symlink(cgroupdir, "./cgroup")) {
	}
	snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
	if (symlink(cgroupdir, "./cgroup.cpu")) {
	}
	snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
	if (symlink(cgroupdir, "./cgroup.net")) {
	}
}

static void initialize_cgroups()
{
	if (mkdir("./syz-tmp/newroot/syzcgroup", 0700))
	exit(1);
	if (mkdir("./syz-tmp/newroot/syzcgroup/unified", 0700))
	exit(1);
	if (mkdir("./syz-tmp/newroot/syzcgroup/cpu", 0700))
	exit(1);
	if (mkdir("./syz-tmp/newroot/syzcgroup/net", 0700))
	exit(1);
	unsigned bind_mount_flags = MS_BIND | MS_REC | MS_PRIVATE;
	if (mount("/syzcgroup/unified", "./syz-tmp/newroot/syzcgroup/unified", NULL, bind_mount_flags, NULL)) {
	}
	if (mount("/syzcgroup/cpu", "./syz-tmp/newroot/syzcgroup/cpu", NULL, bind_mount_flags, NULL)) {
	}
	if (mount("/syzcgroup/net", "./syz-tmp/newroot/syzcgroup/net", NULL, bind_mount_flags, NULL)) {
	}
}

static void setup_gadgetfs();
static void setup_binderfs();
static void setup_fusectl();
static void sandbox_common_mount_tmpfs(void)
{
	write_file("/proc/sys/fs/mount-max", "100000");
	if (mkdir("./syz-tmp", 0777))
	exit(1);
	if (mount("", "./syz-tmp", "tmpfs", 0, NULL))
	exit(1);
	if (mkdir("./syz-tmp/newroot", 0777))
	exit(1);
	if (mkdir("./syz-tmp/newroot/dev", 0700))
	exit(1);
	unsigned bind_mount_flags = MS_BIND | MS_REC | MS_PRIVATE;
	if (mount("/dev", "./syz-tmp/newroot/dev", NULL, bind_mount_flags, NULL))
	exit(1);
	if (mkdir("./syz-tmp/newroot/proc", 0700))
	exit(1);
	if (mount("syz-proc", "./syz-tmp/newroot/proc", "proc", 0, NULL))
	exit(1);
	if (mkdir("./syz-tmp/newroot/selinux", 0700))
	exit(1);
	const char* selinux_path = "./syz-tmp/newroot/selinux";
	if (mount("/selinux", selinux_path, NULL, bind_mount_flags, NULL)) {
		if (errno != ENOENT)
	exit(1);
		if (mount("/sys/fs/selinux", selinux_path, NULL, bind_mount_flags, NULL) && errno != ENOENT)
	exit(1);
	}
	if (mkdir("./syz-tmp/newroot/sys", 0700))
	exit(1);
	if (mount("/sys", "./syz-tmp/newroot/sys", 0, bind_mount_flags, NULL))
	exit(1);
	if (mount("/sys/kernel/debug", "./syz-tmp/newroot/sys/kernel/debug", NULL, bind_mount_flags, NULL) && errno != ENOENT)
	exit(1);
	if (mount("/sys/fs/smackfs", "./syz-tmp/newroot/sys/fs/smackfs", NULL, bind_mount_flags, NULL) && errno != ENOENT)
	exit(1);
	if (mount("/proc/sys/fs/binfmt_misc", "./syz-tmp/newroot/proc/sys/fs/binfmt_misc", NULL, bind_mount_flags, NULL) && errno != ENOENT)
	exit(1);
	if (mkdir("./syz-tmp/newroot/syz-inputs", 0700))
	exit(1);
	if (mount("/syz-inputs", "./syz-tmp/newroot/syz-inputs", NULL, bind_mount_flags | MS_RDONLY, NULL) && errno != ENOENT)
	exit(1);
	initialize_cgroups();
	if (mkdir("./syz-tmp/pivot", 0777))
	exit(1);
	if (syscall(SYS_pivot_root, "./syz-tmp", "./syz-tmp/pivot")) {
		if (chdir("./syz-tmp"))
	exit(1);
	} else {
		if (chdir("/"))
	exit(1);
		if (umount2("./pivot", MNT_DETACH))
	exit(1);
	}
	if (chroot("./newroot"))
	exit(1);
	if (chdir("/"))
	exit(1);
	setup_gadgetfs();
	setup_binderfs();
	setup_fusectl();
}

static void setup_gadgetfs()
{
	if (mkdir("/dev/gadgetfs", 0777)) {
	}
	if (mount("gadgetfs", "/dev/gadgetfs", "gadgetfs", 0, NULL)) {
	}
}

static void setup_fusectl()
{
	if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {
	}
}

static void setup_binderfs()
{
	if (mkdir("/dev/binderfs", 0777)) {
	}
	if (mount("binder", "/dev/binderfs", "binder", 0, NULL)) {
	}
}

static void loop();

static void sandbox_common()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	if (getppid() == 1)
	exit(1);
	struct rlimit rlim;
	rlim.rlim_cur = rlim.rlim_max = (200 << 20);
	setrlimit(RLIMIT_AS, &rlim);
	rlim.rlim_cur = rlim.rlim_max = 32 << 20;
	setrlimit(RLIMIT_MEMLOCK, &rlim);
	rlim.rlim_cur = rlim.rlim_max = 136 << 20;
	setrlimit(RLIMIT_FSIZE, &rlim);
	rlim.rlim_cur = rlim.rlim_max = 1 << 20;
	setrlimit(RLIMIT_STACK, &rlim);
	rlim.rlim_cur = rlim.rlim_max = 128 << 20;
	setrlimit(RLIMIT_CORE, &rlim);
	rlim.rlim_cur = rlim.rlim_max = 256;
	setrlimit(RLIMIT_NOFILE, &rlim);
	if (unshare(CLONE_NEWNS)) {
	}
	if (mount(NULL, "/", NULL, MS_REC | MS_PRIVATE, NULL)) {
	}
	if (unshare(CLONE_NEWIPC)) {
	}
	if (unshare(0x02000000)) {
	}
	if (unshare(CLONE_NEWUTS)) {
	}
	if (unshare(CLONE_SYSVSEM)) {
	}
	typedef struct {
		const char* name;
		const char* value;
	} sysctl_t;
	static const sysctl_t sysctls[] = {
	    {"/proc/sys/kernel/shmmax", "16777216"},
	    {"/proc/sys/kernel/shmall", "536870912"},
	    {"/proc/sys/kernel/shmmni", "1024"},
	    {"/proc/sys/kernel/msgmax", "8192"},
	    {"/proc/sys/kernel/msgmni", "1024"},
	    {"/proc/sys/kernel/msgmnb", "1024"},
	    {"/proc/sys/kernel/sem", "1024 1048576 500 1024"},
	};
	unsigned i;
	for (i = 0; i < sizeof(sysctls) / sizeof(sysctls[0]); i++)
		write_file(sysctls[i].name, sysctls[i].value);
}

static int wait_for_loop(int pid)
{
	if (pid < 0)
	exit(1);
	int status = 0;
	while (waitpid(-1, &status, __WALL) != pid) {
	}
	return WEXITSTATUS(status);
}

static void drop_caps(void)
{
	struct __user_cap_header_struct cap_hdr = {};
	struct __user_cap_data_struct cap_data[2] = {};
	cap_hdr.version = _LINUX_CAPABILITY_VERSION_3;
	cap_hdr.pid = getpid();
	if (syscall(SYS_capget, &cap_hdr, &cap_data))
	exit(1);
	const int drop = (1 << CAP_SYS_PTRACE) | (1 << CAP_SYS_NICE);
	cap_data[0].effective &= ~drop;
	cap_data[0].permitted &= ~drop;
	cap_data[0].inheritable &= ~drop;
	if (syscall(SYS_capset, &cap_hdr, &cap_data))
	exit(1);
}

static int do_sandbox_none(void)
{
	if (unshare(CLONE_NEWPID)) {
	}
	int pid = fork();
	if (pid != 0)
		return wait_for_loop(pid);
	sandbox_common();
	drop_caps();
	if (unshare(CLONE_NEWNET)) {
	}
	write_file("/proc/sys/net/ipv4/ping_group_range", "0 65535");
	sandbox_common_mount_tmpfs();
	loop();
	exit(1);
}

#define FS_IOC_SETFLAGS _IOW('f', 2, long)
static void remove_dir(const char* dir)
{
	int iter = 0;
	DIR* dp = 0;
	const int umount_flags = MNT_FORCE | UMOUNT_NOFOLLOW;

retry:
		while (umount2(dir, umount_flags) == 0) {
		}
	dp = opendir(dir);
	if (dp == NULL) {
		if (errno == EMFILE) {
	exit(1);
		}
	exit(1);
	}
	struct dirent* ep = 0;
	while ((ep = readdir(dp))) {
		if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
			continue;
		char filename[FILENAME_MAX];
		snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
			while (umount2(filename, umount_flags) == 0) {
			}
		struct stat st;
		if (lstat(filename, &st))
	exit(1);
		if (S_ISDIR(st.st_mode)) {
			remove_dir(filename);
			continue;
		}
		int i;
		for (i = 0;; i++) {
			if (unlink(filename) == 0)
				break;
			if (errno == EPERM) {
				int fd = open(filename, O_RDONLY);
				if (fd != -1) {
					long flags = 0;
					if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0) {
					}
					close(fd);
					continue;
				}
			}
			if (errno == EROFS) {
				break;
			}
			if (errno != EBUSY || i > 100)
	exit(1);
				if (umount2(filename, umount_flags))
	exit(1);
		}
	}
	closedir(dp);
	for (int i = 0;; i++) {
		if (rmdir(dir) == 0)
			break;
		if (i < 100) {
			if (errno == EPERM) {
				int fd = open(dir, O_RDONLY);
				if (fd != -1) {
					long flags = 0;
					if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0) {
					}
					close(fd);
					continue;
				}
			}
			if (errno == EROFS) {
				break;
			}
			if (errno == EBUSY) {
					if (umount2(dir, umount_flags))
	exit(1);
				continue;
			}
			if (errno == ENOTEMPTY) {
				if (iter < 100) {
					iter++;
					goto retry;
				}
			}
		}
	exit(1);
	}
}

static int inject_fault(int nth)
{
	int fd;
	fd = open("/proc/thread-self/fail-nth", O_RDWR);
	if (fd == -1)
	exit(1);
	char buf[16];
	sprintf(buf, "%d", nth);
	if (write(fd, buf, strlen(buf)) != (ssize_t)strlen(buf))
	exit(1);
	return fd;
}

static void kill_and_wait(int pid, int* status)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
	for (int i = 0; i < 100; i++) {
		if (waitpid(-1, status, WNOHANG | __WALL) == pid)
			return;
		usleep(1000);
	}
	DIR* dir = opendir("/sys/fs/fuse/connections");
	if (dir) {
		for (;;) {
			struct dirent* ent = readdir(dir);
			if (!ent)
				break;
			if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
				continue;
			char abort[300];
			snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort", ent->d_name);
			int fd = open(abort, O_WRONLY);
			if (fd == -1) {
				continue;
			}
			if (write(fd, abort, 1) < 0) {
			}
			close(fd);
		}
		closedir(dir);
	} else {
	}
	while (waitpid(-1, status, __WALL) != pid) {
	}
}

static void setup_loop()
{
	setup_cgroups_loop();
}

static void setup_test()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	setpgrp();
	setup_cgroups_test();
	write_file("/proc/self/oom_score_adj", "1000");
	if (symlink("/dev/binderfs", "./binderfs")) {
	}
}

static void close_fds()
{
	for (int fd = 3; fd < MAX_FDS; fd++)
		close(fd);
}

static const char* setup_fault()
{
	int fd = open("/proc/self/make-it-fail", O_WRONLY);
	if (fd == -1)
		return "CONFIG_FAULT_INJECTION is not enabled";
	close(fd);
	fd = open("/proc/thread-self/fail-nth", O_WRONLY);
	if (fd == -1)
		return "kernel does not have systematic fault injection support";
	close(fd);
	static struct {
		const char* file;
		const char* val;
		bool fatal;
	} files[] = {
	    {"/sys/kernel/debug/failslab/ignore-gfp-wait", "N", true},
	    {"/sys/kernel/debug/fail_futex/ignore-private", "N", false},
	    {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-highmem", "N", false},
	    {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-wait", "N", false},
	    {"/sys/kernel/debug/fail_page_alloc/min-order", "0", false},
	};
	unsigned i;
	for (i = 0; i < sizeof(files) / sizeof(files[0]); i++) {
		if (!write_file(files[i].file, files[i].val)) {
			if (files[i].fatal)
				return "failed to write fault injection file";
		}
	}
	return NULL;
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
	setup_loop();
	int iter = 0;
	for (;; iter++) {
		char cwdbuf[32];
		sprintf(cwdbuf, "./%d", iter);
		if (mkdir(cwdbuf, 0777))
	exit(1);
		int pid = fork();
		if (pid < 0)
	exit(1);
		if (pid == 0) {
			if (chdir(cwdbuf))
	exit(1);
			setup_test();
			execute_one();
			close_fds();
			exit(0);
		}
		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			sleep_ms(10);
			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
				break;
			if (current_time_ms() - start < 5000)
				continue;
			kill_and_wait(pid, &status);
			break;
		}
		remove_dir(cwdbuf);
	}
}

uint64_t r[4] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};

void execute_one(void)
{
		intptr_t res = 0;
	if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {}
*(uint32_t*)0x20000080 = 0;
*(uint32_t*)0x20000084 = -1;
*(uint32_t*)0x20000088 = 0;
*(uint32_t*)0x2000008c = 7;
*(uint64_t*)0x20000090 = 0x20000000;
memcpy((void*)0x20000000, "cgroup\000", 7);
	syscall(__NR_bpf, /*cmd=*/0x14ul, /*arg=*/0x20000080ul, /*size=*/0x30ul);
	res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul, /*file=*/0x20000000ul, /*flags=*/0x200002, /*mode=*/0);
	if (res != -1)
		r[0] = res;
	res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul, /*file=*/0x20000000ul, /*flags=*/0x200002, /*mode=*/0);
	if (res != -1)
		r[1] = res;
*(uint32_t*)0x20000080 = 9;
*(uint32_t*)0x20000084 = 4;
*(uint64_t*)0x20000088 = 0x200003c0;
memcpy((void*)0x200003c0, "\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x61\x12\x00\x00\x00\x00\x00\x00\x95\x00\x00\x00\x00\x00\x00\x00\x51\xfa\x78\x24\xc7\x41\x86\xdc\x02\xec\x06\x96\xc3\x7b\x64\xe3\xb2\x4d\xa3\x18\x01\x00\x00\x00\x05\x16\x5c\x0f\x63\xcd\xc2\xe8\x28\x18\x25\x49\x50\xee\x03\x56\x8b\x88\x09\xa1\xf0\x4c\x7c\x47\x50\xea\xbf\xaf\xcb\x95\x31\xb3\x1e\x6a\x86\x82\x7d\x10\x10\xc5\xa9\x09\xab\x98\xe0\x0e\x19\x64\x4a\x88\xe9\x5b\xa2\x6d\x1c\x9e\xec\xdd\xb2\xd1\x1c\x54\x14\x18\xce\xeb\x29\xb9\xb6\x82\x9c\x6e\x43\x38\x22\xbd\xb3\xcc\x85\x24\x4a\xab\x66\xc1\xaa\xe1\x31\x4d\x73\x81\xfc\xfe\xb9\x70\xbe\xa6\x72\xcf\x1e\x92\x6f\x6a\x51\x47\x93\x43\x14\x46\x48\xa0\x7a\x97\x5b\xd8\x9d\xc3\x98\x71\x23\x76\x61\x0f\xaa\x54\xf1\x24\x95\xb4\x65\x9b\xe8\x67\x30\x86\xf6\xf3\x54\x32\x05\xd4\xbc\x4c\xe0\x5b\x8b\x96\x11\x03\x67\x3d\xff\x7f\x15\x80\x52\xe6\x2b\xfb\xdc\xdd\xde\x69\x85\xf3\xf1\xac\x5d\x9a\x94\xcc\x53\x20\xf0\x5f\xd2\x41\x08\xd8\x36\x3d\x44\xfc\xd0\xf8\xf3\x64\x78\x99\x76\x2a\x17\x28\x2a\x19\x14\x45\x2d\x11\xf5\x57\x4f\x90\x35\xf2\xb5\xf7\x03\xe5\xbe\x7e\x4a\xcf\x8b\x78\xc2\x83\x4a\xe5\x80\x5f\xff\xee\x38\xa9\xa0\x03\x3d\x52\x0b\xcf\x6b\x08\xed\xe5\x08\x99\xd4\xb9\xbd\xf8\x5c\x71\xc5\xde\x25\x03\xda\xb3\x58\xf4\x2a\x26\x24\xc7\xda\xa9\xed\x44\x03\x9a\xab\x46\x41\x94\x96\x36\x2e\x54\xcf\xad\x05\xa0\x00\x4a\xc7\x1a\x00\x3d\x7b\x85\xd0\x71\x91\xbe\xd4\xe5\xa8\x90\x82\x63\x72\x21\x41\x46\xf7\xed\x56\x99\x85\x43\x9b\xaa\x35\x5c\x27\x66\xdd\x05\x6f\x5d\x79\xe4\x54\xf3\xd8\x73\x1f\x5e\x7a\x23\x7b\xc0\x6d\x03\x5a\x8d\x60\x1f\x21\x74\x6d\x88\x64\x19\xf3\x8b\x34\xa4\x95\x04\x00\x00\x00\x00\x71\xc2\xf0\xcc\xe8\xc9\x3c\xc1\x7e\x9a\xfa\x31\x4f\xcb\x2b\xa1\x5d\x64\x6c\x66\xb0\xf6\x50\x21\x82\x9f\x87\xd9\x88\xc9\xfb\xd2\xb9\xd9\xb4\xe2\xd7\x17\x53\xb1\x54\x9f\xa7\x34\xf0\xb2\xe5\x6d\xbd\x21\xed\x2e\x09\xd0\xcd\xda\xd7\x21\x97\x16\x37\xf3\x84\xee\xd3\x03\x45\x97\x9d\xb9\xc9\x3e\x1c\x52\xf4\x2c\xad\x0e\xd0\x9c\x39\x5d\xc6\xe9\x70\x36\x60\xfe\xfa\x1c\x80\xf4\x67\x36\x7c\x00\x6f\x25\xca\xf0\xcb\xce\xfd\x13\xd6\x88\x39\x89\x3e\x39\xc5\x88\xeb\x03\x29\x05\xf9\x1c\xaf\xa4\x99\x6d\xbf\x0c\x9b\xe9\x65\x4d\xb0\x5f\xb9\x18\x08\x6c\xc8\x22\x8d\x02\xa3\x09\x2c\x08\x30\xb8\xf5\x87\xa5\x62\x45\x15\x29\x8b\x2d\x4e\xb2\xbd\xe6\xf9\xa2\xeb\x83\xd5\x3f\x71\x0c\x49\x0e\xcd\x08\x5d\x28\x11\xa7\x55\x5c\x53\x8c\xff\xff\xff\x7f\x00\x00\x00\x00\xdd\x87\x22\x44\xbf\xa6\x47\x8e\xb9\x6b\x07\x9c\x27\x7e\x29\x10\xb7\xcc\xdc\x3d\x67\x26\xd3\x4a\xa6\x52\x78\xc5\x49\xe2\xab\xb5\x49\xad\x34\x48\x84\x28\x91\x30\xbc\x71\xce\xe2\xb7\xde\x62\xbf\x48\x12\x9a\xe1\xaf\x05\x2a\x2d\x46\xa6\x16\x5e\xb0\x94\x4d\xac\x72\x65\xf1\xf4\x25\x73\x5a\xcf\x63\x77\x79\x39\x46\xb3\x22\x9e\x86\x1d\x8e\xa4\x98\x06\xb3\xb5\x33\x34\x5d\x36\xec\xef\x9d\xf7\xd4\x29\x5f\x6b\x00\x00\x00\x00\x00\x00\xf3\x37\xb1\xce\xb2\xd8\xa6\x5d\xcd\xcd\x89\x5d\x7b\xa3\x70\x98\xd2\x59\x3f\xda\xae\xf4\x45\xaf\x5b\xee\x02\x01\x9c\x00\x00\x00\x99\xb1\x3e\xcd\xa2\xa5\xb3\x7d\xe0", 732);
*(uint64_t*)0x20000090 = 0x20000100;
memcpy((void*)0x20000100, "GPL\000", 4);
*(uint32_t*)0x20000098 = 0;
*(uint32_t*)0x2000009c = 0;
*(uint64_t*)0x200000a0 = 0;
*(uint32_t*)0x200000a8 = 0;
*(uint32_t*)0x200000ac = 0;
memset((void*)0x200000b0, 0, 16);
*(uint32_t*)0x200000c0 = 0;
*(uint32_t*)0x200000c4 = 0;
*(uint32_t*)0x200000c8 = -1;
*(uint32_t*)0x200000cc = 8;
*(uint64_t*)0x200000d0 = 0;
*(uint32_t*)0x200000d8 = 0;
*(uint32_t*)0x200000dc = 0x10;
*(uint64_t*)0x200000e0 = 0;
*(uint32_t*)0x200000e8 = 0;
*(uint32_t*)0x200000ec = 0;
*(uint32_t*)0x200000f0 = -1;
*(uint32_t*)0x200000f4 = 0;
*(uint64_t*)0x200000f8 = 0;
*(uint64_t*)0x20000100 = 0;
*(uint32_t*)0x20000108 = 0x10;
*(uint32_t*)0x2000010c = 0;
*(uint32_t*)0x20000110 = 0;
	res = syscall(__NR_bpf, /*cmd=*/5ul, /*arg=*/0x20000080ul, /*size=*/0x70ul);
	if (res != -1)
		r[2] = res;
*(uint32_t*)0x20000340 = r[2];
*(uint32_t*)0x20000344 = r[1];
*(uint32_t*)0x20000348 = 2;
*(uint32_t*)0x2000034c = 0;
*(uint32_t*)0x20000350 = 0;
	syscall(__NR_bpf, /*cmd=*/0x1cul, /*arg=*/0x20000340ul, /*size=*/0x10ul);
*(uint32_t*)0x20000080 = 9;
*(uint32_t*)0x20000084 = 4;
*(uint64_t*)0x20000088 = 0x200001c0;
memcpy((void*)0x200001c0, "\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x61\x12\x00\x00\x00\x00\x00\x00\x95\x00\x00\x00\x00\x00\x00\x00\x01\xc4\x86\x39\x02\x41\x7d\x6f\x49\x90\x53\x3b\x81\x54\x09\x47\x6a\x54\xdc\x97\xbe\x2d\x4c\x69\x53\x33\x36\x5b\x85\xff\xba\x67\x06\xcb\x80\xbb\x3c\x01\xf1\xbc\x42\x69\x8d\x29\x20\xc9\x7c\x52\xce\x26\x27\xa5\xba\xdb\x9a\xce\x8f\x8f\xc6\xb3\x15\xe8\x16\x1d\x00\x2e\x18\x10\x65\x36\x5f\x4e\xae\x98\xc4\xdf\x8f\x02\x75\x33\xa7\xd2\x07\xf1\xaa\xa4\xe5\xfe\x47\xdf\x06\xc3\xdc\x1c\x65\x17\x6c\xab\x75\x47\x22\x37\x0c\xca\x9f\x5b\xf0\x75\x04\x37\xef\xff\x6f\xdb\xd5\xf0\x00\x51\x2d\xf2\xf9\x5e\x73\x60\xba\x71\xee\x73\x70\x36\xb3\xed\x5a\x1e\xc3\x05\xb8\xd2\x05\x2f\xcd\x20\x1a\x0c\x35\x1a\x15\x32\x01\x19\x87\x21\xed\x56\xcb\x03\x9a\x9c\x1d\xad\xac\x06\x6d\xc7\x06\xa3\xd5\x7b\x33\x66\xef\x36\x15\xed\xa5\x10\xae\xbf\x58\x52\xc9\x8e\xb6\x8d\xf7\xad\x44\xf2\xae\x7e\x38\xd9\x65\xad\x9b\x82\xa4\x37\x0c\xbb\x38\x5b\xd9\xb3\xac\x48\x0b\xcc\x5e\xa0\x6f\x1e\x1b\xa9\xd6\xd2\xd5\xee\xef\xba\x69\xe6\xa7\x87\x59\x2d\x8c\x09\xbc\x7d\x84\x12\x2f\x1e\x59\xbf\x09\x28\x62", 271);
*(uint64_t*)0x20000090 = 0x20000100;
memcpy((void*)0x20000100, "GPL\000", 4);
*(uint32_t*)0x20000098 = 0;
*(uint32_t*)0x2000009c = 0;
*(uint64_t*)0x200000a0 = 0;
*(uint32_t*)0x200000a8 = 0;
*(uint32_t*)0x200000ac = 0;
memset((void*)0x200000b0, 0, 16);
*(uint32_t*)0x200000c0 = 0;
*(uint32_t*)0x200000c4 = 0;
*(uint32_t*)0x200000c8 = -1;
*(uint32_t*)0x200000cc = 8;
*(uint64_t*)0x200000d0 = 0;
*(uint32_t*)0x200000d8 = 0;
*(uint32_t*)0x200000dc = 0x10;
*(uint64_t*)0x200000e0 = 0;
*(uint32_t*)0x200000e8 = 0;
*(uint32_t*)0x200000ec = 0;
*(uint32_t*)0x200000f0 = -1;
*(uint32_t*)0x200000f4 = 0;
*(uint64_t*)0x200000f8 = 0;
*(uint64_t*)0x20000100 = 0;
*(uint32_t*)0x20000108 = 0x10;
*(uint32_t*)0x2000010c = 0;
*(uint32_t*)0x20000110 = 0;
	res = syscall(__NR_bpf, /*cmd=*/5ul, /*arg=*/0x20000080ul, /*size=*/0x70ul);
	if (res != -1)
		r[3] = res;
*(uint32_t*)0x20000100 = r[3];
*(uint32_t*)0x20000104 = r[0];
*(uint32_t*)0x20000108 = 2;
*(uint32_t*)0x2000010c = 0;
*(uint32_t*)0x20000110 = 0;
	syscall(__NR_bpf, /*cmd=*/0x1cul, /*arg=*/0x20000100ul, /*size=*/0x10ul);
	inject_fault(1);
	syscall(__NR_close_range, /*fd=*/r[0], /*max_fd=*/r[3], /*flags=*/0ul);

}
int main(void)
{
		syscall(__NR_mmap, /*addr=*/0x1ffff000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x20000000ul, /*len=*/0x1000000ul, /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/7ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x21000000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/(intptr_t)-1, /*offset=*/0ul);
	setup_cgroups();
	const char* reason;
	(void)reason;
	if ((reason = setup_fault()))
		printf("the reproducer may not work as expected: fault injection setup failed: %s\n", reason);
			use_temporary_dir();
			do_sandbox_none();
	return 0;
}
