from typing import List, Optional
import re

from kernel_image import KernelAdapter
from parse import LexedCode, Ident, Delim, Literal, is_delim, Token

RewriteValue = int | str

def parse_rewrite_value(token: Token) -> Optional[RewriteValue]:
    match token:
        case Literal(_, value):
            return value
        case _:
            return None

def parse_rewrite_values(tokens: List[Token]) -> Optional[List[RewriteValue]]:
    values = [parse_rewrite_value(token) for token in tokens]

    if any(value is None for value in values):
        return None
    else:
        return values


def rewrite_value_to_string(value: RewriteValue) -> str:
    match value:
        case int(x):
            return hex(x)
        case str(x):
            return f'"{x}"'

def rewrite_values_to_string(values: List[RewriteValue]) -> str:
    return ', '.join(rewrite_value_to_string(value) for value in values)

class RewriteRule:
    """
    A rewrite rule looks for a function call in C code and it replaces arguments based on current arguments.

    This uses regex based approach, as creating diffs based on parsing is problematic due to preprocessor
    (unless parser can parese preprocess direcives as well, but this requires modifying C parsing library).
    """

    def rule_name(self) -> str:
        """Returns name of rewrite rule function"""
        pass

    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        """Applies the rewrite"""
        pass


class AddressRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return "__kexploit_kernel_address"
    
    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        match args:
            case [int(offset)]:
                return [self.adapter.translate_address(offset)]

class OffsetRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return "__kexploit_kernel_offset"
    
    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        match args:
            case [int(offset)]:
                return [self.adapter.translate_offset(offset)]

def gen_rewrite_rules(adapter: KernelAdapter) -> List[RewriteRule]:
    return [
        AddressRewrite(adapter),
        OffsetRewrite(adapter),
    ]

def is_valid_ident_char(c: str) -> bool:
    assert len(c) == 1
    return c.isalnum() or c == '_'

def apply_rewrites(rules: List[RewriteRule], input: LexedCode) -> str:
    rule_map = { rule.rule_name(): rule for rule in rules }

    output = ""
    last_index = 0
    token_index = 0

    while token_index < len(input.tokens):
        token = input.tokens[token_index]
        # put all characters from last processed token end to this tokens end into output
        output += input.code[last_index:token.span.end_index]
        last_index = token.span.end_index
        token_index += 1

        # need at least ident and 2 delims
        if token_index + 3 <= len(input.tokens):
            match token, input.tokens[token_index]:
                case Ident(_, name), Delim(_, delim='(') if name in rule_map:
                    # skip paren
                    token_index += 1
                    arg_index = token_index

                    # find index of closing paren
                    end_index = next((i + arg_index for i, token in enumerate(input.tokens[arg_index:]) if is_delim(token, ')')), None)
                    if end_index is None:
                        continue

                    args = parse_rewrite_values(input.tokens[arg_index:end_index])
                    result = rule_map[name].rewrite(args)

                    output += f'({rewrite_values_to_string(result)})'

                    token_index = end_index + 1
                    last_index = input.tokens[end_index].span.end_index
    
    # append remaining characters
    output += input.code[last_index:]

    return output




    current_ident = ""
    continue_ident = False

    i = 0
    while i < len(input):
        c = input[i]
        output += c

        if is_valid_ident_char(c):
            if continue_ident:
                current_ident += c
            else:
                # new ident encountered
                current_ident = c
        elif c == '(' and current_ident in rule_map:
            # start of rewrite
            try:
                end_index = input[i:].index(')') + i
            except:
                # ignore rule with non terminated paren
                i += 1
                continue

            rule_input = input[i + 1:end_index]
            args = [parse_rewrite_value(arg.strip()) for arg in rule_input.split(',')]

            new_args = rule_map[current_ident].rewrite(args)

            output += rewrite_values_to_string(new_args)
            output += ')'
            i = end_index
        elif not c.isspace():
            # reset current identifier if non whitespace character is encountered
            current_ident = ""

        continue_ident = is_valid_ident_char(c)

        i += 1
    
    return output
