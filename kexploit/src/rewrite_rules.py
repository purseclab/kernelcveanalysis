from typing import List, Optional
import re

from kernel_image import KernelAdapter

RewriteValue = int | str

def parse_rewrite_value(value: str) -> Optional[RewriteValue]:
    # first check if value is string
    if len(value) >= 2 and value[0] == '"' and value[-1] == '"':
        return value[1:-1]

    try:
        return int(value, 0)
    except:
        return None

def rewrite_values_to_string(values: List[RewriteValue]) -> str:
    return ','.join(str(value) for value in values)

class RewriteRule:
    """
    A rewrite rule looks for a function call in C code and it replaces arguments based on current arguments.

    This uses regex based approach, as creating diffs based on parsing is problematic due to preprocessor
    (unless parser can parese preprocess direcives as well, but this requires modifying C parsing library).
    """

    def rule_name(self) -> str:
        """Returns name of rewrite rule function"""
        pass

    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        """Applies the rewrite"""
        pass


class AddressRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return "__kexploit_kernel_address"
    
    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        match args:
            case [int(offset)]:
                return [self.adapter.translate_address(offset)]

class OffsetRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return "__kexploit_kernel_offset"
    
    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        match args:
            case [int(offset)]:
                return [self.adapter.translate_offset(offset)]

def gen_rewrite_rules(adapter: KernelAdapter) -> List[RewriteRule]:
    return [
        AddressRewrite(adapter),
        OffsetRewrite(adapter),
    ]

def is_valid_ident_char(c: str) -> bool:
    assert len(c) == 1
    return c.isalnum() or c == '_'

def apply_rewrites(rules: List[RewriteRule], input: str) -> str:
    rule_map = { rule.rule_name(): rule for rule in rules }

    output = ""
    current_ident = ""
    continue_ident = False

    i = 0
    while i < len(input):
        c = input[i]
        output += c

        print(c)
        print(current_ident)
        print(rule_map)

        if is_valid_ident_char(c):
            if continue_ident:
                current_ident += c
            else:
                # new ident encountered
                current_ident = c
        elif c == '(' and current_ident in rule_map:
            print('rewrite')
            print(current_ident)
            # start of rewrite
            try:
                end_index = input[i:].index(')') + i
            except:
                # ignore rule with non terminated paren
                i += 1
                continue

            rule_input = input[i + 1:end_index]
            args = [parse_rewrite_value(arg.strip()) for arg in rule_input.split(',')]

            new_args = rule_map[current_ident].rewrite(args)

            output += rewrite_values_to_string(new_args)
            output += ')'
            i = end_index + 1
        elif not c.isspace():
            # reset current identifier if non whitespace character is encountered
            current_ident = ""

        continue_ident = is_valid_ident_char(c)

        i += 1
    
    return output
