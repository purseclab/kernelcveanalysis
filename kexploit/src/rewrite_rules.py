from typing import List, Optional, Tuple
import re

from kernel_image import KernelAdapter
from parse import LexedCode, Ident, Delim, Literal, is_delim, Token

RewriteValue = int | str

def parse_rewrite_value(token: Token) -> Optional[RewriteValue]:
    match token:
        case Literal(_, value):
            return value
        case _:
            return None

def parse_rewrite_values(tokens: List[Token]) -> Optional[List[RewriteValue]]:
    values = [parse_rewrite_value(token) for token in tokens]

    if any(value is None for value in values):
        return None
    else:
        return values


def rewrite_value_to_string(value: RewriteValue) -> str:
    match value:
        case int(x):
            return hex(x)
        case str(x):
            return f'"{x}"'

def rewrite_values_to_string(values: List[RewriteValue]) -> str:
    return ', '.join(rewrite_value_to_string(value) for value in values)

class RewriteRule:
    """
    A rewrite rule looks for a function call in C code and it replaces arguments based on current arguments.

    This uses regex based approach, as creating diffs based on parsing is problematic due to preprocessor
    (unless parser can parese preprocess direcives as well, but this requires modifying C parsing library).
    """

    def rule_name(self) -> str:
        """Returns name of rewrite rule function"""
        pass

    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        """Applies the rewrite"""
        pass


class AddressRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return "__kexploit_kernel_address"
    
    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        match args:
            case [int(offset)]:
                return [self.adapter.translate_address(offset)]

class OffsetRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return "__kexploit_kernel_offset"
    
    def rewrite(self, args: List[RewriteValue]) -> List[RewriteValue]:
        match args:
            case [int(offset)]:
                return [self.adapter.translate_offset(offset)]

def gen_rewrite_rules(adapter: KernelAdapter) -> List[RewriteRule]:
    return [
        AddressRewrite(adapter),
        OffsetRewrite(adapter),
    ]

def is_valid_ident_char(c: str) -> bool:
    assert len(c) == 1
    return c.isalnum() or c == '_'

def apply_rewrites(rules: List[RewriteRule], input: LexedCode) -> str:
    rule_map = { rule.rule_name(): rule for rule in rules }

    def rewrite(tokens: List[Token], token_index: int) -> Optional[Tuple[int, str]]:
        # need at least ident and 2 delims
        if token_index + 3 <= len(tokens):
            match tokens[token_index], tokens[token_index + 1]:
                case Ident(_, name), Delim(_, delim='(') if name in rule_map:
                    # skip paren and ident
                    arg_index = token_index + 2

                    # find index of closing paren
                    end_index = next((i + arg_index for i, token in enumerate(tokens[arg_index:]) if is_delim(token, ')')), None)
                    if end_index is None:
                        return None

                    args = parse_rewrite_values(tokens[arg_index:end_index])
                    result = rule_map[name].rewrite(args)

                    output = f'{name}({rewrite_values_to_string(result)})'
                    return end_index - token_index + 1, output
        
        return None
    
    return input.replace_tokens(rewrite)