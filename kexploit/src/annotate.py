from pathlib import Path
from typing import Optional
from difflib import unified_diff
import os
from dataclasses import dataclass

from openai import OpenAI
from pydantic import BaseModel

from parse import Literal, Token
from rewrite_rules import is_annotated, KEXPLOIT_ADDRESS, KEXPLOIT_OFFSET, KEXPLOIT_STRUCT_OFFSET
from parse import lex, LexedCode

SYSTEM_PROMPT = '''
You are a model which analyses exploits for the linux kernel. These exploits depend on addresses, offsets, and struct field offsets in the linux kernel to work.
You should find all these addresses, and output JSON data containing a list of these addresses, offsets, and struct field offsets?

Addresses are 64 bit absolute virtual kernel addresses, typically with many leading 0xffffff bits, and have a type of `address`.
Offsets are offsets relative to the base of the kernel executable, and have a type of `offset`.
Struct field offsets are the offset from the start of a struct to a field in the struct. They are typically much smaller then offsets relative to the kernel base, typically less than 2048.
Struct field offsets have a type of `struct_offset`.

Report addresses and offsets exactly as they appear in the code. Don't try to compute offsets from the addresses present in the code, just report the address constants in the JSON data.

For example, for the given code:
```
#define A 0xffffffc010020f58
#define B_OFFSET 0x120

int main() {
    size_t c = 0xffffffc092004cd0;
    size_t d_offset = 0x34980;
    size_t z_offset = A - 0xffffffc088084000;
}
```

The corresponding JSON data is:
```
{
    "data": [
        {
            "type": "address",
            "value": "0xffffffc010020f58"
        },
        {
            "type": "struct_offset",
            "value": "0x120"
        },
        {
            "type": "address",
            "value": "0xffffffc092004cd0"
        },
        {
            "type": "offset",
            "value": "0x34980"
        },
        {
            "type": "address",
            "value": "0xffffffc088084000"
        }
    ]
}
```

You will be given C code from several files, and should output only the JSON data.
'''
MODEL = 'gpt-4.1-mini'

class AnnotateContext:
    files: dict[str, LexedCode]

    def __init__(self):
        # mapping from filename to file lexed file content
        self.files = {}

class KernelOffset(BaseModel):
    file: str
    # either `address`, `offset`, or `struct_offset`
    type: str
    value: str

class AnnotationData(BaseModel):
    data: list[KernelOffset]

def get_chatgpt_completions(context: AnnotateContext) -> dict[tuple[str, int], str]:
    prompt = ''
    for file_name, file_data in context.files.items():
        prompt += f'File: {os.path.basename(file_name)}\n`{file_data.code}`\n'
    
    # TODO: use json schema
    response = OpenAI().responses.parse(
        model=MODEL,
        instructions=SYSTEM_PROMPT,
        input=prompt,
        text_format=AnnotationData,
    )

    annotation_map = {}
    for offset in response.output_parsed.data:
        try:
            n = int(offset.value, 0)
        except:
            # only consider things chatgpt reports which are just integer constants for now
            continue

        match offset.type:
            case 'address':
                annotation = KEXPLOIT_ADDRESS
            case 'offset':
                annotation = KEXPLOIT_OFFSET
            case 'struct_offset':
                annotation = KEXPLOIT_STRUCT_OFFSET
            case _:
                # if invalid type ignore
                print(f'Warning: invalid offset type received from LLM: {offset.type}')
                continue

        annotation_map[(offset.file, n)] = annotation
    
    return annotation_map

def annotate(exploit_files: list[Path], apply: bool):
    # def do_annotate(tokens: list[Token], index: int) -> Optional[tuple[int, str]]:
    #     match tokens[index].data:
    #         case Literal(int(address)):
    #             # don't annotate if already annotated
    #             if is_annotated(tokens, index):
    #                 return None
                
    #             # TODO: use different kernel address base for x86
    #             if address & 0xffffffc000000000 == 0xffffffc000000000:
    #                 return 1, f'__kexploit_kernel_address({hex(address)})'
        
    #     return None

    diff = ''
    context = AnnotateContext()

    for file in exploit_files:
        # if kexploit.h is globbed in exploit_files, ignore
        if os.path.basename(file) == 'kexploit.h':
            continue

        with open(file, 'r') as f:
            exploit_code = f.read()

        context.files[file] = lex(file, exploit_code)
    
    annotation_map = get_chatgpt_completions(context)

    for lexed_file in context.files.values():
        def do_annotate(tokens: list[Token], index: int) -> Optional[tuple[int, str]]:
            match tokens[index].data:
                case Literal(int(value)):
                    # don't annotate if already annotated
                    if is_annotated(tokens, index):
                        return None
                    
                    # TODO: use different kernel address base for x86
                    if value & 0xffffffc000000000 == 0xffffffc000000000:
                        return 1, f'__kexploit_kernel_address({hex(value)})'

                    annotation = annotation_map.get((os.path.basename(lexed_file.filename), value))
                    if annotation is None:
                        return None
                    
                    return 1, f'{annotation}({hex(value)})'

            return None
        
        annotated_code = lexed_file.replace_tokens(do_annotate)

        # diff just for user
        for diff_line in unified_diff(
            lexed_file.code.split('\n'),
            annotated_code.split('\n'),
            fromfile=str(lexed_file.filename),
            tofile=str(lexed_file.filename),
            lineterm='',
        ):
            diff += diff_line + '\n'

        if apply:
            with open(lexed_file.filename, 'w') as f:
                f.write(annotated_code)
    
    print(diff)