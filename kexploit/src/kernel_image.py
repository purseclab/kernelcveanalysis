from dataclasses import dataclass
from pathlib import Path
from typing import Self, Mapping, List
import bisect

from elftools.elf.elffile import ELFFile
from elftools.elf.sections import SymbolTableSection

@dataclass
class Symbol:
    name: str
    address: int
    offset: int

@dataclass
class KernelImage:
    # elf_data: ELFFile
    # symbol_table: SymbolTableSection
    symbol_index_map: Mapping[str, int]
    # sorted list of symbols
    symbols: List[Symbol]
    kernel_base: int

    def from_file(file: Path) -> Self:
        elf_file = ELFFile.load_from_path(file)
        symbol_table = elf_file.get_section_by_name(".symtab")
        # kernel_base = symbol_table.get_symbol_by_name("_head")[0]['st_value']

        symbols = [
            # fill out offset later
            Symbol(symbol.name, symbol['st_value'], 0) for symbol in symbol_table.iter_symbols()
        ]
        symbols.sort(key = lambda symbol: symbol.address)
        symbol_index_map = { symbol.name: i for i, symbol in enumerate(symbols) }

        kernel_base = symbols[symbol_index_map["_head"]].address
        for symbol in symbols:
            symbol.offset = symbol.address - kernel_base

        return KernelImage(
            symbol_index_map=symbol_index_map,
            symbols=symbols,
            kernel_base=kernel_base,
        )

    def get_symbol(self, name: str) -> Symbol:
        return self.symbols[self.symbol_index_map[name]]

    def find_previous_symbol_offset(self, offset: int) -> Symbol:
        index = bisect.bisect_left(self.symbols, offset, key = lambda symbol: symbol.offset)
        return self.symbols[index]
    
    def find_previous_symbol_absolute(self, address: int) -> Symbol:
        return self.find_previous_symbol_offset(address - self.kernel_base)

class KernelAdapter:
    def __init__(self, src_file: Path, dst_file: Path):
        # original image exploit was made for
        self.src_image = KernelImage.from_file(src_file)

        # new kernel image to adapt exploit to
        self.dst_image = KernelImage.from_file(dst_file)
    
    # TODO: translate references to code differently
    # look for similar instruction sequences instead
    def translate_offset(self, offset: int) -> int:
        symbol = self.src_image.find_previous_symbol_offset(offset)
        offset_diff = offset - symbol.offset

        new_symbol = self.dst_image.get_symbol(symbol.name)
        return new_symbol.offset + offset_diff
    
    def translate_address(self, address: int) -> int:
        return self.translate_offset(address - self.src_image.kernel_base) + self.dst_image.kernel_base