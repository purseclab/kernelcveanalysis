# Pulls buts from syzkaller syzbot and filters for interesting looking ones

from typing import Optional, Self, Any
from dataclasses import dataclass
from pathlib import Path
import os
import sqlite3
from datetime import datetime
import time
import json
import subprocess

from bs4 import BeautifulSoup, Tag
import requests

def get_tag_string(tag: Tag) -> str:
    return ' '.join(tag.find_all(string=True)).strip()

def parse_table_row(row: Tag, header=False) -> list[Tag]:
    assert row.name == 'tr'
    look_tag = 'th' if header else 'td'
    return row.find_all(look_tag)

def parse_table_row_strings(row: Tag, header=False) -> list[str]:
    return [get_tag_string(entry.find(name=True)) for entry in parse_table_row(row, header)]

def parse_table(table: Tag) -> list[dict[str, Tag]]:
    assert table.name == 'table'
    header_values = ['_'.join(value.lower().split()) for value in parse_table_row_strings(table.thead.tr, header=True)]
    
    output = []
    for row in table.tbody.find_all(name='tr'):
        row = parse_table_row(row)
        row_data = {}

        for header, row_value in zip(header_values, row):
            row_data[header] = row_value
        
        output.append(row_data)
            
    return output

# find a table based on if the name in the name in the caption element contains `name_part`
def find_table_by_name(html: BeautifulSoup, name_part: str) -> Tag:
    for caption in html.find_all('caption'):
        if name_part.lower() in get_tag_string(caption).lower():
            parent = caption.parent
            if parent.name == 'table':
                return parent

    return None

def path_to_syzkall_url(url_path: str) -> str:
    return f'https://syzkaller.appspot.com/{url_path}'

def get_syzkall_html(url_path: str) -> BeautifulSoup:
    response = requests.get(path_to_syzkall_url(url_path))
    return BeautifulSoup(response.text, 'html.parser')

# filters for bugs which are potentially exploitable
def filter_bugs(data: list[dict[str, Tag]]) -> list[dict[str, Tag]]:
    # we are only interested in bugs with a reproduction
    data = [row for row in data if get_tag_string(row['repro']) == 'C']
    
    # look for bugs that look exploitable
    # for now that just means is KASAN in the title, since that is typically memory unsafety issue
    data = [row for row in data if 'KASAN' in get_tag_string(row['title'])]
    return data

# uses syz_prog2c tool to translate syzkaller DSL to C code
def syz_to_c(syz_path: Path, options: dict[str, Any]) -> str:
    # features which can be enabled / disabled
    features = set([
        'binfmt_misc',
        'cgroups',
        'close_fds',
        'devlink_pci',
        'ieee802154',
        'net_dev',
        'net_reset',
        'nic_vf',
        'swap',
        'sysctl',
        'tun',
        'usb',
        'vhci',
        'wifi',
    ])

    # boolean flags which need to be converted to just cli flag
    prog2c_flags = set([
        'leak',
        'segv',
        'threaded',
        'tmpdir',
        'trace',
    ])

    features = []
    # FIXME: don't hard code
    args = ['./syz-prog2c', '-prog', str(syz_path)]

    for key, value in options.items():
        # cli tool expects 0 for repate forever
        if key == 'repeat' and value == True:
            value = 0
    
        if key in prog2c_flags and value == True:
            args.append(f'-{key}')
        elif key in features and value == True:
            features.append(key)
        else:
            args.append(f'-{key}')
            args.append(str(value))
    
    args.append('-enable')
    args.append(','.join(features))

    return subprocess.check_output(args).decode('utf-8')

@dataclass
class BugMetadata:
    bug_id: str

    description: str
    # stored in database as comma seperated string
    # TODO: don't store as string in db
    subsystems: list[str]
    crash_time: datetime

    # name of kernel pulled from syzkaller
    kernel_name: str
    # link to git commit with kernel src
    kernel_url: Optional[str]
    kernel_config_url: Optional[str]

    crash_report: str
    syz_repro_url: str
    c_repro_url: str
    disk_image_url: Optional[str]
    disk_image_is_bootable: bool
    kernel_image_url: Optional[str]
    vmlinux_url: Optional[str]

    # returns a path to the artifact with the given name
    def artifact_path(self, bug_folder: Path, artifact_name: str) -> Path:
        artifact_folder = Path(os.path.join(bug_folder, self.bug_id))
        artifact_folder.mkdir(parents=True, exist_ok=True)

        return Path(os.path.join(artifact_folder, artifact_name))

    def save_url_to_artifact_folder(self, bug_folder: Path, artifact_name: str, url: str) -> Path:
        artifact_path = self.artifact_path(bug_folder, artifact_name)
        # if artifact already exists, don't redownload
        if artifact_path.exists():
            return artifact_path
        
        response = requests.get(url)
        with open(artifact_path, 'wb') as f:
            f.write(response.content)
        
        return artifact_path
    
    def save_syz_repro(self, bug_folder: Path) -> Path:
        return self.save_url_to_artifact_folder(bug_folder, 'repro.syz', self.syz_repro_url)
    
    def save_c_repro(self, bug_folder: Path) -> Path:
        return self.save_url_to_artifact_folder(bug_folder, 'repro.c', self.c_repro_url)
    
    # FIXME: don't use str for arch
    def generate_c_repro(self, bug_folder: Path, arch: str) -> Path:
        syz_repro = self.save_syz_repro(bug_folder)
        with open(syz_repro, 'r') as f:
            syz_data = f.read()
        
        options_start = syz_data.find('#{')
        options_end = syz_data.find('}\n')
        assert options_start != -1 and options_end != -1
        options = json.loads(syz_data[options_start + 1:options_end + 1])
        options['arch'] = arch

        c_code = syz_to_c(syz_repro, options)
        c_code_path = self.artifact_path(bug_folder, f'repro_{arch}.c')
        with open(c_code_path, 'w') as f:
            f.write(c_code)
        
        return c_code_path

    def compile_repro(self, bug_folder: Path) -> Path:
        c_repro_path = self.generate_c_repro(bug_folder)
        repro_bin_path = self.artifact_path(bug_folder, 'repro')
        # FIXME: this is hack for making compiling easier
        # don't hardcode random script name used for compilation
        os.system(f'./compile.sh "{c_repro_path.absolute()}" "{repro_bin_path.absolute()}"')
        assert repro_bin_path.exists()
        return repro_bin_path
    
    def run_repro(self, bug_folder: Path):
        repro_path = self.compile_repro(bug_folder)

    @classmethod
    def from_db_tuple(cls, data: tuple) -> Self:
        return BugMetadata(
            bug_id=data[0],
            description=data[1],
            subsystems=data[2].split(','),
            crash_time=data[3],
            kernel_name=data[4],
            kernel_url=data[5],
            kernel_config_url=data[6],
            crash_report=data[7],
            syz_repro_url=data[8],
            c_repro_url=data[9],
            disk_image_url=data[10],
            disk_image_is_bootable=(data[11] == 1),
            kernel_image_url=data[12],
            vmlinux_url=data[13],
        )
    
    def to_db_tuple(self) -> tuple:
        return (
            self.bug_id,
            self.description,
            ','.join(self.subsystems),
            self.crash_time,
            self.kernel_name,
            self.kernel_url,
            self.kernel_config_url,
            self.crash_report,
            self.syz_repro_url,
            self.c_repro_url,
            self.disk_image_url,
            self.disk_image_is_bootable,
            self.kernel_image_url,
            self.vmlinux_url,
        )

class SyzkallBugDatabase:
    base_folder: Path
    metadata_db: sqlite3.Connection

    def __init__(self, base_folder: Path):
        self.base_folder = base_folder
        self.base_folder.mkdir(parents=True, exist_ok=True)

        self.metadata_db = sqlite3.connect(os.path.join(self.base_folder, 'metadata_db.sqlite'))
        self.metadata_db.execute('''
        CREATE TABLE IF NOT EXISTS bugs (
            id TEXT PRIMARY KEY,
            description TEXT,
            subsystems TEXT,
            crash_time TIMESTAMP,
            kernel_name TEXT,
            kernel_url TEXT,
            kernel_config_url TEXT,
            crash_report TEXT,
            syz_repro_url TEXT,
            c_repro_url TEXT,
            disk_image_url TEXT,
            disk_image_is_bootable INTEGER,
            kernel_image_url TEXT,
            vmlinux_url TEXT
        )
        ''')
    
    def close(self):
        self.metadata_db.close()
    
    def save_bug_metadata(self, metadata: BugMetadata):
        self.metadata_db.execute('''
        INSERT INTO bugs (
            id,
            description,
            subsystems,
            crash_time,
            kernel_name,
            kernel_url,
            kernel_config_url,
            crash_report,
            syz_repro_url,
            c_repro_url,
            disk_image_url,
            disk_image_is_bootable,
            kernel_image_url,
            vmlinux_url
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', metadata.to_db_tuple())
        self.metadata_db.commit()
    
    def get_bug_metadata(self, id: str) -> Optional[BugMetadata]:
        result = self.metadata_db.execute('SELECT * FROM bugs WHERE id = ?', (id,)).fetchone()
        if result is None:
            return None
        
        return BugMetadata.from_db_tuple(result)
    
    def get_all_bugs(self) -> list[BugMetadata]:
        results = self.metadata_db.execute('SELECT * FROM bugs').fetchall()

        return [BugMetadata.from_db_tuple(row) for row in results]

def bug_id_from_url(url_path: str) -> str:
    return url_path.split('=')[1].strip()

def download_bug_metadata(bug: dict[str, Tag]) -> Optional[BugMetadata]:
    url = bug['title'].a['href']
    bug_page = get_syzkall_html(url)
    table = parse_table(find_table_by_name(bug_page, 'crashes'))

    for c_repro_row in table:
        if get_tag_string(c_repro_row['c_repro']) != 'C':
            continue

        # asset paths are full url to google cloud bucket, not relative path like c_repro_path
        assets = c_repro_row['assets']

        disk_image_str = assets.find(string='disk image')
        disk_image_non_bootable = assets.find(string='disk image (non-bootable)')

        # use non bootable image if bootable one does not exist
        disk_image_is_bootable = True
        if disk_image_str is None and disk_image_non_bootable is not None:
            disk_image_str = disk_image_non_bootable
            disk_image_is_bootable = False

        vmlinux_str = assets.find(string='vmlinux')
        kernel_image_str = assets.find(string='kernel image')

        # assets are missing on older bug reports
        disk_image_path = None if disk_image_str is None else disk_image_str.parent['href']
        vmlinux_path = None if vmlinux_str is None else vmlinux_str.parent['href']
        kernel_image_path = None if kernel_image_str is None else kernel_image_str.parent['href']
        
        # title contains subsystems, without false positives
        subsystems = [get_tag_string(span) for span in bug['title'].find_all(name='span', attrs={'class': 'bug-label'})]

        syz_repro_a = c_repro_row['syz_repro'].find(name='a', string='syz')
        if syz_repro_a is None:
            continue

        c_repro_path = path_to_syzkall_url(c_repro_row['c_repro'].a['href'])

        # very rarely kernel commit is not an anchor and doesn't have url, so ignore
        kernel_commit_a = c_repro_row['commit'].a
        kernel_commit_url = None if kernel_commit_a is None else kernel_commit_a['href']

        # also check if config isn't proper link
        kernel_config_a = c_repro_row['config'].a
        kernel_config_url = None if kernel_config_a is None else path_to_syzkall_url(kernel_config_a['href'])

        crash_report = get_tag_string(bug_page.pre)

        crash_time_string = get_tag_string(c_repro_row['time'])
        crash_time = datetime.strptime(crash_time_string, '%Y/%m/%d %H:%M')

        return BugMetadata(
            bug_id=bug_id_from_url(url),
            description=get_tag_string(c_repro_row['title']),
            subsystems=subsystems,
            crash_time=crash_time,
            kernel_name=get_tag_string(c_repro_row['kernel']),
            kernel_url=kernel_commit_url,
            kernel_config_url=kernel_config_url,
            crash_report=crash_report,
            syz_repro_url=syz_repro_a['href'],
            c_repro_url=c_repro_path,
            disk_image_url=disk_image_path,
            disk_image_is_bootable=disk_image_is_bootable,
            kernel_image_url=kernel_image_path,
            vmlinux_url=vmlinux_path,
        )
    
    return None

# kernel_name is upstream for default linux
# can also be android
def get_bugs_for_kernel(kernel_name: str) -> tuple[list[dict[str, Tag]], list[dict[str, Tag]]]:
    open_bugs_table = find_table_by_name(get_syzkall_html(kernel_name), 'open')
    fixed_bugs_table = get_syzkall_html(f'{kernel_name}/fixed').find_all(name='table')[1]

    bugs_open = filter_bugs(parse_table(open_bugs_table))
    bugs_fixed = filter_bugs(parse_table(fixed_bugs_table))

    return bugs_open, bugs_fixed

def pull(kernel_name: str, bug_path: Path):
    bugs_open, bugs_fixed = get_bugs_for_kernel(kernel_name)
    bugs_combined = bugs_open + bugs_fixed

    db = SyzkallBugDatabase(bug_path)

    try:
        for bug in bugs_combined:
            print('Pulling:')
            print(get_tag_string(bug['title']).replace('\n', ' '))

            url = bug['title'].a['href']
            id = bug_id_from_url(url)
            if db.get_bug_metadata(id) is not None:
                print('already downloaded')
                continue

            bug_metadata = download_bug_metadata(bug)
            time.sleep(3)
            if bug_metadata is None:
                print('Failed to parse')
                continue
            db.save_bug_metadata(bug_metadata)
    finally:
        db.close()

def query(bug_path: Path):
    db = SyzkallBugDatabase(bug_path)
    bugs = db.get_all_bugs()

    for bug in bugs:
        # print(bug.description)
        # print(bug.kernel_name)
        if 'android' not in bug.kernel_name:
            continue
        print(f'{bug.bug_id}: {bug.description}')
        print(bug.crash_time)

def test(id: str, bug_path: Path):
    db = SyzkallBugDatabase(bug_path)
    metadata = db.get_bug_metadata(id)
    if metadata is None:
        print('Invalid bug id supplied')
        return
    
    print(f'Compiling {metadata.description}...')
    metadata.compile_repro(bug_path)