from typing import Optional, Self
from dataclasses import dataclass
from pathlib import Path
import os
import sqlite3
import json
from datetime import datetime

import requests

from .run_bug import syz_to_c
from ..data import kexploit_data_dir

def syzkall_db_path() -> Path:
    return kexploit_data_dir("syzkaller_bugs")

@dataclass
class BugMetadata:
    bug_id: str

    description: str
    # stored in database as comma seperated string
    # TODO: don't store as string in db
    subsystems: list[str]
    crash_time: datetime

    # name of kernel pulled from syzkaller
    kernel_name: str
    # link to git commit with kernel src
    kernel_url: Optional[str]
    kernel_config_url: Optional[str]

    crash_report: str
    syz_repro_url: str
    c_repro_url: str
    disk_image_url: Optional[str]
    disk_image_is_bootable: bool
    kernel_image_url: Optional[str]
    vmlinux_url: Optional[str]

    # returns a path to the artifact with the given name
    def artifact_path(self, artifact_name: str) -> Path:
        artifact_folder = Path(os.path.join(syzkall_db_path(), self.bug_id))
        artifact_folder.mkdir(parents=True, exist_ok=True)

        return Path(os.path.join(artifact_folder, artifact_name))

    def save_url_to_artifact_folder(self, artifact_name: str, url: str) -> Path:
        artifact_path = self.artifact_path(artifact_name)
        # if artifact already exists, don't redownload
        if artifact_path.exists():
            return artifact_path
        
        response = requests.get(url)
        with open(artifact_path, 'wb') as f:
            f.write(response.content)
        
        return artifact_path
    
    def save_syz_repro(self) -> Path:
        return self.save_url_to_artifact_folder('repro.syz', self.syz_repro_url)
    
    def save_c_repro(self) -> Path:
        return self.save_url_to_artifact_folder('repro.c', self.c_repro_url)
    
    # FIXME: don't use str for arch
    def generate_c_repro(self, arch: str) -> Path:
        syz_repro = self.save_syz_repro()
        with open(syz_repro, 'r') as f:
            syz_data = f.read()
        
        options_start = syz_data.find('#{')
        options_end = syz_data.find('}\n')
        assert options_start != -1 and options_end != -1
        options = json.loads(syz_data[options_start + 1:options_end + 1])
        options['arch'] = arch

        c_code = syz_to_c(syz_repro, options)
        c_code_path = self.artifact_path(f'repro_{arch}.c')
        with open(c_code_path, 'w') as f:
            f.write(c_code)
        
        return c_code_path

    def compile_repro(self, arch: str) -> Path:
        c_repro_path = self.generate_c_repro(arch)
        repro_bin_path = self.artifact_path('repro')
        # FIXME: this is hack for making compiling easier
        # don't hardcode random script name used for compilation
        os.system(f'./compile.sh "{c_repro_path.absolute()}" "{repro_bin_path.absolute()}"')
        assert repro_bin_path.exists()
        return repro_bin_path
    
    def run_repro(self, arch: str):
        repro_path = self.compile_repro(arch)


    @classmethod
    def from_db_tuple(cls, data: tuple) -> Self:
        return BugMetadata(
            bug_id=data[0],
            description=data[1],
            subsystems=data[2].split(','),
            crash_time=data[3],
            kernel_name=data[4],
            kernel_url=data[5],
            kernel_config_url=data[6],
            crash_report=data[7],
            syz_repro_url=data[8],
            c_repro_url=data[9],
            disk_image_url=data[10],
            disk_image_is_bootable=(data[11] == 1),
            kernel_image_url=data[12],
            vmlinux_url=data[13],
        )
    
    def to_db_tuple(self) -> tuple:
        return (
            self.bug_id,
            self.description,
            ','.join(self.subsystems),
            self.crash_time,
            self.kernel_name,
            self.kernel_url,
            self.kernel_config_url,
            self.crash_report,
            self.syz_repro_url,
            self.c_repro_url,
            self.disk_image_url,
            self.disk_image_is_bootable,
            self.kernel_image_url,
            self.vmlinux_url,
        )

class SyzkallBugDatabase:
    base_folder: Path
    metadata_db: sqlite3.Connection

    def __init__(self):
        self.base_folder = syzkall_db_path()

        self.metadata_db = sqlite3.connect(os.path.join(self.base_folder, 'metadata_db.sqlite'))
        self.metadata_db.execute('''
        CREATE TABLE IF NOT EXISTS bugs (
            id TEXT PRIMARY KEY,
            description TEXT,
            subsystems TEXT,
            crash_time TIMESTAMP,
            kernel_name TEXT,
            kernel_url TEXT,
            kernel_config_url TEXT,
            crash_report TEXT,
            syz_repro_url TEXT,
            c_repro_url TEXT,
            disk_image_url TEXT,
            disk_image_is_bootable INTEGER,
            kernel_image_url TEXT,
            vmlinux_url TEXT
        )
        ''')
    
    def close(self):
        self.metadata_db.close()
    
    def save_bug_metadata(self, metadata: BugMetadata):
        self.metadata_db.execute('''
        INSERT INTO bugs (
            id,
            description,
            subsystems,
            crash_time,
            kernel_name,
            kernel_url,
            kernel_config_url,
            crash_report,
            syz_repro_url,
            c_repro_url,
            disk_image_url,
            disk_image_is_bootable,
            kernel_image_url,
            vmlinux_url
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', metadata.to_db_tuple())
        self.metadata_db.commit()
    
    def get_bug_metadata(self, id: str) -> Optional[BugMetadata]:
        result = self.metadata_db.execute('SELECT * FROM bugs WHERE id = ?', (id,)).fetchone()
        if result is None:
            return None
        
        return BugMetadata.from_db_tuple(result)
    
    def get_all_bugs(self) -> list[BugMetadata]:
        results = self.metadata_db.execute('SELECT * FROM bugs').fetchall()

        return [BugMetadata.from_db_tuple(row) for row in results]
