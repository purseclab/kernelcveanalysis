from typing import Any
from pathlib import Path
import subprocess
import os
import time

# uses syz_prog2c tool to translate syzkaller DSL to C code
def syz_to_c(syz_path: Path, options: dict[str, Any]) -> str:
    # features which can be enabled / disabled
    feature_flags = set([
        'binfmt_misc',
        'cgroups',
        'close_fds',
        'devlink_pci',
        'ieee802154',
        'net_dev',
        'net_reset',
        'nic_vf',
        'swap',
        'sysctl',
        'tun',
        'usb',
        'vhci',
        'wifi',
    ])

    # boolean flags which need to be converted to just cli flag
    prog2c_flags = set([
        'leak',
        'segv',
        'threaded',
        'tmpdir',
        'trace',
    ])

    features = []
    # FIXME: don't hard code
    args = ['./syz-prog2c', '-prog', str(syz_path)]

    for key, value in options.items():
        # cli tool expects 0 for repate forever
        if key == 'repeat' and value is True:
            value = 0
    
        if key in prog2c_flags:
            if value is True:
                args.append(f'-{key}')
        elif key in feature_flags:
            if value is True:
                features.append(key)
        else:
            args.append(f'-{key}')
            args.append(str(value))
    
    if len(features) > 0:
        args.append('-enable')
        args.append(','.join(features))

    return subprocess.check_output(args, stderr=subprocess.DEVNULL).decode('utf-8')

# FIXME: don't hardcode this
# ADB assumes adb server is avaialable at localhost:5037
# To proxy cuttlefish server, us `ssh -L localhost:5037:localhost:5037 cuttlefish`
ADB_EXE_PATH = './adb'

def wait_for_connection():
    print('Waiting for adb device to be available...')
    subprocess.run([ADB_EXE_PATH, 'wait-for-device'], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def adb_upload_file(file: Path, upload_location: Path):
    subprocess.run([ADB_EXE_PATH, 'push', str(file), str(upload_location)], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

def is_device_connected() -> bool:
    # Output looks like:
    # List of devices attached
    # 0.0.0.0:6520    offline

    result = subprocess.check_output([ADB_EXE_PATH, 'devices']).decode().strip().split('\n')
    # if no devices in device list, not connected
    if len(result) == 1:
        return False
    
    # more than 1 device not supported
    assert len(result) <= 2

    status = result[1].split()[1]
    # device is connected if in device state
    return status == 'device'


# Path of repro in android VM
REPRO_PATH = '/data/local/tmp/repro'

# assumes an instance of cuttlefish VM is already running
# tests the exploit at the given path to see if it crashes the kernel
# returns true if it does
def test_repro_crashes(repro_path: Path) -> bool:
    wait_for_connection()

    adb_upload_file(repro_path, Path(REPRO_PATH))

    crash_occured = False

    run_repro_cmd = f'cd {os.path.dirname(REPRO_PATH)} && su root {REPRO_PATH}'
    print(run_repro_cmd)
    with subprocess.Popen([ADB_EXE_PATH, 'shell', run_repro_cmd]) as exploit_process:
        # wait for exploit to run a bit
        time.sleep(5)

        exploit_process.poll()
        if exploit_process.returncode is not None or not is_device_connected():
            # exploit adb process has exited, or device no longer being available
            # indicates a crash may have 
            crash_occured = True
        
        exploit_process.terminate()
    
    return crash_occured
