from dataclasses import dataclass
from enum import Enum, StrEnum
from pathlib import Path
from typing import Self, Optional, Generator
from collections import defaultdict
import bisect
import itertools
import subprocess
import os

from elftools.elf.elffile import ELFFile
from elftools.elf.segments import Segment as ElfSegment
from elftools.elf.sections import Section as ElfSection
from capstone import Cs, CsInsn, CS_ARCH_ARM64, CS_MODE_ARM, CS_ARCH_X86, CS_MODE_64
from capstone.x86 import X86_OP_IMM
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_ARM, KS_ARCH_X86, KS_MODE_64

from .data import kernel_image_dir
from .ghidra import GhidraInstance, GhidraApi, RefType, Reference

def path_for_kernel_name(kernel_name: str) -> Path:
    return Path(os.path.join(kernel_image_dir(), kernel_name))

class ElfConstants(StrEnum):
    ELF_64 = 'ELFCLASS64'
    ELF_AARCH64 = 'EM_AARCH64'
    ELF_X86_64 = 'EM_X86_64'

class ArchType(Enum):
    AARCH64 = 0
    X86_64 = 1

# flags deremining segment rwx in phdr.p_flags
ELF_FLAGS_READ = 4
ELF_FLAGS_WRITE = 2
ELF_FLAGS_EXEC = 1

SECTION_FLAG_WRITE = 1
SECTION_FLAG_ALLOC = 2
SECTION_FLAG_EXEC = 4

@dataclass
class AssemblerConstants:
    asm_arch: int
    asm_mode: int
    disasm_arch: int
    disasm_mode: int

@dataclass
class ArchInfo:
    arch_type: ArchType
    kernel_base_mask: int
    kernel_base_symbol: str
    page_size: int

    assembler_constants: AssemblerConstants

    @classmethod
    def from_elf_file(cls, elf_file: ELFFile) -> Optional[Self]:
        match elf_file['e_ident']['EI_CLASS'], elf_file['e_machine']:
            case ElfConstants.ELF_64, ElfConstants.ELF_AARCH64:
                return cls(
                    arch_type=ArchType.AARCH64,
                    kernel_base_mask=0xffffffc000000000,
                    kernel_base_symbol='_head',
                    page_size=4096,
                    assembler_constants=AssemblerConstants(
                        asm_arch=KS_ARCH_ARM64,
                        asm_mode=KS_MODE_ARM,
                        disasm_arch=CS_ARCH_ARM64,
                        disasm_mode=CS_MODE_ARM,
                    ),
                )
            case ElfConstants.ELF_64, ElfConstants.ELF_X86_64:
                return cls(
                    arch_type=ArchType.X86_64,
                    # FIXME: get correct value for x86_64
                    kernel_base_mask=0xffffffc000000000,
                    kernel_base_symbol='_stext',
                    page_size=4096,
                    assembler_constants=AssemblerConstants(
                        asm_arch=KS_ARCH_X86,
                        asm_mode=KS_MODE_64,
                        disasm_arch=CS_ARCH_X86,
                        disasm_mode=CS_MODE_64,
                    ),
                )
            case _:
                return None
    
    def is_kernel_address(self, address: int) -> bool:
        # Ignore address which is too big
        return (address & self.kernel_base_mask == self.kernel_base_mask) and (address < 0xfffffffffff00000)
    
    def get_assembler(self) -> Ks:
        assembler = Ks(self.assembler_constants.asm_arch, self.assembler_constants.asm_mode)
        return assembler
    
    def get_disassembler(self) -> Cs:
        disassembler = Cs(self.assembler_constants.disasm_arch, self.assembler_constants.disasm_mode)
        disassembler.detail = True
        return disassembler

@dataclass
class Symbol:
    name: str
    address: int
    offset: int

@dataclass
class MemoryPerms:
    read: bool
    write: bool
    exec: bool

    # Returns permissions which match the list of given sections
    @classmethod
    def from_section(cls, section: ElfSection) -> Self:
        rx_sections = ['.text']
        ro_sections = ['.rodata']
        rw_sections = ['.bss', '.data']

        read = True
        write = False
        exec = False

        if section.name in rx_sections:
            exec = True
        elif section.name in rw_sections:
            write = True
        elif section.name not in ro_sections:
            # fallback to section flags
            flags = section['sh_flags']
            write = (flags & SECTION_FLAG_WRITE) != 0
            exec = (flags & SECTION_FLAG_EXEC) != 0
        
        return cls(
            read=read,
            write=write,
            exec=exec,
        )
    
    @classmethod
    def from_sections(cls, sections: list[ElfSection]) -> Optional[Self]:
        if len(sections) == 0:
            return None

        perms = [cls.from_section(section) for section in sections]
        for perm1, perm2 in itertools.pairwise(perms):
            assert perm1 == perm2, "Conflicting section permissions"
        
        return perms[0]

    def __repr__(self) -> str:
        read = 'r' if self.read else '-'
        write = 'w' if self.write else '-'
        exec = 'x' if self.exec else '-'

        return read + write + exec

class Segment:
    vaddr: int
    size: int
    segment_perms: MemoryPerms
    section_perms: Optional[MemoryPerms]
    file_data: bytes
    # sections within this segment
    sections: list[ElfSection]

    def __init__(self, segment: ElfSegment, sections: list[ElfSection]):
        self.vaddr = segment['p_vaddr']
        self.size = segment['p_memsz']

        flags = segment['p_flags']
        self.segment_perms = MemoryPerms(
            read=(flags & ELF_FLAGS_READ) != 0,
            write=(flags & ELF_FLAGS_WRITE) != 0,
            exec=(flags & ELF_FLAGS_EXEC) != 0,
        )
        self.section_perms = None

        self.file_data = segment.data()

        def contains_section(section):
            return (
                section['sh_addr'] >= self.vaddr
                # handle case with 0 size sections not being counted if directly after this segment
                and section['sh_addr'] < self.end_vaddr()
                and (section['sh_addr'] + section['sh_size']) <= self.end_vaddr()
                # TODO: this might not be corrrect way of determihning loaded sections
                # maybe use alloc flag instead
                and (section['sh_type'] == 'SHT_PROGBITS' or section['sh_type'] == 'SHT_NOBITS')
            )

        self.sections = [section for section in sections if contains_section(section)]
    
    def infer_perms(self):
        self.section_perms = MemoryPerms.from_sections(self.sections)

    def end_vaddr(self) -> int:
        return self.vaddr + self.size
    
    def perms(self) -> MemoryPerms:
        if self.section_perms is not None:
            return self.section_perms
        else:
            return self.segment_perms
    
    @property
    def read(self) -> bool:
        return self.perms().read
    
    @property
    def write(self) -> bool:
        return self.perms().write
    
    @property
    def exec(self) -> bool:
        return self.perms().exec
    
    def __repr__(self) -> str:
        section_names = [section.name for section in self.sections]
        return f'Segment(start={hex(self.vaddr)}, end={hex(self.end_vaddr())}, flags={self.segment_perms}, inferred_flags={self.section_perms}, sections={section_names})'

def align_up(address: int, align: int) -> int:
    return (address + align - 1) & ~(align - 1)

def align_down(address: int, align: int) -> int:
    return address & ~(align - 1)

def bytes_findall(data: bytes, search_term: bytes) -> Generator[int, None, None]:
    index = 0
    while True:
        find_index = data[index:].find(search_term)
        if find_index == -1:
            return None

        yield index + find_index

        index += find_index + len(search_term)

class KernelImage:
    arch_info: ArchInfo
    # elf_data: ELFFile
    # symbol_table: SymbolTableSection
    symbol_index_map: dict[str, int]
    # sorted list of symbols
    symbols: list[Symbol]
    # loadable segments sorted by order of virtual address
    segments: list[Segment]
    kernel_base: int
    # indicates if kernel has been compiled with CONFIG_KALLSYMS_ALL
    # This means kernel will have kallsyms symbols for variables in data section
    # otherwise, kallsyms will only have symbols for functions
    kallsyms_all: bool

    ghidra: GhidraInstance

    def __init__(self, kernel_name: str):
        kernel_path = path_for_kernel_name(kernel_name)
        assert kernel_path.exists(), "Invalid kernel name given"
        elf_file = ELFFile.load_from_path(kernel_path)
    
        symbol_table = elf_file.get_section_by_name(".symtab")

        self.arch_info = ArchInfo.from_elf_file(elf_file)

        self.symbols = [
            # fill out offset later
            Symbol(symbol.name, symbol['st_value'], 0) for symbol in symbol_table.iter_symbols()
        ]
        self.symbols.sort(key = lambda symbol: symbol.address)
        self.symbol_index_map = { symbol.name: i for i, symbol in enumerate(self.symbols) }

        self.kernel_base = self.symbols[self.symbol_index_map[self.arch_info.kernel_base_symbol]].address
        for symbol in self.symbols:
            symbol.offset = symbol.address - self.kernel_base
        
        self.kallsyms_all = False

        sections = list(elf_file.iter_sections())
        
        # collect segments and iterate in sorted order
        self.segments = []
        for segment in elf_file.iter_segments():
            if not segment['p_type'] == 'PT_LOAD':
                continue

            segment = Segment(segment, sections)

            self.segments.append(segment)

        self.segments.sort(key=lambda segment: segment.vaddr)

        # if all segments are rwx, segment permissions are not accuret
        # infer permissions from sections instead
        if all(segment.read and segment.write and segment.exec for segment in self.segments):
            print('Inferring segment permissions')
            for segment in self.segments:
                segment.infer_perms()
        
        # detect if CONFIG_KALLSYMS_ALL is enabled
        for segment in self.segments:
            if not self.kallsyms_all and not segment.exec:
                # look for symbol within this data segment
                # if there is one, kallsyms_all is true,
                # because kernel includes data symbols
                match self.find_previous_symbol_absolute(segment.end_vaddr()):
                    case Symbol(_, address, _) if address >= segment.vaddr:
                        self.kallsyms_all = True
        
        self.ghidra = GhidraInstance(kernel_path)

    def get_symbol(self, name: str) -> Optional[Symbol]:
        if name in self.symbol_index_map:
            return self.symbols[self.symbol_index_map[name]]
        else:
            return None

    def find_previous_symbol_offset(self, offset: int) -> Optional[Symbol]:
        return self.find_previous_symbol_absolute(self.kernel_base + offset)
    
    def find_previous_symbol_absolute(self, address: int) -> Optional[Symbol]:
        index = bisect.bisect_right(self.symbols, address, key = lambda symbol: symbol.address) - 1
        if index >= 0:
            return self.symbols[index]
        else:
            return None
    
    def segment_index(self, vaddr: int) -> Optional[int]:
        index = bisect.bisect_right(self.segments, vaddr, key=lambda segment: segment.vaddr) - 1

        if index >= 0 and vaddr < self.segments[index].end_vaddr():
            return index
        else:
            return None
    
    def containing_segment(self, vaddr: int) -> Optional[Segment]:
        index = self.segment_index(vaddr)
        if index is None:
            return None
        else:
            return self.segments[index]
    
    def is_rop_chain_address(self, vaddr: int) -> bool:
        segment = self.containing_segment(vaddr)
        symbol = self.find_previous_symbol_absolute(vaddr)
        
        # if vaddr points to address in executable section, but not at the start of a function,
        # it is probably a rop gadget
        return segment is not None and symbol is not None and segment.exec and symbol.address != vaddr
    
    def is_rop_chain_offset(self, offset: int) -> bool:
        return self.is_rop_chain_address(self.kernel_base + offset)
    
    def is_executable_address(self, address: int) -> bool:
        segment = self.containing_segment(address)
        if segment is None:
            return False
        else:
            return segment.exec
    
    # TODO: find instruction type
    def dissasemble_region(self, address: int, length: int) -> Optional[list[CsInsn]]:
        segment = self.containing_segment(address)
        if segment is None or not segment.exec:
            return None
        else:
            dissasembler = self.arch_info.get_disassembler()
            file_offset = address - segment.vaddr
            if file_offset >= len(segment.file_data):
                return None

            return list(dissasembler.disasm(segment.file_data[file_offset:file_offset+length], address))
    
    def is_ret_or_jmp_to_ret(self, address: int) -> bool:
        instructions = self.dissasemble_region(address, 0x20)
        if instructions is None or len(instructions) == 0:
            return False
        instruction = instructions[0]

        if instruction.mnemonic == 'ret':
            return True
        elif instruction.mnemonic == 'jmp' and len(instruction.operands) == 1:
            operand = instruction.operands[0]

            if operand.type == X86_OP_IMM:
                # for jmp capstone already converted immediate to target address,
                # but python interpertets it as signed so, fix sign issue if it is negative
                address = operand.imm
                if address < 0:
                    address += 2**64
                return self.is_ret_or_jmp_to_ret(address)
            else:
                return False
        else:
            return False

    def get_rop_chain_instructions(self, address: int) -> str:
        assert self.arch_info.arch_type == ArchType.X86_64, "Rop translation not supported on arm"

        segment = self.containing_segment(address)
        if segment is None:
            return None

        dissasembler = self.arch_info.get_disassembler()

        rop_end_instructions = set([
            'ret',
            'jmp',
        ])

        data_offset = address - segment.vaddr
        # dissasemble just a set amount of instructions forward, rop gadget is not that big
        # TODO: handle large rop gadgets, and rop gadgets spanning across elf segments
        instructions = []
        for instruction in dissasembler.disasm(segment.file_data[data_offset:data_offset+0x100], address):
            instructions.append(instruction)

            # branch instruction signifies end of rop / jop gadget
            if instruction.mnemonic in rop_end_instructions:
                break

        return '; '.join(f'{instruction.mnemonic} {instruction.op_str}' for instruction in instructions)
    
    def get_rop_chain_instructions_offset(self, offset: int) -> str:
        return self.get_rop_chain_instructions(self.kernel_base + offset)

@dataclass
class CodeToDataReference:
    symbol: Symbol
    reference_chain: list[Reference]

    def start_from_address(self) -> int:
        return self.reference_chain[0].from_address

class KernelAdapter:
    src_image: KernelImage
    dst_image: KernelImage

    def __init__(self, src_kernel: str, dst_kernel: str):
        # original image exploit was made for
        self.src_image = KernelImage(src_kernel)

        # new kernel image to adapt exploit to
        self.dst_image = KernelImage(dst_kernel)
    
    def translate_rop_gadget(self, instructions: str) -> Optional[int]:
        assert self.src_image.arch_info.arch_type == ArchType.X86_64 and self.dst_image.arch_info.arch_type == ArchType.X86_64, "Rop translation not supported on arm"

        instructions = instructions.split('; ')

        last_instruction = instructions[-1].strip()
        last_operands = last_instruction.split()
        # if we want a gadget that just returns, jmp to return or return itself is interchangable
        tail_jump_or_ret = (
            (len(last_operands) == 2 and last_operands[0] == 'jmp' and last_operands[1].startswith('0x'))
            or (len(last_operands) == 1 and last_operands[0] == 'ret')
        )
        if tail_jump_or_ret:
            instructions = instructions[:-1]

        assembler = self.src_image.arch_info.get_assembler()
        # TODO: handle relative jmp at end to return address
        encoding, _count = assembler.asm('; '.join(instructions))

        if encoding is None:
            print('Warning: invalid rop gadget instruction')
            return None
        
        encoding = bytes(encoding)

        for segment in self.dst_image.segments:
            for index in bytes_findall(segment.file_data, bytes(encoding)):
                # if tail jump does not jump to return address, ignore
                if tail_jump_or_ret and not self.dst_image.is_ret_or_jmp_to_ret(segment.vaddr + index + len(encoding)):
                    continue

                return segment.vaddr + index
        
        return None

    def translate_rop_gadget_offset(self, instructions: str) -> Optional[int]:
        result = self.translate_rop_gadget(instructions)
        if result is None:
            return None
        else:
            return result - self.dst_image.kernel_base
    
    def find_code_symbol_referencing_data(self, ghidra_api: GhidraApi, address: int) -> Optional[CodeToDataReference]:
        address_queue = [(address, [])]

        # BFS search back over data references until we find a code reference
        # which is present in both binaries
        while len(address_queue) > 0:
            address, reference_chain = address_queue.pop(0)
            references = ghidra_api.references_to_address(address)
            code_refs = [reference for reference in references if self.src_image.is_executable_address(reference.from_address)]

            for reference in code_refs:
                symbol = self.src_image.find_previous_symbol_absolute(reference.from_address)
                if self.dst_image.get_symbol(symbol.name) is not None:
                    return CodeToDataReference(
                        symbol=symbol,
                        reference_chain=([reference] + reference_chain)
                    )
            
            # TODO: don't copy reference chain for every reference
            # this degrades perfomance to quadriatic or something like that I think
            # chains are for now very short though so it doesn't matter
            address_queue.extend(
                (reference.from_address, [reference] + reference_chain)
                for reference in references if not self.src_image.is_executable_address(reference.from_address)
            )
        
        return None

    # translates an address in the data section, without relying on data symbols
    # needed when either src or dst kernel image does not have symbols for data section
    def translate_data_address_no_syms(self, address: int) -> Optional[int]:
        with self.src_image.ghidra as src_ghidra, self.dst_image.ghidra as dst_ghidra:
            data_ref = self.find_code_symbol_referencing_data(src_ghidra, address)
            if data_ref is None:
                print('Warning: could not find code reference for data address')
                return None
            
            src_function = src_ghidra.get_function(data_ref.symbol.address)
            src_basic_blocks = src_ghidra.get_basic_blocks(src_function)

            src_block_index = src_basic_blocks.block_index_for_address(src_ghidra.to_address(data_ref.start_from_address()))
            characteristic = src_basic_blocks.block_characteristic(src_ghidra, src_block_index)

            dst_symbol = self.dst_image.get_symbol(data_ref.symbol.name)
            dst_function = dst_ghidra.get_function(dst_symbol.address)
            dst_function_refs = [
                reference for reference in
                dst_ghidra.references_in_function(dst_function)
                if reference.ref_type == data_ref.reference_chain[0].ref_type
            ]
            dst_basic_blocks = dst_ghidra.get_basic_blocks(dst_function)

            # mapping from basic block index to list of refs it has
            dst_ref_index_map = defaultdict(list)
            for ref in dst_function_refs:
                block_index = dst_basic_blocks.block_index_for_address(dst_ghidra.to_address(ref.from_address))
                dst_ref_index_map[block_index].append(ref)
            
            dst_block_characteristics = [
                dst_basic_blocks.block_characteristic(dst_ghidra, block_index)
                for block_index in dst_ref_index_map.keys()
            ]
            
            # match basic blocks based on characteristic
            matching_characteristic = characteristic.closest_match(dst_block_characteristics)
            if matching_characteristic is None:
                # TODO: retry on different symbol
                print('Warning: could not find matching basic block reference for translating data address')
            
            matching_block = dst_basic_blocks.block_index(matching_characteristic.block)
            matching_refs = dst_ref_index_map[matching_block]
            
            # match references based on characteristic
            target_ref_characteristic = src_basic_blocks.reference_characteristic(src_ghidra, data_ref.reference_chain[0])
            matching_refs_characteristics = [
                dst_basic_blocks.reference_characteristic(dst_ghidra, reference) for reference in matching_refs
            ]
            matching_ref = target_ref_characteristic.closest_match(matching_refs_characteristics)
            if matching_ref is None:
                print('Warning: could not match references in basic block')
                return None
            matching_ref = matching_ref.reference
            
            # reference is now found, trace reference chain back to data address we are interested in
            for _ in range(len(data_ref.reference_chain) - 1):
                matching_ref = dst_ghidra.deref(matching_ref)
                if matching_ref is None:
                    print('Warning: reference chain does not match in new kernel')
                    return None

            return matching_ref.to_address

        return None

    def translate_address(self, address: int) -> Optional[int]:
        segment = self.src_image.containing_segment(address)
        if segment is None:
            print('Warning: address to translate does not point in kernel loadable segment')
            return None
        
        if not segment.exec and not (self.src_image.kallsyms_all and self.dst_image.kallsyms_all):
            return self.translate_data_address_no_syms(address)

        index = bisect.bisect_right(self.src_image.symbols, address, key = lambda symbol: symbol.address) - 1

        # find first symbol before address which exists in both images
        # use that as base to translate the address
        while index >= 0:
            symbol = self.src_image.symbols[index]
            address_diff = address - symbol.address

            # this likely means an incorrect value was annotated
            if abs(address_diff) > 0x10_000:
                print('Warning: very large address diff, ignoring address')
                return None

            new_symbol = self.dst_image.get_symbol(symbol.name)
            if new_symbol is not None:
                return new_symbol.address + address_diff
            
            index -= 1

        return None
    
    def translate_offset(self, offset: int) -> Optional[int]:
        result = self.translate_address(self.src_image.kernel_base + offset)
        if result is None:
            return None
        else:
            return result - self.dst_image.kernel_base

def add_kernel(image_path: Path, name: Optional[str]):
    if name is None:
        name = os.path.basename(image_path)
    
    dst_path = path_for_kernel_name(name)
    if dst_path.exists():
        print('Kernel with given name already exists')
        return

    subprocess.run(['vmlinux-to-elf', str(image_path), str(dst_path)], check=True)
    print('Kernel converted to elf')

    with GhidraInstance(dst_path) as api:
        api.analyze()

    print('Kernel analysis done')

def list_kernels():
    for kernel_name in os.listdir(kernel_image_dir()):
        print(kernel_name)