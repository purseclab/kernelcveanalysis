from dataclasses import dataclass
from enum import Enum, StrEnum
from pathlib import Path
from typing import Self, Optional, Generator
from collections import defaultdict
import bisect
import itertools
import subprocess
import struct
import shutil
import os

from elftools.elf.elffile import ELFFile
from elftools.elf.segments import Segment as ElfSegment
from elftools.elf.sections import Section as ElfSection
from capstone import Cs, CsInsn, CS_ARCH_ARM64, CS_MODE_ARM, CS_ARCH_X86, CS_MODE_64
from capstone.x86 import X86_OP_IMM
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_ARM, KS_ARCH_X86, KS_MODE_64

from .data import kernel_elf_dir, kernel_image_dir, download_file_if_not_exist
from .ghidra import GhidraInstance, GhidraApi, Reference, RefType
from .tui import console

class Kernel:
    name: str

    def __init__(self, kernel_name: str):
        self.name = kernel_name
    
    def elf_path(self) -> Path:
        return Path(os.path.join(kernel_elf_dir(), self.name))
    
    def image_path(self) -> Path:
        return Path(os.path.join(kernel_image_dir(), self.name))
    
    def exists(self) -> bool:
        return self.elf_path().exists()
    
    def image_exists(self) -> bool:
        return self.image_path().exists()
    
    def kernelctf_kernel_name(self) -> Optional[str]:
        parts = self.name.split('_')
        if len(parts) == 3 and parts[0] == 'kernelctf':
            return f'{parts[2]}-{parts[1]}'
        else:
            return None
    
    def install_kernel_image(self, image_path: Optional[Path]):
        if self.image_exists():
            return
        
        print(f'Adding kernel image `{self.name}`')
        
        if image_path is None:
            kernelctf_name = self.kernelctf_kernel_name()
            assert kernelctf_name is not None, 'Cannot automatically install non kernelctf kernel without image path'
            url = f'https://storage.googleapis.com/kernelctf-build/releases/{kernelctf_name}/bzImage'

            download_file_if_not_exist(self.image_path(), url)
        else:
            shutil.copyfile(image_path, self.image_path())
        
        print(f'Kernel image added')
    
    def install_kernel_elf(self):
        self.install_kernel_image(None)

        if self.exists():
            return

        print(f'Adding kernel ELF `{self.name}` and analyzing')
        subprocess.run(['vmlinux-to-elf', str(self.image_path()), str(self.elf_path())], check=True)
        print('Kernel converted to elf')

        with GhidraInstance(self.elf_path()) as api:
            api.analyze()
        print('Kernel analysis done')
    
    @classmethod
    def from_kernelctf_name(cls, kernelctf_name: str) -> Self:
        parts = kernelctf_name.split('-')
        prefix = parts[0]
        rest = '-'.join(parts[1:])

        return cls(f'kernelctf_{rest}_{prefix}')

class ElfConstants(StrEnum):
    ELF_64 = 'ELFCLASS64'
    ELF_AARCH64 = 'EM_AARCH64'
    ELF_X86_64 = 'EM_X86_64'

class ArchType(Enum):
    AARCH64 = 0
    X86_64 = 1

# flags deremining segment rwx in phdr.p_flags
ELF_FLAGS_READ = 4
ELF_FLAGS_WRITE = 2
ELF_FLAGS_EXEC = 1

SECTION_FLAG_WRITE = 1
SECTION_FLAG_ALLOC = 2
SECTION_FLAG_EXEC = 4

@dataclass
class AssemblerConstants:
    asm_arch: int
    asm_mode: int
    disasm_arch: int
    disasm_mode: int

# strings representing how to convert integers to bytes using python struct module
@dataclass
class StructConstants:
    word_size: int
    usize: str

@dataclass
class ArchInfo:
    arch_type: ArchType
    kernel_base_mask: int
    kernel_base_symbol: str
    page_size: int

    assembler_constants: AssemblerConstants
    struct_constants: StructConstants

    @classmethod
    def from_elf_file(cls, elf_file: ELFFile) -> Optional[Self]:
        match elf_file['e_ident']['EI_CLASS'], elf_file['e_machine']:
            case ElfConstants.ELF_64, ElfConstants.ELF_AARCH64:
                return cls(
                    arch_type=ArchType.AARCH64,
                    kernel_base_mask=0xffffffc000000000,
                    kernel_base_symbol='_head',
                    page_size=4096,
                    assembler_constants=AssemblerConstants(
                        asm_arch=KS_ARCH_ARM64,
                        asm_mode=KS_MODE_ARM,
                        disasm_arch=CS_ARCH_ARM64,
                        disasm_mode=CS_MODE_ARM,
                    ),
                    struct_constants=StructConstants(
                        word_size=8,
                        usize='<Q',
                    ),
                )
            case ElfConstants.ELF_64, ElfConstants.ELF_X86_64:
                return cls(
                    arch_type=ArchType.X86_64,
                    # FIXME: get correct value for x86_64
                    kernel_base_mask=0xffffffc000000000,
                    kernel_base_symbol='_stext',
                    page_size=4096,
                    assembler_constants=AssemblerConstants(
                        asm_arch=KS_ARCH_X86,
                        asm_mode=KS_MODE_64,
                        disasm_arch=CS_ARCH_X86,
                        disasm_mode=CS_MODE_64,
                    ),
                    struct_constants=StructConstants(
                        word_size=8,
                        usize='<Q',
                    ),
                )
            case _:
                return None
    
    def get_assembler(self) -> Ks:
        assembler = Ks(self.assembler_constants.asm_arch, self.assembler_constants.asm_mode)
        return assembler
    
    def get_disassembler(self) -> Cs:
        disassembler = Cs(self.assembler_constants.disasm_arch, self.assembler_constants.disasm_mode)
        disassembler.detail = True
        return disassembler
    
    def pack_usize(self, value: int) -> bytes:
        return struct.pack(self.struct_constants.usize, value)
    
    def unpack_usize(self, data: bytes) -> int:
        return struct.unpack(self.struct_constants.usize, data)[0]
    
    def word_size(self) -> int:
        return self.struct_constants.word_size
    
    def rop_translation_supported(self) -> bool:
        return self.arch_type == ArchType.X86_64

@dataclass
class Symbol:
    name: str
    address: int
    offset: int

@dataclass
class MemoryPerms:
    read: bool
    write: bool
    exec: bool

    # Returns permissions which match the list of given sections
    @classmethod
    def from_section(cls, section: ElfSection) -> Self:
        rx_sections = ['.text']
        ro_sections = ['.rodata']
        rw_sections = ['.bss', '.data']

        read = True
        write = False
        exec = False

        if section.name in rx_sections:
            exec = True
        elif section.name in rw_sections:
            write = True
        elif section.name not in ro_sections:
            # fallback to section flags
            flags = section['sh_flags']
            write = (flags & SECTION_FLAG_WRITE) != 0
            exec = (flags & SECTION_FLAG_EXEC) != 0
        
        return cls(
            read=read,
            write=write,
            exec=exec,
        )
    
    @classmethod
    def from_sections(cls, sections: list[ElfSection]) -> Optional[Self]:
        if len(sections) == 0:
            return None

        perms = [cls.from_section(section) for section in sections]
        for perm1, perm2 in itertools.pairwise(perms):
            assert perm1 == perm2, "Conflicting section permissions"
        
        return perms[0]

    def __repr__(self) -> str:
        read = 'r' if self.read else '-'
        write = 'w' if self.write else '-'
        exec = 'x' if self.exec else '-'

        return read + write + exec

class Segment:
    vaddr: int
    size: int
    segment_perms: MemoryPerms
    section_perms: Optional[MemoryPerms]
    file_data: bytes
    # sections within this segment
    sections: list[ElfSection]

    def __init__(self, segment: ElfSegment, sections: list[ElfSection]):
        self.vaddr = segment['p_vaddr']
        self.size = segment['p_memsz']

        flags = segment['p_flags']
        self.segment_perms = MemoryPerms(
            read=(flags & ELF_FLAGS_READ) != 0,
            write=(flags & ELF_FLAGS_WRITE) != 0,
            exec=(flags & ELF_FLAGS_EXEC) != 0,
        )
        self.section_perms = None

        self.file_data = segment.data()

        def contains_section(section):
            return (
                section['sh_addr'] >= self.vaddr
                # handle case with 0 size sections not being counted if directly after this segment
                and section['sh_addr'] < self.end_vaddr()
                and (section['sh_addr'] + section['sh_size']) <= self.end_vaddr()
                # TODO: this might not be corrrect way of determihning loaded sections
                # maybe use alloc flag instead
                and (section['sh_type'] == 'SHT_PROGBITS' or section['sh_type'] == 'SHT_NOBITS')
            )

        self.sections = [section for section in sections if contains_section(section)]
    
    def infer_perms(self):
        self.section_perms = MemoryPerms.from_sections(self.sections)

    def end_vaddr(self) -> int:
        return self.vaddr + self.size
    
    def perms(self) -> MemoryPerms:
        if self.section_perms is not None:
            return self.section_perms
        else:
            return self.segment_perms
    
    @property
    def read(self) -> bool:
        return self.perms().read
    
    @property
    def write(self) -> bool:
        return self.perms().write
    
    @property
    def exec(self) -> bool:
        return self.perms().exec
    
    def __repr__(self) -> str:
        section_names = [section.name for section in self.sections]
        return f'Segment(start={hex(self.vaddr)}, end={hex(self.end_vaddr())}, flags={self.segment_perms}, inferred_flags={self.section_perms}, sections={section_names})'

def align_up(address: int, align: int) -> int:
    return (address + align - 1) & ~(align - 1)

def align_down(address: int, align: int) -> int:
    return address & ~(align - 1)

def bytes_findall(data: bytes, search_term: bytes) -> Generator[int, None, None]:
    index = 0
    while True:
        find_index = data[index:].find(search_term)
        if find_index == -1:
            return None

        yield index + find_index

        index += find_index + len(search_term)

class KernelImage:
    kernel: Kernel
    arch_info: ArchInfo
    # elf_data: ELFFile
    # symbol_table: SymbolTableSection
    symbol_index_map: dict[str, int]
    # sorted list of symbols
    symbols: list[Symbol]
    # loadable segments sorted by order of virtual address
    segments: list[Segment]
    kernel_base: int
    # indicates if kernel has been compiled with CONFIG_KALLSYMS_ALL
    # This means kernel will have kallsyms symbols for variables in data section
    # otherwise, kallsyms will only have symbols for functions
    kallsyms_all: bool
    # maps address -> list of all pointers to that address
    raw_reference_map: dict[int, list[int]]

    ghidra: GhidraInstance

    def __init__(self, kernel: Kernel):
        print(f'Loading kernel `{kernel.name}`')
        self.kernel = kernel

        assert kernel.exists(), "Invalid kernel name given"
        kernel_path = kernel.elf_path()
        elf_file = ELFFile.load_from_path(kernel_path)
    
        symbol_table = elf_file.get_section_by_name(".symtab")

        
        arch_info = ArchInfo.from_elf_file(elf_file)
        assert arch_info is not None, 'Unsupported architecture'
        self.arch_info = arch_info

        self.symbols = [
            # fill out offset later
            Symbol(symbol.name, symbol['st_value'], 0) for symbol in symbol_table.iter_symbols()
        ]
        self.symbols.sort(key = lambda symbol: symbol.address)
        self.symbol_index_map = { symbol.name: i for i, symbol in enumerate(self.symbols) }

        self.kernel_base = self.symbols[self.symbol_index_map[self.arch_info.kernel_base_symbol]].address
        print(f'Kernel base: {hex(self.kernel_base)}')
        for symbol in self.symbols:
            symbol.offset = symbol.address - self.kernel_base
        
        self.kallsyms_all = False

        sections = list(elf_file.iter_sections())
        
        # collect segments and iterate in sorted order
        self.segments = []
        for segment in elf_file.iter_segments():
            if not segment['p_type'] == 'PT_LOAD':
                continue

            segment = Segment(segment, sections)

            self.segments.append(segment)

        self.segments.sort(key=lambda segment: segment.vaddr)

        # if all segments are rwx, segment permissions are not accuret
        # infer permissions from sections instead
        if all(segment.read and segment.write and segment.exec for segment in self.segments):
            print('Inferring segment permissions')
            for segment in self.segments:
                segment.infer_perms()
        
        # detect if CONFIG_KALLSYMS_ALL is enabled
        for segment in self.segments:
            if not self.kallsyms_all and not segment.exec:
                # look for symbol within this data segment
                # if there is one, kallsyms_all is true,
                # because kernel includes data symbols
                match self.find_previous_symbol_absolute(segment.end_vaddr()):
                    case Symbol(_, address, _) if address >= segment.vaddr:
                        self.kallsyms_all = True
        
        self.ghidra = GhidraInstance(kernel_path)
        self.calculate_raw_references()
        print('Kernel loaded')
    
    def min_address(self) -> int:
        return self.segments[0].vaddr
    
    def max_address(self) -> int:
        return self.segments[-1].end_vaddr()
    
    def max_offset(self) -> int:
        return self.max_address() - self.kernel_base
    
    def is_kernel_address(self, address: int) -> bool:
        return self.kernel_base <= address and address < self.max_address()
    
    def is_kernel_offset(self, offset: int) -> bool:
        return 0 <= offset and offset < self.max_offset()
    
    def address_to_offset(self, address: int) -> int:
        assert self.is_kernel_address(address)
        return address - self.kernel_base
    
    def offset_to_address(self, offset: int) -> int:
        assert self.is_kernel_offset(offset)
        return self.kernel_base + offset
    
    def calculate_raw_references(self):
        self.raw_reference_map = defaultdict(list)

        for segment in self.segments:
            start_index = align_up(segment.vaddr, self.arch_info.word_size()) - segment.vaddr

            # look only at word aligned data for addresses
            for index in range(start_index, len(segment.file_data), self.arch_info.word_size()):
                data = segment.file_data[index:index + self.arch_info.word_size()]
                if len(data) != self.arch_info.word_size():
                    continue

                from_address = segment.vaddr + index
                to_address = self.arch_info.unpack_usize(data)

                if self.is_kernel_address(to_address):
                    self.raw_reference_map[to_address].append(from_address)

    def get_symbol(self, name: str) -> Optional[Symbol]:
        if name in self.symbol_index_map:
            return self.symbols[self.symbol_index_map[name]]
        else:
            return None

    def find_previous_symbol_offset(self, offset: int) -> Optional[Symbol]:
        return self.find_previous_symbol_absolute(self.kernel_base + offset)
    
    def find_previous_symbol_absolute(self, address: int) -> Optional[Symbol]:
        index = bisect.bisect_right(self.symbols, address, key = lambda symbol: symbol.address) - 1
        if index >= 0:
            return self.symbols[index]
        else:
            return None
    
    def segment_index(self, vaddr: int) -> Optional[int]:
        index = bisect.bisect_right(self.segments, vaddr, key=lambda segment: segment.vaddr) - 1

        if index >= 0 and vaddr < self.segments[index].end_vaddr():
            return index
        else:
            return None
    
    def containing_segment(self, vaddr: int) -> Optional[Segment]:
        index = self.segment_index(vaddr)
        if index is None:
            return None
        else:
            return self.segments[index]
    
    def get_bytes(self, vaddr: int, size: int) -> Optional[bytes]:
        segment = self.containing_segment(vaddr)
        if segment is None:
            return None
        
        index = vaddr - segment.vaddr
        # FIXME: handle region of bytes overlapping multiple segments
        return segment.file_data[index:index + size]
    
    def get_word(self, vaddr: int) -> Optional[int]:
        bytes = self.get_bytes(vaddr, self.arch_info.word_size())
        if bytes is None:
            return None
        
        return self.arch_info.unpack_usize(bytes)
    
    def is_executable_address(self, address: int) -> bool:
        segment = self.containing_segment(address)
        if segment is None:
            return False
        else:
            return segment.exec
    
    # returns generator returning addresses which have data matching the given bytes
    def find_bytes(self, search_bytes: bytes) -> Generator[int, None, None]:
        for segment in self.segments:
            for index in bytes_findall(segment.file_data, search_bytes):
                yield segment.vaddr + index
        
        return None
    
    # finds references using ghidra and just searching for raw bytes
    # ghidra sometimes does not find all references from data to other data
    def find_references(self, ghidra_api: GhidraApi, address: int) -> list[Reference]:
        references = ghidra_api.references_to_address(address)
        found_references = set(reference.from_address for reference in references)

        raw_references = [
            Reference(
                from_address=from_address,
                to_address=address,
                ref_type=RefType.RAW,
            )
            for from_address in self.raw_reference_map.get(address) or []
            if from_address not in found_references
        ]

        return references + raw_references
    
    def find_references_before(self, ghidra_api: GhidraApi, address: int) -> list[Reference]:
        """Finds references to the nearest address before and including `address` which has references to it."""
        origingal_address = address

        # check at most 0x100 addresses backwards from original address
        while origingal_address - address < 0x100:
            references = self.find_references(ghidra_api, address)
            if len(references) != 0:
                return references
            
            address -= 1
        
        return []

    def dissasemble_region(self, address: int, length: int) -> Optional[list[CsInsn]]:
        # TODO: handle dissasemble across segments
        segment = self.containing_segment(address)
        if segment is None or not segment.exec:
            return None
        else:
            dissasembler = self.arch_info.get_disassembler()
            file_offset = address - segment.vaddr
            if file_offset >= len(segment.file_data):
                return None

            return list(dissasembler.disasm(segment.file_data[file_offset:file_offset+length], address))
    
    def get_rop_ending_type(self, address: int) -> 'RopEndingType':
        instructions = self.dissasemble_region(address, 0x20)
        if instructions is None or len(instructions) == 0:
            return RopEndingType.NON_INSTRUCTION
        instruction = instructions[0]

        if instruction.mnemonic == 'ret':
            return RopEndingType.RET
        elif instruction.mnemonic == 'jmp' and len(instruction.operands) == 1:
            operand = instruction.operands[0]

            if operand.type == X86_OP_IMM:
                # for jmp capstone already converted immediate to target address,
                # but python interpertets it as signed so, fix sign issue if it is negative
                address = operand.imm
                if address < 0:
                    address += 2**64
                
                rop_type = self.get_rop_ending_type(address)
                if rop_type == RopEndingType.RET:
                    return RopEndingType.RET
                else:
                    return RopEndingType.JMP_TO_NON_RET
            else:
                return RopEndingType.NON_ABSOLUTE_JMP
        else:
            return RopEndingType.UNKNOWN
    

    def is_rop_chain_address(self, vaddr: int) -> bool:
        segment = self.containing_segment(vaddr)
        symbol = self.find_previous_symbol_absolute(vaddr)
        
        # if vaddr points to address in executable section, but not at the start of a function,
        # it is probably a rop gadget
        return segment is not None and symbol is not None and segment.exec and symbol.address != vaddr

    def get_rop_chain_instructions(self, address: int) -> Optional[str]:
        """
        Gets rop gadget instructions if the given addreess seems to point to a rop/jop gadget.

        Returns `None` if instructions do not look like a rop gadget instructions
        """
        assert self.arch_info.rop_translation_supported(), "Rop translation not supported on arm"

        if not self.is_rop_chain_address(address):
            return None

        disasm_instructions = self.dissasemble_region(address, 0x100)
        if disasm_instructions is None:
            raise AdaptError('Could not get rop chain instructions for address which is not in binary')

        rop_end_instructions = set([
            'ret',
            'jmp',
        ])

        instructions = []
        for instruction in disasm_instructions:
            instructions.append(instruction)

            # branch instruction signifies end of rop / jop gadget
            if instruction.mnemonic in rop_end_instructions:
                rop_type = self.get_rop_ending_type(instruction.address)

                if rop_type not in set([RopEndingType.RET, RopEndingType.NON_ABSOLUTE_JMP]):
                    return None
                else:
                    return '; '.join(f'{instruction.mnemonic} {instruction.op_str}' for instruction in instructions)
        
        # gadget too long without terminal being encountered
        return None
    
    def get_rop_chain_instructions_offset(self, offset: int) -> Optional[str]:
        return self.get_rop_chain_instructions(self.kernel_base + offset)

class RopEndingType(Enum):
    """Conveys the type of rop gadget a sequence of instructions is based on its terminating instruction."""

    # ret or jmp to ret gadget
    RET = 0
    # absolute jump to non return address
    JMP_TO_NON_RET = 1
    # non absulote jmp, so probably jop
    NON_ABSOLUTE_JMP = 2
    # random potentially non branching instruction
    UNKNOWN = 3
    # the address doesn't point to instructions at all
    NON_INSTRUCTION = 4

@dataclass
class ReferenceChainElement:
    # reference has from address and to address
    reference: Reference
    # this is offset from to address to next reference from address
    dst_offset: int

@dataclass
class CodeToDataReference:
    symbol: Symbol
    reference_chain: list[ReferenceChainElement]

    def start_from_address(self) -> int:
        return self.reference_chain[0].reference.from_address

# Indicates exploit annotation could not be adapted from 1 kernel to another
class AdaptError(Exception):
    message: str

    def __init__(self, message):
        self.message = message
        super().__init__(message)

class KernelAdapter:
    src_image: KernelImage
    dst_image: KernelImage

    def __init__(self, src_kernel: Kernel, dst_kernel: Kernel):
        # original image exploit was made for
        self.src_image = KernelImage(src_kernel)

        # new kernel image to adapt exploit to
        self.dst_image = KernelImage(dst_kernel)
    
    # raises AdaptError if rop gadget could not be translated
    def translate_rop_gadget(self, instructions_str: str) -> int:
        assert self.src_image.arch_info.rop_translation_supported() and self.dst_image.arch_info.rop_translation_supported(), "Rop translation not supported on arm"

        instructions = instructions_str.split('; ')

        last_instruction = instructions[-1].strip()
        last_operands = last_instruction.split()
        # if we want a gadget that just returns, jmp to return or return itself is interchangable
        tail_jump_or_ret = (
            (len(last_operands) == 2 and last_operands[0] == 'jmp' and last_operands[1].startswith('0x'))
            or (len(last_operands) == 1 and last_operands[0] == 'ret')
        )
        if tail_jump_or_ret:
            instructions = instructions[:-1]

        assembler = self.src_image.arch_info.get_assembler()
        # TODO: handle relative jmp at end to return address
        encoding, _count = assembler.asm('; '.join(instructions))

        if encoding is None:
            raise AdaptError('Invald rop gadget instruction')
        
        encoding = bytes(encoding)

        for address in self.dst_image.find_bytes(bytes(encoding)):
            # if tail jump does not jump to return address, ignore
            if tail_jump_or_ret and self.dst_image.get_rop_ending_type(address + len(encoding)) != RopEndingType.RET:
                continue

            return address
        
        raise AdaptError('Could not find matching rop gadget')

    def translate_rop_gadget_offset(self, instructions: str) -> int:
        return self.translate_rop_gadget(instructions) - self.dst_image.kernel_base
    
    def find_code_symbol_referencing_data(self, ghidra_api: GhidraApi, address: int) -> Optional[CodeToDataReference]:
        address_queue: list[tuple[int, list[ReferenceChainElement]]] = [(address, [])]
        non_referenced_queue: list[tuple[int, list[ReferenceChainElement]]] = []

        visited_addresses = set()

        # BFS search back over data references until we find a code reference
        # which is present in both binaries
        while True:
            # if address queue is empty, try to fallback to non referenced queue
            # and search forward to find references that don't point exactly
            if len(address_queue) == 0 and len(non_referenced_queue) == 0:
                # no more references to follow
                break
            elif len(address_queue) == 0:
                address, reference_chain = non_referenced_queue.pop(0)
                references = self.src_image.find_references_before(ghidra_api, address)
                if len(references) == 0:
                    return None
            else:
                address, reference_chain = address_queue.pop(0)
                references = self.src_image.find_references(ghidra_api, address)
            
            visited_addresses.add(address)

            code_refs = [reference for reference in references if self.src_image.is_executable_address(reference.from_address)]

            for reference in code_refs:
                symbol = self.src_image.find_previous_symbol_absolute(reference.from_address)
                if symbol is not None and self.dst_image.get_symbol(symbol.name) is not None:
                    return CodeToDataReference(
                        symbol=symbol,
                        reference_chain=([ReferenceChainElement(reference, address - reference.to_address)] + reference_chain)
                    )
            
            # TODO: don't copy reference chain for every reference
            # this degrades perfomance to quadriatic or something like that I think
            # chains are for now very short though so it doesn't matter
            address_queue.extend(
                (reference.from_address, [ReferenceChainElement(reference, address - reference.to_address)] + reference_chain)
                for reference in references
                if not self.src_image.is_executable_address(reference.from_address)
                    and not reference.from_address in visited_addresses
            )

            if len(references) == 0:
                non_referenced_queue.append((address, reference_chain))
        
        return None

    # translates an address in the data section, without relying on data symbols
    # needed when either src or dst kernel image does not have symbols for data section
    def translate_data_address_no_syms(self, address: int) -> int:
        with self.src_image.ghidra as src_ghidra, self.dst_image.ghidra as dst_ghidra:
            data_ref = self.find_code_symbol_referencing_data(src_ghidra, address)
            if data_ref is None:
                raise AdaptError('Could not find code reference for data address')
            
            src_function = src_ghidra.get_function(data_ref.symbol.address)
            src_basic_blocks = src_ghidra.get_basic_blocks(src_function)

            src_block_index = src_basic_blocks.block_index_for_address(src_ghidra.to_address(data_ref.start_from_address()))
            if src_block_index is None:
                # TODO: retry on different symbol
                raise AdaptError('Data reference block index outside of function')
            
            characteristic = src_basic_blocks.block_characteristic(src_ghidra, src_block_index)

            dst_symbol = self.dst_image.get_symbol(data_ref.symbol.name)
            assert dst_symbol is not None

            dst_function = dst_ghidra.get_function(dst_symbol.address)
            dst_function_refs = [
                reference for reference in
                dst_ghidra.references_in_function(dst_function)
                if reference.ref_type == data_ref.reference_chain[0].reference.ref_type
            ]
            dst_basic_blocks = dst_ghidra.get_basic_blocks(dst_function)

            # mapping from basic block index to list of refs it has
            dst_ref_index_map = defaultdict(list)
            for ref in dst_function_refs:
                block_index = dst_basic_blocks.block_index_for_address(dst_ghidra.to_address(ref.from_address))
                if block_index is None:
                    continue

                dst_ref_index_map[block_index].append(ref)
            
            dst_block_characteristics = [
                dst_basic_blocks.block_characteristic(dst_ghidra, block_index)
                for block_index in dst_ref_index_map.keys()
            ]
            
            # match basic blocks based on characteristic
            matching_characteristic = characteristic.closest_match(dst_block_characteristics)
            if matching_characteristic is None:
                # TODO: retry on different symbol
                raise AdaptError('Could not find matching basic block reference for translating data address')
            
            matching_block = dst_basic_blocks.block_index(matching_characteristic.block)
            assert matching_block is not None
            matching_refs = dst_ref_index_map[matching_block]
            
            # match references based on characteristic
            target_ref_characteristic = src_basic_blocks.reference_characteristic(src_ghidra, data_ref.reference_chain[0].reference)
            matching_refs_characteristics = [
                dst_basic_blocks.reference_characteristic(dst_ghidra, reference) for reference in matching_refs
            ]
            
            matching_ref_characteristic = target_ref_characteristic.match(matching_refs_characteristics)
            if matching_ref_characteristic is None:
                raise AdaptError('Could not match references in basic block')
            matching_ref = matching_ref_characteristic.reference

            # reference is now found, trace reference chain back to data address we are interested in
            current_address = matching_ref.to_address + data_ref.reference_chain[0].dst_offset
            for original_reference in data_ref.reference_chain[1:]:
                if original_reference.reference.ref_type == RefType.RAW:
                    new_address = self.dst_image.get_word(current_address)
                    if new_address is None:
                        raise AdaptError('Reference chain does not match in new kernel')
                    
                    current_address = new_address + original_reference.dst_offset
                else:
                    new_ref = dst_ghidra.deref(current_address)
                    if new_ref is None:
                        raise AdaptError('Reference chain does not match in new kernel')
                    
                    current_address = new_ref.to_address + original_reference.dst_offset

            return current_address

    def translate_address(self, address: int) -> int:
        segment = self.src_image.containing_segment(address)
        if segment is None:
            raise AdaptError('Address to translate does not point in kernel loadable segment')
        
        if not segment.exec and not (self.src_image.kallsyms_all and self.dst_image.kallsyms_all):
            return self.translate_data_address_no_syms(address)

        index = bisect.bisect_right(self.src_image.symbols, address, key = lambda symbol: symbol.address) - 1

        # find first symbol before address which exists in both images
        # use that as base to translate the address
        while index >= 0:
            symbol = self.src_image.symbols[index]
            address_diff = address - symbol.address

            # this likely means an incorrect value was annotated
            if abs(address_diff) > 0x10_000:
                raise AdaptError('Very large address diff, ignoring address')

            new_symbol = self.dst_image.get_symbol(symbol.name)
            if new_symbol is not None:
                return new_symbol.address + address_diff
            
            index -= 1

        raise AdaptError('No matching symbol found')
    
    def translate_offset(self, offset: int) -> int:
        return self.translate_address(self.src_image.kernel_base + offset) - self.dst_image.kernel_base

def add_kernel(image_path: Path, name: Optional[str]):
    if name is None:
        name = os.path.basename(image_path)
    
    print(f'Adding kernel `{name}`')
    kernel = Kernel(name)
    
    if kernel.exists():
        console.error('Kernel with given name already exists')
        return
    
    kernel.install_kernel_image(image_path)
    kernel.install_kernel_elf()

def get_kernel_names():
    return os.listdir(kernel_elf_dir())

def list_kernels():
    for kernel_name in get_kernel_names():
        print(kernel_name)