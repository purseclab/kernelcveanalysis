from dataclasses import dataclass
from enum import Enum, StrEnum
from pathlib import Path
from typing import Self, Optional
import bisect

from elftools.elf.elffile import ELFFile

class ElfConstants(StrEnum):
    ELF_64 = 'ELFCLASS64'
    ELF_AARCH64 = 'EM_AARCH64'
    ELF_X86_64 = 'EM_X86_64'

class ArchType(Enum):
    AARCH64 = 0
    X86_64 = 1

@dataclass
class ArchInfo:
    arch_type: ArchType
    kernel_base_mask: int

    @classmethod
    def from_elf_file(cls, elf_file: ELFFile) -> Optional[Self]:
        match elf_file['e_ident']['EI_CLASS'], elf_file['e_machine']:
            case ElfConstants.ELF_64, ElfConstants.ELF_AARCH64:
                return cls(
                    arch_type=ArchType.AARCH64,
                    kernel_base_mask=0xffffffc000000000,
                )
            case ElfConstants.ELF_64, ElfConstants.ELF_X86_64:
                return cls(
                    arch_type=ArchType.X86_64,
                    # FIXME: get correct value for x86_64
                    kernel_base_mask=0xffffffc000000000,
                )
            case _:
                return None
    
    def is_kernel_address(self, address: int) -> bool:
        return address & self.kernel_base_mask == self.kernel_base_mask

@dataclass
class Symbol:
    name: str
    address: int
    offset: int

@dataclass
class KernelImage:
    arch_info: ArchInfo
    # elf_data: ELFFile
    # symbol_table: SymbolTableSection
    symbol_index_map: dict[str, int]
    # sorted list of symbols
    symbols: list[Symbol]
    kernel_base: int

    @classmethod
    def from_file(cls, file: Path) -> Self:
        elf_file = ELFFile.load_from_path(file)
        symbol_table = elf_file.get_section_by_name(".symtab")

        ArchInfo.from_elf_file(elf_file)

        symbols = [
            # fill out offset later
            Symbol(symbol.name, symbol['st_value'], 0) for symbol in symbol_table.iter_symbols()
        ]
        symbols.sort(key = lambda symbol: symbol.address)
        symbol_index_map = { symbol.name: i for i, symbol in enumerate(symbols) }

        kernel_base = symbols[symbol_index_map["_head"]].address
        for symbol in symbols:
            symbol.offset = symbol.address - kernel_base

        return cls(
            arch_info=ArchInfo.from_elf_file(elf_file),
            symbol_index_map=symbol_index_map,
            symbols=symbols,
            kernel_base=kernel_base,
        )

    def get_symbol(self, name: str) -> Optional[Symbol]:
        if name in self.symbol_index_map:
            return self.symbols[self.symbol_index_map[name]]
        else:
            return None

    def find_previous_symbol_offset(self, offset: int) -> Symbol:
        index = bisect.bisect_left(self.symbols, offset, key = lambda symbol: symbol.offset)
        return self.symbols[index]
    
    def find_previous_symbol_absolute(self, address: int) -> Symbol:
        return self.find_previous_symbol_offset(address - self.kernel_base)

class KernelAdapter:
    src_image: KernelImage
    dst_image: KernelImage

    def __init__(self, src_file: Path, dst_file: Path):
        # original image exploit was made for
        self.src_image = KernelImage.from_file(src_file)

        # new kernel image to adapt exploit to
        self.dst_image = KernelImage.from_file(dst_file)
    
    # TODO: translate references to code differently
    # look for similar instruction sequences instead
    def translate_offset(self, offset: int) -> int:
        index = bisect.bisect_right(self.src_image.symbols, offset, key = lambda symbol: symbol.offset) - 1

        # find first symbol before address which exists in both images
        # use that as base to translate the offset
        while index >= 0:
            symbol = self.src_image.symbols[index]
            offset_diff = offset - symbol.offset

            # this likely means an incorrect value was annotated
            if abs(offset_diff) > 0x1000_000:
                print('Warning: very large offset diff, ignoring address')
                return offset

            new_symbol = self.dst_image.get_symbol(symbol.name)
            if new_symbol is not None:
                return new_symbol.offset + offset_diff
            
            index -= 1

        assert False, 'Could not translate offset'
    
    def translate_address(self, address: int) -> int:
        return self.translate_offset(address - self.src_image.kernel_base) + self.dst_image.kernel_base