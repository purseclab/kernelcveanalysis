from dataclasses import dataclass
from enum import Enum, StrEnum
from pathlib import Path
from typing import Self, Optional
import bisect

from elftools.elf.elffile import ELFFile
from elftools.elf.segments import Segment as ElfSegment
from capstone import Cs, CsInsn, CS_ARCH_ARM64, CS_MODE_ARM, CS_ARCH_X86, CS_MODE_64
from capstone.x86 import X86_OP_IMM
from keystone import Ks, KS_ARCH_ARM64, KS_MODE_ARM, KS_ARCH_X86, KS_MODE_64

class ElfConstants(StrEnum):
    ELF_64 = 'ELFCLASS64'
    ELF_AARCH64 = 'EM_AARCH64'
    ELF_X86_64 = 'EM_X86_64'

class ArchType(Enum):
    AARCH64 = 0
    X86_64 = 1

# flags deremining segment rwx in phdr.p_flags
ELF_FLAGS_READ = 4
ELF_FLAGS_WRITE = 2
ELF_FLAGS_EXEC = 1

@dataclass
class AssemblerConstants:
    asm_arch: int
    asm_mode: int
    disasm_arch: int
    disasm_mode: int

@dataclass
class ArchInfo:
    arch_type: ArchType
    kernel_base_mask: int
    kernel_base_symbol: str
    page_size: int

    assembler_constants: AssemblerConstants

    @classmethod
    def from_elf_file(cls, elf_file: ELFFile) -> Optional[Self]:
        match elf_file['e_ident']['EI_CLASS'], elf_file['e_machine']:
            case ElfConstants.ELF_64, ElfConstants.ELF_AARCH64:
                return cls(
                    arch_type=ArchType.AARCH64,
                    kernel_base_mask=0xffffffc000000000,
                    kernel_base_symbol='_head',
                    page_size=4096,
                    assembler_constants=AssemblerConstants(
                        asm_arch=KS_ARCH_ARM64,
                        asm_mode=KS_MODE_ARM,
                        disasm_arch=CS_ARCH_ARM64,
                        disasm_mode=CS_MODE_ARM,
                    ),
                )
            case ElfConstants.ELF_64, ElfConstants.ELF_X86_64:
                return cls(
                    arch_type=ArchType.X86_64,
                    # FIXME: get correct value for x86_64
                    kernel_base_mask=0xffffffc000000000,
                    kernel_base_symbol='_stext',
                    page_size=4096,
                    assembler_constants=AssemblerConstants(
                        asm_arch=KS_ARCH_X86,
                        asm_mode=KS_MODE_64,
                        disasm_arch=CS_ARCH_X86,
                        disasm_mode=CS_MODE_64,
                    ),
                )
            case _:
                return None
    
    def is_kernel_address(self, address: int) -> bool:
        # Ignore address which is too big
        return (address & self.kernel_base_mask == self.kernel_base_mask) and (address < 0xfffffffffff00000)
    
    def get_assembler(self) -> Ks:
        assembler = Ks(self.assembler_constants.asm_arch, self.assembler_constants.asm_mode)
        return assembler
    
    def get_disassembler(self) -> Cs:
        disassembler = Cs(self.assembler_constants.disasm_arch, self.assembler_constants.disasm_mode)
        disassembler.detail = True
        return disassembler

@dataclass
class Symbol:
    name: str
    address: int
    offset: int

class Segment:
    vaddr: int
    size: int
    read: bool
    write: bool
    exec: bool
    file_data: bytes

    def __init__(self, segment: ElfSegment, arch_info: ArchInfo):
        self.vaddr = segment['p_vaddr']
        self.size = self.vaddr + segment['p_memsz']

        flags = segment['p_flags']
        self.read = (flags & ELF_FLAGS_READ) != 0
        self.write = (flags & ELF_FLAGS_WRITE) != 0
        self.exec = (flags & ELF_FLAGS_EXEC) != 0

        self.file_data = segment.data()

    def end_vaddr(self) -> int:
        return self.vaddr + self.size

def align_up(address: int, align: int) -> int:
    return (address + align - 1) & ~(align - 1)

def align_down(address: int, align: int) -> int:
    return address & ~(align - 1)

@dataclass
class KernelImage:
    arch_info: ArchInfo
    # elf_data: ELFFile
    # symbol_table: SymbolTableSection
    symbol_index_map: dict[str, int]
    # sorted list of symbols
    symbols: list[Symbol]
    # loadable segments sorted by order of virtual address
    segments: list[Segment]
    kernel_base: int

    @classmethod
    def from_file(cls, file: Path) -> Self:
        elf_file = ELFFile.load_from_path(file)
        symbol_table = elf_file.get_section_by_name(".symtab")

        arch_info = ArchInfo.from_elf_file(elf_file)

        symbols = [
            # fill out offset later
            Symbol(symbol.name, symbol['st_value'], 0) for symbol in symbol_table.iter_symbols()
        ]
        symbols.sort(key = lambda symbol: symbol.address)
        symbol_index_map = { symbol.name: i for i, symbol in enumerate(symbols) }

        kernel_base = symbols[symbol_index_map[arch_info.kernel_base_symbol]].address
        for symbol in symbols:
            symbol.offset = symbol.address - kernel_base
        
        # collect segments and iterate in sorted order
        segments = []
        for segment in elf_file.iter_segments():
            if not segment['p_type'] == 'PT_LOAD':
                continue

            segments.append(Segment(segment, arch_info))

        segments.sort(key=lambda segment: segment.vaddr)

        return cls(
            arch_info=arch_info,
            symbol_index_map=symbol_index_map,
            symbols=symbols,
            segments=segments,
            kernel_base=kernel_base,
        )

    def get_symbol(self, name: str) -> Optional[Symbol]:
        if name in self.symbol_index_map:
            return self.symbols[self.symbol_index_map[name]]
        else:
            return None

    def find_previous_symbol_offset(self, offset: int) -> Optional[Symbol]:
        return self.find_previous_symbol_absolute(self.kernel_base + offset)
    
    def find_previous_symbol_absolute(self, address: int) -> Optional[Symbol]:
        index = bisect.bisect_right(self.symbols, address, key = lambda symbol: symbol.address) - 1
        if index >= 0:
            return self.symbols[index]
        else:
            return None
    
    def segment_index(self, vaddr: int) -> Optional[int]:
        index = bisect.bisect_right(self.segments, vaddr, key=lambda segment: segment.vaddr) - 1

        if index >= 0 and vaddr < self.segments[index].end_vaddr():
            return index
        else:
            return None
    
    def containing_segment(self, vaddr: int) -> Optional[Segment]:
        index = self.segment_index(vaddr)
        if index is None:
            return None
        else:
            return self.segments[index]
    
    def is_rop_chain_address(self, vaddr: int) -> bool:
        segment = self.containing_segment(vaddr)
        symbol = self.find_previous_symbol_absolute(vaddr)
        
        # if vaddr points to address in executable section, but not at the start of a function,
        # it is probably a rop gadget
        return segment is not None and symbol is not None and segment.exec and symbol.address != vaddr
    
    def is_rop_chain_offset(self, offset: int) -> bool:
        return self.is_rop_chain_address(self.kernel_base + offset)
    
    # TODO: find instruction type
    def dissasemble_region(self, address: int, length: int) -> Optional[list[CsInsn]]:
        segment = self.containing_segment(address)
        if segment is None or not segment.exec:
            return None
        else:
            dissasembler = self.arch_info.get_disassembler()
            file_offset = address - segment.vaddr

            return list(dissasembler.disasm(segment.file_data[file_offset:file_offset+length], address))
    
    def is_ret_or_jmp_to_ret(self, address: int) -> bool:
        instructions = self.dissasemble_region(address, 0x20)
        if instructions is None:
            return False
        instruction = instructions[0]

        if instruction.mnemonic == 'ret':
            return True
        elif instruction.mnemonic == 'jmp' and len(instruction.operands) == 1:
            operand = instruction.operands[0]

            if operand.type == X86_OP_IMM:
                # for jmp capstone already converted immediate to target address,
                # but python interpertets it as signed so, fix sign issue if it is negative
                address = operand.imm
                if address < 0:
                    address += 2**64
                return self.is_ret_or_jmp_to_ret(address)
            else:
                return False
        else:
            return False

    def get_rop_chain_instructions(self, address: int) -> str:
        assert self.arch_info.arch_type == ArchType.X86_64, "Rop translation not supported on arm"

        segment = self.containing_segment(address)
        if segment is None:
            return None

        dissasembler = self.arch_info.get_disassembler()

        rop_end_instructions = set([
            'ret',
            'jmp',
        ])

        data_offset = address - segment.vaddr
        # dissasemble just a set amount of instructions forward, rop gadget is not that big
        # TODO: handle large rop gadgets, and rop gadgets spanning across elf segments
        instructions = []
        for instruction in dissasembler.disasm(segment.file_data[data_offset:data_offset+0x100], address):
            instructions.append(instruction)

            # branch instruction signifies end of rop / jop gadget
            if instruction.mnemonic in rop_end_instructions:
                break

        return '; '.join(f'{instruction.mnemonic} {instruction.op_str}' for instruction in instructions)
    
    def get_rop_chain_instructions_offset(self, offset: int) -> str:
        return self.get_rop_chain_instructions(self.kernel_base + offset)
        

class KernelAdapter:
    src_image: KernelImage
    dst_image: KernelImage

    def __init__(self, src_file: Path, dst_file: Path):
        # original image exploit was made for
        self.src_image = KernelImage.from_file(src_file)

        # new kernel image to adapt exploit to
        self.dst_image = KernelImage.from_file(dst_file)
    
    def translate_rop_gadget(self, instructions: str) -> Optional[int]:
        assert self.src_image.arch_info.arch_type == ArchType.X86_64 and self.dst_image.arch_info.arch_type == ArchType.X86_64, "Rop translation not supported on arm"

        instructions = instructions.split('; ')

        last_instruction = instructions[-1].strip()
        last_operands = last_instruction.split()
        tail_jump = len(last_operands) == 2 and last_operands[0] == 'jmp' and last_operands[1].startswith('0x')
        if tail_jump:
            instructions = instructions[:-1]

        assembler = self.src_image.arch_info.get_assembler()
        # TODO: handle relative jmp at end to return address
        encoding, _count = assembler.asm('; '.join(instructions))
        encoding = bytes(encoding)

        for segment in self.dst_image.segments:
            index = segment.file_data.find(bytes(encoding))
            if index == -1:
                continue

            # if tail jump does not jump to return address, ignore
            if tail_jump and not self.dst_image.is_ret_or_jmp_to_ret(segment.vaddr + index + len(encoding)):
                continue

            return segment.vaddr + index
        
        return None

    def translate_rop_gadget_offset(self, instructions: str) -> Optional[int]:
        result = self.translate_rop_gadget(instructions)
        if result is None:
            return None
        else:
            return result - self.dst_image.kernel_base

    # TODO: translate references to code differently
    # look for similar instruction sequences instead
    def translate_address(self, address: int) -> int:
        index = bisect.bisect_right(self.src_image.symbols, address, key = lambda symbol: symbol.address) - 1

        # find first symbol before address which exists in both images
        # use that as base to translate the address
        while index >= 0:
            symbol = self.src_image.symbols[index]
            address_diff = address - symbol.address
            print(symbol)
            print(address_diff)

            # this likely means an incorrect value was annotated
            if abs(address_diff) > 0x1000_000:
                print('Warning: very large address diff, ignoring address')
                return address

            new_symbol = self.dst_image.get_symbol(symbol.name)
            if new_symbol is not None:
                return new_symbol.address + address_diff
            
            index -= 1

        assert False, 'Could not translate address'
    
    def translate_offset(self, offset: int) -> int:
        return self.translate_address(self.src_image.kernel_base + offset) - self.dst_image.kernel_base
