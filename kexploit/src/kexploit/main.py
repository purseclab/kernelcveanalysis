from pathlib import Path
from typing_extensions import Annotated
from difflib import unified_diff
import os

from dotenv import load_dotenv
import typer

from .kernel_image import KernelAdapter
from .rewrite_rules import gen_rewrite_rules, apply_rewrites
from .parse import lex
from .kernel_image import add_kernel, list_kernels
from .tui import console
from . import annotate as annotate_module
from . import syzkall

app = typer.Typer()

# subcommand groups
kernel_commands = typer.Typer()
syzkall_commands = typer.Typer()

app.add_typer(kernel_commands, name="kernel")
app.add_typer(syzkall_commands, name="syzkall")

@app.command()
def adapt(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to adapt")],
    old_kernel: Annotated[str, typer.Option(help="Name of kernel original exploit was made for")],
    new_kernel: Annotated[str, typer.Option(help="Name of new kernel to adapt exploit to")],
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
    o: Annotated[Path, typer.Option(help="Output file for exploit diff")] = Path("new_exploit.diff"),
):
    diff = ''

    adapter = KernelAdapter(old_kernel, new_kernel)
    rewrites = gen_rewrite_rules(adapter)

    for file in exploit_files:
        # if kexploit.h is globbed in exploit_files, ignore
        if os.path.basename(file) == 'kexploit.h':
            continue

        with open(file, 'r') as f:
            exploit_code = f.read()

        lexed_code = lex(file, exploit_code)
        new_code = apply_rewrites(rewrites, lexed_code)

        for diff_line in unified_diff(
            exploit_code.split('\n'),
            new_code.split('\n'),
            fromfile=str(file),
            tofile=str(file),
            lineterm='',
        ):
            diff += diff_line + '\n'
        
        if apply:
            with open(file, 'w') as f:
                f.write(new_code)

    console.print_diff(diff)

    with open(o, 'w') as f:
        f.write(diff)

@app.command()
def annotate(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to annotate")],
    kernel: Annotated[str, typer.Option(help="Name of kernel original exploit was made for")],
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
):
    annotate_module.annotate(exploit_files, kernel, apply)

@kernel_commands.command()
def add(
    kernel_path: Annotated[Path, typer.Argument(help="Path to kernel image to import")],
    name: Annotated[str, typer.Option(help="Name to use for added kernel")] = None,
):
    add_kernel(kernel_path, name)

@kernel_commands.command()
def list():
    list_kernels()

# TODO: decide if this will even be apart of kexploit
@syzkall_commands.command()
def pull(
    syzkall_kernel: Annotated[str, typer.Option(help='Kernel name to pull bugs for')] = 'upstream',
):
    syzkall.pull(syzkall_kernel)

# Probably temprorary command
@syzkall_commands.command()
def query():
    syzkall.query()

# Probably temprorary command
@syzkall_commands.command()
def test(
    bug_id: Annotated[str, typer.Argument(help='Bug ID to test')],
):
    syzkall.test(bug_id)

def main():
    load_dotenv()
    app()

if __name__ == "__main__":
    main()
