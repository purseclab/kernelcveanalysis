from pathlib import Path
from typing import Optional
from typing_extensions import Annotated

from dotenv import load_dotenv
import typer

from .kernel_image import KernelAdapter
from .rewrite_rules import gen_rewrite_rules, apply_rewrites
from .parse import ExploitFileError, ExploitFileGroup
from .kernel_image import add_kernel, list_kernels
from .tui import console
from . import annotate as annotate_module
from . import syzkall

app = typer.Typer()

# subcommand groups
kernel_commands = typer.Typer()
syzkall_commands = typer.Typer()

app.add_typer(kernel_commands, name="kernel")
app.add_typer(syzkall_commands, name="syzkall")

@app.command()
def adapt(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to adapt")],
    new_kernel: Annotated[str, typer.Option(help="Name of new kernel to adapt exploit to")],
    old_kernel: Annotated[Optional[str], typer.Option(help="Name of kernel original exploit was made for")] = None,
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
    o: Annotated[Path, typer.Option(help="Output file for exploit diff")] = Path("new_exploit.diff"),
):
    files = ExploitFileGroup(exploit_files)

    if old_kernel is None:
        try:
            old_kernel = files.get_src_kernel_name()
        except ExploitFileError as e:
            console.error(f'Could not determine old kernel: {e.message}')
            return

    adapter = KernelAdapter(old_kernel, new_kernel)
    rewrites = gen_rewrite_rules(adapter)
    
    files.rewrite_files(
        lambda code: apply_rewrites(rewrites, code),
        diff_output=o,
        apply_diff=apply,
    )

@app.command()
def annotate(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to annotate")],
    kernel: Annotated[str, typer.Option(help="Name of kernel original exploit was made for")],
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
    o: Annotated[Path, typer.Option(help="Output file for exploit diff")] = Path("new_exploit.diff"),
):
    annotate_module.annotate(exploit_files, kernel, o, apply)

@kernel_commands.command()
def add(
    kernel_path: Annotated[Path, typer.Argument(help="Path to kernel image to import")],
    name: Annotated[str, typer.Option(help="Name to use for added kernel")] = None,
):
    add_kernel(kernel_path, name)

@kernel_commands.command()
def list():
    list_kernels()

# TODO: decide if this will even be apart of kexploit
@syzkall_commands.command()
def pull(
    syzkall_kernel: Annotated[str, typer.Option(help='Kernel name to pull bugs for')] = 'upstream',
):
    syzkall.pull(syzkall_kernel)

# Probably temprorary command
@syzkall_commands.command()
def query():
    syzkall.query()

# Probably temprorary command
@syzkall_commands.command()
def test(
    bug_id: Annotated[str, typer.Argument(help='Bug ID to test')],
):
    syzkall.test(bug_id)

def main():
    load_dotenv()
    app()

if __name__ == "__main__":
    main()
