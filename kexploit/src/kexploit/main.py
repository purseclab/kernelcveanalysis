from pathlib import Path
from typing import Optional
from typing_extensions import Annotated

from dotenv import load_dotenv
import typer

from .parse import DiffMode
from .kernel_image import add_kernel, list_kernels
from .kernelctf_test import test_adapt_exploits
from . import annotate as annotate_module
from . import rewrite_rules
from . import syzkall

app = typer.Typer()

# subcommand groups
kernel_commands = typer.Typer()
syzkall_commands = typer.Typer()

app.add_typer(kernel_commands, name="kernel")
app.add_typer(syzkall_commands, name="syzkall")

@app.command()
def adapt(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to adapt")],
    new_kernel: Annotated[str, typer.Option(help="Name of new kernel to adapt exploit to")],
    old_kernel: Annotated[Optional[str], typer.Option(help="Name of kernel original exploit was made for")] = None,
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
    o: Annotated[Path, typer.Option(help="Output file for exploit diff")] = Path("new_exploit.diff"),
):
    if apply:
        diff_mode = DiffMode.ASK_APPLY_DIFF
    else:
        diff_mode = DiffMode.SHOW_DIFF

    rewrite_rules.adapt(exploit_files, old_kernel, new_kernel, o, diff_mode)

@app.command()
def annotate(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to annotate")],
    kernel: Annotated[str, typer.Option(help="Name of kernel original exploit was made for")],
    llm: Annotated[bool, typer.Option(help="Use ChatGPT API to identify addresses and offsets when annotating exploit")] = True,
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
    o: Annotated[Path, typer.Option(help="Output file for exploit diff")] = Path("new_exploit.diff"),
):
    if apply:
        diff_mode = DiffMode.ASK_APPLY_DIFF
    else:
        diff_mode = DiffMode.SHOW_DIFF

    annotate_module.annotate(exploit_files, kernel, llm, o, diff_mode)

@app.command()
def kernelctf_test(
    force_annotate: Annotated[bool, typer.Option(help="Force annotation to run even if annotated exploit code already exists")] = False,
    llm: Annotated[bool, typer.Option(help="Use ChatGPT API to identify addresses and offsets when annotating exploit")] = True,
    test_original: Annotated[bool, typer.Option(help="Make sure original version of exploit works against intended kernel when compiled")] = False,
):
    test_adapt_exploits(force_annotate, llm, test_original)

@kernel_commands.command()
def add(
    kernel_path: Annotated[Path, typer.Argument(help="Path to kernel image to import")],
    name: Annotated[Optional[str], typer.Option(help="Name to use for added kernel")] = None,
):
    add_kernel(kernel_path, name)

@kernel_commands.command(name='list')
def list_kernels_command():
    list_kernels()

# TODO: decide if this will even be apart of kexploit
@syzkall_commands.command()
def pull(
    syzkall_kernel: Annotated[str, typer.Option(help='Kernel name to pull bugs for')] = 'upstream',
):
    syzkall.pull(syzkall_kernel)

# Probably temprorary command
@syzkall_commands.command()
def query():
    syzkall.query()

# Probably temprorary command
@syzkall_commands.command()
def test(
    bug_id: Annotated[str, typer.Argument(help='Bug ID to test')],
):
    syzkall.test(bug_id)

# Probably temprorary command
@syzkall_commands.command()
def testall():
    syzkall.test_all()

def main():
    load_dotenv()
    app()

if __name__ == "__main__":
    main()
