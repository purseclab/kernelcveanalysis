# Test exploit adaptation using kernelctf exploits

from typing import Self, Optional
from dataclasses import dataclass
from pathlib import Path
from enum import StrEnum
import subprocess
import shutil
import tempfile
import glob
import json
import os

import requests

from .kernel_image import get_kernel_names, add_kernel
from .parse import DiffMode
from .annotate import annotate
from .rewrite_rules import adapt
from .tui import console

def kernelctf_exploits_dir() -> Path:
    return Path(os.environ['KERNELCTF_EXPLOITS_DIR'])

def kernelctf_similator_dir() -> Path:
    return Path(os.environ['KERNELCTF_SIMULATOR_DIR'])

class KernelCtfEnv(StrEnum):
    LTS = 'lts'
    COS = 'cos'
    MITIGATION = 'mitigation'

KEXPLOIT_H_CONTENTS = '''
#ifndef KEXPLOIT_H
#define KEXPLOIT_H

// metadata is string containing json metadata about src file
#define __kexploit_src_metadata(metadata)

// marks the input as a kernel address
#define __kexploit_kernel_address(address) address

// marks the input as a kernel offset
#define __kexploit_kernel_offset(offset) offset

// marks the input as an offset in a struct
#define __kexploit_struct_offset(offset) offset

// marks the input as an address for a rop / jop gadget
#define __kexploit_rop_address(address, gadget) address

// marks the input as an offset for a rop / jop gadget
#define __kexploit_rop_offset(offset, gadget) offset

#endif
'''

def kernel_name_for_kernelctf_kernel(kernelctf_kernel: str) -> str:
    if 'lts' in kernelctf_kernel:
        # the kernels I loaded in are lts and have lts written after kenrel name
        # I don't want to reload them so load them with this name
        return f'kernelctf_{kernelctf_kernel.split('-')[1]}_lts'
    else:
        return f'kernelctf_{kernelctf_kernel}'

def is_kernelctf_kernel_installed(kernelctf_kernel: str) -> bool:
    return kernel_name_for_kernelctf_kernel(kernelctf_kernel) in get_kernel_names()

def install_kernelctf_kernel(kernelctf_kernel):
    if is_kernelctf_kernel_installed(kernelctf_kernel):
        return
    
    url = f'https://storage.googleapis.com/kernelctf-build/releases/{kernelctf_kernel}/bzImage'
    with tempfile.NamedTemporaryFile() as f:
        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            for chunk in r.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
        
        add_kernel(f.name, kernel_name_for_kernelctf_kernel(kernelctf_kernel))

@dataclass
class KernelCtfExploitInfo:
    cve: str
    env: KernelCtfEnv
    kernelctf_kernel_name: str
    exploit_folder: Path
    requires_seperate_leak: bool
    reliability_info: str

    def name(self) -> str:
        return f'{self.cve}_{self.env}'
    
    def kexploit_kernel_name(self) -> str:
        return kernel_name_for_kernelctf_kernel(self.kernelctf_kernel_name)

    def exploit_file(self, file: str) -> Path:
        return Path(os.path.join(self.exploit_folder, file))
    
    def annotated_src_folder(self) -> Path:
        return self.exploit_file('annotated_src')
    
    def original_src_folder(self) -> Path:
        return self.exploit_file('original_code')
    
    def exploit_src_filenames(self) -> list[str]:
        return glob.glob('*.c', root_dir=self.exploit_folder) + glob.glob('*.h', root_dir=self.exploit_folder)
    
    def exploit_src_file_paths(self, base_dir: Path) -> list[Path]:
        return [Path(os.path.join(base_dir, file)) for file in self.exploit_src_filenames()]
    
    def copy_exploit_files(self, from_folder: Path, to_folder: Path):
        if not to_folder.exists():
            to_folder.mkdir()
        else:
            # make sure no file with same name exists
            assert to_folder.is_dir()

        for filename in self.exploit_src_filenames():
            shutil.copyfile(os.path.join(from_folder, filename), os.path.join(to_folder, filename))

    def annotate_file(self, force_annotate: bool, llm_annotate: bool):
        kexploit_header = self.exploit_file('kexploit.h')
        if not os.path.exists(kexploit_header):
            with open(kexploit_header, 'w') as f:
                f.write(KEXPLOIT_H_CONTENTS)
        
        if not force_annotate and self.annotated_src_folder().exists():
            return

        self.copy_exploit_files(self.exploit_folder, self.annotated_src_folder())

        annotate(self.exploit_src_file_paths(self.annotated_src_folder()), self.kexploit_kernel_name(), llm_annotate, None, DiffMode.ASK_APPLY_DIFF)
    
    def adapt_file(self, new_kernel_name: str) -> Path:
        '''
        Adapts an exploit to run with the `new_kernel_name`.

        Returns a path to the new adapted exploit file.
        '''
        
        adapted_path = self.exploit_file(f'exploit_adapted_{new_kernel_name}')
        self.copy_exploit_files(self.annotated_src_folder(), adapted_path)

        adapt(self.exploit_src_file_paths(adapted_path), self.kexploit_kernel_name(), new_kernel_name, None, DiffMode.APPLY_DIFF)

        return adapted_path
    
    def compile_exploit(self, adapted_folder: Path):
        self.copy_exploit_files(self.exploit_folder, self.original_src_folder())
        self.copy_exploit_files(adapted_folder, self.exploit_folder)

        try:
            self.compile_original_exploit()
        finally:
            self.copy_exploit_files(self.original_src_folder(), self.exploit_folder)
    
    def compile_original_exploit(self):
        # delete original binary
        self.exploit_file('exploit').unlink(missing_ok=True)
        subprocess.run([self.exploit_file('compile.sh')], check=True)
    
    def test_exploit(self, kernelctf_kernel: str, tries=5) -> bool:
        for _ in range(tries):
            result = subprocess.run([
                os.path.join(kernelctf_similator_dir(), 'test_exploit.py'),
                '--test-success',
                self.exploit_file('exploit'),
                kernelctf_kernel,
                # 'DEBUG'
            ])
            
            if result.returncode == 0:
                return True
        
        return False

    @classmethod
    def exploits_from_folder(cls, folder: Path) -> list[Self]:
        try:
            with open(os.path.join(folder, 'metadata.json'), 'r') as f:
                metadata = json.loads(f.read())
        except:
            # not an exploit folder
            return []
        
        vulnerability = metadata['vulnerability']

        if metadata['$schema'] == 'https://google.github.io/security-research/kernelctf/metadata.schema.v2.json':
            exploit_info = [(exploit['environment'], exploit) for exploit in metadata['exploits']]
        elif metadata['$schema'] == 'https://google.github.io/security-research/kernelctf/metadata.schema.v3.json':
            exploit_info = list(metadata['exploits'].items())
        else:
            return []

        exploits = []
        for kernel, data in exploit_info:
            if 'lts' in kernel:
                env = KernelCtfEnv.LTS
            elif 'cos' in kernel:
                env = KernelCtfEnv.COS
            elif 'mitigation' in kernel:
                env = KernelCtfEnv.MITIGATION
            else:
                continue

            requires_seperate_leak = data.get('requires_separate_kaslr_leak')
            if requires_seperate_leak is None:
                # sometimes key is spelled differently
                requires_seperate_leak = data.get('requires_seperate_kaslr_leak')
            
            if requires_seperate_leak is None:
                continue

            exploits.append(cls(
                cve=vulnerability['cve'],
                env=env,
                kernelctf_kernel_name=kernel,
                exploit_folder=Path(os.path.join(folder, f'exploit/{kernel}')),
                requires_seperate_leak=requires_seperate_leak,
                reliability_info=data['stability_notes'],
            ))
        
        return exploits

    @classmethod
    def get_all_exploits(cls) -> list[Self]:
        exploits = []

        for subdir in os.listdir(kernelctf_exploits_dir()):
            path = os.path.join(kernelctf_exploits_dir(), subdir)

            # ignore exploits which are version 2 of another exploit for now
            if path.split('_')[-1].isdigit():
                continue
            
            if os.path.isdir(path):
                exploits.extend(cls.exploits_from_folder(Path(path)))
        
        return exploits

class ExploitTester:
    exploit_map: dict[tuple[str, KernelCtfEnv], KernelCtfExploitInfo]
    success_count: int
    fail_count: int
    test_original: bool
    force_annotate: bool
    llm_annotate: bool

    def __init__(self, exploits: list[KernelCtfExploitInfo], force_annotate: bool, llm_annotate: bool, test_original: bool):
        self.exploit_map = { (exploit.cve, exploit.env): exploit for exploit in exploits }
        self.test_original = test_original
        self.force_annotate = force_annotate
        self.llm_annotate = llm_annotate
        self.success_count = 0
        self.fail_count = 0

    def test_adapted_exploit(self, cve: str, kernel_env: KernelCtfEnv, new_kernelctf_kernel: str, tries: int = 5):
        exploit = self.exploit_map[(cve, kernel_env)]

        install_kernelctf_kernel(exploit.kernelctf_kernel_name)
        install_kernelctf_kernel(new_kernelctf_kernel)
        new_kernel_name_kexploit = kernel_name_for_kernelctf_kernel(new_kernelctf_kernel)

        exploit.annotate_file(self.force_annotate, self.llm_annotate)
        adapted_file = exploit.adapt_file(new_kernel_name_kexploit)
        exploit.compile_exploit(adapted_file)

        if exploit.test_exploit(new_kernelctf_kernel, tries):
            print(f'{exploit.name()} successfully adapted to {new_kernelctf_kernel}')
            self.success_count += 1
        else:
            console.error(f'{exploit.name()} failed to adapt to {new_kernelctf_kernel}')
            self.fail_count += 1
    
    def test_original_exploit(self, cve: str, kernel_env: KernelCtfEnv, tries: int = 5):
        exploit = self.exploit_map[(cve, kernel_env)]
        exploit.compile_original_exploit()

        if exploit.test_exploit(exploit.kernelctf_kernel_name, tries):
            print(f'{exploit.name()} works on original kernel {exploit.kernelctf_kernel_name}')
            self.success_count += 1
        else:
            print(f'{exploit.name()} fails on original kernel {exploit.kernelctf_kernel_name}')
            self.fail_count += 1
    
    def test(self, cve: str, kernel_env: KernelCtfEnv, new_kernelctf_kernel: str, tries: int = 5):
        if self.test_original:
            self.test_original_exploit(cve, kernel_env, tries)
        else:
            self.test_adapted_exploit(cve, kernel_env, new_kernelctf_kernel, tries)
    
    def show_summary(self):
        print('Test stats:')
        print(f'Successes: {self.success_count}')
        print(f'Failures: {self.fail_count}')

def test_adapt_exploits(force_annotate: bool, llm_annotate: bool, test_original: bool):
    exploits = KernelCtfExploitInfo.get_all_exploits()
    t = ExploitTester(exploits, force_annotate, llm_annotate, test_original)

    ####################################
    # Working Adaptations ##############
    ####################################

    # original kernel 6.1.36
    # t.test('CVE-2023-4244', KernelCtfEnv.LTS, 'lts-6.1.52')

    # original kernel 6.6.62
    # t.test('CVE-2024-53141', KernelCtfEnv.LTS, 'lts-6.1.31')

    # original kernel 6.6.30
    # t.test('CVE-2024-39503', KernelCtfEnv.LTS, 'lts-6.6.32')
    
    # some nftables stuff
    # original kernel 6.1.81
    # t.test('CVE-2024-26925', KernelCtfEnv.LTS, 'lts-6.1.70')

    # original kernel 6.1.47
    # nftables
    # t.test('CVE-2023-5197', KernelCtfEnv.LTS, 'lts-6.1.36')

    # smbfs
    # original kernel 6.1.52
    # FIXME: there is a weird offset which is lowest 20 bits of an address this is not annotated successfully
    # but adaptation works
    # t.test('CVE-2023-5345', KernelCtfEnv.LTS, 'lts-6.1.36')

    ####################################
    # Failing Adaptations ##############
    ####################################

    # FIXME: Doesn't work (rop issue)
    # t.test('CVE-2023-3611', KernelCtfEnv.LTS, 'lts-6.1.31')
    # TODO: determine if this version is vulnerable to same bug
    # FIXME: Doesn't work (triggering bug issue issue)
    # t.test('CVE-2023-4015', KernelCtfEnv.LTS, 'lts-6.1.35')

    # original kernel 6.1.36
    # FIXME: triggering issue
    # t.test('CVE-2023-4147', KernelCtfEnv.LTS, 'lts-6.1.31')

    # original kernel 6.1.78
    # FIXME: kernel 6.1.78 fails in vmlinux-to-kallsyms tool,
    # so importing kernel for annotating is not possible
    # t.test('CVE-2023-52620', KernelCtfEnv.LTS, 'lts-6.1.70')

    # original kernel 6.1.67
    # FIXME: kernel 6.1.67 also fails to import
    # t.test('CVE-2024-0193', KernelCtfEnv.LTS, 'lts-6.1.52')

    # Manually tested failing: CVE-2023-3777 (triggering issue)

    ####################################
    # Original Exploit Fails ###########
    ####################################

    # netfilter bug
    # original kernel 6.6.31
    # FIXME: doesn't work, even original exploit seems to fail
    # t.test('CVE-2024-41010', KernelCtfEnv.LTS, 'lts-6.6.30')

    # UAF on Qdisc into eBPF shellcode
    # Unreliabel, 1 in 10
    # t.test('CVE-2023-4206', KernelCtfEnv.LTS, 'lts-6.1.31', tries=20)

    # original kernel 6.1.61
    # FIXME: fix the original exploit code
    # it gives error: fsetxattr: no space left on device
    # even though vm has plenty storage left
    # probably some other resource exhausted
    t.test('CVE-2023-6931', KernelCtfEnv.LTS, 'lts-6.1.52')
    
    t.show_summary()