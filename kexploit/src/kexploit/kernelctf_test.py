# Test exploit adaptation using kernelctf exploits

from typing import Self, Optional
from dataclasses import dataclass
from pathlib import Path
from enum import StrEnum
import subprocess
import shutil
import tempfile
import glob
import json
import os

from .kernel_image import Kernel
from .parse import DiffMode
from .annotate import annotate
from .rewrite_rules import adapt
from .tui import console
from .exploit_vm import test_exploit

def kernelctf_exploits_dir() -> Path:
    return Path(os.environ['KERNELCTF_EXPLOITS_DIR'])

def kernelctf_similator_dir() -> Path:
    return Path(os.environ['KERNELCTF_SIMULATOR_DIR'])

class KernelCtfEnv(StrEnum):
    LTS = 'lts'
    COS = 'cos'
    MITIGATION = 'mitigation'

KEXPLOIT_H_CONTENTS = '''
#ifndef KEXPLOIT_H
#define KEXPLOIT_H

// metadata is string containing json metadata about src file
#define __kexploit_src_metadata(metadata)

// marks the input as a kernel address
#define __kexploit_kernel_address(address) address

// marks the input as a kernel offset
#define __kexploit_kernel_offset(offset) offset

// marks the input as an offset in a struct
#define __kexploit_struct_offset(offset) offset

// marks the input as an address for a rop / jop gadget
#define __kexploit_rop_address(address, gadget) address

// marks the input as an offset for a rop / jop gadget
#define __kexploit_rop_offset(offset, gadget) offset

#endif
'''

KEXPLOIT_PY_CONTENTS = '''
def __kexploit_src_metadata(metadata: str):
    """Metadata is string containing json metadata about src file."""
    return None

def __kexploit_kernel_address(address: int) -> int:
    """Marks the input as a kernel address."""
    return address

def __kexploit_kernel_offset(offset: int) -> int:
    """Marks the input as a kernel offset."""
    return offset

def __kexploit_struct_offset(offset: int) -> int:
    """Marks the input as an offset in a struct."""
    return offset

def __kexploit_rop_address(address: int, _gadget: str) -> int:
    """Marks the input as an address for a rop / jop gadget."""
    return address

def __kexploit_rop_offset(offset: int, _gadget: str) -> int:
    """Marks the input as an offset for a rop / jop gadget."""
    return offset
'''

@dataclass
class KernelCtfExploitInfo:
    cve: str
    env: KernelCtfEnv
    original_kernel: Kernel
    exploit_folder: Path
    requires_seperate_leak: bool
    reliability_info: str

    def name(self) -> str:
        return f'{self.cve}_{self.env}'

    def exploit_file(self, file: str) -> Path:
        return Path(os.path.join(self.exploit_folder, file))
    
    def annotated_src_folder(self) -> Path:
        return self.exploit_file('annotated_src')
    
    def original_src_folder(self) -> Path:
        return self.exploit_file('original_code')
    
    def exploit_src_filenames(self) -> list[str]:
        files = (
            glob.glob('*.c', root_dir=self.exploit_folder)
            + glob.glob('*.h', root_dir=self.exploit_folder)
            + glob.glob('*.py', root_dir=self.exploit_folder)
        )
        return [file for file in files if file not in ('kexploit.h', 'kexploit.py')]
    
    def exploit_src_file_paths(self, base_dir: Path) -> list[Path]:
        return [Path(os.path.join(base_dir, file)) for file in self.exploit_src_filenames()]
    
    def copy_exploit_files(self, from_folder: Path, to_folder: Path):
        if not to_folder.exists():
            to_folder.mkdir()
        else:
            # make sure no file with same name exists
            assert to_folder.is_dir()

        for filename in self.exploit_src_filenames():
            shutil.copyfile(os.path.join(from_folder, filename), os.path.join(to_folder, filename))

    def annotate_file(self, force_annotate: bool, llm_annotate: bool):
        kexploit_header = self.exploit_file('kexploit.h')
        if not kexploit_header.exists():
            with open(kexploit_header, 'w') as f:
                f.write(KEXPLOIT_H_CONTENTS)
        
        kexploit_py = self.exploit_file('kexploit.py')
        if not kexploit_py.exists():
            with open(kexploit_py, 'w') as f:
                f.write(KEXPLOIT_PY_CONTENTS)
        
        if not force_annotate and self.annotated_src_folder().exists():
            return

        self.copy_exploit_files(self.exploit_folder, self.annotated_src_folder())

        annotate(self.exploit_src_file_paths(self.annotated_src_folder()), self.original_kernel, llm_annotate, None, DiffMode.ASK_APPLY_DIFF)
    
    def adapt_file(self, new_kernel: Kernel) -> Path:
        '''
        Adapts an exploit to run with the `new_kernel_name`.

        Returns a path to the new adapted exploit file.
        '''
        
        adapted_path = self.exploit_file(f'exploit_adapted_{new_kernel.name}')
        self.copy_exploit_files(self.annotated_src_folder(), adapted_path)

        adapt(self.exploit_src_file_paths(adapted_path), self.original_kernel, new_kernel, None, DiffMode.APPLY_DIFF)

        return adapted_path
    
    def compile_exploit(self, adapted_folder: Path):
        self.copy_exploit_files(self.exploit_folder, self.original_src_folder())
        self.copy_exploit_files(adapted_folder, self.exploit_folder)

        try:
            self.compile_original_exploit()
        finally:
            self.copy_exploit_files(self.original_src_folder(), self.exploit_folder)
    
    def compile_original_exploit(self):
        # delete original binary
        self.exploit_file('exploit').unlink(missing_ok=True)
        subprocess.run([self.exploit_file('compile.sh')], check=True)
    
    def test_exploit(self, kernel: Kernel, tries=5) -> bool:
        for _ in range(tries):
            if test_exploit(kernel, self.exploit_file('exploit')):
                return True
        
        return False

    @classmethod
    def exploits_from_folder(cls, folder: Path) -> list[Self]:
        try:
            with open(os.path.join(folder, 'metadata.json'), 'r') as f:
                metadata = json.loads(f.read())
        except:
            # not an exploit folder
            return []
        
        vulnerability = metadata['vulnerability']

        if metadata['$schema'] == 'https://google.github.io/security-research/kernelctf/metadata.schema.v2.json':
            exploit_info = [(exploit['environment'], exploit) for exploit in metadata['exploits']]
        elif metadata['$schema'] == 'https://google.github.io/security-research/kernelctf/metadata.schema.v3.json':
            exploit_info = list(metadata['exploits'].items())
        else:
            return []

        exploits = []
        for kernel_name, data in exploit_info:
            if 'lts' in kernel_name:
                env = KernelCtfEnv.LTS
            elif 'cos' in kernel_name:
                env = KernelCtfEnv.COS
            elif 'mitigation' in kernel_name:
                env = KernelCtfEnv.MITIGATION
            else:
                continue

            requires_seperate_leak = data.get('requires_separate_kaslr_leak')
            if requires_seperate_leak is None:
                # sometimes key is spelled differently
                requires_seperate_leak = data.get('requires_seperate_kaslr_leak')
            
            if requires_seperate_leak is None:
                continue

            exploits.append(cls(
                cve=vulnerability['cve'],
                env=env,
                original_kernel=Kernel.from_kernelctf_name(kernel_name),
                exploit_folder=Path(os.path.join(folder, f'exploit/{kernel_name}')),
                requires_seperate_leak=requires_seperate_leak,
                reliability_info=data['stability_notes'],
            ))
        
        return exploits

    @classmethod
    def get_all_exploits(cls) -> list[Self]:
        exploits = []

        for subdir in os.listdir(kernelctf_exploits_dir()):
            path = os.path.join(kernelctf_exploits_dir(), subdir)

            # ignore exploits which are version 2 of another exploit for now
            if path.split('_')[-1].isdigit():
                continue
            
            if os.path.isdir(path):
                exploits.extend(cls.exploits_from_folder(Path(path)))
        
        return exploits

class ExploitTester:
    exploit_map: dict[tuple[str, KernelCtfEnv], KernelCtfExploitInfo]
    success_count: int
    fail_count: int
    test_original: bool
    force_annotate: bool
    llm_annotate: bool

    def __init__(self, exploits: list[KernelCtfExploitInfo], force_annotate: bool, llm_annotate: bool, test_original: bool):
        self.exploit_map = { (exploit.cve, exploit.env): exploit for exploit in exploits }
        self.test_original = test_original
        self.force_annotate = force_annotate
        self.llm_annotate = llm_annotate
        self.success_count = 0
        self.fail_count = 0

    def test_adapted_exploit(self, cve: str, kernel_env: KernelCtfEnv, new_kernel_name: str, tries: int = 5):
        exploit = self.exploit_map[(cve, kernel_env)]
        new_kernel = Kernel(new_kernel_name)

        exploit.original_kernel.install_kernel_elf()
        new_kernel.install_kernel_elf()

        exploit.annotate_file(self.force_annotate, self.llm_annotate)
        adapted_file = exploit.adapt_file(new_kernel)
        exploit.compile_exploit(adapted_file)

        if exploit.test_exploit(new_kernel, tries):
            print(f'{exploit.name()} successfully adapted to {new_kernel_name}')
            self.success_count += 1
        else:
            console.error(f'{exploit.name()} failed to adapt to {new_kernel_name}')
            self.fail_count += 1
    
    def test_original_exploit(self, cve: str, kernel_env: KernelCtfEnv, tries: int = 5):
        exploit = self.exploit_map[(cve, kernel_env)]
        exploit.compile_original_exploit()

        if exploit.test_exploit(exploit.original_kernel, tries):
            print(f'{exploit.name()} works on original kernel {exploit.original_kernel.name}')
            self.success_count += 1
        else:
            print(f'{exploit.name()} fails on original kernel {exploit.original_kernel.name}')
            self.fail_count += 1
    
    def test(self, cve: str, kernel_env: KernelCtfEnv, new_kernelctf_kernel: str, tries: int = 5):
        if self.test_original:
            self.test_original_exploit(cve, kernel_env, tries)
        else:
            self.test_adapted_exploit(cve, kernel_env, new_kernelctf_kernel, tries)
    
    def show_summary(self):
        print('Test stats:')
        print(f'Successes: {self.success_count}')
        print(f'Failures: {self.fail_count}')

def test_adapt_exploits(force_annotate: bool, llm_annotate: bool, test_original: bool):
    exploits = KernelCtfExploitInfo.get_all_exploits()
    t = ExploitTester(exploits, force_annotate, llm_annotate, test_original)

    # original kernel 6.6.28
    # some unix socket gc bug
    # t.test('CVE-2024-36972', KernelCtfEnv.LTS, 'kernelctf_6.1.81_lts')

    ####################################
    # Working Adaptations ##############
    ####################################

    # original kernel 6.1.36
    # FIXME: fails to annotate offsets which are written as sum of 2 offsets
    # t.test('CVE-2023-4244', KernelCtfEnv.LTS, 'kernelctf_6.1.52_lts')

    # original kernel 6.6.62
    # t.test('CVE-2024-53141', KernelCtfEnv.LTS, 'kernelctf_6.1.31_lts')

    # original kernel 6.6.30
    # t.test('CVE-2024-39503', KernelCtfEnv.LTS, 'kernelctf_6.6.32_lts')
    
    # some nftables stuff
    # original kernel 6.1.81
    # t.test('CVE-2024-26925', KernelCtfEnv.LTS, 'kernelctf_6.1.70_lts')

    # original kernel 6.1.47
    # nftables
    # t.test('CVE-2023-5197', KernelCtfEnv.LTS, 'kernelctf_6.1.36_lts')
    # FIXME: failure due to rop
    # t.test('CVE-2023-5197', KernelCtfEnv.LTS, 'build_6.1.35_lts')

    # smbfs
    # original kernel 6.1.52
    # FIXME: there is a weird offset which is lowest 20 bits of an address this is not annotated successfully
    # but adaptation works
    # t.test('CVE-2023-5345', KernelCtfEnv.LTS, 'kernelctf_6.1.36_lts')
    # FIXME: failure due to rop and failing to translate data ref to init_task 
    t.test('CVE-2023-5345', KernelCtfEnv.LTS, 'build_6.1.35_lts')

    # original kernel 6.1.36
    # traffic control bug
    # t.test('CVE-2023-3776', KernelCtfEnv.LTS, 'kernelctf_6.1.31_lts')
    # t.test('CVE-2023-3776', KernelCtfEnv.LTS, 'build_6.1.35_lts')

    # original kernel 6.1.36
    # traffic control bug
    # t.test('CVE-2023-4208', KernelCtfEnv.LTS, 'kernelctf_6.1.31_lts')

    ####################################
    # Failing Adaptations ##############
    ####################################

    # FIXME: Doesn't work (rop issue)
    # t.test('CVE-2023-3611', KernelCtfEnv.LTS, 'kernelctf_6.1.31_lts')
    
    # TODO: determine if this version is vulnerable to same bug
    # FIXME: Doesn't work (triggering bug issue issue)
    # t.test('CVE-2023-4015', KernelCtfEnv.LTS, 'kernelctf_6.1.35_lts')

    # original kernel 6.1.36
    # FIXME: triggering issue
    # t.test('CVE-2023-4147', KernelCtfEnv.LTS, 'kernelctf_6.1.31_lts')

    # original kernel 6.1.78
    # FIXME: kernel 6.1.78 fails in vmlinux-to-kallsyms tool,
    # so importing kernel for annotating is not possible
    # t.test('CVE-2023-52620', KernelCtfEnv.LTS, 'kernelctf_6.1.70_lts')

    # original kernel 6.1.67
    # FIXME: kernel 6.1.67 also fails to import
    # t.test('CVE-2024-0193', KernelCtfEnv.LTS, 'kernelctf_6.1.52_lts')

    # Manually tested failing: CVE-2023-3777 (triggering issue)

    ####################################
    # Original Exploit Fails ###########
    ####################################

    # netfilter bug
    # original kernel 6.6.31
    # FIXME: doesn't work, even original exploit seems to fail
    # t.test('CVE-2024-41010', KernelCtfEnv.LTS, 'kernelctf_6.6.30_lts')

    # UAF on Qdisc into eBPF shellcode
    # Unreliabel, 1 in 10
    # t.test('CVE-2023-4206', KernelCtfEnv.LTS, 'kernelctf_6.1.31_lts', tries=20)

    # original kernel 6.1.61
    # FIXME: fix the original exploit code
    # it gives error: fsetxattr: no space left on device
    # even though vm has plenty storage left
    # probably some other resource exhausted
    # t.test('CVE-2023-6931', KernelCtfEnv.LTS, 'kernelctf_6.1.52_lts')
    
    t.show_summary()