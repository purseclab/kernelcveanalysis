from contextlib import AbstractContextManager
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Self, Optional
from abc import ABC, abstractmethod
import math
import sys

import pyghidra

from .data import ghidra_project_dir

class RefType(Enum):
    OTHER = 1
    # Pointer in memory references data, but also can mean unknown
    DATA = 2
    READ = 3
    WRITE = 4
    PARAM = 5

@dataclass
class Reference:
    from_address: int
    to_address: int
    ref_type: RefType

    @classmethod
    def from_ghidra_reference(cls, reference) -> Self:
        from ghidra.program.model.symbol import RefType as GhidraRefType

        ghidra_ref_type = reference.getReferenceType()
        if ghidra_ref_type == GhidraRefType.DATA:
            ref_type = RefType.DATA
        elif ghidra_ref_type == GhidraRefType.READ:
            ref_type = RefType.READ
        elif ghidra_ref_type == GhidraRefType.WRITE:
            ref_type = RefType.WRITE
        elif ghidra_ref_type == GhidraRefType.PARAM:
            ref_type = RefType.PARAM
        else:
            ref_type = RefType.OTHER

        return cls(
            from_address=address_to_int(reference.getFromAddress()),
            to_address=address_to_int(reference.getToAddress()),
            ref_type=ref_type,
        )

class Characteristic(ABC):
    @abstractmethod
    def properties(self) -> list[int]:
        pass

    def distance(self, other: Self) -> float:
        properties = zip(self.properties(), other.properties())
        return math.sqrt(sum((prop_a - prop_b) ** 2 for prop_a, prop_b in properties))
    
    def closest_match(self, others: list[Self]) -> Optional[Self]:
        if len(others) == 0:
            return None
        elif len(others) == 1:
            return others[0]

        others = sorted(others, key=lambda c: self.distance(c))
        if math.isclose(self.distance(others[0]), self.distance(others[1]), rel_tol=sys.float_info.epsilon):
            # we want unique smallest characteristic
            return None
        else:
            return others[0]

# Bindif paper used instruction count from start and end of basic block for instruction selector
@dataclass
class ReferenceCharacteristic(Characteristic):
    reference: Reference
    # distance from start and end of basic block
    start_distance: int
    end_distance: int

    def properties(self) -> list[int]:
        return [self.start_distance, self.end_distance]

# selector used in https://github.com/google/bindiff/blob/main/docs/papers/bindiffsstic05-1.pdf
# these 3 properties are treated as euclidan vector and nodes are considered same if vector is close,
# but for now we test if characteristic is exactly the same
@dataclass
class BasicBlockCharacteristic(Characteristic):
    # ghidra basic block object
    block: object
    # distance in basic block graph from entrpoint to basic block
    entry_distance: int
    # distance in basic block graph from node to exit point
    exit_distance: int
    call_count: int

    def properties(self) -> list[int]:
        return [self.entry_distance, self.exit_distance, self.call_count]

class BasicBlockGraph:
    # Monitor an basic block model also stored in BasicBlockGraph
    blocks: list
    # self.edges[i] is set of edges going from i to other nodes
    edges: list[set[int]]
    address_to_block_map: dict[int, int]
    entrypoint_index: int
    # set of all nodes that return from the function
    exit_nodes: set[int]
    node_distances: list[list[Optional[int]]]

    def __init__(self, program, function):
        from ghidra.program.model.block import BasicBlockModel
        from ghidra.util.task import ConsoleTaskMonitor

        self.monitor = ConsoleTaskMonitor()
        self.bb_model = BasicBlockModel(program)

        self.blocks = list(self.bb_model.getCodeBlocksContaining(function.getBody(), self.monitor))

        self.address_to_block_map = { address_to_int(block.getMinAddress()): i for i, block in enumerate(self.blocks) }
        self.edges = []

        for block in self.blocks:
            current_node_edges = []

            # this method returns something like an iterator but its not actually an iterator
            # so have to manually while loop through it
            destinations = block.getDestinations(self.monitor)
            while destinations.hasNext():
                dest_block = destinations.next().getDestinationBlock()

                index = self.block_index(dest_block)
                # if index is none, it is usually a call to another function
                # calls are marked as a reference, but the basic block itself still includes
                # instructions after the call, so we can ignore it
                if index is None:
                    continue

                current_node_edges.append(index)
            
            self.edges.append(set(current_node_edges))
        
        self.entrypoint_index = self.address_to_block_map[address_to_int(function.getEntryPoint())]
        self.exit_nodes = set(i for i, edges in enumerate(self.edges) if len(edges) == 0)

        self.calculate_node_distances()
    
    def calculate_node_distances(self):
        # floyd warshall to calculate distances between all nodes
        node_count = len(self.blocks)

        dp_table = [[[0] * (node_count + 1) for _ in range(node_count)] for _ in range(node_count)]

        # there will never be this many nodes so path will never be this long
        # easier then using none if path doesn't exist
        int_max = 1 << 64

        # fill out k = 0 entries
        for i in range(node_count):
            for j in range(node_count):
                if i == j:
                    dp_table[i][j][0] = 0
                elif j in self.edges[i]:
                    dp_table[i][j][0] = 1
                else:
                    # node i and j are not adjacent
                    dp_table[i][j][0] = int_max
        
        for k in range(1, node_count + 1):
            for i in range(node_count):
                for j in range(node_count):
                    dp_table[i][j][k] = min(
                        dp_table[i][j][k - 1],
                        dp_table[i][k - 1][k - 1] + dp_table[k - 1][j][k - 1],
                    )
        
        self.node_distances = [
            [None if dp_table[i][j][node_count] >= int_max else dp_table[i][j][node_count] for j in range(node_count)]
            for i in range(node_count)
        ]
    
    def block_characteristic(self, ghidra_api: 'GhidraApi', node_index: int) -> BasicBlockCharacteristic:
        from ghidra.program.model.pcode import PcodeOp

        listing = ghidra_api.current_program().getListing()

        call_count = 0
        for address in self.blocks[node_index].getAddresses(True):
            instruction = listing.getInstructionAt(address)

            # getAddresses returns all addresses in basic block, some of them point inside instructions
            # in this case getInstructionAt returns None
            # there doesn't seem to be any issue with unaligned address being interpreted as different instruction,
            # listing seems to handle that
            if instruction is None:
                continue

            # pcode is like architecture independant microcode used by ghidra
            # we look for call pcode opcode
            for pcode_op in instruction.getPcode():
                op = pcode_op.getOpcode()

                if op in (PcodeOp.CALL, PcodeOp.CALLIND, PcodeOp.CALLOTHER):
                    call_count += 1
                    break
        
        entry_distance = self.node_distances[self.entrypoint_index][node_index]

        exit_distance = None
        for exit_index in self.exit_nodes:
            distance = self.node_distances[node_index][exit_index]
            if exit_distance is None or (distance is not None and distance < exit_distance):
                exit_distance = distance
        
        assert entry_distance is not None and exit_distance is not None
        
        return BasicBlockCharacteristic(
            block=self.blocks[node_index],
            entry_distance=entry_distance,
            exit_distance=exit_distance,
            call_count=call_count,
        )
    
    def reference_characteristic(self, ghidra_api: 'GhidraApi', reference: Reference) -> ReferenceCharacteristic:
        block_index = self.block_index_for_address(ghidra_api.to_address(reference.from_address))
        listing = ghidra_api.current_program().getListing()
        
        before_count = 0
        after_count = 0
        hit_reference = False

        for address in self.blocks[block_index].getAddresses(True):
            instruction = listing.getInstructionAt(address)
            if instruction is None:
                continue

            if address_to_int(address) == reference.from_address:
                hit_reference = True
            elif hit_reference:
                after_count += 1
            else:
                before_count += 1
        
        return ReferenceCharacteristic(
            reference=reference,
            start_distance=before_count,
            end_distance=after_count,
        )

    def is_entrypoint(self, node_index: int) -> bool:
        return self.entrypoint_index == node_index
    
    def is_return(self, node_index: int) -> bool:
        # no nodes after in graph, so assume this is return node
        # TODO: check flow type to make sure
        return node_index in self.exit_nodes
    
    def block_index(self, block) -> Optional[int]:
        return self.address_to_block_map.get(address_to_int(block.getMinAddress()))
    
    def block_index_for_address(self, address) -> Optional[int]:
        block = self.bb_model.getFirstCodeBlockContaining(address, self.monitor)
        return self.block_index(block)

# converts ghidra address to integer
def address_to_int(address) -> int:
    address = address.getOffset()
    if address < 0:
        return address + (1 << 64)
    else:
        return address

# utility functions which wrap ghidra api
# Can't give types unfortunately because types are based of runtime loaded java classes
class GhidraApi:
    def __init__(self, flat_api):
        self.flat_api = flat_api
    
    # converts integer to ghidra address
    def to_address(self, address: int):
        # there are 3 variants of toAddr, one which takes int,
        # one which takes long, and on that takes string
        # addresses we have are bigger then long max, so should be negative
        # but then the jpype library treats them as negative int
        # also anything bigger then int max doesn't work for long
        # so have to use string version
        return self.flat_api.toAddr(str(address))
    
    def current_program(self):
        return self.flat_api.getCurrentProgram()
    
    def reference_manager(self):
        return self.current_program().getReferenceManager()

    # returns ghidra.program.model.listing.Function
    def get_function(self, address: int):
        ghidra_address = self.to_address(address)
        return self.current_program().getFunctionManager().getFunctionAt(ghidra_address)
    
    def analyze(self):
        self.flat_api.analyzeAll(self.current_program())
    
    def references_to_address(self, address: int) -> list[Reference]:
        ghidra_address = self.to_address(address)

        ref_manager = self.reference_manager()

        return [Reference.from_ghidra_reference(reference) for reference in ref_manager.getReferencesTo(ghidra_address)]
    
    def references_in_function(self, function) -> list[Reference]:
        ref_manager = self.reference_manager()

        out = []
        for address in function.getBody().getAddresses(True):
            out.extend(ref_manager.getReferencesFrom(address))
        
        return [Reference.from_ghidra_reference(reference) for reference in out]

    # returns a reference that passed in reference is pointing to
    def deref(self, reference: Reference) -> Optional[Reference]:
        references = self.reference_manager().getReferencesFrom(self.to_address(reference.to_address))
        if len(references) != 1:
            return None
        
        return Reference.from_ghidra_reference(references[0])
    
    def get_basic_blocks(self, function) -> BasicBlockGraph:
        return BasicBlockGraph(self.current_program(), function)

class GhidraInstance(AbstractContextManager):
    def __init__(self, kernel: Path):
        if not pyghidra.started():
            pyghidra.start()
        
        self.kernel_path = kernel
    
    def __enter__(self) -> GhidraApi:
        self.flat_api_manager = pyghidra.open_program(
            binary_path=self.kernel_path,
            project_location=ghidra_project_dir(),
            analyze=False,
        )

        return GhidraApi(self.flat_api_manager.__enter__())

    def __exit__(self, exc_type, exc_value, traceback):
        return self.flat_api_manager.__exit__(exc_type, exc_value, traceback)
