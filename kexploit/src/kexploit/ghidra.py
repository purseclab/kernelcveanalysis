from contextlib import AbstractContextManager
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Self

import pyghidra

from .data import ghidra_project_dir

class RefType(Enum):
    DATA = 1
    CODE = 2

@dataclass
class Reference:
    from_address: int
    to_address: int
    ref_type: RefType

    @classmethod
    def from_ghidra_reference(cls, reference) -> Self:
        from ghidra.program.model.symbol import RefType as GhidraRefType

        ghidra_ref_type = reference.getReferenceType()
        if ghidra_ref_type == GhidraRefType.DATA:
            ref_type = RefType.DATA
        else:
            ref_type = RefType.CODE

        return cls(
            from_address=address_to_int(reference.getFromAddress()),
            to_address=address_to_int(reference.getToAddress()),
            ref_type=ref_type,
        )

# converts ghidra address to integer
def address_to_int(address) -> int:
    address = address.getOffset()
    if address < 0:
        return address + (1 << 64)
    else:
        return address

# utility functions which wrap ghidra api
# Can't give types unfortunately because types are based of runtime loaded java classes
class GhidraApi:
    def __init__(self, flat_api):
        self.flat_api = flat_api
    
    # converts integer to ghidra address
    def to_address(self, address: int):
        # there are 3 variants of toAddr, one which takes int,
        # one which takes long, and on that takes string
        # addresses we have are bigger then long max, so should be negative
        # but then the jpype library treats them as negative int
        # also anything bigger then int max doesn't work for long
        # so have to use string version
        return self.flat_api.toAddr(str(address))
    
    def current_program(self):
        return self.flat_api.getCurrentProgram()
    
    def analyze(self):
        self.flat_api.analyzeAll(self.current_program())
    
    def references_to_address(self, address: int) -> list[Reference]:
        ghidra_address = self.to_address(address)

        ref_manager = self.current_program().getReferenceManager()

        return [Reference.from_ghidra_reference(reference) for reference in ref_manager.getReferencesTo(ghidra_address)]

class GhidraInstance(AbstractContextManager):
    def __init__(self, kernel: Path):
        if not pyghidra.started():
            pyghidra.start()
        
        self.kernel_path = kernel
    
    def __enter__(self) -> GhidraApi:
        self.flat_api_manager = pyghidra.open_program(
            binary_path=self.kernel_path,
            project_location=ghidra_project_dir(),
            analyze=False,
        )

        return GhidraApi(self.flat_api_manager.__enter__())

    def __exit__(self, exc_type, exc_value, traceback):
        return self.flat_api_manager.__exit__(exc_type, exc_value, traceback)
