from enum import StrEnum
from abc import ABC, abstractmethod
from typing import Type

from pydantic import BaseModel

from .kernel_image import KernelAdapter, AdaptError

class AnnotationType(StrEnum):
    KEXPLOIT_META = "__kexploit_src_metadata"
    KEXPLOIT_ADDRESS = "__kexploit_kernel_address"
    KEXPLOIT_ROP_ADDRESS = "__kexploit_rop_address"
    KEXPLOIT_KERNEL_DATA = "__kexploit_kernel_data"

class Annotation(BaseModel, ABC):
    @staticmethod
    @abstractmethod
    def annotation_type() -> AnnotationType:
        '''
        Returns the annotation type corresponding to this annotation.
        '''
        pass

    @abstractmethod
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        '''
        Returns C code corresponding to this annotation.

        Used to convert annotated exploit to concrete exploit code for a specific kernel.
        '''
        pass

    def __str__(self) -> str:
        # escape string quotes
        args = self.model_dump_json().replace('"', '\\"')

        return f'{self.__class__.annotation_type()}("{args}")'

# annotations are below
class SrcMetadata(Annotation):
    # kernel original exploit was written for
    original_kernel_name: str
    # kernel exploit is currently adapted to
    current_kernel_name: str

    def annotation_type():
        return AnnotationType.KEXPLOIT_META
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        # metadata has no corresponding code
        return ''

class KernelAddress(Annotation):
    address: int
    is_relative: bool

    def annotation_type():
        return AnnotationType.KEXPLOIT_ADDRESS
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        if self.is_relative:
            return hex(adapter.translate_offset(self.address))
        else:
            return hex(adapter.translate_address(self.address))

class RopAddress(Annotation):
    gadget: str
    is_relative: bool
    original_value: int

    def annotation_type():
        return AnnotationType.KEXPLOIT_ROP_ADDRESS
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        if self.is_relative:
            return hex(adapter.translate_rop_gadget_offset(self.gadget))
        else:
            return hex(adapter.translate_rop_gadget(self.gadget))

class KernelData(Annotation):
    address: int
    num_bytes: int
    original_value: int

    def annotation_type():
        return AnnotationType.KEXPLOIT_KERNEL_DATA
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        assert self.num_bytes <= 8
        new_address = adapter.translate_address(self.address)

        value_bytes = adapter.dst_image.get_bytes(new_address, self.num_bytes)
        if value_bytes is None:
            raise AdaptError('Could not retreive bytes for new address in kernel')
        
        return hex(adapter.dst_image.arch_info.unpack_usize(value_bytes))

annotation_map = { annotation.annotation_type(): annotation for annotation in Annotation.__subclasses__() }
def annotation_for_annotation_type(annotation_type: AnnotationType) -> Type[Annotation]:
    return annotation_map[annotation_type]