from typing import Optional
import re

from .kernel_image import KernelAdapter
from .parse import LexedCode, Ident, Delim, Literal, is_delim, Token, find_before, find_after

RewriteValue = int | str

def parse_rewrite_value(token: Token) -> Optional[RewriteValue]:
    match token.data:
        case Literal(value):
            return value
        case _:
            return None

def parse_rewrite_values(tokens: list[Token]) -> Optional[list[RewriteValue]]:
    values = [parse_rewrite_value(token) for token in tokens]

    if any(value is None for value in values):
        return None
    else:
        return values


def rewrite_value_to_string(value: RewriteValue) -> str:
    match value:
        case int(x):
            return hex(x)
        case str(x):
            return f'"{x}"'

def rewrite_values_to_string(values: list[RewriteValue]) -> str:
    return ', '.join(rewrite_value_to_string(value) for value in values)

class RewriteRule:
    """
    A rewrite rule looks for a function call in C code and it replaces arguments based on current arguments.

    This uses regex based approach, as creating diffs based on parsing is problematic due to preprocessor
    (unless parser can parese preprocess direcives as well, but this requires modifying C parsing library).
    """

    def rule_name(self) -> str:
        """Returns name of rewrite rule function"""
        pass

    def rewrite(self, args: list[RewriteValue]) -> Optional[list[RewriteValue]]:
        """Applies the rewrite"""
        pass

KEXPLOIT_ADDRESS = "__kexploit_kernel_address"
KEXPLOIT_OFFSET = "__kexploit_kernel_offset"
KEXPLOIT_STRUCT_OFFSET = "__kexploit_struct_offset"
KEXPLOIT_ROP_ADDRESS = "__kexploit_rop_address"
KEXPLOIT_ROP_OFFSET = "__kexploit_rop_offset"

rule_names = set([KEXPLOIT_ADDRESS, KEXPLOIT_OFFSET, KEXPLOIT_STRUCT_OFFSET])
def is_rule_token(token: Token) -> bool:
    match token.data:
        case Ident(name) if name in rule_names:
            return True
        case _:
            return False

def is_annotated(tokens: list[Token], index: int) -> bool:
    """
    Checks if the token at the given index is annotated
    """
    start_paren_index = find_before(tokens, index, lambda token: is_delim(token, '('))
    end_paren_index = find_after(tokens, index, lambda token: is_delim(token, ')'))

    match start_paren_index, end_paren_index:
        case int(start_i), int(end_i) if start_i > 0 and is_rule_token(tokens[start_i - 1]):
            # if there are any delimiters or such this is not an annotation
            return all(token.is_literal() for token in tokens[start_i + 1:end_i])
        case _:
            return False


class AddressRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return KEXPLOIT_ADDRESS
    
    def rewrite(self, args: list[RewriteValue]) -> Optional[list[RewriteValue]]:
        match args:
            case [int(address)]:
                address = self.adapter.translate_address(address)
                if address is None:
                    return None
                
                return [address]

class OffsetRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return KEXPLOIT_OFFSET
    
    def rewrite(self, args: list[RewriteValue]) -> Optional[list[RewriteValue]]:
        match args:
            case [int(offset)]:
                offset = self.adapter.translate_offset(offset)
                if offset is None:
                    return None
                
                return [offset]

class AddressRopRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter
    
    def rule_name(self):
        return KEXPLOIT_ROP_ADDRESS
    
    def rewrite(self, args: list[RewriteValue]) -> Optional[list[RewriteValue]]:
        match args:
            case [int(address), str(gadget)]:
                address = self.adapter.translate_rop_gadget(gadget)
                if address is None:
                    return None

                return [address, gadget]

class OffsetRopRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter
    
    def rule_name(self):
        return KEXPLOIT_ROP_OFFSET
    
    def rewrite(self, args: list[RewriteValue]) -> Optional[list[RewriteValue]]:
        match args:
            case [int(offset), str(gadget)]:
                offset = self.adapter.translate_rop_gadget_offset(gadget)
                if offset is None:
                    return None
                
                return [offset, gadget]

def gen_rewrite_rules(adapter: KernelAdapter) -> list[RewriteRule]:
    return [
        AddressRewrite(adapter),
        OffsetRewrite(adapter),
        AddressRopRewrite(adapter),
        OffsetRopRewrite(adapter),
    ]

def apply_rewrites(rules: list[RewriteRule], input: LexedCode) -> str:
    rule_map = { rule.rule_name(): rule for rule in rules }

    def rewrite(tokens: list[Token], token_index: int) -> Optional[tuple[int, str]]:
        # need at least ident and 2 delims
        if token_index + 3 <= len(tokens):
            match tokens[token_index].data, tokens[token_index + 1].data:
                case Ident(name), Delim(delim='(') if name in rule_map:
                    # skip paren and ident
                    arg_index = token_index + 2

                    # find index of closing paren
                    end_index = find_after(tokens, token_index, lambda token: is_delim(token, ')'))
                    # end_index = next((i + arg_index for i, token in enumerate(tokens[arg_index:]) if is_delim(token, ')')), None)
                    if end_index is None:
                        return None

                    args = parse_rewrite_values(tokens[arg_index:end_index])
                    result = rule_map[name].rewrite(args)
                    if result is None:
                        print(f'Failed to translate: {tokens[token_index]}')
                        return None

                    output = f'{name}({rewrite_values_to_string(result)})'
                    return end_index - token_index + 1, output
        
        return None
    
    return input.replace_tokens(rewrite)