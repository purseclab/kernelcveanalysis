from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional

from .kernel_image import KernelAdapter, AdaptError, Kernel
from .parse import LexedCode, is_delim, Token, find_before, find_after, ReplaceResult, RewriteValue, is_rule_token, AnnotationType, Annotation, SrcMetadata, ExploitFileGroup, ExploitFileError, DiffMode
from .tui import console

class RewriteRule(ABC):
    """
    A rewrite rule looks for a function call in C code and it replaces arguments based on current arguments.

    This uses regex based approach, as creating diffs based on parsing is problematic due to preprocessor
    (unless parser can parese preprocess direcives as well, but this requires modifying C parsing library).
    """

    @abstractmethod
    def rule_name(self) -> str:
        """Returns name of rewrite rule function"""
        pass

    @abstractmethod
    def rewrite(self, args: list[RewriteValue]) -> list[RewriteValue]:
        """Applies the rewrite"""
        pass

def is_annotated(tokens: list[Token], index: int) -> bool:
    """
    Checks if the token at the given index is annotated
    """
    start_paren_index = find_before(tokens, index, lambda token: is_delim(token, '('))
    end_paren_index = find_after(tokens, index, lambda token: is_delim(token, ')'))

    match start_paren_index, end_paren_index:
        case int(start_i), int(end_i) if start_i > 0 and is_rule_token(tokens[start_i - 1]):
            # if there are any delimiters or such this is not an annotation
            return all(token.is_literal() for token in tokens[start_i + 1:end_i])
        case _:
            return False


class AddressRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return AnnotationType.KEXPLOIT_ADDRESS
    
    def rewrite(self, args: list[RewriteValue]) -> list[RewriteValue]:
        match args:
            case [int(address)]:
                address = self.adapter.translate_address(address)
                
                return [address]
            case _:
                raise AdaptError('Invalid arguments')

class OffsetRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter

    def rule_name(self):
        return AnnotationType.KEXPLOIT_OFFSET
    
    def rewrite(self, args: list[RewriteValue]) -> list[RewriteValue]:
        match args:
            case [int(offset)]:
                offset = self.adapter.translate_offset(offset)
                
                return [offset]
            case _:
                raise AdaptError('Invalid arguments')

class AddressRopRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter
    
    def rule_name(self):
        return AnnotationType.KEXPLOIT_ROP_ADDRESS
    
    def rewrite(self, args: list[RewriteValue]) -> list[RewriteValue]:
        match args:
            case [int(address), str(gadget)]:
                address = self.adapter.translate_rop_gadget(gadget)

                return [address, gadget]
            case _:
                raise AdaptError('Invalid arguments')

class OffsetRopRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter
    
    def rule_name(self):
        return AnnotationType.KEXPLOIT_ROP_OFFSET
    
    def rewrite(self, args: list[RewriteValue]) -> list[RewriteValue]:
        match args:
            case [int(offset), str(gadget)]:
                offset = self.adapter.translate_rop_gadget_offset(gadget)
                
                return [offset, gadget]
            case _:
                raise AdaptError('Invalid arguments')

class MetadataRewrite(RewriteRule):
    def __init__(self, adapter: KernelAdapter):
        self.adapter = adapter
    
    def rule_name(self):
        return AnnotationType.KEXPLOIT_META
    
    def rewrite(self, args):
        match args:
            case [str(metadata_json)]:
                metadata = SrcMetadata.model_validate_json(metadata_json)
                metadata.current_kernel_name = self.adapter.dst_image.kernel.name

                return [metadata.model_dump_json()]
            case _:
                raise AdaptError('Invalid arguments')

def gen_rewrite_rules(adapter: KernelAdapter) -> list[RewriteRule]:
    return [
        AddressRewrite(adapter),
        OffsetRewrite(adapter),
        AddressRopRewrite(adapter),
        OffsetRopRewrite(adapter),
        MetadataRewrite(adapter),
    ]

def apply_rewrites(rules: list[RewriteRule], input: LexedCode) -> str:
    rule_map = { rule.rule_name(): rule for rule in rules }

    def rewrite(tokens: list[Token], token_index: int) -> ReplaceResult:
        annotation = Annotation.parse(tokens, token_index)
        if annotation is None or annotation.annotation_name not in rule_map:
            return ReplaceResult.skip()
        
        try:
            new_annotation = annotation.with_args(rule_map[annotation.annotation_name].rewrite(annotation.args))
        except AdaptError as e:
            return ReplaceResult.error(e.message, tokens[token_index])
        
        return ReplaceResult.replace(annotation.token_count(), str(new_annotation))
    
    adapted_code, errors = input.replace_tokens(rewrite)
    console.print_errors(errors)
    return adapted_code

def adapt(exploit_files: list[Path], old_kernel: Optional[Kernel], new_kernel: Kernel, diff_output: Optional[Path], diff_mode: DiffMode):
    files = ExploitFileGroup(exploit_files)

    if old_kernel is None:
        try:
            old_kernel = files.get_src_kernel()
        except ExploitFileError as e:
            console.error(f'Could not determine old kernel: {e.message}')
            return

    adapter = KernelAdapter(old_kernel, new_kernel)
    rewrites = gen_rewrite_rules(adapter)
    
    files.rewrite_files(
        lambda code: apply_rewrites(rewrites, code),
        diff_output=diff_output,
        diff_mode=diff_mode,
    )