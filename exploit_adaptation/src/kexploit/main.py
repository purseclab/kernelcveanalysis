from pathlib import Path
from typing import Optional
from typing_extensions import Annotated

from dotenv import load_dotenv
import typer

from .parse import DiffMode
from .kernel_image import add_kernel, list_kernels, Kernel
from .kernelctf_test import test_adapt_exploits
from .synthesis import setup_kernel_for_synthesis, synthesis_test_temp
from . import annotate as annotate_module
from . import adapt as adapt_module
from . import adapt_project as adapt_project_module

app = typer.Typer()

# subcommand groups
kernel_commands = typer.Typer()
synthesize_commands = typer.Typer()

app.add_typer(kernel_commands, name="kernel")
app.add_typer(synthesize_commands, name="synthesize")

@app.command()
def adapt(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to adapt")],
    new_kernel: Annotated[str, typer.Option(help="Name of new kernel to adapt exploit to")],
    old_kernel: Annotated[Optional[str], typer.Option(help="Name of kernel original exploit was made for")] = None,
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
    o: Annotated[Path, typer.Option(help="Output file for exploit diff")] = Path("new_exploit.diff"),
):
    if apply:
        diff_mode = DiffMode.ASK_APPLY_DIFF
    else:
        diff_mode = DiffMode.SHOW_DIFF

    adapt_module.adapt(
        exploit_files,
        None if old_kernel is None else Kernel(old_kernel),
        Kernel(new_kernel),
        o,
        diff_mode,
    )

@app.command()
def adapt_project(
    new_kernel: Annotated[str, typer.Option(help="Name of new kernel to adapt exploit to")],
    project: Annotated[Optional[Path], typer.Option(help="Path to project to adapt")] = None,
):
    adapt_project_module.adapt_project(
        project,
        Kernel(new_kernel),
    )

@app.command()
def annotate(
    exploit_files: Annotated[list[Path], typer.Argument(help="C source code files of exploit to annotate")],
    kernel: Annotated[str, typer.Option(help="Name of kernel original exploit was made for")],
    llm: Annotated[bool, typer.Option(help="Use ChatGPT API to identify addresses and offsets when annotating exploit")] = True,
    apply: Annotated[bool, typer.Option(help="Apply changes to exploit")] = False,
    o: Annotated[Path, typer.Option(help="Output file for exploit diff")] = Path("new_exploit.diff"),
):
    if apply:
        diff_mode = DiffMode.ASK_APPLY_DIFF
    else:
        diff_mode = DiffMode.SHOW_DIFF

    annotate_module.annotate(exploit_files, Kernel(kernel), llm, o, diff_mode)

@app.command()
def kernelctf_test(
    force_annotate: Annotated[bool, typer.Option(help="Force annotation to run even if annotated exploit code already exists")] = False,
    llm: Annotated[bool, typer.Option(help="Use ChatGPT API to identify addresses and offsets when annotating exploit")] = True,
    test_original: Annotated[bool, typer.Option(help="Make sure original version of exploit works against intended kernel when compiled")] = False,
):
    test_adapt_exploits(force_annotate, llm, test_original)

@kernel_commands.command()
def add(
    kernel_path: Annotated[Path, typer.Argument(help="Path to kernel image to import")],
    name: Annotated[Optional[str], typer.Option(help="Name to use for added kernel")] = None,
):
    add_kernel(kernel_path, name)

@kernel_commands.command(name='list')
def list_kernels_command():
    list_kernels()

@synthesize_commands.command(name='setup')
def synthesize_setup(
    kernel: Annotated[str, typer.Option(help="Name of kernel to set up exploit synthesis for")],
    codeql_db: Annotated[Path, typer.Option(help="Path to codeql database for the kernel")],
    vmlinux: Annotated[Path, typer.Option(help="Path to vmlinux elf binary with debug info")],
    linux_src: Annotated[Path, typer.Option(help="Path to linux source code")],
):
    setup_kernel_for_synthesis(Kernel(kernel), vmlinux, codeql_db, linux_src)

# FIXME: remove this temp command
@synthesize_commands.command(name='test')
def synthesis_test():
    synthesis_test_temp()

def main():
    load_dotenv()
    app()

if __name__ == "__main__":
    main()
