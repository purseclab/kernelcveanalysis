from enum import StrEnum
from abc import ABC, abstractmethod
from typing import Type

from pydantic import BaseModel

from .kernel_image import KernelAdapter, AdaptError

class AnnotationType(StrEnum):
    KEXPLOIT_META = "__kexploit_src_metadata"
    KEXPLOIT_ADDRESS = "__kexploit_kernel_address"
    KEXPLOIT_ROP_ADDRESS = "__kexploit_rop_address"
    KEXPLOIT_KERNEL_DATA = "__kexploit_kernel_data"

class Annotation(BaseModel, ABC):
    @staticmethod
    @abstractmethod
    def annotation_type() -> AnnotationType:
        '''
        Returns the annotation type corresponding to this annotation.
        '''
        pass

    @abstractmethod
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        '''
        Returns C code corresponding to this annotation.

        Used to convert annotated exploit to concrete exploit code for a specific kernel.
        '''
        pass

    @abstractmethod
    def adapt_fallback(self, adapter: KernelAdapter) -> str:
        '''
        Returns C code which is a fallback in case adapting fails.

        This should never fail, and should probably return C code corresponding to original annotation value.
        '''
        pass

    def __str__(self) -> str:
        # escape string quotes
        args = self.model_dump_json().replace('"', '\\"')

        return f'{self.annotation_type()}("{args}")'

# annotations are below
class SrcMetadata(Annotation):
    # kernel original exploit was written for
    original_kernel_name: str
    # kernel exploit is currently adapted to
    current_kernel_name: str

    @staticmethod
    def annotation_type():
        return AnnotationType.KEXPLOIT_META
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        # metadata has no corresponding code, just leave information in comment
        return f'''
// Exploit adapted by kexploit
// Original kernel name: {self.original_kernel_name}
// Adaptation kernel name: {adapter.dst_image.kernel.name}
'''
    
    def adapt_fallback(self, adapter: KernelAdapter) -> str:
        return self.adapt_to_code(adapter)

class KernelAddress(Annotation):
    address: int
    is_relative: bool

    @staticmethod
    def annotation_type():
        return AnnotationType.KEXPLOIT_ADDRESS
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        new_address = adapter.translate_address(self.address)
        if self.is_relative:
            return hex(adapter.dst_image.address_to_offset(new_address))
        else:
            return hex(new_address)
    
    def adapt_fallback(self, adapter: KernelAdapter) -> str:
        if self.is_relative:
            return hex(adapter.dst_image.address_to_offset(self.address))
        else:
            return hex(self.address)

class RopAddress(Annotation):
    gadget: str
    is_relative: bool
    original_value: int

    @staticmethod
    def annotation_type():
        return AnnotationType.KEXPLOIT_ROP_ADDRESS
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        if self.is_relative:
            return hex(adapter.translate_rop_gadget_offset(self.gadget))
        else:
            return hex(adapter.translate_rop_gadget(self.gadget))
    
    def adapt_fallback(self, adapter: KernelAdapter) -> str:
        return hex(self.original_value)

class KernelData(Annotation):
    address: int
    num_bytes: int
    original_value: int

    @staticmethod
    def annotation_type():
        return AnnotationType.KEXPLOIT_KERNEL_DATA
    
    def adapt_to_code(self, adapter: KernelAdapter) -> str:
        assert self.num_bytes <= 8
        new_address = adapter.translate_address(self.address)

        value_bytes = adapter.dst_image.get_bytes(new_address, self.num_bytes)
        if value_bytes is None:
            raise AdaptError('Could not retreive bytes for new address in kernel')
        
        return hex(adapter.dst_image.arch_info.unpack_usize(value_bytes))
    
    def adapt_fallback(self, adapter: KernelAdapter) -> str:
        return hex(self.original_value)

annotation_map = { annotation.annotation_type(): annotation for annotation in Annotation.__subclasses__() }
def annotation_for_annotation_type(annotation_type: AnnotationType) -> Type[Annotation]:
    return annotation_map[annotation_type]