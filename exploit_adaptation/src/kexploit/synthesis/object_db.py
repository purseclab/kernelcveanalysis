import re
import sqlite3
from dataclasses import dataclass, asdict
from enum import StrEnum
from pathlib import Path
from typing import List, Optional, Union, Any

from .btf_types import BtfType, BtfTypes
from .location import Location

OBJECT_DB_FILE_NAME = 'object_db.sqlite'

# TODO: add kcalloc and friends
class AllocType(StrEnum):
    KMALLOC = "kmalloc"
    KZALLOC = "kzalloc"
    KVMALLOC = "kvmalloc"
    UNKNOWN = "unknown"

    @classmethod
    def from_string(cls, s: str):
        s = s.lower()
        if "kzalloc" in s: return cls.KZALLOC
        if "kmalloc" in s: return cls.KMALLOC
        if "kvmalloc" in s: return cls.KVMALLOC
        return cls.UNKNOWN

# TODO: identify kmalloc cache used
@dataclass
class KmallocCall:
    call_site: Location
    call_type: AllocType
    struct_type: str
    struct_def: Location
    struct_size: int
    flags: str
    alloc_size: Optional[int]  # None if "unknown"
    sizeof_expr: str
    is_flexible: bool

    @classmethod
    def from_csv_row(cls, row: List[Any]):
        """Parses a single row from CodeQL CSV output."""
        # Clean up alloc_size (handle "unknown" and numeric strings)
        raw_alloc_size = row[6].strip()
        alloc_size = int(raw_alloc_size) if raw_alloc_size.isdigit() else None

        return cls(
            call_site=Location.from_str(row[0]),
            call_type=AllocType.from_string(row[1]),
            struct_type=row[2],
            struct_def=Location.from_str(row[3]),
            struct_size=int(row[4]),
            flags=row[5],
            alloc_size=alloc_size,
            sizeof_expr=row[7],
            is_flexible=row[8].lower() == "true"
        )

    def to_db_dict(self):
        """Prepares data for SQLite storage (converts Enums and Locations to strings)."""
        d = asdict(self)
        d['call_site'] = str(self.call_site)
        d['struct_def'] = str(self.struct_def)
        # d['call_type'] = self.call_type.value
        return d

    @classmethod
    def from_db_row(cls, row: tuple):
        """Creates a KmallocCall instance from a SQLite row tuple."""
        # We cast the last element (is_flexible) to bool explicitly 
        # because SQLite returns it as an int (0 or 1).
        return cls(
            call_site=Location.from_str(row[0]),
            call_type=AllocType(row[1]), # Convert string back to Enum
            struct_type=row[2],
            struct_def=Location.from_str(row[3]),
            struct_size=row[4],
            flags=row[5],
            alloc_size=row[6], # Will be int or None (NULL in DB)
            sizeof_expr=row[7],
            is_flexible=bool(row[8]) # Convert 0/1 back to True/False
        )

@dataclass
class HeapObject:
    id: int
    btf_type: BtfType
    location: Location
    source_code: str
    is_anon: bool

    def to_db_dict(self) -> dict:
        d = asdict(self)
        d['btf_type'] = self.btf_type.id
        d['location'] = str(self.location)
    
    # @classmethod
    # def from_db_row(cls, row: tuple):
    #     return cls(
    #         id=row[0],
    #         btf_type=BtfType.from_db_row(row[1]),
    #     )

class ObjectDb:
    def __init__(self, db_path: Path):
        self.db = sqlite3.connect(db_path)
        self._setup_tables()

    def _setup_tables(self):
        self.db.execute('''
            CREATE TABLE IF NOT EXISTS btf_types (
                id INTEGER PRIMARY KEY,
                kind TEXT NOT NULL,
                name TEXT NOT NULL,
                type_id INTEGER,
                size INTEGER,
                bits_offset INTEGER,
                nr_bits INTEGER,
                encoding TEXT,
                index_type_id INTEGER,
                nr_elems INTEGER,
                vlen INTEGER,
                members TEXT,
                -- values must be values_json because values is a keyword
                values_json TEXT,
                fwd_kind TEXT,
                ret_type_id INTEGER,
                params TEXT,
                vars TEXT,
                linkage TEXT,
                component_idx INTEGER
            )
        ''')
        self.db.execute('''
            CREATE TABLE IF NOT EXISTS objects (
                id INTEGER PRIMARY KEY,
                type_id INTEGER NOT NULL REFERENCES btf_types(id),
                location TEXT NOT NULL,
                source_code TEXT NOT NULL,
                is_anon INTEGER NOT NULL
            )
        ''')
        self.db.execute('''
            CREATE TABLE IF NOT EXISTS kmalloc_calls (
                call_site TEXT NOT NULL,
                call_type TEXT NOT NULL,
                struct_type TEXT NOT NULL,
                struct_def TEXT NOT NULL,
                struct_size INTEGER NOT NULL,
                flags TEXT NOT NULL,
                alloc_size INTEGER,
                sizeof_expr TEXT NOT NULL,
                is_flexible INTEGER NOT NULL
            )
        ''')
        self.db.commit()

    def save_kmalloc_call(self, call: KmallocCall):
        """Saves a single KmallocCall instance to the database."""
        query = '''
            INSERT INTO kmalloc_calls (
                call_site, call_type, struct_type, struct_def, 
                struct_size, flags, alloc_size, sizeof_expr, is_flexible
            ) VALUES (
                :call_site, :call_type, :struct_type, :struct_def, 
                :struct_size, :flags, :alloc_size, :sizeof_expr, :is_flexible
            )
        '''
        with self.db:
            self.db.execute(query, call.to_db_dict())

    def get_all_kmalloc_calls(self) -> list[KmallocCall]:
        """Retrieves all records and returns them as a list of KmallocCall objects."""
        cursor = self.db.execute('SELECT * FROM kmalloc_calls')
        return [KmallocCall.from_db_row(row) for row in cursor.fetchall()]

    def save_btf_type(self, btf_type: BtfType):
        """Saves a single BtfType instance to the database."""
        query = '''
            INSERT INTO btf_types (
                id, kind, name, type_id, size, bits_offset, nr_bits, encoding,
                index_type_id, nr_elems, vlen, members, values_json, fwd_kind,
                ret_type_id, params, vars, linkage, component_idx
            ) VALUES (
                :id, :kind, :name, :type_id, :size, :bits_offset, :nr_bits, :encoding,
                :index_type_id, :nr_elems, :vlen, :members, :values_json, :fwd_kind,
                :ret_type_id, :params, :vars, :linkage, :component_idx
            )
        '''
        with self.db:
            self.db.execute(query, btf_type.to_db_dict())

    def save_btf_types(self, btf_types_list: list[BtfType]):
        """Saves a list of BtfType instances to the database efficiently."""
        query = '''
            INSERT INTO btf_types (
                id, kind, name, type_id, size, bits_offset, nr_bits, encoding,
                index_type_id, nr_elems, vlen, members, values_json, fwd_kind,
                ret_type_id, params, vars, linkage, component_idx
            ) VALUES (
                :id, :kind, :name, :type_id, :size, :bits_offset, :nr_bits, :encoding,
                :index_type_id, :nr_elems, :vlen, :members, :values_json, :fwd_kind,
                :ret_type_id, :params, :vars, :linkage, :component_idx
            )
        '''
        with self.db:
            self.db.executemany(query, [t.to_db_dict() for t in btf_types_list])

    def get_all_btf_types(self, btf_types_ctx: BtfTypes) -> list[BtfType]:
        """Retrieves all BtfType records and returns them as a list."""
        cursor = self.db.execute('''
            SELECT 
                id, kind, name, type_id, size, bits_offset, nr_bits, encoding,
                index_type_id, nr_elems, vlen, members, values_json, fwd_kind,
                ret_type_id, params, vars, linkage, component_idx
            FROM btf_types
        ''')
        return [BtfType.from_db_row(btf_types_ctx, row) for row in cursor.fetchall()]
    
    def save_heap_object(self, object: HeapObject):
        query = '''
            INSERT INTO objects (
                id, type_id, location, source_code, is_anon
            ) VALUES (
                :id, :btf_type, :location, :source_code, :is_anon
            )
        '''
        with self.db:
            self.db.execute(query, object.to_db_dict())