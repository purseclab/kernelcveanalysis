import re
import sqlite3
from dataclasses import dataclass, asdict
from enum import StrEnum
from pathlib import Path
from typing import List, Optional, Union, Any

OBJECT_DB_FILE_NAME = 'object_db.sqlite'

# TODO: add kcalloc and friends
class AllocType(StrEnum):
    KMALLOC = "kmalloc"
    KZALLOC = "kzalloc"
    KVMALLOC = "kvmalloc"
    UNKNOWN = "unknown"

    @classmethod
    def from_string(cls, s: str):
        s = s.lower()
        if "kzalloc" in s: return cls.KZALLOC
        if "kmalloc" in s: return cls.KMALLOC
        if "kvmalloc" in s: return cls.KVMALLOC
        return cls.UNKNOWN

@dataclass
class Location:
    file_path: str
    line_start: int
    col_start: int
    line_end: int
    col_end: int

    @classmethod
    def from_str(cls, s: str):
        # 1. Strip potential quotes if the CSV parser didn't catch them
        s = s.strip('"')
        
        # 2. Match: Optional file:// prefix, then path, then 4 colon-separated numbers
        pattern = r"^(?:file://)?(.*?):(\d+):(\d+):(\d+):(\d+)$"
        match = re.match(pattern, s)
        
        if not match:
            # Fallback for unexpected formats
            return cls(file_path=s, line_start=0, col_start=0, line_end=0, col_end=0)
        
        path, l1, c1, l2, c2 = match.groups()
        
        return cls(
            file_path=path,
            line_start=int(l1),
            col_start=int(c1),
            line_end=int(l2),
            col_end=int(c2)
        )

    def __str__(self):
        """Full string representation for round-tripping data."""
        return f"{self.file_path}:{self.line_start}:{self.col_start}:{self.line_end}:{self.col_end}"

# TODO: identify kmalloc cache used
@dataclass
class KmallocCall:
    call_site: Location
    call_type: AllocType
    struct_type: str
    struct_def: Location
    struct_size: int
    flags: str
    alloc_size: Optional[int]  # None if "unknown"
    sizeof_expr: str
    is_flexible: bool

    @classmethod
    def from_csv_row(cls, row: List[Any]):
        """Parses a single row from CodeQL CSV output."""
        # Clean up alloc_size (handle "unknown" and numeric strings)
        raw_alloc_size = row[6].strip()
        alloc_size = int(raw_alloc_size) if raw_alloc_size.isdigit() else None

        return cls(
            call_site=Location.from_str(row[0]),
            call_type=AllocType.from_string(row[1]),
            struct_type=row[2],
            struct_def=Location.from_str(row[3]),
            struct_size=int(row[4]),
            flags=row[5],
            alloc_size=alloc_size,
            sizeof_expr=row[7],
            is_flexible=row[8].lower() == "true"
        )

    def to_db_dict(self):
        """Prepares data for SQLite storage (converts Enums and Locations to strings)."""
        d = asdict(self)
        d['call_site'] = str(self.call_site)
        d['struct_def'] = str(self.struct_def)
        # d['call_type'] = self.call_type.value
        return d

    @classmethod
    def from_db_row(cls, row: tuple):
        """Creates a KmallocCall instance from a SQLite row tuple."""
        # We cast the last element (is_flexible) to bool explicitly 
        # because SQLite returns it as an int (0 or 1).
        return cls(
            call_site=Location.from_codeql_str(row[0]),
            call_type=AllocType(row[1]), # Convert string back to Enum
            struct_type=row[2],
            struct_def=Location.from_codeql_str(row[3]),
            struct_size=row[4],
            flags=row[5],
            alloc_size=row[6], # Will be int or None (NULL in DB)
            sizeof_expr=row[7],
            is_flexible=bool(row[8]) # Convert 0/1 back to True/False
        )

class ObjectDb:
    def __init__(self, db_path: Path):
        self.db = sqlite3.connect(db_path)
        self._setup_tables()

    def _setup_tables(self):
        self.db.execute('''
            CREATE TABLE IF NOT EXISTS kmalloc_calls (
                call_site TEXT NOT NULL,
                call_type TEXT NOT NULL,
                struct_type TEXT NOT NULL,
                struct_def TEXT NOT NULL,
                struct_size INTEGER NOT NULL,
                flags TEXT NOT NULL,
                alloc_size INTEGER,
                sizeof_expr TEXT NOT NULL,
                is_flexible INTEGER NOT NULL
            )
        ''')
        self.db.commit()

    def save_kmalloc_call(self, call: KmallocCall):
        """Saves a single KmallocCall instance to the database."""
        query = '''
            INSERT INTO kmalloc_calls (
                call_site, call_type, struct_type, struct_def, 
                struct_size, flags, alloc_size, sizeof_expr, is_flexible
            ) VALUES (
                :call_site, :call_type, :struct_type, :struct_def, 
                :struct_size, :flags, :alloc_size, :sizeof_expr, :is_flexible
            )
        '''
        with self.db:
            self.db.execute(query, call.to_db_dict())

    def get_all_kmalloc_calls(self) -> List[KmallocCall]:
        """Retrieves all records and returns them as a list of KmallocCall objects."""
        cursor = self.db.execute('SELECT * FROM kmalloc_calls')
        return [KmallocCall.from_db_row(row) for row in cursor.fetchall()]