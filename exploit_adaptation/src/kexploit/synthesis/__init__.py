from pathlib import Path
import subprocess
import json
import csv

from ..kernel_image import Kernel
from .codeql import CodeqlContext, CodeqlQuery
from .object_db import ObjectDb, OBJECT_DB_FILE_NAME, KmallocCall
from .btf_types import BtfTypes, BTF_JSON_NAME

def setup_kernel_for_synthesis(kernel: Kernel, vmlinux_path: Path, codeql_db_path: Path):
    synthesis_data = kernel.synthesis_data_path()
    # TODO: remove exists ok
    synthesis_data.mkdir(exist_ok=True)

    codeql = CodeqlContext(codeql_db_path)
    object_db = ObjectDb(synthesis_data / OBJECT_DB_FILE_NAME)

    extract_type_info(synthesis_data / BTF_JSON_NAME, vmlinux_path)
    extract_kmalloc_calls(object_db, codeql)

def extract_type_info(json_file: Path, vmlinux_path: Path):
    # https://www.kernel.org/doc/html/latest/bpf/btf.html

    # NOTE: kernel dashboard originally uses pahole to extract and reencode btf data to another file first
    # I don't think this is necessary
    raw_json_output = subprocess.check_output([
        'bpftool', 'btf', 'dump', '--json', 'file', str(vmlinux_path),
    ])

    with open(json_file, 'w') as f:
        f.write(raw_json_output.decode('utf-8'))

def extract_kmalloc_calls(object_db: ObjectDb, codeql: CodeqlContext):
    csv_data = codeql.run_query(CodeqlQuery.KmallocCalls)
    rows = csv.reader(csv_data.splitlines())
    # skip header row
    next(rows)
    for row in rows:
        call = KmallocCall.from_csv_row(row)
        object_db.save_kmalloc_call(call)

def synthesis_test_temp():
    kernel = Kernel('ingots_5.10.107')
    bpf_types = BtfTypes.load(kernel)
    print(bpf_types.types[1])
    print(bpf_types.get_type_by_name('pipe_buffer'))