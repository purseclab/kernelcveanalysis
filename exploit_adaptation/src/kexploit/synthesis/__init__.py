from pathlib import Path
import subprocess
import shutil
import json

from ..kernel_image import Kernel
from .codeql import CodeqlContext, CodeqlQuery
from .object_db import ObjectDb, OBJECT_DB_FILE_NAME, KmallocCall, HeapObject
from .btf_types import BtfTypes, BTF_JSON_NAME, BtfStruct
from .location import Location
from .synthesis_metadata import SynthesisMetadata

def setup_kernel_for_synthesis(kernel: Kernel, vmlinux_path: Path, codeql_db_path: Path, compile_commands_path: Path, linux_src_path: Path):
    synthesis_data = kernel.synthesis_data_path()
    # TODO: remove exists ok
    synthesis_data.mkdir(exist_ok=True)

    metadata = SynthesisMetadata(
        kernel_name=kernel.name,
        vmlinux=vmlinux_path,
        codeql_db=codeql_db_path,
        linux_src=linux_src_path,
    )
    # put compile commands in syntehsis data so clangd puts the cache in there
    shutil.copy(compile_commands_path, metadata.compile_commands_path())
    # TODO: maybe copy data like kernel image, compile commands over to data folder as well
    metadata.save()

    codeql = CodeqlContext(codeql_db_path)
    object_db = ObjectDb(synthesis_data / OBJECT_DB_FILE_NAME)

    extract_type_info(codeql, object_db, vmlinux_path)
    extract_kmalloc_calls(object_db, codeql)

# FIXME: a bit scuffed to have objects in json but kmalloc calls in sqlite
# this is just the lazy approach for now
def extract_type_info(codeql: CodeqlContext, object_db: ObjectDb, vmlinux_path: Path):
    # https://www.kernel.org/doc/html/latest/bpf/btf.html

    # NOTE: kernel dashboard originally uses pahole to extract and reencode btf data to another file first
    # I don't think this is necessary
    raw_json_output = subprocess.check_output([
        'bpftool', 'btf', 'dump', '--json', 'file', str(vmlinux_path),
    ]).decode('utf-8')
    types = BtfTypes(json.loads(raw_json_output))

    codeql_structs = codeql.get_structs()

    # mapping from struct name and field names to struct
    # used to match codeql structs with btf structs
    mapping = {}

    ids = list(sorted(types.types.keys()))
    objects = [types.get_type(id) for id in ids]
    object_db.save_btf_types(objects)

    for btf_type in types.types.values():
        if type(btf_type) is not BtfStruct:
            continue

        members = tuple(member.name for member in btf_type.members)
        mapping[(btf_type.name, members)] = btf_type
    
    # FIXME: see if there are any no matches for btf to codeql
    # FIXME: figure out why some codeql don't have a match
    # FIXME: just use codeql
    for struct in codeql_structs:
        name = '(anon)' if struct.is_anon else struct.struct_name
        key = (name, tuple(struct.field_names))
        if key not in mapping:
            # print(f'warning: no matching btf struct signature for {struct}')
            continue
        
        btf_type = mapping[key]
        mapping[key] = None

        if btf_type is None:
            print(f'warning: duplicate btf struct signature for {struct}')
            continue

        object_db.save_btf_type(btf_type)
        object_db.save_heap_object(HeapObject(
            id=struct.location.to_db_id(),
            type_id=btf_type.id,
            location=str(struct.location),
            source_code='TODO',
            is_anon=struct.is_anon,
        ))

    # with open(json_file, 'w') as f:
    #     f.write(raw_json_output.decode('utf-8'))

def extract_kmalloc_calls(object_db: ObjectDb, codeql: CodeqlContext):
    results = codeql.get_kmalloc_calls()
    for result in results:
        call = KmallocCall.from_codeql_result(result)
        
        # Link to HeapObject if possible
        heap_obj_id = result.struct_def.to_db_id()
        if object_db.get_heap_object(heap_obj_id):
            call.heap_object_id = heap_obj_id
            
        object_db.save_kmalloc_call(call)

def synthesis_test_temp():
    kernel = Kernel('ingots_5.10.107')
    metadata = SynthesisMetadata.load_for_kernel(kernel)
    codeql = CodeqlContext(metadata.codeql_db)

    calls = codeql.get_kmalloc_calls()
    for call in calls:
        if call.kmalloc_cache_name is not None:
            print(call)
    # caches = codeql.run_query_raw(CodeqlQuery.Caches)
    # print(caches)

    # bpf_types = BtfTypes.load(kernel)
    # print(bpf_types.types[1])
    # print(bpf_types.get_type_by_name('pipe_buffer').format_long())

    # for row in codeql.run_query(CodeqlQuery.Structs):
    #     print(row)

    # anon_count = 0
    # for bpf_type in bpf_types.types.values():
    #     if bpf_type.kind == 'STRUCT' and bpf_type.name == '(anon)':
    #         anon_count += 1
    # print(anon_count)