import subprocess
import pylspclient
from pathlib import Path
from typing import Optional

from .synthesis_metadata import SynthesisMetadata

class KernelLsp:
    def __init__(self, metadata: SynthesisMetadata):
        self.metadata = metadata
        self.proc: Optional[subprocess.Popen] = None
        self.client: Optional[pylspclient.LspClient] = None
        self.lsp_endpoint: Optional[pylspclient.LspEndpoint] = None
        
        self._start()

    def _start(self):
        compile_commands_path = self.metadata.compile_commands_path()
        # clangd expects the directory containing compile_commands.json
        compile_commands_dir = compile_commands_path.parent if compile_commands_path.name == 'compile_commands.json' else compile_commands_path

        cmd = [
            'clangd',
            f'--compile-commands-dir={compile_commands_dir}',
            '--background-index',
            '--limit-results=0',
            '--header-insertion=never'
        ]

        self.proc = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
        )

        json_rpc_endpoint = pylspclient.JsonRpcEndpoint(self.proc.stdin, self.proc.stdout)
        self.lsp_endpoint = pylspclient.LspEndpoint(json_rpc_endpoint)
        self.client = pylspclient.LspClient(self.lsp_endpoint)

        root_uri = f'file://{self.metadata.linux_src.resolve()}'
        
        # Initialize
        self.client.initialize(
            processId=self.proc.pid,
            rootUri=root_uri,
            capabilities={}
        )
        self.client.initialized()

    def definition(self, file_path: Path | str, line: int, character: int):
        # line and character are 0-based
        if isinstance(file_path, str):
            file_path = Path(file_path)
            
        uri = f'file://{file_path.resolve()}'
        return self.client.definition(
            textDocument={'uri': uri},
            position={'line': line, 'character': character}
        )

    def shutdown(self):
        if self.client:
            try:
                self.client.shutdown()
                self.client.exit()
            except Exception:
                pass
        
        if self.proc:
            self.proc.terminate()
            self.proc.wait()
