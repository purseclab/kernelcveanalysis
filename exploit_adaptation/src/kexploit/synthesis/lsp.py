import subprocess
# import pylspclient
from pathlib import Path
from typing import Optional, Type, Self, List, Union, TypeVar, Generic
from dataclasses import dataclass
from enum import StrEnum

from multilspy import SyncLanguageServer
from multilspy.multilspy_config import MultilspyConfig
from multilspy.multilspy_logger import MultilspyLogger
from multilspy.multilspy_types import UnifiedSymbolInformation, SymbolKind, Location as MultilspyLocation
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field, PrivateAttr

from .synthesis_metadata import SynthesisMetadata
from .location import Location, Position

# tools for llm to use lsp to traverse structure of source code
# maybe could be done with codeql but I think this is would be more complicated to set up
# perhaps in future everything should just be codeql to be cleaner though

class SymbolType(StrEnum):
    File = 'file'
    Module = 'module'
    Namespace = 'namespace'
    Package = 'package'
    Class = 'class'
    Method = 'method'
    Property = 'property'
    Field = 'field'
    Constructor = 'constructor'
    Enum = 'enum'
    Interface = 'interface'
    Function = 'function'
    Variable = 'variable'
    Constant = 'constant'
    String = 'string'
    Number = 'number'
    Boolean = 'boolean'
    Array = 'array'
    Object = 'object'
    Key = 'key'
    Null = 'null'
    EnumMember = 'enum-member'
    Struct = 'struct'
    Event = 'event'
    Operator = 'operator'
    TypeParameter = 'type-parameter'
    Macro = 'macro'
    Unknown = 'unknown'

    @classmethod
    def from_multilspy_symbol(cls, symbol: UnifiedSymbolInformation) -> Self:
        kind = symbol['kind']
        mapping = {
            1: cls.File,
            2: cls.Module,
            3: cls.Namespace,
            4: cls.Package,
            5: cls.Class,
            6: cls.Method,
            7: cls.Property,
            8: cls.Field,
            9: cls.Constructor,
            10: cls.Enum,
            11: cls.Interface,
            12: cls.Function,
            13: cls.Variable,
            14: cls.Constant,
            15: cls.String,
            16: cls.Number,
            17: cls.Boolean,
            18: cls.Array,
            19: cls.Object,
            20: cls.Key,
            21: cls.Null,
            22: cls.EnumMember,
            23: cls.Struct,
            24: cls.Event,
            25: cls.Operator,
            26: cls.TypeParameter,
        }
        return mapping.get(kind, cls.Unknown)

@dataclass
class LlmSymbolDefinition:
    location: Location
    symbol_name: str
    symbol_type: SymbolType
    source_code: str

    @classmethod
    def from_multilspy_symbol(cls, symbol: UnifiedSymbolInformation, metadata: SynthesisMetadata) -> Self:
        location = Location.from_multilspy_location(symbol['location'])
        return cls(
            location=location,
            symbol_name=symbol['name'],
            symbol_type=SymbolType.from_multilspy_symbol(symbol),
            source_code=location.read_source(metadata)
        )

    @classmethod
    def from_multilspy_location(cls, location: MultilspyLocation, metadata: SynthesisMetadata, symbol_name: str, symbol_type: SymbolType = SymbolType.Unknown) -> Self:
        loc = Location.from_multilspy_location(location)
        return cls(
            location=loc,
            symbol_name=symbol_name,
            symbol_type=symbol_type,
            source_code=loc.read_source(metadata)
        )

    def symbol_info_str(self) -> str:
        if self.symbol_type == SymbolType.Unknown:
            type_str = ''
        else:
            type_str = f' is a {self.symbol_type}'
        return f'{self.symbol_name}{type_str} in file {self.location.file_path} starting at line={self.location.start.line},column={self.location.start.column}'
    
    def symbol_details(self, max_lines: Optional[int] = None) -> str:
        # keeps empty lines in the start and middle, but not end, which is what we want
        lines = self.source_code.splitlines()
        if max_lines is not None and len(lines) > max_lines:
            used_lines = '\n'.join(lines[:max_lines])
            remaining_count = len(lines) - max_lines

            return f'{self.symbol_info_str()}\n```\n{used_lines}\n({remaining_count} lines not shown...)```'
        else:
            # show all source code
            return f'{self.symbol_info_str()}\n```\n{self.source_code}```'

@dataclass
class LlmSymbolReference:
    symbol: LlmSymbolDefinition
    reference_location: Location

T = TypeVar('T')

class LspSearchResult(BaseModel, Generic[T]):
    result: Optional[T] = None
    # We use LlmSymbolDefinition here because when we have ambiguity, we want to show "potential definitions" at those locations
    ambiguous_candidates: Optional[List[LlmSymbolDefinition]] = None
    error: Optional[str] = None
    
    class Config:
        arbitrary_types_allowed = True

    def is_ambiguous(self) -> bool:
        return self.ambiguous_candidates is not None and len(self.ambiguous_candidates) > 0
        
    def is_error(self) -> bool:
        return self.error is not None

class LlmSymbolLookupInfo(BaseModel):
    symbol_name: str = Field(description='Name of symbol to lookup')
    file: str = Field(description='File path to lookup symbol in, where either the symbol exists or references to the symbol exist')
    start_line: Optional[int] = Field(description='Optional start line, only needed when multiple symbols or references are present in the same file')
    end_line: Optional[int] = Field(description='Optional start column, only needed when multiple symbols or references are present in the same file on the same line')


def create_lsp(metadata: SynthesisMetadata) -> SyncLanguageServer:
    config = MultilspyConfig.from_dict({
        'code_language': 'cpp',
    })
    logger = MultilspyLogger()
    return SyncLanguageServer.create(config, logger, str(metadata.linux_src))

class KernelLsp:
    _lsp: SyncLanguageServer
    _metadata: SynthesisMetadata

    def __init__(self, metadata: SynthesisMetadata, lsp: SyncLanguageServer):
        '''
        Create a KernelLsp from an already started multilspy lsp
        '''
        self._metadata = metadata
        self._lsp = lsp
    
    def search_symbols(self, query: str) -> list[LlmSymbolDefinition]:
        symbols = self._lsp.request_workspace_symbol(query)
        if not symbols:
            return []

        return [LlmSymbolDefinition.from_multilspy_symbol(symbol, self._metadata) for symbol in symbols]
    
    def _symbols_in_file(self, file: str) -> list[LlmSymbolDefinition]:
        symbols = self._lsp.request_document_symbols(file)
        if not symbols:
            return []
        
        return [LlmSymbolDefinition.from_multilspy_symbol(symbol, self._metadata) for symbol in symbols]

    def find_symbols(self, file: str, symbol_name: str, line: Optional[int] = None) -> list[LlmSymbolDefinition]:
        symbols = self._symbols_in_file(file)

        return [
            symbol for symbol in symbols
            if symbol.symbol_name == symbol_name and (line is None or line == symbol.location.start.line)
        ]

    def _find_reference_positions(self, file: str, symbol_name: str, line: Optional[int] = None) -> List[Position]:
        """
        Helper to find line/column for a symbol in a file.
        Returns a list of matching positions.
        """
        path = self._metadata.linux_src / file
        if not path.exists():
            return []
        
        # Simple text search for now as fallback/primary method for "location of string in file"
        # Since LSP 'documentSymbol' gives defined symbols, not all tokens.
        # But we want 'definition' or 'references' starting from a token.
        
        positions = []
        try:
            with open(path, 'r', encoding='utf-8', errors='replace') as f:
                lines = f.readlines()
            
            for i, text in enumerate(lines):
                if line is not None and (i + 1) != line:
                    continue
                
                # Check for symbol presence. 
                # Ideally we want exact token match, but a simple find is a start.
                # We iterate to find all occurrences in the line
                idx = 0
                while True:
                    idx = text.find(symbol_name, idx)
                    if idx == -1:
                        break
                    
                    # Basic word boundary check
                    is_start = (idx == 0) or (not text[idx-1].isalnum() and text[idx-1] != '_')
                    is_end = (idx + len(symbol_name) == len(text)) or (not text[idx+len(symbol_name)].isalnum() and text[idx+len(symbol_name)] != '_')
                    
                    if is_start and is_end:
                         # LSP uses 0-based indexing for line and char
                        positions.append(Position(line=i, column=idx))
                    
                    idx += 1
        except Exception:
            pass
            
        return positions

    # follows definition -> references
    def find_references(self, file: str, symbol_name: str, line: Optional[int] = None) -> LspSearchResult[List[LlmSymbolReference]]:
        """
        Returns list of references (as LlmSymbolReference) or error string.
        """
        symbols = self.find_symbols(file, symbol_name, line)
        
        if not symbols:
            return LspSearchResult(error=f"Could not find symbol '{symbol_name}' in '{file}'" + (f" at line {line}" if line else ""))
        
        if len(symbols) > 1:
            return LspSearchResult(ambiguous_candidates=symbols)

        # Unique match
        symbol = symbols[0]

        # 2. Get references
        # convert to 0 indexed
        refs = self._lsp.request_references(file, symbol.start.line - 1, symbol.start.column - 1)
        
        results = []
        for ref in refs:
            ref_loc = Location.from_multilspy_location(ref)
            results.append(LlmSymbolReference(
                symbol=symbol,
                reference_location=ref_loc
            ))
            
        return LspSearchResult(result=results)

    # follows reference -> definition
    def find_definition(self, references_file: str, symbol_name: str, line: Optional[int] = None) -> LspSearchResult[List[LlmSymbolDefinition]]:
        """
        Returns list of definitions or error/ambiguity list.
        """
        reference_positions = self._find_reference_positions(references_file, symbol_name, line)
        
        if not reference_positions:
            return LspSearchResult(error=f"Could not find symbol '{symbol_name}' in '{references_file}'" + (f" at line {line}" if line else ""))
        
        if len(reference_positions) > 1:
             # Ambiguous - return list of potential starting points
            ambiguous_matches = []
            for pos in reference_positions:
                loc = Location(references_file, Position(pos.line + 1, pos.column + 1), Position(pos.line + 1, pos.column + 1 + len(symbol_name)))
                ambiguous_matches.append(LlmSymbolDefinition(
                    location=loc,
                    symbol_name=symbol_name,
                    symbol_type=SymbolType.Unknown,
                    source_code=loc.read_source(self._metadata)
                ))
            return LspSearchResult(ambiguous_candidates=ambiguous_matches)

        pos = reference_positions[0]
        defs = self._lsp.request_definition(references_file, pos.line, pos.column)
        
        results = []
        for d in defs:
            results.append(LlmSymbolDefinition.from_multilspy_location(d, self._metadata, symbol_name))
            
        return LspSearchResult(result=results)

MAX_SEARCH_RESULTS = 256
SHORT_RESULT_NUM_LINES = 8

class SearchSymbolInput(BaseModel):
    query: str = Field(description='search for a symbol with a name similar to this query string')
    max_results: int = Field(
        default=32,
        description=f'Maximum number of matching symbol results returned, cant be more then {MAX_SEARCH_RESULTS}'
    )

class LspSearchSymbolTool(BaseTool):
    name: str = 'search_symbol'
    description: str = 'Search for a given symbol such as a struct or function name in the linux kernel and return the results'
    args_schema: Type[BaseModel] = SearchSymbolInput

    _lsp: KernelLsp = PrivateAttr()

    def __init__(self, lsp: KernelLsp, **kwargs):
        super().__init__(**kwargs)
        self._lsp = lsp

    def run(self, query: str, max_results: int = 5) -> str:
        symbols = self._lsp.search_symbols(query)
        # Sort or filter if needed, for now just take top N
        symbols = symbols[:max_results]
        if not symbols:
            return f'No symbols found matching `{query}`'
        
        symbol_results = '\n\n'.join(symbol.symbol_details(max_lines=SHORT_RESULT_NUM_LINES) for symbol in symbols)
        return f'symbol search results for `{query}`:\n{symbol_results}'

class FindReferencesInput(BaseModel):
    symbol_name: str = Field(description='Name of symbol to find references for')
    file: str = Field(description='File path where the symbol is located')
    line: Optional[int] = Field(description='Optional line number to disambiguate if the symbol appears multiple times in the file')

class LspFindReferencesTool(BaseTool):
    name: str = 'find_references'
    description: str = 'Find references to a symbol occurring in a specific file. Returns list of locations where the symbol is referenced.'
    args_schema: Type[BaseModel] = FindReferencesInput
    
    _lsp: KernelLsp = PrivateAttr()

    def __init__(self, lsp: KernelLsp, **kwargs):
        super().__init__(**kwargs)
        self._lsp = lsp

    def run(self, symbol_name: str, file: str, line: Optional[int] = None) -> str:
        res = self._lsp.find_references(file, symbol_name, line)
        
        if res.is_error():
            return f"Error: {res.error}"
        
        if res.is_ambiguous():
             output = ["Ambiguous match. Please specify the correct line number from the following candidates:\n"]
             for cand in res.ambiguous_candidates:
                 output.append(cand.symbol_details(max_lines=SHORT_RESULT_NUM_LINES))
             return "\n\n".join(output)
        
        if not res.result:
            return "No references found."
        
        output = []
        # Result is List[LlmSymbolReference]
        for ref in res.result:
             # We want to show the code at the reference location
             # The 'symbol' field contains the definition info, which might be useful context,
             # but usually for 'find references' we want to see the usages.
             
             # Read source at reference location
             ref_code = ref.reference_location.read_source(self._lsp._metadata)
             
             # Format output
             # Trim code to max 8 lines for brevity
             lines = ref_code.splitlines()
             if len(lines) > SHORT_RESULT_NUM_LINES:
                 ref_code = '\n'.join(lines[:SHORT_RESULT_NUM_LINES]) + '\n(more lines...)'
                 
             output.append(f"Reference at {ref.reference_location.file_path}:{ref.reference_location.start.line}:\n```\n{ref_code}\n```")
             
        return "\n\n".join(output)

class FindDefinitionInput(BaseModel):
    symbol_name: str = Field(description='Name of symbol to find definition for')
    file: str = Field(description='File path where the symbol usage is located')
    line: Optional[int] = Field(description='Optional line number to disambiguate if the symbol usage appears multiple times in the file')

class LspFindDefinitionTool(BaseTool):
    name: str = 'find_definition'
    description: str = 'Find definition of a symbol given a usage occurring in a specific file.'
    args_schema: Type[BaseModel] = FindDefinitionInput
    
    _lsp: KernelLsp = PrivateAttr()

    def __init__(self, lsp: KernelLsp, **kwargs):
        super().__init__(**kwargs)
        self._lsp = lsp

    def run(self, symbol_name: str, file: str, line: Optional[int] = None) -> str:
        res = self._lsp.find_definition(file, symbol_name, line)
        
        if res.is_error():
            return f"Error: {res.error}"

        if res.is_ambiguous():
             output = ["Ambiguous matches, please specify line number:"]
             for cand in res.ambiguous_candidates:
                 output.append(cand.symbol_details(max_lines=SHORT_RESULT_NUM_LINES))
             return "\n\n".join(output)

        if not res.result:
            return "No definition found."
            
        output = []
        for res in res.result:
            output.append(res.symbol_details(max_lines=SHORT_RESULT_NUM_LINES))

        return "\n\n".join(output)

class ReadSymbolInput(BaseModel):
    symbol_name: str = Field(description='Name of symbol to find and read')
    file: str = Field(description='File path where the symbol usage is located')
    line: Optional[int] = Field(description='Optional line number to disambiguate if the symbol usage appears multiple times in the file')
    
class LspReadSymbolTool(BaseTool):
    name: str = 'read_symbol'
    description: str = 'Finds a symbol and returns its full source code. If multiple symbols match, returns a list of ambiguous matches with shortened source.'
    args_schema: Type[BaseModel] = ReadSymbolInput

    _lsp: KernelLsp = PrivateAttr()
    
    def __init__(self, lsp: KernelLsp, **kwargs):
        super().__init__(**kwargs)
        self._lsp = lsp
    
    def run(self, symbol_name: str, file: str, line: Optional[int] = None) -> str:
        symbols = self._lsp.find_symbols(file, symbol_name, line)

        if not symbols:
            return f"No symbols found matching '{symbol_name}'"
    
        if len(symbols) == 1:
            return symbols[0].symbol_details(max_lines=None)
    
        output = [f"Ambiguous matches for '{symbol_name}':\n"]
        limit = 16
        for symbol in symbols[:limit]:
            output.append(symbol.symbol_details(max_lines=SHORT_RESULT_NUM_LINES))
    
        if len(symbols) > limit:
            output.append(f"\n... and {len(symbols) - limit} more matches.")
    
        return "\n\n".join(output)
    
