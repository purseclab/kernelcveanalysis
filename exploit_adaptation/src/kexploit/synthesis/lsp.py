import subprocess
# import pylspclient
from pathlib import Path
from typing import Optional, Type, Self
from dataclasses import dataclass
from enum import StrEnum

from multilspy import SyncLanguageServer
from multilspy.multilspy_config import MultilspyConfig
from multilspy.multilspy_logger import MultilspyLogger
from multilspy.multilspy_types import UnifiedSymbolInformation, SymbolKind
from langchain_code.tools import BaseTool
from pydantic import BaseModel, Field, PrivateAttr

from .synthesis_metadata import SynthesisMetadata
from .location import Location

# planned LLM tools with lsp
#
# search symbol: returns a list of symbols, which have file name, symbol name, symbol type, and line number and column number
# (line and column can maybe be ommitted if there are no duplicates in file, but might as well still send)
# also return source code of location (maybe limit number of lines returned)
#
# find references: takes in symbol name and file, and optinally a line number of the symbol definition for disambiguation if there are multiple same named symbols in file
# returns a list of references in the same way as search symbo
# line number ignored if no duplicates, just return real line number
# if duplicate names in file, and no line specified, return info to llm which has both symbols info displayed, and an error saying not unique
#
# find definition: takes in file name where symbol occured, and symbol name, finds definition of the symbol
# in similar manner will return a message to llm which indicates there are multiple different symbols of the same name used in a file, and return a list of symbols
#
# read symbol takes in symbol id and returns the source code of the symbol
# 
# maybe some read context
#
# all these tools which operate givenen a symbol locatin with ommitted line numbers should return a shortened symbol text (maxlines=8 maybe) for ever matching one if the line numbers are missing and there are multiple possiblities, so the llm can examine the possible symbols and select the correct one for an updated query
# find definition is similar, but it should return the definition of all matching symbols for all possible references, with shortened output for the symbols, and with the reference also listed

class SymbolType(StrEnum):
    File = 'file'
    Module = 'module'
    Namespace = 'namespace'
    Package = 'package'
    Class = 'class'
    Method = 'method'
    Property = 'property'
    Field = 'field'
    Constructor = 'constructor'
    Enum = 'enum'
    Interface = 'interface'
    Function = 'function'
    Variable = 'variable'
    Constant = 'constant'
    String = 'string'
    Number = 'number'
    Boolean = 'boolean'
    Array = 'array'
    Object = 'object'
    Key = 'key'
    Null = 'null'
    EnumMember = 'enum-member'
    Struct = 'struct'
    Event = 'event'
    Operator = 'operator'
    TypeParameter = 'type-parameter'
    Macro = 'macro'
    Unknown = 'unknown'

    @classmethod
    def from_multilspy_symbol(cls, symbol: UnifiedSymbolInformation) -> Self:
        kind = symbol['kind']
        mapping = {
            1: cls.File,
            2: cls.Module,
            3: cls.Namespace,
            4: cls.Package,
            5: cls.Class,
            6: cls.Method,
            7: cls.Property,
            8: cls.Field,
            9: cls.Constructor,
            10: cls.Enum,
            11: cls.Interface,
            12: cls.Function,
            13: cls.Variable,
            14: cls.Constant,
            15: cls.String,
            16: cls.Number,
            17: cls.Boolean,
            18: cls.Array,
            19: cls.Object,
            20: cls.Key,
            21: cls.Null,
            22: cls.EnumMember,
            23: cls.Struct,
            24: cls.Event,
            25: cls.Operator,
            26: cls.TypeParameter,
        }
        return mapping.get(kind, cls.Unknown)

@dataclass
class LlmSymbolDefinition:
    location: Location
    symbol_name: str
    symbol_type: SymbolType
    source_code: str

    @classmethod
    def from_multilspy_symbol(cls, symbol: UnifiedSymbolInformation, metadata: SynthesisMetadata) -> Self:
        location = Location.from_multilspy_location(symbol['location'])
        return cls(
            location=location,
            symbol_name=symbol['name'],
            symbol_type=SymbolType.from_multilspy_symbol(symbol),
            source_code=location.read_source(metadata)
        )

    def symbol_info_str(self) -> str:
        return f'{self.symbol_name} is a {self.symbol_type} in file {self.location.file_path} starting at line={self.location.start.line},column={self.location.start.column}'
    
    def symbol_details(self, max_lines: Optional[int] = None) -> str:
        # keeps empty lines in the start and middle, but not end, which is what we want
        lines = self.source_code.splitlines()
        if max_lines is not None and len(lines) > max_lines:
            used_lines = '\n'.join(lines[:max_lines])
            remaining_count = len(lines) - max_lines

            return f'{self.symbol_info_str()}\n```\n{used_lines}\n({remaining_count} lines not shown...)```'
        else:
            # show all source code
            return f'{self.symbol_info_str()}\n```\n{self.source_code}```'

@dataclass
class LlmSymbolReference:
    symbol: LlmSymbolDefinition
    reference_location: Location

class LlmSymbolLookupInfo(BaseModel):
    symbol_name: str = Field(description='Name of symbol to lookup')
    file: str = Field(description='File path to lookup symbol in, where either the symbol exists or references to the symbol exist')
    start_line: Optional[int] = Field(description='Optional start line, only needed when multiple symbols or references are present in the same file')
    end_line: Optional[int] = Field(description='Optional start column, only needed when multiple symbols or references are present in the same file on the same line')


def create_lsp(metadata: SynthesisMetadata) -> SyncLanguageServer:
    config = MultilspyConfig.from_dict({
        'code_language': 'cpp',
    })
    logger = MultilspyLogger()
    return SyncLanguageServer.create(config, logger, metadata.linux_src)

class KernelLsp:
    _lsp: SyncLanguageServer
    _metadata: SynthesisMetadata

    def __init__(self, metadata: SynthesisMetadata, lsp: SyncLanguageServer):
        '''
        Create a KernelLsp from an already started multilspy lsp
        '''
        self._metadata = metadata
        self._lsp = lsp
    
    def search_symbols(self, query: str) -> list[LlmSymbolDefinition]:
        symbols = self._lsp.request_workspace_symbol(query)

        return [LlmSymbolDefinition.from_multilspy_symbol(self._metadata, symbol) for symbol in symbols]

MAX_SEARCH_RESULTS = 256

class SearchSymbolInput(BaseModel):
    query: str = Field(description='search for a symbol with a name similar to this query string')
    max_results: int = Field(
        default=32,
        description='Maximum number of matching symbol results returned, cant be more then {MAX_SEARCH_RESULTS}'
    )

class LspSearchSymbolTool(BaseTool):
    name: str = 'search_symbol'
    description: str = 'Search for a given symbol such as a struct or function name in the linux kernel and return the results'
    args_schema: Type[BaseModel] = SearchSymbolInput

    _lsp: KernelLsp = PrivateAttr()

    def __init__(self, lsp: KernelLsp, **kwargs):
        super().__init__(**kwargs)
        self._lsp = lsp

    def run(self, query: str, max_results: int = 5) -> str:
        symbols = self._lsp.search_symbols(query)[:max_results]
        symbol_results = '\n\n'.join(symbol.symbol_details(max_lines=8) for symbol in symbols)
        return f'symbol search results for `{query}`:\n{symbol_results}'