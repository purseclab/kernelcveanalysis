from dataclasses import dataclass, fields
from typing import Optional, Type, Any, Self
import json

from ..kernel_image import Kernel

BTF_JSON_NAME = 'btf_types.json'

def _filter_kwargs(cls, data):
    valid_fields = {f.name for f in fields(cls)}
    return {k: v for k, v in data.items() if k in valid_fields}

class BtfTypes:
    # maps type ids to types
    types: dict[int, 'BtfType']
    # maps names to types
    type_name_map: dict[str, 'BtfType']

    def __init__(self, json_data: dict[str, Any]):
        self.types = {}
        self.type_name_map = {}

        for type_data in json_data.get('types', []):
            btf_type = BtfType.from_json(type_data)
            self.types[btf_type.id] = btf_type
            self.type_name_map[btf_type.name] = btf_type
    
    @classmethod
    def load(cls, kernel: Kernel) -> Self:
        with open(kernel.synthesis_data_path() / BTF_JSON_NAME, 'r') as f:
            json_data = json.load(f)
        
        return cls(json_data)
            
    def get_type(self, type_id: int) -> Optional['BtfType']:
        return self.types.get(type_id)
    
    def get_type_by_name(self, type_name: str) -> Optional['BtfType']:
        return self.type_name_map.get(type_name)

    def get_type_ref(self, type_id: int) -> 'TypeReference':
        return TypeReference(self, type_id)

class TypeReference:
    def __init__(self, btf_types: BtfTypes, type_id: int):
        self.btf_types = btf_types
        self.type_id = type_id

    @property
    def type(self) -> Optional['BtfType']:
        return self.btf_types.get_type(self.type_id)

    @property
    def name(self) -> Optional[str]:
        t = self.type
        return t.name if t else None

    @property
    def kind(self) -> Optional[str]:
        t = self.type
        return t.kind if t else None

@dataclass
class BtfType:
    id: int
    kind: str
    name: str

    @classmethod
    def from_json(cls, data: dict) -> 'BtfType':
        kind = data.get('kind')
        
        target_cls: Type[BtfType] = BtfType
        
        if kind == 'INT': target_cls = BtfInt
        elif kind == 'PTR': target_cls = BtfPtr
        elif kind == 'ARRAY': target_cls = BtfArray
        elif kind == 'STRUCT': target_cls = BtfStruct
        elif kind == 'UNION': target_cls = BtfUnion
        elif kind == 'ENUM': target_cls = BtfEnum
        elif kind == 'FWD': target_cls = BtfFwd
        elif kind == 'TYPEDEF': target_cls = BtfTypedef
        elif kind == 'VOLATILE': target_cls = BtfVolatile
        elif kind == 'CONST': target_cls = BtfConst
        elif kind == 'RESTRICT': target_cls = BtfRestrict
        elif kind == 'FUNC': target_cls = BtfFunc
        elif kind == 'FUNC_PROTO': target_cls = BtfFuncProto
        elif kind == 'VAR': target_cls = BtfVar
        elif kind == 'DATASEC': target_cls = BtfDatasec
        elif kind == 'FLOAT': target_cls = BtfFloat
        elif kind == 'DECL_TAG': target_cls = BtfDeclTag
        elif kind == 'TYPE_TAG': target_cls = BtfTypeTag
        
        data_copy = data.copy()
        
        # Pre-process nested lists of objects
        if target_cls == BtfStruct or target_cls == BtfUnion:
            m_data = data_copy.pop('members', [])
            data_copy['members'] = [BtfMember(**_filter_kwargs(BtfMember, m)) for m in m_data]
        elif target_cls == BtfEnum:
            v_data = data_copy.pop('values', [])
            data_copy['values'] = [BtfEnumMember(**_filter_kwargs(BtfEnumMember, v)) for v in v_data]
        elif target_cls == BtfFuncProto:
            p_data = data_copy.pop('params', [])
            data_copy['params'] = [BtfParam(**_filter_kwargs(BtfParam, p)) for p in p_data]
        elif target_cls == BtfDatasec:
            v_data = data_copy.pop('vars', [])
            data_copy['vars'] = [BtfDatasecVar(**_filter_kwargs(BtfDatasecVar, v)) for v in v_data]

        return target_cls(**_filter_kwargs(target_cls, data_copy))

@dataclass
class BtfRefType(BtfType):
    type_id: int

@dataclass
class BtfInt(BtfType):
    size: int
    bits_offset: int
    nr_bits: int
    encoding: str

@dataclass
class BtfPtr(BtfRefType):
    pass

@dataclass
class BtfArray(BtfType):
    type_id: int
    index_type_id: int
    nr_elems: int

@dataclass
class BtfMember:
    name: str
    type_id: int
    bits_offset: int
    bitfield_size: int = 0

@dataclass
class BtfStruct(BtfType):
    size: int
    vlen: int
    members: list[BtfMember]

@dataclass
class BtfUnion(BtfStruct):
    pass

@dataclass
class BtfEnumMember:
    name: str
    val: int

@dataclass
class BtfEnum(BtfType):
    size: int
    vlen: int
    encoding: str = "UNSIGNED"
    values: list[BtfEnumMember] = None # type: ignore

@dataclass
class BtfFwd(BtfType):
    fwd_kind: str

@dataclass
class BtfTypedef(BtfRefType):
    pass

@dataclass
class BtfVolatile(BtfRefType):
    pass

@dataclass
class BtfConst(BtfRefType):
    pass

@dataclass
class BtfRestrict(BtfRefType):
    pass

@dataclass
class BtfFunc(BtfRefType):
    pass

@dataclass
class BtfParam:
    name: str
    type_id: int

@dataclass
class BtfFuncProto(BtfType):
    ret_type_id: int
    vlen: int
    params: list[BtfParam]

@dataclass
class BtfVar(BtfRefType):
    linkage: int

@dataclass
class BtfDatasecVar:
    type_id: int
    offset: int
    size: int

@dataclass
class BtfDatasec(BtfType):
    size: int
    vlen: int
    vars: list[BtfDatasecVar]

@dataclass
class BtfFloat(BtfType):
    size: int

@dataclass
class BtfDeclTag(BtfRefType):
    component_idx: int

@dataclass
class BtfTypeTag(BtfRefType):
    pass
