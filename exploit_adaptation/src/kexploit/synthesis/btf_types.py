from dataclasses import dataclass, fields
from typing import Optional, Type, Any, Self
import json

from ..kernel_image import Kernel

BTF_JSON_NAME = 'btf_types.json'

def _filter_kwargs(cls, btf_types: 'BtfTypes', data):
    if 'type_id' in data:
        data['type_id'] = TypeReference(btf_types, data['type_id'])
    
    valid_fields = {f.name for f in fields(cls)}
    return {k: v for k, v in data.items() if k in valid_fields}

class BtfTypes:
    # maps type ids to types
    types: dict[int, 'BtfType']
    # maps names to types
    type_name_map: dict[str, 'BtfType']

    def __init__(self, json_data: dict[str, Any]):
        self.types = {}
        self.type_name_map = {}

        for type_data in json_data.get('types', []):
            btf_type = BtfType.from_json(self, type_data)
            self.types[btf_type.id] = btf_type
            self.type_name_map[btf_type.name] = btf_type
    
    @classmethod
    def load(cls, kernel: Kernel) -> Self:
        with open(kernel.synthesis_data_path() / BTF_JSON_NAME, 'r') as f:
            json_data = json.load(f)
        
        return cls(json_data)
            
    def get_type(self, type_id: int) -> Optional['BtfType']:
        return self.types.get(type_id)
    
    def get_type_by_name(self, type_name: str) -> Optional['BtfType']:
        return self.type_name_map.get(type_name)

    def get_type_ref(self, type_id: int) -> 'TypeReference':
        return TypeReference(self, type_id)

class TypeReference:
    def __init__(self, btf_types: BtfTypes, type_id: int):
        self.btf_types = btf_types
        self.type_id = type_id

    @property
    def type(self) -> Optional['BtfType']:
        return self.btf_types.get_type(self.type_id)

    @property
    def name(self) -> Optional[str]:
        t = self.type
        return t.name if t else None

    @property
    def kind(self) -> Optional[str]:
        t = self.type
        return t.kind if t else None

@dataclass
class BtfType:
    id: int
    kind: str
    name: str

    @classmethod
    def from_json(cls, btf_types: BtfTypes, data: dict) -> 'BtfType':
        kind = data.get('kind')
        
        target_cls: Type[BtfType] = BtfType
        
        if kind == 'INT': target_cls = BtfInt
        elif kind == 'PTR': target_cls = BtfPtr
        elif kind == 'ARRAY': target_cls = BtfArray
        elif kind == 'STRUCT': target_cls = BtfStruct
        elif kind == 'UNION': target_cls = BtfUnion
        elif kind == 'ENUM': target_cls = BtfEnum
        elif kind == 'FWD': target_cls = BtfFwd
        elif kind == 'TYPEDEF': target_cls = BtfTypedef
        elif kind == 'VOLATILE': target_cls = BtfVolatile
        elif kind == 'CONST': target_cls = BtfConst
        elif kind == 'RESTRICT': target_cls = BtfRestrict
        elif kind == 'FUNC': target_cls = BtfFunc
        elif kind == 'FUNC_PROTO': target_cls = BtfFuncProto
        elif kind == 'VAR': target_cls = BtfVar
        elif kind == 'DATASEC': target_cls = BtfDatasec
        elif kind == 'FLOAT': target_cls = BtfFloat
        elif kind == 'DECL_TAG': target_cls = BtfDeclTag
        elif kind == 'TYPE_TAG': target_cls = BtfTypeTag
        
        data_copy = data.copy()
        
        # Pre-process nested lists of objects
        if target_cls == BtfStruct or target_cls == BtfUnion:
            m_data = data_copy.pop('members', [])
            data_copy['members'] = [BtfMember(**_filter_kwargs(BtfMember, btf_types, m)) for m in m_data]
        elif target_cls == BtfEnum:
            v_data = data_copy.pop('values', [])
            data_copy['values'] = [BtfEnumMember(**_filter_kwargs(BtfEnumMember, btf_types, v)) for v in v_data]
        elif target_cls == BtfFuncProto:
            p_data = data_copy.pop('params', [])
            data_copy['params'] = [BtfParam(**_filter_kwargs(BtfParam, btf_types, p)) for p in p_data]
        elif target_cls == BtfDatasec:
            v_data = data_copy.pop('vars', [])
            data_copy['vars'] = [BtfDatasecVar(**_filter_kwargs(BtfDatasecVar, btf_types, v)) for v in v_data]
        elif target_cls == BtfArray:
            # array has 2 type ids
            data_copy['index_type_id'] = TypeReference(btf_types, data_copy['index_type_id'])

        return target_cls(**_filter_kwargs(target_cls, btf_types, data_copy))
    
    def format_short(self) -> str:
        return self.format_long()
    
    def format_long(self) -> str:
        return str(self)
    
    def __repr__(self) -> str:
        return self.format_long()

@dataclass
class BtfRefType(BtfType):
    type_id: TypeReference

    def format_short(self) -> str:
        return f'{self.type_id.type.format_short()}*'
    
    def format_long(self) -> str:
        return f'{self.type_id.type.format_long()}*'

@dataclass
class BtfInt(BtfType):
    size: int
    bits_offset: int
    nr_bits: int
    encoding: str

    def format_long(self) -> str:
        return self.name

@dataclass
class BtfPtr(BtfRefType):
    pass

@dataclass
class BtfArray(BtfType):
    type_id: TypeReference
    index_type_id: TypeReference
    nr_elems: int

    # For array, we don't ever have long format children, like c
    def format_long(self) -> str:
        return f'{self.type_id.type.format_short()}[{self.nr_elems}]'

@dataclass
class BtfMember:
    name: str
    type_id: TypeReference
    bits_offset: int
    bitfield_size: int = 0

@dataclass
class BtfStruct(BtfType):
    size: int
    vlen: int
    members: list[BtfMember]

    def format_short(self) -> str:
        return f'struct {self.name}'
    
    def format_long(self) -> str:
        return f'struct {self.name} {{\n{self.format_fields()}}}'

    def format_fields(self) -> str:
        # TODO: handle bits offset, bitfields, etc.
        return ''.join(
            f'    // field byte offset: {field.bits_offset // 8}\n    {field.type_id.type.format_short()} {field.name};\n'
            for field in self.members
        )

@dataclass
class BtfUnion(BtfStruct):
    def format_short(self) -> str:
        return f'union {self.name}'
    
    def format_long(self) -> str:
        return f'union {self.name} {{\n{self.format_fields()}}}'

@dataclass
class BtfEnumMember:
    name: str
    val: int

@dataclass
class BtfEnum(BtfType):
    size: int
    vlen: int
    encoding: str = "UNSIGNED"
    values: list[BtfEnumMember] = None # type: ignore

    def format_short(self) -> str:
        return f'union {self.name}'
    
    def format_long(self) -> str:
        return f'union {self.name} {{\n{self.format_variants()}}}'
    
    def format_variants(self) -> str:
        return ''.join(f'    {variant.name} = {variant.val},\n' for variant in self.values)

@dataclass
class BtfFwd(BtfType):
    fwd_kind: str

    def format_long(self) -> str:
        return f'{self.fwd_kind} {self.name}'

@dataclass
class BtfTypedef(BtfRefType):
    type_id: TypeReference

    # format short is just a reference to a typedef
    def format_short(self) -> str:
        return self.name
    
    def format_long(self) -> str:
        return f'typedef {self.type_id.type.format_long()} {self.name}'

@dataclass
class BtfVolatile(BtfRefType):
    def format_short(self) -> str:
        return f'volatile {self.type_id.type.format_short()}'
    
    def format_long(self) -> str:
        return f'volatile {self.type_id.type.format_long()}'

@dataclass
class BtfConst(BtfRefType):
    type_id: TypeReference

    def format_short(self) -> str:
        return f'const {self.type_id.type.format_short()}'
    
    def format_long(self) -> str:
        return f'const {self.type_id.type.format_long()}'

@dataclass
class BtfRestrict(BtfRefType):
    type_id: TypeReference

    def format_short(self) -> str:
        return f'restrict {self.type_id.type.format_short()}'
    
    def format_long(self) -> str:
        return f'restrict {self.type_id.type.format_long()}'

@dataclass
class BtfFunc(BtfRefType):
    pass

@dataclass
class BtfParam:
    name: str
    type_id: TypeReference

@dataclass
class BtfFuncProto(BtfType):
    ret_type_id: int
    vlen: int
    params: list[BtfParam]

@dataclass
class BtfVar(BtfRefType):
    linkage: int

@dataclass
class BtfDatasecVar:
    type_id: TypeReference
    offset: int
    size: int

@dataclass
class BtfDatasec(BtfType):
    size: int
    vlen: int
    vars: list[BtfDatasecVar]

@dataclass
class BtfFloat(BtfType):
    size: int

@dataclass
class BtfDeclTag(BtfRefType):
    component_idx: int

@dataclass
class BtfTypeTag(BtfRefType):
    pass
